// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>You are not authorized to access the cluster.</p>
    AccessToClusterDeniedFault(crate::error::AccessToClusterDeniedFault),
    /// <p>The owner of the specified snapshot has not authorized your account to access the snapshot.</p>
    AccessToSnapshotDeniedFault(crate::error::AccessToSnapshotDeniedFault),
    /// <p>The authentication profile already exists.</p>
    AuthenticationProfileAlreadyExistsFault(crate::error::AuthenticationProfileAlreadyExistsFault),
    /// <p>The authentication profile can't be found.</p>
    AuthenticationProfileNotFoundFault(crate::error::AuthenticationProfileNotFoundFault),
    /// <p>The size or number of authentication profiles has exceeded the quota. The maximum length of the JSON string and maximum number of authentication profiles is determined by a quota for your account.</p>
    AuthenticationProfileQuotaExceededFault(crate::error::AuthenticationProfileQuotaExceededFault),
    /// <p>The specified CIDR block or EC2 security group is already authorized for the specified cluster security group.</p>
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    /// <p>The specified CIDR IP range or EC2 security group is not authorized for the specified cluster security group.</p>
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    /// <p>The authorization quota for the cluster security group has been reached.</p>
    AuthorizationQuotaExceededFault(crate::error::AuthorizationQuotaExceededFault),
    /// <p>The maximum number for a batch delete of snapshots has been reached. The limit is 100. </p>
    BatchDeleteRequestSizeExceededFault(crate::error::BatchDeleteRequestSizeExceededFault),
    /// <p>The maximum number for snapshot identifiers has been reached. The limit is 100. </p>
    BatchModifyClusterSnapshotsLimitExceededFault(
        crate::error::BatchModifyClusterSnapshotsLimitExceededFault,
    ),
    /// <p>Could not find the specified S3 bucket.</p>
    BucketNotFoundFault(crate::error::BucketNotFoundFault),
    /// <p>The account already has a cluster with the given identifier.</p>
    ClusterAlreadyExistsFault(crate::error::ClusterAlreadyExistsFault),
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>Cluster is already on the latest database revision.</p>
    ClusterOnLatestRevisionFault(crate::error::ClusterOnLatestRevisionFault),
    /// <p>A cluster parameter group with the same name already exists.</p>
    ClusterParameterGroupAlreadyExistsFault(crate::error::ClusterParameterGroupAlreadyExistsFault),
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster parameter groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterParameterGroupQuotaExceededFault(crate::error::ClusterParameterGroupQuotaExceededFault),
    /// <p>The request would exceed the allowed number of cluster instances for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterQuotaExceededFault(crate::error::ClusterQuotaExceededFault),
    /// <p>A cluster security group with the same name already exists.</p>
    ClusterSecurityGroupAlreadyExistsFault(crate::error::ClusterSecurityGroupAlreadyExistsFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster security groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSecurityGroupQuotaExceededFault(crate::error::ClusterSecurityGroupQuotaExceededFault),
    /// <p>The value specified as a snapshot identifier is already used by an existing snapshot.</p>
    ClusterSnapshotAlreadyExistsFault(crate::error::ClusterSnapshotAlreadyExistsFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster snapshots.</p>
    ClusterSnapshotQuotaExceededFault(crate::error::ClusterSnapshotQuotaExceededFault),
    /// <p>A <i>ClusterSubnetGroupName</i> is already used by an existing cluster subnet group. </p>
    ClusterSubnetGroupAlreadyExistsFault(crate::error::ClusterSubnetGroupAlreadyExistsFault),
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The request would result in user exceeding the allowed number of cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSubnetGroupQuotaExceededFault(crate::error::ClusterSubnetGroupQuotaExceededFault),
    /// <p>The request would result in user exceeding the allowed number of subnets in a cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSubnetQuotaExceededFault(crate::error::ClusterSubnetQuotaExceededFault),
    /// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
    CopyToRegionDisabledFault(crate::error::CopyToRegionDisabledFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
    EndpointAlreadyExistsFault(crate::error::EndpointAlreadyExistsFault),
    /// <p>The authorization already exists for this endpoint.</p>
    EndpointAuthorizationAlreadyExistsFault(crate::error::EndpointAuthorizationAlreadyExistsFault),
    /// <p>The authorization for this endpoint can't be found.</p>
    EndpointAuthorizationNotFoundFault(crate::error::EndpointAuthorizationNotFoundFault),
    /// <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
    EndpointAuthorizationsPerClusterLimitExceededFault(
        crate::error::EndpointAuthorizationsPerClusterLimitExceededFault,
    ),
    /// <p>The endpoint name doesn't refer to an existing endpoint.</p>
    EndpointNotFoundFault(crate::error::EndpointNotFoundFault),
    /// <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
    EndpointsPerAuthorizationLimitExceededFault(
        crate::error::EndpointsPerAuthorizationLimitExceededFault,
    ),
    /// <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
    EndpointsPerClusterLimitExceededFault(crate::error::EndpointsPerClusterLimitExceededFault),
    /// <p>The request would exceed the allowed number of event subscriptions for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    /// <p>There is already an existing Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateAlreadyExistsFault(crate::error::HsmClientCertificateAlreadyExistsFault),
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>The quota for HSM client certificates has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    HsmClientCertificateQuotaExceededFault(crate::error::HsmClientCertificateQuotaExceededFault),
    /// <p>There is already an existing Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationAlreadyExistsFault(crate::error::HsmConfigurationAlreadyExistsFault),
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The quota for HSM configurations has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    HsmConfigurationQuotaExceededFault(crate::error::HsmConfigurationQuotaExceededFault),
    /// <p>You have exceeded the allowed number of table restore requests. Wait for your current table restore requests to complete before making a new request.</p>
    InProgressTableRestoreQuotaExceededFault(
        crate::error::InProgressTableRestoreQuotaExceededFault,
    ),
    /// <p>The specified options are incompatible.</p>
    IncompatibleOrderableOptions(crate::error::IncompatibleOrderableOptions),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The cluster does not have read bucket or put object permissions on the S3 bucket specified when enabling logging.</p>
    InsufficientS3BucketPolicyFault(crate::error::InsufficientS3BucketPolicyFault),
    /// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
    InvalidAuthenticationProfileRequestFault(
        crate::error::InvalidAuthenticationProfileRequestFault,
    ),
    /// <p>The status of the authorization is not valid.</p>
    InvalidAuthorizationStateFault(crate::error::InvalidAuthorizationStateFault),
    /// <p>The cluster parameter group action can not be completed because another task is in progress that involves the parameter group. Wait a few moments and try the operation again.</p>
    InvalidClusterParameterGroupStateFault(crate::error::InvalidClusterParameterGroupStateFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The cluster snapshot schedule state is not valid.</p>
    InvalidClusterSnapshotScheduleStateFault(
        crate::error::InvalidClusterSnapshotScheduleStateFault,
    ),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The cluster subnet group cannot be deleted because it is in use.</p>
    InvalidClusterSubnetGroupStateFault(crate::error::InvalidClusterSubnetGroupStateFault),
    /// <p>The state of the subnet is invalid.</p>
    InvalidClusterSubnetStateFault(crate::error::InvalidClusterSubnetStateFault),
    /// <p>The provided cluster track name is not valid.</p>
    InvalidClusterTrackFault(crate::error::InvalidClusterTrackFault),
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
    InvalidElasticIpFault(crate::error::InvalidElasticIpFault),
    /// <p>The status of the endpoint is not valid.</p>
    InvalidEndpointStateFault(crate::error::InvalidEndpointStateFault),
    /// <p>The specified HSM client certificate is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
    InvalidHsmClientCertificateStateFault(crate::error::InvalidHsmClientCertificateStateFault),
    /// <p>The specified HSM configuration is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
    InvalidHsmConfigurationStateFault(crate::error::InvalidHsmConfigurationStateFault),
    /// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
    InvalidNamespaceFault(crate::error::InvalidNamespaceFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>The restore is invalid.</p>
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>The S3 bucket name is invalid. For more information about naming rules, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3) Developer Guide.</p>
    InvalidS3BucketNameFault(crate::error::InvalidS3BucketNameFault),
    /// <p>The string specified for the logging S3 key prefix does not comply with the documented constraints.</p>
    InvalidS3KeyPrefixFault(crate::error::InvalidS3KeyPrefixFault),
    /// <p>The schedule you submitted isn't valid.</p>
    InvalidScheduleFault(crate::error::InvalidScheduleFault),
    /// <p>The scheduled action is not valid. </p>
    InvalidScheduledActionFault(crate::error::InvalidScheduledActionFault),
    /// <p>The snapshot copy grant can't be deleted because it is used by one or more clusters.</p>
    InvalidSnapshotCopyGrantStateFault(crate::error::InvalidSnapshotCopyGrantStateFault),
    /// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>The subscription request is invalid because it is a duplicate request. This subscription request is already in progress.</p>
    InvalidSubscriptionStateFault(crate::error::InvalidSubscriptionStateFault),
    /// <p>The value specified for the <code>sourceDatabaseName</code>, <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a combination of these, doesn't exist in the snapshot.</p>
    InvalidTableRestoreArgumentFault(crate::error::InvalidTableRestoreArgumentFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The usage limit is not valid.</p>
    InvalidUsageLimitFault(crate::error::InvalidUsageLimitFault),
    /// <p>The cluster subnet group does not cover all Availability Zones.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
    NumberOfNodesPerClusterLimitExceededFault(
        crate::error::NumberOfNodesPerClusterLimitExceededFault,
    ),
    /// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    NumberOfNodesQuotaExceededFault(crate::error::NumberOfNodesQuotaExceededFault),
    /// <p>The name of the partner was not found.</p>
    PartnerNotFoundFault(crate::error::PartnerNotFoundFault),
    /// <p>User already has a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The reserved-node exchange status wasn't found.</p>
    ReservedNodeExchangeNotFoundFault(crate::error::ReservedNodeExchangeNotFoundFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>Request would exceed the user's compute node quota. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ReservedNodeQuotaExceededFault(crate::error::ReservedNodeQuotaExceededFault),
    /// <p>A resize operation for the specified cluster is not found.</p>
    ResizeNotFoundFault(crate::error::ResizeNotFoundFault),
    /// <p>The resource could not be found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS topic.</p>
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    /// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    /// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not exist.</p>
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    /// <p>The definition you submitted is not supported.</p>
    ScheduleDefinitionTypeUnsupportedFault(crate::error::ScheduleDefinitionTypeUnsupportedFault),
    /// <p>The scheduled action already exists. </p>
    ScheduledActionAlreadyExistsFault(crate::error::ScheduledActionAlreadyExistsFault),
    /// <p>The scheduled action cannot be found. </p>
    ScheduledActionNotFoundFault(crate::error::ScheduledActionNotFoundFault),
    /// <p>The quota for scheduled actions exceeded. </p>
    ScheduledActionQuotaExceededFault(crate::error::ScheduledActionQuotaExceededFault),
    /// <p>The action type specified for a scheduled action is not supported. </p>
    ScheduledActionTypeUnsupportedFault(crate::error::ScheduledActionTypeUnsupportedFault),
    /// <p>The cluster already has cross-region snapshot copy disabled.</p>
    SnapshotCopyAlreadyDisabledFault(crate::error::SnapshotCopyAlreadyDisabledFault),
    /// <p>The cluster already has cross-region snapshot copy enabled.</p>
    SnapshotCopyAlreadyEnabledFault(crate::error::SnapshotCopyAlreadyEnabledFault),
    /// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
    SnapshotCopyDisabledFault(crate::error::SnapshotCopyDisabledFault),
    /// <p>The snapshot copy grant can't be created because a grant with the same name already exists.</p>
    SnapshotCopyGrantAlreadyExistsFault(crate::error::SnapshotCopyGrantAlreadyExistsFault),
    /// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed correctly and that the grant exists in the destination region.</p>
    SnapshotCopyGrantNotFoundFault(crate::error::SnapshotCopyGrantNotFoundFault),
    /// <p>The Amazon Web Services account has exceeded the maximum number of snapshot copy grants in this region.</p>
    SnapshotCopyGrantQuotaExceededFault(crate::error::SnapshotCopyGrantQuotaExceededFault),
    /// <p>The specified snapshot schedule already exists. </p>
    SnapshotScheduleAlreadyExistsFault(crate::error::SnapshotScheduleAlreadyExistsFault),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// <p>You have exceeded the quota of snapshot schedules. </p>
    SnapshotScheduleQuotaExceededFault(crate::error::SnapshotScheduleQuotaExceededFault),
    /// <p>The specified snapshot schedule is already being updated.</p>
    SnapshotScheduleUpdateInProgressFault(crate::error::SnapshotScheduleUpdateInProgressFault),
    /// <p>The specified Amazon Redshift event source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>A specified subnet is already in use by another cluster.</p>
    SubnetAlreadyInUse(crate::error::SubnetAlreadyInUse),
    /// <p>There is already an existing event notification subscription with the specified name.</p>
    SubscriptionAlreadyExistFault(crate::error::SubscriptionAlreadyExistFault),
    /// <p>The value specified for the event category was not one of the allowed values, or it specified a category that does not apply to the specified source type. The allowed values are Configuration, Management, Monitoring, and Security.</p>
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
    SubscriptionEventIdNotFoundFault(crate::error::SubscriptionEventIdNotFoundFault),
    /// <p>An Amazon Redshift event notification subscription with the specified name does not exist.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// <p>The value specified for the event severity was not one of the allowed values, or it specified a severity that does not apply to the specified source type. The allowed values are ERROR and INFO.</p>
    SubscriptionSeverityNotFoundFault(crate::error::SubscriptionSeverityNotFoundFault),
    /// <p>The number of tables in the cluster exceeds the limit for the requested new cluster node type. </p>
    TableLimitExceededFault(crate::error::TableLimitExceededFault),
    /// <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
    TableRestoreNotFoundFault(crate::error::TableRestoreNotFoundFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>The partner integration is not authorized.</p>
    UnauthorizedPartnerIntegrationFault(crate::error::UnauthorizedPartnerIntegrationFault),
    /// <p>The specified region is incorrect or does not exist.</p>
    UnknownSnapshotCopyRegionFault(crate::error::UnknownSnapshotCopyRegionFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// <p>A request option was specified that is not supported.</p>
    UnsupportedOptionFault(crate::error::UnsupportedOptionFault),
    /// <p>The usage limit already exists. </p>
    UsageLimitAlreadyExistsFault(crate::error::UsageLimitAlreadyExistsFault),
    /// <p>The usage limit identifier can't be found.</p>
    UsageLimitNotFoundFault(crate::error::UsageLimitNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessToClusterDeniedFault(inner) => inner.fmt(f),
            Error::AccessToSnapshotDeniedFault(inner) => inner.fmt(f),
            Error::AuthenticationProfileAlreadyExistsFault(inner) => inner.fmt(f),
            Error::AuthenticationProfileNotFoundFault(inner) => inner.fmt(f),
            Error::AuthenticationProfileQuotaExceededFault(inner) => inner.fmt(f),
            Error::AuthorizationAlreadyExistsFault(inner) => inner.fmt(f),
            Error::AuthorizationNotFoundFault(inner) => inner.fmt(f),
            Error::AuthorizationQuotaExceededFault(inner) => inner.fmt(f),
            Error::BatchDeleteRequestSizeExceededFault(inner) => inner.fmt(f),
            Error::BatchModifyClusterSnapshotsLimitExceededFault(inner) => inner.fmt(f),
            Error::BucketNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ClusterNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterOnLatestRevisionFault(inner) => inner.fmt(f),
            Error::ClusterParameterGroupAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ClusterParameterGroupNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterParameterGroupQuotaExceededFault(inner) => inner.fmt(f),
            Error::ClusterQuotaExceededFault(inner) => inner.fmt(f),
            Error::ClusterSecurityGroupAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ClusterSecurityGroupNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterSecurityGroupQuotaExceededFault(inner) => inner.fmt(f),
            Error::ClusterSnapshotAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ClusterSnapshotNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterSnapshotQuotaExceededFault(inner) => inner.fmt(f),
            Error::ClusterSubnetGroupAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ClusterSubnetGroupNotFoundFault(inner) => inner.fmt(f),
            Error::ClusterSubnetGroupQuotaExceededFault(inner) => inner.fmt(f),
            Error::ClusterSubnetQuotaExceededFault(inner) => inner.fmt(f),
            Error::CopyToRegionDisabledFault(inner) => inner.fmt(f),
            Error::DependentServiceRequestThrottlingFault(inner) => inner.fmt(f),
            Error::DependentServiceUnavailableFault(inner) => inner.fmt(f),
            Error::EndpointAlreadyExistsFault(inner) => inner.fmt(f),
            Error::EndpointAuthorizationAlreadyExistsFault(inner) => inner.fmt(f),
            Error::EndpointAuthorizationNotFoundFault(inner) => inner.fmt(f),
            Error::EndpointAuthorizationsPerClusterLimitExceededFault(inner) => inner.fmt(f),
            Error::EndpointNotFoundFault(inner) => inner.fmt(f),
            Error::EndpointsPerAuthorizationLimitExceededFault(inner) => inner.fmt(f),
            Error::EndpointsPerClusterLimitExceededFault(inner) => inner.fmt(f),
            Error::EventSubscriptionQuotaExceededFault(inner) => inner.fmt(f),
            Error::HsmClientCertificateAlreadyExistsFault(inner) => inner.fmt(f),
            Error::HsmClientCertificateNotFoundFault(inner) => inner.fmt(f),
            Error::HsmClientCertificateQuotaExceededFault(inner) => inner.fmt(f),
            Error::HsmConfigurationAlreadyExistsFault(inner) => inner.fmt(f),
            Error::HsmConfigurationNotFoundFault(inner) => inner.fmt(f),
            Error::HsmConfigurationQuotaExceededFault(inner) => inner.fmt(f),
            Error::InProgressTableRestoreQuotaExceededFault(inner) => inner.fmt(f),
            Error::IncompatibleOrderableOptions(inner) => inner.fmt(f),
            Error::InsufficientClusterCapacityFault(inner) => inner.fmt(f),
            Error::InsufficientS3BucketPolicyFault(inner) => inner.fmt(f),
            Error::InvalidAuthenticationProfileRequestFault(inner) => inner.fmt(f),
            Error::InvalidAuthorizationStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterParameterGroupStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterSecurityGroupStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterSnapshotScheduleStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterSnapshotStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterSubnetGroupStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterSubnetStateFault(inner) => inner.fmt(f),
            Error::InvalidClusterTrackFault(inner) => inner.fmt(f),
            Error::InvalidDataShareFault(inner) => inner.fmt(f),
            Error::InvalidElasticIpFault(inner) => inner.fmt(f),
            Error::InvalidEndpointStateFault(inner) => inner.fmt(f),
            Error::InvalidHsmClientCertificateStateFault(inner) => inner.fmt(f),
            Error::InvalidHsmConfigurationStateFault(inner) => inner.fmt(f),
            Error::InvalidNamespaceFault(inner) => inner.fmt(f),
            Error::InvalidReservedNodeStateFault(inner) => inner.fmt(f),
            Error::InvalidRestoreFault(inner) => inner.fmt(f),
            Error::InvalidRetentionPeriodFault(inner) => inner.fmt(f),
            Error::InvalidS3BucketNameFault(inner) => inner.fmt(f),
            Error::InvalidS3KeyPrefixFault(inner) => inner.fmt(f),
            Error::InvalidScheduleFault(inner) => inner.fmt(f),
            Error::InvalidScheduledActionFault(inner) => inner.fmt(f),
            Error::InvalidSnapshotCopyGrantStateFault(inner) => inner.fmt(f),
            Error::InvalidSubnet(inner) => inner.fmt(f),
            Error::InvalidSubscriptionStateFault(inner) => inner.fmt(f),
            Error::InvalidTableRestoreArgumentFault(inner) => inner.fmt(f),
            Error::InvalidTagFault(inner) => inner.fmt(f),
            Error::InvalidUsageLimitFault(inner) => inner.fmt(f),
            Error::InvalidVpcNetworkStateFault(inner) => inner.fmt(f),
            Error::LimitExceededFault(inner) => inner.fmt(f),
            Error::NumberOfNodesPerClusterLimitExceededFault(inner) => inner.fmt(f),
            Error::NumberOfNodesQuotaExceededFault(inner) => inner.fmt(f),
            Error::PartnerNotFoundFault(inner) => inner.fmt(f),
            Error::ReservedNodeAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ReservedNodeAlreadyMigratedFault(inner) => inner.fmt(f),
            Error::ReservedNodeExchangeNotFoundFault(inner) => inner.fmt(f),
            Error::ReservedNodeNotFoundFault(inner) => inner.fmt(f),
            Error::ReservedNodeOfferingNotFoundFault(inner) => inner.fmt(f),
            Error::ReservedNodeQuotaExceededFault(inner) => inner.fmt(f),
            Error::ResizeNotFoundFault(inner) => inner.fmt(f),
            Error::ResourceNotFoundFault(inner) => inner.fmt(f),
            Error::SnsInvalidTopicFault(inner) => inner.fmt(f),
            Error::SnsNoAuthorizationFault(inner) => inner.fmt(f),
            Error::SnsTopicArnNotFoundFault(inner) => inner.fmt(f),
            Error::ScheduleDefinitionTypeUnsupportedFault(inner) => inner.fmt(f),
            Error::ScheduledActionAlreadyExistsFault(inner) => inner.fmt(f),
            Error::ScheduledActionNotFoundFault(inner) => inner.fmt(f),
            Error::ScheduledActionQuotaExceededFault(inner) => inner.fmt(f),
            Error::ScheduledActionTypeUnsupportedFault(inner) => inner.fmt(f),
            Error::SnapshotCopyAlreadyDisabledFault(inner) => inner.fmt(f),
            Error::SnapshotCopyAlreadyEnabledFault(inner) => inner.fmt(f),
            Error::SnapshotCopyDisabledFault(inner) => inner.fmt(f),
            Error::SnapshotCopyGrantAlreadyExistsFault(inner) => inner.fmt(f),
            Error::SnapshotCopyGrantNotFoundFault(inner) => inner.fmt(f),
            Error::SnapshotCopyGrantQuotaExceededFault(inner) => inner.fmt(f),
            Error::SnapshotScheduleAlreadyExistsFault(inner) => inner.fmt(f),
            Error::SnapshotScheduleNotFoundFault(inner) => inner.fmt(f),
            Error::SnapshotScheduleQuotaExceededFault(inner) => inner.fmt(f),
            Error::SnapshotScheduleUpdateInProgressFault(inner) => inner.fmt(f),
            Error::SourceNotFoundFault(inner) => inner.fmt(f),
            Error::SubnetAlreadyInUse(inner) => inner.fmt(f),
            Error::SubscriptionAlreadyExistFault(inner) => inner.fmt(f),
            Error::SubscriptionCategoryNotFoundFault(inner) => inner.fmt(f),
            Error::SubscriptionEventIdNotFoundFault(inner) => inner.fmt(f),
            Error::SubscriptionNotFoundFault(inner) => inner.fmt(f),
            Error::SubscriptionSeverityNotFoundFault(inner) => inner.fmt(f),
            Error::TableLimitExceededFault(inner) => inner.fmt(f),
            Error::TableRestoreNotFoundFault(inner) => inner.fmt(f),
            Error::TagLimitExceededFault(inner) => inner.fmt(f),
            Error::UnauthorizedOperation(inner) => inner.fmt(f),
            Error::UnauthorizedPartnerIntegrationFault(inner) => inner.fmt(f),
            Error::UnknownSnapshotCopyRegionFault(inner) => inner.fmt(f),
            Error::UnsupportedOperationFault(inner) => inner.fmt(f),
            Error::UnsupportedOptionFault(inner) => inner.fmt(f),
            Error::UsageLimitAlreadyExistsFault(inner) => inner.fmt(f),
            Error::UsageLimitNotFoundFault(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AcceptReservedNodeExchangeError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AcceptReservedNodeExchangeError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AcceptReservedNodeExchangeError> for Error {
    fn from(err: crate::error::AcceptReservedNodeExchangeError) -> Self {
        match err {
            crate::error::AcceptReservedNodeExchangeError::DependentServiceUnavailableFault(
                inner,
            ) => Error::DependentServiceUnavailableFault(inner),
            crate::error::AcceptReservedNodeExchangeError::InvalidReservedNodeStateFault(inner) => {
                Error::InvalidReservedNodeStateFault(inner)
            }
            crate::error::AcceptReservedNodeExchangeError::ReservedNodeAlreadyExistsFault(
                inner,
            ) => Error::ReservedNodeAlreadyExistsFault(inner),
            crate::error::AcceptReservedNodeExchangeError::ReservedNodeAlreadyMigratedFault(
                inner,
            ) => Error::ReservedNodeAlreadyMigratedFault(inner),
            crate::error::AcceptReservedNodeExchangeError::ReservedNodeNotFoundFault(inner) => {
                Error::ReservedNodeNotFoundFault(inner)
            }
            crate::error::AcceptReservedNodeExchangeError::ReservedNodeOfferingNotFoundFault(
                inner,
            ) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::AcceptReservedNodeExchangeError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::AcceptReservedNodeExchangeError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddPartnerError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AddPartnerError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AddPartnerError> for Error {
    fn from(err: crate::error::AddPartnerError) -> Self {
        match err {
            crate::error::AddPartnerError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::AddPartnerError::PartnerNotFoundFault(inner) => {
                Error::PartnerNotFoundFault(inner)
            }
            crate::error::AddPartnerError::UnauthorizedPartnerIntegrationFault(inner) => {
                Error::UnauthorizedPartnerIntegrationFault(inner)
            }
            crate::error::AddPartnerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AssociateDataShareConsumerError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AssociateDataShareConsumerError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AssociateDataShareConsumerError> for Error {
    fn from(err: crate::error::AssociateDataShareConsumerError) -> Self {
        match err {
            crate::error::AssociateDataShareConsumerError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::AssociateDataShareConsumerError::InvalidNamespaceFault(inner) => {
                Error::InvalidNamespaceFault(inner)
            }
            crate::error::AssociateDataShareConsumerError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::AuthorizeClusterSecurityGroupIngressError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::AuthorizeClusterSecurityGroupIngressError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AuthorizeClusterSecurityGroupIngressError> for Error {
    fn from(err: crate::error::AuthorizeClusterSecurityGroupIngressError) -> Self {
        match err {
            crate::error::AuthorizeClusterSecurityGroupIngressError::AuthorizationAlreadyExistsFault(inner) => Error::AuthorizationAlreadyExistsFault(inner),
            crate::error::AuthorizeClusterSecurityGroupIngressError::AuthorizationQuotaExceededFault(inner) => Error::AuthorizationQuotaExceededFault(inner),
            crate::error::AuthorizeClusterSecurityGroupIngressError::ClusterSecurityGroupNotFoundFault(inner) => Error::ClusterSecurityGroupNotFoundFault(inner),
            crate::error::AuthorizeClusterSecurityGroupIngressError::InvalidClusterSecurityGroupStateFault(inner) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::AuthorizeClusterSecurityGroupIngressError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AuthorizeDataShareError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AuthorizeDataShareError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AuthorizeDataShareError> for Error {
    fn from(err: crate::error::AuthorizeDataShareError) -> Self {
        match err {
            crate::error::AuthorizeDataShareError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::AuthorizeDataShareError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AuthorizeEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AuthorizeEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AuthorizeEndpointAccessError> for Error {
    fn from(err: crate::error::AuthorizeEndpointAccessError) -> Self {
        match err {
            crate::error::AuthorizeEndpointAccessError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::AuthorizeEndpointAccessError::EndpointAuthorizationAlreadyExistsFault(inner) => Error::EndpointAuthorizationAlreadyExistsFault(inner),
            crate::error::AuthorizeEndpointAccessError::EndpointAuthorizationsPerClusterLimitExceededFault(inner) => Error::EndpointAuthorizationsPerClusterLimitExceededFault(inner),
            crate::error::AuthorizeEndpointAccessError::InvalidAuthorizationStateFault(inner) => Error::InvalidAuthorizationStateFault(inner),
            crate::error::AuthorizeEndpointAccessError::InvalidClusterStateFault(inner) => Error::InvalidClusterStateFault(inner),
            crate::error::AuthorizeEndpointAccessError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::AuthorizeEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AuthorizeSnapshotAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AuthorizeSnapshotAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AuthorizeSnapshotAccessError> for Error {
    fn from(err: crate::error::AuthorizeSnapshotAccessError) -> Self {
        match err {
            crate::error::AuthorizeSnapshotAccessError::AuthorizationAlreadyExistsFault(inner) => {
                Error::AuthorizationAlreadyExistsFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::AuthorizationQuotaExceededFault(inner) => {
                Error::AuthorizationQuotaExceededFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::AuthorizeSnapshotAccessError::InvalidClusterSnapshotStateFault(inner) => {
                Error::InvalidClusterSnapshotStateFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::AuthorizeSnapshotAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchDeleteClusterSnapshotsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchDeleteClusterSnapshotsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchDeleteClusterSnapshotsError> for Error {
    fn from(err: crate::error::BatchDeleteClusterSnapshotsError) -> Self {
        match err {
            crate::error::BatchDeleteClusterSnapshotsError::BatchDeleteRequestSizeExceededFault(
                inner,
            ) => Error::BatchDeleteRequestSizeExceededFault(inner),
            crate::error::BatchDeleteClusterSnapshotsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchModifyClusterSnapshotsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchModifyClusterSnapshotsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchModifyClusterSnapshotsError> for Error {
    fn from(err: crate::error::BatchModifyClusterSnapshotsError) -> Self {
        match err {
            crate::error::BatchModifyClusterSnapshotsError::BatchModifyClusterSnapshotsLimitExceededFault(inner) => Error::BatchModifyClusterSnapshotsLimitExceededFault(inner),
            crate::error::BatchModifyClusterSnapshotsError::InvalidRetentionPeriodFault(inner) => Error::InvalidRetentionPeriodFault(inner),
            crate::error::BatchModifyClusterSnapshotsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CancelResizeError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CancelResizeError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CancelResizeError> for Error {
    fn from(err: crate::error::CancelResizeError) -> Self {
        match err {
            crate::error::CancelResizeError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::CancelResizeError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::CancelResizeError::ResizeNotFoundFault(inner) => {
                Error::ResizeNotFoundFault(inner)
            }
            crate::error::CancelResizeError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::CancelResizeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CopyClusterSnapshotError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CopyClusterSnapshotError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CopyClusterSnapshotError> for Error {
    fn from(err: crate::error::CopyClusterSnapshotError) -> Self {
        match err {
            crate::error::CopyClusterSnapshotError::ClusterSnapshotAlreadyExistsFault(inner) => {
                Error::ClusterSnapshotAlreadyExistsFault(inner)
            }
            crate::error::CopyClusterSnapshotError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::CopyClusterSnapshotError::ClusterSnapshotQuotaExceededFault(inner) => {
                Error::ClusterSnapshotQuotaExceededFault(inner)
            }
            crate::error::CopyClusterSnapshotError::InvalidClusterSnapshotStateFault(inner) => {
                Error::InvalidClusterSnapshotStateFault(inner)
            }
            crate::error::CopyClusterSnapshotError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::CopyClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAuthenticationProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateAuthenticationProfileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateAuthenticationProfileError> for Error {
    fn from(err: crate::error::CreateAuthenticationProfileError) -> Self {
        match err {
            crate::error::CreateAuthenticationProfileError::AuthenticationProfileAlreadyExistsFault(inner) => Error::AuthenticationProfileAlreadyExistsFault(inner),
            crate::error::CreateAuthenticationProfileError::AuthenticationProfileQuotaExceededFault(inner) => Error::AuthenticationProfileQuotaExceededFault(inner),
            crate::error::CreateAuthenticationProfileError::InvalidAuthenticationProfileRequestFault(inner) => Error::InvalidAuthenticationProfileRequestFault(inner),
            crate::error::CreateAuthenticationProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateClusterError> for Error {
    fn from(err: crate::error::CreateClusterError) -> Self {
        match err {
            crate::error::CreateClusterError::ClusterAlreadyExistsFault(inner) => {
                Error::ClusterAlreadyExistsFault(inner)
            }
            crate::error::CreateClusterError::ClusterParameterGroupNotFoundFault(inner) => {
                Error::ClusterParameterGroupNotFoundFault(inner)
            }
            crate::error::CreateClusterError::ClusterQuotaExceededFault(inner) => {
                Error::ClusterQuotaExceededFault(inner)
            }
            crate::error::CreateClusterError::ClusterSecurityGroupNotFoundFault(inner) => {
                Error::ClusterSecurityGroupNotFoundFault(inner)
            }
            crate::error::CreateClusterError::ClusterSubnetGroupNotFoundFault(inner) => {
                Error::ClusterSubnetGroupNotFoundFault(inner)
            }
            crate::error::CreateClusterError::DependentServiceRequestThrottlingFault(inner) => {
                Error::DependentServiceRequestThrottlingFault(inner)
            }
            crate::error::CreateClusterError::HsmClientCertificateNotFoundFault(inner) => {
                Error::HsmClientCertificateNotFoundFault(inner)
            }
            crate::error::CreateClusterError::HsmConfigurationNotFoundFault(inner) => {
                Error::HsmConfigurationNotFoundFault(inner)
            }
            crate::error::CreateClusterError::InsufficientClusterCapacityFault(inner) => {
                Error::InsufficientClusterCapacityFault(inner)
            }
            crate::error::CreateClusterError::InvalidClusterSubnetGroupStateFault(inner) => {
                Error::InvalidClusterSubnetGroupStateFault(inner)
            }
            crate::error::CreateClusterError::InvalidClusterTrackFault(inner) => {
                Error::InvalidClusterTrackFault(inner)
            }
            crate::error::CreateClusterError::InvalidElasticIpFault(inner) => {
                Error::InvalidElasticIpFault(inner)
            }
            crate::error::CreateClusterError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::CreateClusterError::InvalidSubnet(inner) => Error::InvalidSubnet(inner),
            crate::error::CreateClusterError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateClusterError::InvalidVpcNetworkStateFault(inner) => {
                Error::InvalidVpcNetworkStateFault(inner)
            }
            crate::error::CreateClusterError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::CreateClusterError::NumberOfNodesPerClusterLimitExceededFault(inner) => {
                Error::NumberOfNodesPerClusterLimitExceededFault(inner)
            }
            crate::error::CreateClusterError::NumberOfNodesQuotaExceededFault(inner) => {
                Error::NumberOfNodesQuotaExceededFault(inner)
            }
            crate::error::CreateClusterError::SnapshotScheduleNotFoundFault(inner) => {
                Error::SnapshotScheduleNotFoundFault(inner)
            }
            crate::error::CreateClusterError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateClusterError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::CreateClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateClusterParameterGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateClusterParameterGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateClusterParameterGroupError> for Error {
    fn from(err: crate::error::CreateClusterParameterGroupError) -> Self {
        match err {
            crate::error::CreateClusterParameterGroupError::ClusterParameterGroupAlreadyExistsFault(inner) => Error::ClusterParameterGroupAlreadyExistsFault(inner),
            crate::error::CreateClusterParameterGroupError::ClusterParameterGroupQuotaExceededFault(inner) => Error::ClusterParameterGroupQuotaExceededFault(inner),
            crate::error::CreateClusterParameterGroupError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::CreateClusterParameterGroupError::TagLimitExceededFault(inner) => Error::TagLimitExceededFault(inner),
            crate::error::CreateClusterParameterGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateClusterSecurityGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateClusterSecurityGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateClusterSecurityGroupError> for Error {
    fn from(err: crate::error::CreateClusterSecurityGroupError) -> Self {
        match err {
            crate::error::CreateClusterSecurityGroupError::ClusterSecurityGroupAlreadyExistsFault(inner) => Error::ClusterSecurityGroupAlreadyExistsFault(inner),
            crate::error::CreateClusterSecurityGroupError::ClusterSecurityGroupQuotaExceededFault(inner) => Error::ClusterSecurityGroupQuotaExceededFault(inner),
            crate::error::CreateClusterSecurityGroupError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::CreateClusterSecurityGroupError::TagLimitExceededFault(inner) => Error::TagLimitExceededFault(inner),
            crate::error::CreateClusterSecurityGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateClusterSnapshotError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateClusterSnapshotError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateClusterSnapshotError> for Error {
    fn from(err: crate::error::CreateClusterSnapshotError) -> Self {
        match err {
            crate::error::CreateClusterSnapshotError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::CreateClusterSnapshotError::ClusterSnapshotAlreadyExistsFault(inner) => {
                Error::ClusterSnapshotAlreadyExistsFault(inner)
            }
            crate::error::CreateClusterSnapshotError::ClusterSnapshotQuotaExceededFault(inner) => {
                Error::ClusterSnapshotQuotaExceededFault(inner)
            }
            crate::error::CreateClusterSnapshotError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::CreateClusterSnapshotError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::CreateClusterSnapshotError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateClusterSnapshotError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateClusterSubnetGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateClusterSubnetGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateClusterSubnetGroupError> for Error {
    fn from(err: crate::error::CreateClusterSubnetGroupError) -> Self {
        match err {
            crate::error::CreateClusterSubnetGroupError::ClusterSubnetGroupAlreadyExistsFault(
                inner,
            ) => Error::ClusterSubnetGroupAlreadyExistsFault(inner),
            crate::error::CreateClusterSubnetGroupError::ClusterSubnetGroupQuotaExceededFault(
                inner,
            ) => Error::ClusterSubnetGroupQuotaExceededFault(inner),
            crate::error::CreateClusterSubnetGroupError::ClusterSubnetQuotaExceededFault(inner) => {
                Error::ClusterSubnetQuotaExceededFault(inner)
            }
            crate::error::CreateClusterSubnetGroupError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::CreateClusterSubnetGroupError::InvalidSubnet(inner) => {
                Error::InvalidSubnet(inner)
            }
            crate::error::CreateClusterSubnetGroupError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateClusterSubnetGroupError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateClusterSubnetGroupError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::CreateClusterSubnetGroupError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateEndpointAccessError> for Error {
    fn from(err: crate::error::CreateEndpointAccessError) -> Self {
        match err {
            crate::error::CreateEndpointAccessError::AccessToClusterDeniedFault(inner) => Error::AccessToClusterDeniedFault(inner),
            crate::error::CreateEndpointAccessError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::CreateEndpointAccessError::ClusterSubnetGroupNotFoundFault(inner) => Error::ClusterSubnetGroupNotFoundFault(inner),
            crate::error::CreateEndpointAccessError::EndpointAlreadyExistsFault(inner) => Error::EndpointAlreadyExistsFault(inner),
            crate::error::CreateEndpointAccessError::EndpointsPerAuthorizationLimitExceededFault(inner) => Error::EndpointsPerAuthorizationLimitExceededFault(inner),
            crate::error::CreateEndpointAccessError::EndpointsPerClusterLimitExceededFault(inner) => Error::EndpointsPerClusterLimitExceededFault(inner),
            crate::error::CreateEndpointAccessError::InvalidClusterSecurityGroupStateFault(inner) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::CreateEndpointAccessError::InvalidClusterStateFault(inner) => Error::InvalidClusterStateFault(inner),
            crate::error::CreateEndpointAccessError::UnauthorizedOperation(inner) => Error::UnauthorizedOperation(inner),
            crate::error::CreateEndpointAccessError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::CreateEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateEventSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateEventSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateEventSubscriptionError> for Error {
    fn from(err: crate::error::CreateEventSubscriptionError) -> Self {
        match err {
            crate::error::CreateEventSubscriptionError::EventSubscriptionQuotaExceededFault(
                inner,
            ) => Error::EventSubscriptionQuotaExceededFault(inner),
            crate::error::CreateEventSubscriptionError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SnsInvalidTopicFault(inner) => {
                Error::SnsInvalidTopicFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SnsNoAuthorizationFault(inner) => {
                Error::SnsNoAuthorizationFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SnsTopicArnNotFoundFault(inner) => {
                Error::SnsTopicArnNotFoundFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SourceNotFoundFault(inner) => {
                Error::SourceNotFoundFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SubscriptionAlreadyExistFault(inner) => {
                Error::SubscriptionAlreadyExistFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SubscriptionCategoryNotFoundFault(
                inner,
            ) => Error::SubscriptionCategoryNotFoundFault(inner),
            crate::error::CreateEventSubscriptionError::SubscriptionEventIdNotFoundFault(inner) => {
                Error::SubscriptionEventIdNotFoundFault(inner)
            }
            crate::error::CreateEventSubscriptionError::SubscriptionSeverityNotFoundFault(
                inner,
            ) => Error::SubscriptionSeverityNotFoundFault(inner),
            crate::error::CreateEventSubscriptionError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateEventSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateHsmClientCertificateError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateHsmClientCertificateError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateHsmClientCertificateError> for Error {
    fn from(err: crate::error::CreateHsmClientCertificateError) -> Self {
        match err {
            crate::error::CreateHsmClientCertificateError::HsmClientCertificateAlreadyExistsFault(inner) => Error::HsmClientCertificateAlreadyExistsFault(inner),
            crate::error::CreateHsmClientCertificateError::HsmClientCertificateQuotaExceededFault(inner) => Error::HsmClientCertificateQuotaExceededFault(inner),
            crate::error::CreateHsmClientCertificateError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::CreateHsmClientCertificateError::TagLimitExceededFault(inner) => Error::TagLimitExceededFault(inner),
            crate::error::CreateHsmClientCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateHsmConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateHsmConfigurationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateHsmConfigurationError> for Error {
    fn from(err: crate::error::CreateHsmConfigurationError) -> Self {
        match err {
            crate::error::CreateHsmConfigurationError::HsmConfigurationAlreadyExistsFault(
                inner,
            ) => Error::HsmConfigurationAlreadyExistsFault(inner),
            crate::error::CreateHsmConfigurationError::HsmConfigurationQuotaExceededFault(
                inner,
            ) => Error::HsmConfigurationQuotaExceededFault(inner),
            crate::error::CreateHsmConfigurationError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateHsmConfigurationError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateHsmConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateScheduledActionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateScheduledActionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateScheduledActionError> for Error {
    fn from(err: crate::error::CreateScheduledActionError) -> Self {
        match err {
            crate::error::CreateScheduledActionError::InvalidScheduledActionFault(inner) => {
                Error::InvalidScheduledActionFault(inner)
            }
            crate::error::CreateScheduledActionError::InvalidScheduleFault(inner) => {
                Error::InvalidScheduleFault(inner)
            }
            crate::error::CreateScheduledActionError::ScheduledActionAlreadyExistsFault(inner) => {
                Error::ScheduledActionAlreadyExistsFault(inner)
            }
            crate::error::CreateScheduledActionError::ScheduledActionQuotaExceededFault(inner) => {
                Error::ScheduledActionQuotaExceededFault(inner)
            }
            crate::error::CreateScheduledActionError::ScheduledActionTypeUnsupportedFault(
                inner,
            ) => Error::ScheduledActionTypeUnsupportedFault(inner),
            crate::error::CreateScheduledActionError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::CreateScheduledActionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateSnapshotCopyGrantError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateSnapshotCopyGrantError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateSnapshotCopyGrantError> for Error {
    fn from(err: crate::error::CreateSnapshotCopyGrantError) -> Self {
        match err {
            crate::error::CreateSnapshotCopyGrantError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::CreateSnapshotCopyGrantError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateSnapshotCopyGrantError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::CreateSnapshotCopyGrantError::SnapshotCopyGrantAlreadyExistsFault(
                inner,
            ) => Error::SnapshotCopyGrantAlreadyExistsFault(inner),
            crate::error::CreateSnapshotCopyGrantError::SnapshotCopyGrantQuotaExceededFault(
                inner,
            ) => Error::SnapshotCopyGrantQuotaExceededFault(inner),
            crate::error::CreateSnapshotCopyGrantError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateSnapshotCopyGrantError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateSnapshotScheduleError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateSnapshotScheduleError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateSnapshotScheduleError> for Error {
    fn from(err: crate::error::CreateSnapshotScheduleError) -> Self {
        match err {
            crate::error::CreateSnapshotScheduleError::InvalidScheduleFault(inner) => {
                Error::InvalidScheduleFault(inner)
            }
            crate::error::CreateSnapshotScheduleError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::CreateSnapshotScheduleError::ScheduleDefinitionTypeUnsupportedFault(
                inner,
            ) => Error::ScheduleDefinitionTypeUnsupportedFault(inner),
            crate::error::CreateSnapshotScheduleError::SnapshotScheduleAlreadyExistsFault(
                inner,
            ) => Error::SnapshotScheduleAlreadyExistsFault(inner),
            crate::error::CreateSnapshotScheduleError::SnapshotScheduleQuotaExceededFault(
                inner,
            ) => Error::SnapshotScheduleQuotaExceededFault(inner),
            crate::error::CreateSnapshotScheduleError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateSnapshotScheduleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTagsError> for Error {
    fn from(err: crate::error::CreateTagsError) -> Self {
        match err {
            crate::error::CreateTagsError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::CreateTagsError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::CreateTagsError::ResourceNotFoundFault(inner) => {
                Error::ResourceNotFoundFault(inner)
            }
            crate::error::CreateTagsError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateUsageLimitError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateUsageLimitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateUsageLimitError> for Error {
    fn from(err: crate::error::CreateUsageLimitError) -> Self {
        match err {
            crate::error::CreateUsageLimitError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::CreateUsageLimitError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::CreateUsageLimitError::InvalidUsageLimitFault(inner) => {
                Error::InvalidUsageLimitFault(inner)
            }
            crate::error::CreateUsageLimitError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::CreateUsageLimitError::TagLimitExceededFault(inner) => {
                Error::TagLimitExceededFault(inner)
            }
            crate::error::CreateUsageLimitError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::CreateUsageLimitError::UsageLimitAlreadyExistsFault(inner) => {
                Error::UsageLimitAlreadyExistsFault(inner)
            }
            crate::error::CreateUsageLimitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeauthorizeDataShareError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeauthorizeDataShareError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeauthorizeDataShareError> for Error {
    fn from(err: crate::error::DeauthorizeDataShareError) -> Self {
        match err {
            crate::error::DeauthorizeDataShareError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::DeauthorizeDataShareError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAuthenticationProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteAuthenticationProfileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteAuthenticationProfileError> for Error {
    fn from(err: crate::error::DeleteAuthenticationProfileError) -> Self {
        match err {
            crate::error::DeleteAuthenticationProfileError::AuthenticationProfileNotFoundFault(inner) => Error::AuthenticationProfileNotFoundFault(inner),
            crate::error::DeleteAuthenticationProfileError::InvalidAuthenticationProfileRequestFault(inner) => Error::InvalidAuthenticationProfileRequestFault(inner),
            crate::error::DeleteAuthenticationProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteClusterError> for Error {
    fn from(err: crate::error::DeleteClusterError) -> Self {
        match err {
            crate::error::DeleteClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DeleteClusterError::ClusterSnapshotAlreadyExistsFault(inner) => {
                Error::ClusterSnapshotAlreadyExistsFault(inner)
            }
            crate::error::DeleteClusterError::ClusterSnapshotQuotaExceededFault(inner) => {
                Error::ClusterSnapshotQuotaExceededFault(inner)
            }
            crate::error::DeleteClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DeleteClusterError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::DeleteClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteClusterParameterGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteClusterParameterGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteClusterParameterGroupError> for Error {
    fn from(err: crate::error::DeleteClusterParameterGroupError) -> Self {
        match err {
            crate::error::DeleteClusterParameterGroupError::ClusterParameterGroupNotFoundFault(inner) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::DeleteClusterParameterGroupError::InvalidClusterParameterGroupStateFault(inner) => Error::InvalidClusterParameterGroupStateFault(inner),
            crate::error::DeleteClusterParameterGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteClusterSecurityGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteClusterSecurityGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteClusterSecurityGroupError> for Error {
    fn from(err: crate::error::DeleteClusterSecurityGroupError) -> Self {
        match err {
            crate::error::DeleteClusterSecurityGroupError::ClusterSecurityGroupNotFoundFault(inner) => Error::ClusterSecurityGroupNotFoundFault(inner),
            crate::error::DeleteClusterSecurityGroupError::InvalidClusterSecurityGroupStateFault(inner) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::DeleteClusterSecurityGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteClusterSnapshotError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteClusterSnapshotError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteClusterSnapshotError> for Error {
    fn from(err: crate::error::DeleteClusterSnapshotError) -> Self {
        match err {
            crate::error::DeleteClusterSnapshotError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::DeleteClusterSnapshotError::InvalidClusterSnapshotStateFault(inner) => {
                Error::InvalidClusterSnapshotStateFault(inner)
            }
            crate::error::DeleteClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteClusterSubnetGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteClusterSubnetGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteClusterSubnetGroupError> for Error {
    fn from(err: crate::error::DeleteClusterSubnetGroupError) -> Self {
        match err {
            crate::error::DeleteClusterSubnetGroupError::ClusterSubnetGroupNotFoundFault(inner) => {
                Error::ClusterSubnetGroupNotFoundFault(inner)
            }
            crate::error::DeleteClusterSubnetGroupError::InvalidClusterSubnetGroupStateFault(
                inner,
            ) => Error::InvalidClusterSubnetGroupStateFault(inner),
            crate::error::DeleteClusterSubnetGroupError::InvalidClusterSubnetStateFault(inner) => {
                Error::InvalidClusterSubnetStateFault(inner)
            }
            crate::error::DeleteClusterSubnetGroupError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteEndpointAccessError> for Error {
    fn from(err: crate::error::DeleteEndpointAccessError) -> Self {
        match err {
            crate::error::DeleteEndpointAccessError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DeleteEndpointAccessError::EndpointNotFoundFault(inner) => {
                Error::EndpointNotFoundFault(inner)
            }
            crate::error::DeleteEndpointAccessError::InvalidClusterSecurityGroupStateFault(
                inner,
            ) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::DeleteEndpointAccessError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DeleteEndpointAccessError::InvalidEndpointStateFault(inner) => {
                Error::InvalidEndpointStateFault(inner)
            }
            crate::error::DeleteEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteEventSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteEventSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteEventSubscriptionError> for Error {
    fn from(err: crate::error::DeleteEventSubscriptionError) -> Self {
        match err {
            crate::error::DeleteEventSubscriptionError::InvalidSubscriptionStateFault(inner) => {
                Error::InvalidSubscriptionStateFault(inner)
            }
            crate::error::DeleteEventSubscriptionError::SubscriptionNotFoundFault(inner) => {
                Error::SubscriptionNotFoundFault(inner)
            }
            crate::error::DeleteEventSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteHsmClientCertificateError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteHsmClientCertificateError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteHsmClientCertificateError> for Error {
    fn from(err: crate::error::DeleteHsmClientCertificateError) -> Self {
        match err {
            crate::error::DeleteHsmClientCertificateError::HsmClientCertificateNotFoundFault(inner) => Error::HsmClientCertificateNotFoundFault(inner),
            crate::error::DeleteHsmClientCertificateError::InvalidHsmClientCertificateStateFault(inner) => Error::InvalidHsmClientCertificateStateFault(inner),
            crate::error::DeleteHsmClientCertificateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteHsmConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteHsmConfigurationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteHsmConfigurationError> for Error {
    fn from(err: crate::error::DeleteHsmConfigurationError) -> Self {
        match err {
            crate::error::DeleteHsmConfigurationError::HsmConfigurationNotFoundFault(inner) => {
                Error::HsmConfigurationNotFoundFault(inner)
            }
            crate::error::DeleteHsmConfigurationError::InvalidHsmConfigurationStateFault(inner) => {
                Error::InvalidHsmConfigurationStateFault(inner)
            }
            crate::error::DeleteHsmConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeletePartnerError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeletePartnerError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeletePartnerError> for Error {
    fn from(err: crate::error::DeletePartnerError) -> Self {
        match err {
            crate::error::DeletePartnerError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DeletePartnerError::PartnerNotFoundFault(inner) => {
                Error::PartnerNotFoundFault(inner)
            }
            crate::error::DeletePartnerError::UnauthorizedPartnerIntegrationFault(inner) => {
                Error::UnauthorizedPartnerIntegrationFault(inner)
            }
            crate::error::DeletePartnerError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteScheduledActionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteScheduledActionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteScheduledActionError> for Error {
    fn from(err: crate::error::DeleteScheduledActionError) -> Self {
        match err {
            crate::error::DeleteScheduledActionError::ScheduledActionNotFoundFault(inner) => {
                Error::ScheduledActionNotFoundFault(inner)
            }
            crate::error::DeleteScheduledActionError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::DeleteScheduledActionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotCopyGrantError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotCopyGrantError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteSnapshotCopyGrantError> for Error {
    fn from(err: crate::error::DeleteSnapshotCopyGrantError) -> Self {
        match err {
            crate::error::DeleteSnapshotCopyGrantError::InvalidSnapshotCopyGrantStateFault(
                inner,
            ) => Error::InvalidSnapshotCopyGrantStateFault(inner),
            crate::error::DeleteSnapshotCopyGrantError::SnapshotCopyGrantNotFoundFault(inner) => {
                Error::SnapshotCopyGrantNotFoundFault(inner)
            }
            crate::error::DeleteSnapshotCopyGrantError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotScheduleError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteSnapshotScheduleError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteSnapshotScheduleError> for Error {
    fn from(err: crate::error::DeleteSnapshotScheduleError) -> Self {
        match err {
            crate::error::DeleteSnapshotScheduleError::InvalidClusterSnapshotScheduleStateFault(
                inner,
            ) => Error::InvalidClusterSnapshotScheduleStateFault(inner),
            crate::error::DeleteSnapshotScheduleError::SnapshotScheduleNotFoundFault(inner) => {
                Error::SnapshotScheduleNotFoundFault(inner)
            }
            crate::error::DeleteSnapshotScheduleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTagsError> for Error {
    fn from(err: crate::error::DeleteTagsError) -> Self {
        match err {
            crate::error::DeleteTagsError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::DeleteTagsError::ResourceNotFoundFault(inner) => {
                Error::ResourceNotFoundFault(inner)
            }
            crate::error::DeleteTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteUsageLimitError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteUsageLimitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteUsageLimitError> for Error {
    fn from(err: crate::error::DeleteUsageLimitError) -> Self {
        match err {
            crate::error::DeleteUsageLimitError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::DeleteUsageLimitError::UsageLimitNotFoundFault(inner) => {
                Error::UsageLimitNotFoundFault(inner)
            }
            crate::error::DeleteUsageLimitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeAccountAttributesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeAccountAttributesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeAccountAttributesError> for Error {
    fn from(err: crate::error::DescribeAccountAttributesError) -> Self {
        match err {
            crate::error::DescribeAccountAttributesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeAuthenticationProfilesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeAuthenticationProfilesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeAuthenticationProfilesError> for Error {
    fn from(err: crate::error::DescribeAuthenticationProfilesError) -> Self {
        match err {
            crate::error::DescribeAuthenticationProfilesError::AuthenticationProfileNotFoundFault(inner) => Error::AuthenticationProfileNotFoundFault(inner),
            crate::error::DescribeAuthenticationProfilesError::InvalidAuthenticationProfileRequestFault(inner) => Error::InvalidAuthenticationProfileRequestFault(inner),
            crate::error::DescribeAuthenticationProfilesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterDbRevisionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterDbRevisionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterDbRevisionsError> for Error {
    fn from(err: crate::error::DescribeClusterDbRevisionsError) -> Self {
        match err {
            crate::error::DescribeClusterDbRevisionsError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeClusterDbRevisionsError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DescribeClusterDbRevisionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterParameterGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeClusterParameterGroupsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterParameterGroupsError> for Error {
    fn from(err: crate::error::DescribeClusterParameterGroupsError) -> Self {
        match err {
            crate::error::DescribeClusterParameterGroupsError::ClusterParameterGroupNotFoundFault(inner) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::DescribeClusterParameterGroupsError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::DescribeClusterParameterGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterParametersError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterParametersError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterParametersError> for Error {
    fn from(err: crate::error::DescribeClusterParametersError) -> Self {
        match err {
            crate::error::DescribeClusterParametersError::ClusterParameterGroupNotFoundFault(
                inner,
            ) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::DescribeClusterParametersError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClustersError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClustersError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClustersError> for Error {
    fn from(err: crate::error::DescribeClustersError) -> Self {
        match err {
            crate::error::DescribeClustersError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeClustersError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeClustersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterSecurityGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterSecurityGroupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterSecurityGroupsError> for Error {
    fn from(err: crate::error::DescribeClusterSecurityGroupsError) -> Self {
        match err {
            crate::error::DescribeClusterSecurityGroupsError::ClusterSecurityGroupNotFoundFault(
                inner,
            ) => Error::ClusterSecurityGroupNotFoundFault(inner),
            crate::error::DescribeClusterSecurityGroupsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeClusterSecurityGroupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterSnapshotsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterSnapshotsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterSnapshotsError> for Error {
    fn from(err: crate::error::DescribeClusterSnapshotsError) -> Self {
        match err {
            crate::error::DescribeClusterSnapshotsError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeClusterSnapshotsError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::DescribeClusterSnapshotsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeClusterSnapshotsError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::DescribeClusterSnapshotsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterSubnetGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterSubnetGroupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterSubnetGroupsError> for Error {
    fn from(err: crate::error::DescribeClusterSubnetGroupsError) -> Self {
        match err {
            crate::error::DescribeClusterSubnetGroupsError::ClusterSubnetGroupNotFoundFault(
                inner,
            ) => Error::ClusterSubnetGroupNotFoundFault(inner),
            crate::error::DescribeClusterSubnetGroupsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeClusterSubnetGroupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterTracksError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterTracksError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterTracksError> for Error {
    fn from(err: crate::error::DescribeClusterTracksError) -> Self {
        match err {
            crate::error::DescribeClusterTracksError::InvalidClusterTrackFault(inner) => {
                Error::InvalidClusterTrackFault(inner)
            }
            crate::error::DescribeClusterTracksError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::DescribeClusterTracksError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeClusterVersionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeClusterVersionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeClusterVersionsError> for Error {
    fn from(err: crate::error::DescribeClusterVersionsError) -> Self {
        match err {
            crate::error::DescribeClusterVersionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeDataSharesError> for Error {
    fn from(err: crate::error::DescribeDataSharesError) -> Self {
        match err {
            crate::error::DescribeDataSharesError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::DescribeDataSharesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesForConsumerError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesForConsumerError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeDataSharesForConsumerError> for Error {
    fn from(err: crate::error::DescribeDataSharesForConsumerError) -> Self {
        match err {
            crate::error::DescribeDataSharesForConsumerError::InvalidNamespaceFault(inner) => {
                Error::InvalidNamespaceFault(inner)
            }
            crate::error::DescribeDataSharesForConsumerError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesForProducerError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeDataSharesForProducerError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeDataSharesForProducerError> for Error {
    fn from(err: crate::error::DescribeDataSharesForProducerError) -> Self {
        match err {
            crate::error::DescribeDataSharesForProducerError::InvalidNamespaceFault(inner) => {
                Error::InvalidNamespaceFault(inner)
            }
            crate::error::DescribeDataSharesForProducerError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeDefaultClusterParametersError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeDefaultClusterParametersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeDefaultClusterParametersError> for Error {
    fn from(err: crate::error::DescribeDefaultClusterParametersError) -> Self {
        match err {
            crate::error::DescribeDefaultClusterParametersError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEndpointAccessError> for Error {
    fn from(err: crate::error::DescribeEndpointAccessError) -> Self {
        match err {
            crate::error::DescribeEndpointAccessError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeEndpointAccessError::EndpointNotFoundFault(inner) => {
                Error::EndpointNotFoundFault(inner)
            }
            crate::error::DescribeEndpointAccessError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DescribeEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEndpointAuthorizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEndpointAuthorizationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEndpointAuthorizationError> for Error {
    fn from(err: crate::error::DescribeEndpointAuthorizationError) -> Self {
        match err {
            crate::error::DescribeEndpointAuthorizationError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeEndpointAuthorizationError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::DescribeEndpointAuthorizationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEventCategoriesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEventCategoriesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEventCategoriesError> for Error {
    fn from(err: crate::error::DescribeEventCategoriesError) -> Self {
        match err {
            crate::error::DescribeEventCategoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEventsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeEventsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEventsError> for Error {
    fn from(err: crate::error::DescribeEventsError) -> Self {
        match err {
            crate::error::DescribeEventsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEventSubscriptionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEventSubscriptionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEventSubscriptionsError> for Error {
    fn from(err: crate::error::DescribeEventSubscriptionsError) -> Self {
        match err {
            crate::error::DescribeEventSubscriptionsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeEventSubscriptionsError::SubscriptionNotFoundFault(inner) => {
                Error::SubscriptionNotFoundFault(inner)
            }
            crate::error::DescribeEventSubscriptionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeHsmClientCertificatesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeHsmClientCertificatesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeHsmClientCertificatesError> for Error {
    fn from(err: crate::error::DescribeHsmClientCertificatesError) -> Self {
        match err {
            crate::error::DescribeHsmClientCertificatesError::HsmClientCertificateNotFoundFault(
                inner,
            ) => Error::HsmClientCertificateNotFoundFault(inner),
            crate::error::DescribeHsmClientCertificatesError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeHsmClientCertificatesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeHsmConfigurationsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeHsmConfigurationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeHsmConfigurationsError> for Error {
    fn from(err: crate::error::DescribeHsmConfigurationsError) -> Self {
        match err {
            crate::error::DescribeHsmConfigurationsError::HsmConfigurationNotFoundFault(inner) => {
                Error::HsmConfigurationNotFoundFault(inner)
            }
            crate::error::DescribeHsmConfigurationsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeHsmConfigurationsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeLoggingStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeLoggingStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeLoggingStatusError> for Error {
    fn from(err: crate::error::DescribeLoggingStatusError) -> Self {
        match err {
            crate::error::DescribeLoggingStatusError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeLoggingStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeNodeConfigurationOptionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeNodeConfigurationOptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeNodeConfigurationOptionsError> for Error {
    fn from(err: crate::error::DescribeNodeConfigurationOptionsError) -> Self {
        match err {
            crate::error::DescribeNodeConfigurationOptionsError::AccessToSnapshotDeniedFault(inner) => Error::AccessToSnapshotDeniedFault(inner),
            crate::error::DescribeNodeConfigurationOptionsError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::DescribeNodeConfigurationOptionsError::ClusterSnapshotNotFoundFault(inner) => Error::ClusterSnapshotNotFoundFault(inner),
            crate::error::DescribeNodeConfigurationOptionsError::InvalidClusterSnapshotStateFault(inner) => Error::InvalidClusterSnapshotStateFault(inner),
            crate::error::DescribeNodeConfigurationOptionsError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::DescribeNodeConfigurationOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeOrderableClusterOptionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeOrderableClusterOptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeOrderableClusterOptionsError> for Error {
    fn from(err: crate::error::DescribeOrderableClusterOptionsError) -> Self {
        match err {
            crate::error::DescribeOrderableClusterOptionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribePartnersError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribePartnersError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribePartnersError> for Error {
    fn from(err: crate::error::DescribePartnersError) -> Self {
        match err {
            crate::error::DescribePartnersError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribePartnersError::UnauthorizedPartnerIntegrationFault(inner) => {
                Error::UnauthorizedPartnerIntegrationFault(inner)
            }
            crate::error::DescribePartnersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<crate::error::DescribeReservedNodeExchangeStatusError, R>,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeReservedNodeExchangeStatusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeReservedNodeExchangeStatusError> for Error {
    fn from(err: crate::error::DescribeReservedNodeExchangeStatusError) -> Self {
        match err {
            crate::error::DescribeReservedNodeExchangeStatusError::ReservedNodeExchangeNotFoundFault(inner) => Error::ReservedNodeExchangeNotFoundFault(inner),
            crate::error::DescribeReservedNodeExchangeStatusError::ReservedNodeNotFoundFault(inner) => Error::ReservedNodeNotFoundFault(inner),
            crate::error::DescribeReservedNodeExchangeStatusError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::DescribeReservedNodeExchangeStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeReservedNodeOfferingsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeReservedNodeOfferingsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeReservedNodeOfferingsError> for Error {
    fn from(err: crate::error::DescribeReservedNodeOfferingsError) -> Self {
        match err {
            crate::error::DescribeReservedNodeOfferingsError::DependentServiceUnavailableFault(
                inner,
            ) => Error::DependentServiceUnavailableFault(inner),
            crate::error::DescribeReservedNodeOfferingsError::ReservedNodeOfferingNotFoundFault(
                inner,
            ) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::DescribeReservedNodeOfferingsError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::DescribeReservedNodeOfferingsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeReservedNodesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeReservedNodesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeReservedNodesError> for Error {
    fn from(err: crate::error::DescribeReservedNodesError) -> Self {
        match err {
            crate::error::DescribeReservedNodesError::DependentServiceUnavailableFault(inner) => {
                Error::DependentServiceUnavailableFault(inner)
            }
            crate::error::DescribeReservedNodesError::ReservedNodeNotFoundFault(inner) => {
                Error::ReservedNodeNotFoundFault(inner)
            }
            crate::error::DescribeReservedNodesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeResizeError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeResizeError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeResizeError> for Error {
    fn from(err: crate::error::DescribeResizeError) -> Self {
        match err {
            crate::error::DescribeResizeError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeResizeError::ResizeNotFoundFault(inner) => {
                Error::ResizeNotFoundFault(inner)
            }
            crate::error::DescribeResizeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeScheduledActionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeScheduledActionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeScheduledActionsError> for Error {
    fn from(err: crate::error::DescribeScheduledActionsError) -> Self {
        match err {
            crate::error::DescribeScheduledActionsError::ScheduledActionNotFoundFault(inner) => {
                Error::ScheduledActionNotFoundFault(inner)
            }
            crate::error::DescribeScheduledActionsError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::DescribeScheduledActionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotCopyGrantsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotCopyGrantsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeSnapshotCopyGrantsError> for Error {
    fn from(err: crate::error::DescribeSnapshotCopyGrantsError) -> Self {
        match err {
            crate::error::DescribeSnapshotCopyGrantsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeSnapshotCopyGrantsError::SnapshotCopyGrantNotFoundFault(
                inner,
            ) => Error::SnapshotCopyGrantNotFoundFault(inner),
            crate::error::DescribeSnapshotCopyGrantsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotSchedulesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeSnapshotSchedulesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeSnapshotSchedulesError> for Error {
    fn from(err: crate::error::DescribeSnapshotSchedulesError) -> Self {
        match err {
            crate::error::DescribeSnapshotSchedulesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeStorageError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeStorageError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeStorageError> for Error {
    fn from(err: crate::error::DescribeStorageError) -> Self {
        match err {
            crate::error::DescribeStorageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTableRestoreStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeTableRestoreStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTableRestoreStatusError> for Error {
    fn from(err: crate::error::DescribeTableRestoreStatusError) -> Self {
        match err {
            crate::error::DescribeTableRestoreStatusError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeTableRestoreStatusError::TableRestoreNotFoundFault(inner) => {
                Error::TableRestoreNotFoundFault(inner)
            }
            crate::error::DescribeTableRestoreStatusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTagsError> for Error {
    fn from(err: crate::error::DescribeTagsError) -> Self {
        match err {
            crate::error::DescribeTagsError::InvalidTagFault(inner) => {
                Error::InvalidTagFault(inner)
            }
            crate::error::DescribeTagsError::ResourceNotFoundFault(inner) => {
                Error::ResourceNotFoundFault(inner)
            }
            crate::error::DescribeTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeUsageLimitsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeUsageLimitsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeUsageLimitsError> for Error {
    fn from(err: crate::error::DescribeUsageLimitsError) -> Self {
        match err {
            crate::error::DescribeUsageLimitsError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DescribeUsageLimitsError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::DescribeUsageLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableLoggingError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisableLoggingError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableLoggingError> for Error {
    fn from(err: crate::error::DisableLoggingError) -> Self {
        match err {
            crate::error::DisableLoggingError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DisableLoggingError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DisableLoggingError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisableSnapshotCopyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisableSnapshotCopyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableSnapshotCopyError> for Error {
    fn from(err: crate::error::DisableSnapshotCopyError) -> Self {
        match err {
            crate::error::DisableSnapshotCopyError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::DisableSnapshotCopyError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::DisableSnapshotCopyError::SnapshotCopyAlreadyDisabledFault(inner) => {
                Error::SnapshotCopyAlreadyDisabledFault(inner)
            }
            crate::error::DisableSnapshotCopyError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::DisableSnapshotCopyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisassociateDataShareConsumerError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DisassociateDataShareConsumerError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisassociateDataShareConsumerError> for Error {
    fn from(err: crate::error::DisassociateDataShareConsumerError) -> Self {
        match err {
            crate::error::DisassociateDataShareConsumerError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::DisassociateDataShareConsumerError::InvalidNamespaceFault(inner) => {
                Error::InvalidNamespaceFault(inner)
            }
            crate::error::DisassociateDataShareConsumerError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableLoggingError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EnableLoggingError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableLoggingError> for Error {
    fn from(err: crate::error::EnableLoggingError) -> Self {
        match err {
            crate::error::EnableLoggingError::BucketNotFoundFault(inner) => {
                Error::BucketNotFoundFault(inner)
            }
            crate::error::EnableLoggingError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::EnableLoggingError::InsufficientS3BucketPolicyFault(inner) => {
                Error::InsufficientS3BucketPolicyFault(inner)
            }
            crate::error::EnableLoggingError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::EnableLoggingError::InvalidS3BucketNameFault(inner) => {
                Error::InvalidS3BucketNameFault(inner)
            }
            crate::error::EnableLoggingError::InvalidS3KeyPrefixFault(inner) => {
                Error::InvalidS3KeyPrefixFault(inner)
            }
            crate::error::EnableLoggingError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EnableSnapshotCopyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::EnableSnapshotCopyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableSnapshotCopyError> for Error {
    fn from(err: crate::error::EnableSnapshotCopyError) -> Self {
        match err {
            crate::error::EnableSnapshotCopyError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::EnableSnapshotCopyError::CopyToRegionDisabledFault(inner) => {
                Error::CopyToRegionDisabledFault(inner)
            }
            crate::error::EnableSnapshotCopyError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::EnableSnapshotCopyError::IncompatibleOrderableOptions(inner) => {
                Error::IncompatibleOrderableOptions(inner)
            }
            crate::error::EnableSnapshotCopyError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::EnableSnapshotCopyError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::EnableSnapshotCopyError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::EnableSnapshotCopyError::SnapshotCopyAlreadyEnabledFault(inner) => {
                Error::SnapshotCopyAlreadyEnabledFault(inner)
            }
            crate::error::EnableSnapshotCopyError::SnapshotCopyGrantNotFoundFault(inner) => {
                Error::SnapshotCopyGrantNotFoundFault(inner)
            }
            crate::error::EnableSnapshotCopyError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::EnableSnapshotCopyError::UnknownSnapshotCopyRegionFault(inner) => {
                Error::UnknownSnapshotCopyRegionFault(inner)
            }
            crate::error::EnableSnapshotCopyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetClusterCredentialsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetClusterCredentialsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetClusterCredentialsError> for Error {
    fn from(err: crate::error::GetClusterCredentialsError) -> Self {
        match err {
            crate::error::GetClusterCredentialsError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::GetClusterCredentialsError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::GetClusterCredentialsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetClusterCredentialsWithIAMError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetClusterCredentialsWithIAMError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetClusterCredentialsWithIAMError> for Error {
    fn from(err: crate::error::GetClusterCredentialsWithIAMError) -> Self {
        match err {
            crate::error::GetClusterCredentialsWithIAMError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::GetClusterCredentialsWithIAMError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::GetClusterCredentialsWithIAMError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetReservedNodeExchangeConfigurationOptionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetReservedNodeExchangeConfigurationOptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReservedNodeExchangeConfigurationOptionsError> for Error {
    fn from(err: crate::error::GetReservedNodeExchangeConfigurationOptionsError) -> Self {
        match err {
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::ClusterSnapshotNotFoundFault(inner) => Error::ClusterSnapshotNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::DependentServiceUnavailableFault(inner) => Error::DependentServiceUnavailableFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::InvalidReservedNodeStateFault(inner) => Error::InvalidReservedNodeStateFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeAlreadyMigratedFault(inner) => Error::ReservedNodeAlreadyMigratedFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeNotFoundFault(inner) => Error::ReservedNodeNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeOfferingNotFoundFault(inner) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::GetReservedNodeExchangeConfigurationOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetReservedNodeExchangeOfferingsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetReservedNodeExchangeOfferingsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReservedNodeExchangeOfferingsError> for Error {
    fn from(err: crate::error::GetReservedNodeExchangeOfferingsError) -> Self {
        match err {
            crate::error::GetReservedNodeExchangeOfferingsError::DependentServiceUnavailableFault(inner) => Error::DependentServiceUnavailableFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::InvalidReservedNodeStateFault(inner) => Error::InvalidReservedNodeStateFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::ReservedNodeAlreadyMigratedFault(inner) => Error::ReservedNodeAlreadyMigratedFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::ReservedNodeNotFoundFault(inner) => Error::ReservedNodeNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::ReservedNodeOfferingNotFoundFault(inner) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::GetReservedNodeExchangeOfferingsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyAquaConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyAquaConfigurationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyAquaConfigurationError> for Error {
    fn from(err: crate::error::ModifyAquaConfigurationError) -> Self {
        match err {
            crate::error::ModifyAquaConfigurationError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyAquaConfigurationError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyAquaConfigurationError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::ModifyAquaConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyAuthenticationProfileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyAuthenticationProfileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyAuthenticationProfileError> for Error {
    fn from(err: crate::error::ModifyAuthenticationProfileError) -> Self {
        match err {
            crate::error::ModifyAuthenticationProfileError::AuthenticationProfileNotFoundFault(inner) => Error::AuthenticationProfileNotFoundFault(inner),
            crate::error::ModifyAuthenticationProfileError::AuthenticationProfileQuotaExceededFault(inner) => Error::AuthenticationProfileQuotaExceededFault(inner),
            crate::error::ModifyAuthenticationProfileError::InvalidAuthenticationProfileRequestFault(inner) => Error::InvalidAuthenticationProfileRequestFault(inner),
            crate::error::ModifyAuthenticationProfileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterError> for Error {
    fn from(err: crate::error::ModifyClusterError) -> Self {
        match err {
            crate::error::ModifyClusterError::ClusterAlreadyExistsFault(inner) => {
                Error::ClusterAlreadyExistsFault(inner)
            }
            crate::error::ModifyClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyClusterError::ClusterParameterGroupNotFoundFault(inner) => {
                Error::ClusterParameterGroupNotFoundFault(inner)
            }
            crate::error::ModifyClusterError::ClusterSecurityGroupNotFoundFault(inner) => {
                Error::ClusterSecurityGroupNotFoundFault(inner)
            }
            crate::error::ModifyClusterError::DependentServiceRequestThrottlingFault(inner) => {
                Error::DependentServiceRequestThrottlingFault(inner)
            }
            crate::error::ModifyClusterError::HsmClientCertificateNotFoundFault(inner) => {
                Error::HsmClientCertificateNotFoundFault(inner)
            }
            crate::error::ModifyClusterError::HsmConfigurationNotFoundFault(inner) => {
                Error::HsmConfigurationNotFoundFault(inner)
            }
            crate::error::ModifyClusterError::InsufficientClusterCapacityFault(inner) => {
                Error::InsufficientClusterCapacityFault(inner)
            }
            crate::error::ModifyClusterError::InvalidClusterSecurityGroupStateFault(inner) => {
                Error::InvalidClusterSecurityGroupStateFault(inner)
            }
            crate::error::ModifyClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyClusterError::InvalidClusterTrackFault(inner) => {
                Error::InvalidClusterTrackFault(inner)
            }
            crate::error::ModifyClusterError::InvalidElasticIpFault(inner) => {
                Error::InvalidElasticIpFault(inner)
            }
            crate::error::ModifyClusterError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::ModifyClusterError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::ModifyClusterError::NumberOfNodesPerClusterLimitExceededFault(inner) => {
                Error::NumberOfNodesPerClusterLimitExceededFault(inner)
            }
            crate::error::ModifyClusterError::NumberOfNodesQuotaExceededFault(inner) => {
                Error::NumberOfNodesQuotaExceededFault(inner)
            }
            crate::error::ModifyClusterError::TableLimitExceededFault(inner) => {
                Error::TableLimitExceededFault(inner)
            }
            crate::error::ModifyClusterError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ModifyClusterError::UnsupportedOptionFault(inner) => {
                Error::UnsupportedOptionFault(inner)
            }
            crate::error::ModifyClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterDbRevisionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterDbRevisionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterDbRevisionError> for Error {
    fn from(err: crate::error::ModifyClusterDbRevisionError) -> Self {
        match err {
            crate::error::ModifyClusterDbRevisionError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyClusterDbRevisionError::ClusterOnLatestRevisionFault(inner) => {
                Error::ClusterOnLatestRevisionFault(inner)
            }
            crate::error::ModifyClusterDbRevisionError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyClusterDbRevisionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterIamRolesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterIamRolesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterIamRolesError> for Error {
    fn from(err: crate::error::ModifyClusterIamRolesError) -> Self {
        match err {
            crate::error::ModifyClusterIamRolesError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyClusterIamRolesError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyClusterIamRolesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterMaintenanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterMaintenanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterMaintenanceError> for Error {
    fn from(err: crate::error::ModifyClusterMaintenanceError) -> Self {
        match err {
            crate::error::ModifyClusterMaintenanceError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyClusterMaintenanceError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyClusterMaintenanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterParameterGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterParameterGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterParameterGroupError> for Error {
    fn from(err: crate::error::ModifyClusterParameterGroupError) -> Self {
        match err {
            crate::error::ModifyClusterParameterGroupError::ClusterParameterGroupNotFoundFault(inner) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::ModifyClusterParameterGroupError::InvalidClusterParameterGroupStateFault(inner) => Error::InvalidClusterParameterGroupStateFault(inner),
            crate::error::ModifyClusterParameterGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterSnapshotError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterSnapshotError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterSnapshotError> for Error {
    fn from(err: crate::error::ModifyClusterSnapshotError) -> Self {
        match err {
            crate::error::ModifyClusterSnapshotError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::ModifyClusterSnapshotError::InvalidClusterSnapshotStateFault(inner) => {
                Error::InvalidClusterSnapshotStateFault(inner)
            }
            crate::error::ModifyClusterSnapshotError::InvalidRetentionPeriodFault(inner) => {
                Error::InvalidRetentionPeriodFault(inner)
            }
            crate::error::ModifyClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterSnapshotScheduleError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterSnapshotScheduleError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterSnapshotScheduleError> for Error {
    fn from(err: crate::error::ModifyClusterSnapshotScheduleError) -> Self {
        match err {
            crate::error::ModifyClusterSnapshotScheduleError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::ModifyClusterSnapshotScheduleError::InvalidClusterSnapshotScheduleStateFault(inner) => Error::InvalidClusterSnapshotScheduleStateFault(inner),
            crate::error::ModifyClusterSnapshotScheduleError::SnapshotScheduleNotFoundFault(inner) => Error::SnapshotScheduleNotFoundFault(inner),
            crate::error::ModifyClusterSnapshotScheduleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyClusterSubnetGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyClusterSubnetGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyClusterSubnetGroupError> for Error {
    fn from(err: crate::error::ModifyClusterSubnetGroupError) -> Self {
        match err {
            crate::error::ModifyClusterSubnetGroupError::ClusterSubnetGroupNotFoundFault(inner) => {
                Error::ClusterSubnetGroupNotFoundFault(inner)
            }
            crate::error::ModifyClusterSubnetGroupError::ClusterSubnetQuotaExceededFault(inner) => {
                Error::ClusterSubnetQuotaExceededFault(inner)
            }
            crate::error::ModifyClusterSubnetGroupError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::ModifyClusterSubnetGroupError::InvalidSubnet(inner) => {
                Error::InvalidSubnet(inner)
            }
            crate::error::ModifyClusterSubnetGroupError::SubnetAlreadyInUse(inner) => {
                Error::SubnetAlreadyInUse(inner)
            }
            crate::error::ModifyClusterSubnetGroupError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ModifyClusterSubnetGroupError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyEndpointAccessError> for Error {
    fn from(err: crate::error::ModifyEndpointAccessError) -> Self {
        match err {
            crate::error::ModifyEndpointAccessError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifyEndpointAccessError::EndpointNotFoundFault(inner) => {
                Error::EndpointNotFoundFault(inner)
            }
            crate::error::ModifyEndpointAccessError::InvalidClusterSecurityGroupStateFault(
                inner,
            ) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::ModifyEndpointAccessError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ModifyEndpointAccessError::InvalidEndpointStateFault(inner) => {
                Error::InvalidEndpointStateFault(inner)
            }
            crate::error::ModifyEndpointAccessError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ModifyEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyEventSubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyEventSubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyEventSubscriptionError> for Error {
    fn from(err: crate::error::ModifyEventSubscriptionError) -> Self {
        match err {
            crate::error::ModifyEventSubscriptionError::InvalidSubscriptionStateFault(inner) => {
                Error::InvalidSubscriptionStateFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SnsInvalidTopicFault(inner) => {
                Error::SnsInvalidTopicFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SnsNoAuthorizationFault(inner) => {
                Error::SnsNoAuthorizationFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SnsTopicArnNotFoundFault(inner) => {
                Error::SnsTopicArnNotFoundFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SourceNotFoundFault(inner) => {
                Error::SourceNotFoundFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SubscriptionCategoryNotFoundFault(
                inner,
            ) => Error::SubscriptionCategoryNotFoundFault(inner),
            crate::error::ModifyEventSubscriptionError::SubscriptionEventIdNotFoundFault(inner) => {
                Error::SubscriptionEventIdNotFoundFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SubscriptionNotFoundFault(inner) => {
                Error::SubscriptionNotFoundFault(inner)
            }
            crate::error::ModifyEventSubscriptionError::SubscriptionSeverityNotFoundFault(
                inner,
            ) => Error::SubscriptionSeverityNotFoundFault(inner),
            crate::error::ModifyEventSubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyScheduledActionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyScheduledActionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyScheduledActionError> for Error {
    fn from(err: crate::error::ModifyScheduledActionError) -> Self {
        match err {
            crate::error::ModifyScheduledActionError::InvalidScheduledActionFault(inner) => {
                Error::InvalidScheduledActionFault(inner)
            }
            crate::error::ModifyScheduledActionError::InvalidScheduleFault(inner) => {
                Error::InvalidScheduleFault(inner)
            }
            crate::error::ModifyScheduledActionError::ScheduledActionNotFoundFault(inner) => {
                Error::ScheduledActionNotFoundFault(inner)
            }
            crate::error::ModifyScheduledActionError::ScheduledActionTypeUnsupportedFault(
                inner,
            ) => Error::ScheduledActionTypeUnsupportedFault(inner),
            crate::error::ModifyScheduledActionError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ModifyScheduledActionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ModifySnapshotCopyRetentionPeriodError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ModifySnapshotCopyRetentionPeriodError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifySnapshotCopyRetentionPeriodError> for Error {
    fn from(err: crate::error::ModifySnapshotCopyRetentionPeriodError) -> Self {
        match err {
            crate::error::ModifySnapshotCopyRetentionPeriodError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ModifySnapshotCopyRetentionPeriodError::InvalidClusterStateFault(
                inner,
            ) => Error::InvalidClusterStateFault(inner),
            crate::error::ModifySnapshotCopyRetentionPeriodError::InvalidRetentionPeriodFault(
                inner,
            ) => Error::InvalidRetentionPeriodFault(inner),
            crate::error::ModifySnapshotCopyRetentionPeriodError::SnapshotCopyDisabledFault(
                inner,
            ) => Error::SnapshotCopyDisabledFault(inner),
            crate::error::ModifySnapshotCopyRetentionPeriodError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ModifySnapshotCopyRetentionPeriodError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifySnapshotScheduleError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifySnapshotScheduleError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifySnapshotScheduleError> for Error {
    fn from(err: crate::error::ModifySnapshotScheduleError) -> Self {
        match err {
            crate::error::ModifySnapshotScheduleError::InvalidScheduleFault(inner) => {
                Error::InvalidScheduleFault(inner)
            }
            crate::error::ModifySnapshotScheduleError::SnapshotScheduleNotFoundFault(inner) => {
                Error::SnapshotScheduleNotFoundFault(inner)
            }
            crate::error::ModifySnapshotScheduleError::SnapshotScheduleUpdateInProgressFault(
                inner,
            ) => Error::SnapshotScheduleUpdateInProgressFault(inner),
            crate::error::ModifySnapshotScheduleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ModifyUsageLimitError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ModifyUsageLimitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyUsageLimitError> for Error {
    fn from(err: crate::error::ModifyUsageLimitError) -> Self {
        match err {
            crate::error::ModifyUsageLimitError::InvalidUsageLimitFault(inner) => {
                Error::InvalidUsageLimitFault(inner)
            }
            crate::error::ModifyUsageLimitError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::ModifyUsageLimitError::UsageLimitNotFoundFault(inner) => {
                Error::UsageLimitNotFoundFault(inner)
            }
            crate::error::ModifyUsageLimitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PauseClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PauseClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PauseClusterError> for Error {
    fn from(err: crate::error::PauseClusterError) -> Self {
        match err {
            crate::error::PauseClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::PauseClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::PauseClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PurchaseReservedNodeOfferingError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::PurchaseReservedNodeOfferingError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PurchaseReservedNodeOfferingError> for Error {
    fn from(err: crate::error::PurchaseReservedNodeOfferingError) -> Self {
        match err {
            crate::error::PurchaseReservedNodeOfferingError::ReservedNodeAlreadyExistsFault(
                inner,
            ) => Error::ReservedNodeAlreadyExistsFault(inner),
            crate::error::PurchaseReservedNodeOfferingError::ReservedNodeOfferingNotFoundFault(
                inner,
            ) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::PurchaseReservedNodeOfferingError::ReservedNodeQuotaExceededFault(
                inner,
            ) => Error::ReservedNodeQuotaExceededFault(inner),
            crate::error::PurchaseReservedNodeOfferingError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::PurchaseReservedNodeOfferingError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RebootClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RebootClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RebootClusterError> for Error {
    fn from(err: crate::error::RebootClusterError) -> Self {
        match err {
            crate::error::RebootClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::RebootClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::RebootClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RejectDataShareError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RejectDataShareError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RejectDataShareError> for Error {
    fn from(err: crate::error::RejectDataShareError) -> Self {
        match err {
            crate::error::RejectDataShareError::InvalidDataShareFault(inner) => {
                Error::InvalidDataShareFault(inner)
            }
            crate::error::RejectDataShareError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ResetClusterParameterGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ResetClusterParameterGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ResetClusterParameterGroupError> for Error {
    fn from(err: crate::error::ResetClusterParameterGroupError) -> Self {
        match err {
            crate::error::ResetClusterParameterGroupError::ClusterParameterGroupNotFoundFault(inner) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::ResetClusterParameterGroupError::InvalidClusterParameterGroupStateFault(inner) => Error::InvalidClusterParameterGroupStateFault(inner),
            crate::error::ResetClusterParameterGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ResizeClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ResizeClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ResizeClusterError> for Error {
    fn from(err: crate::error::ResizeClusterError) -> Self {
        match err {
            crate::error::ResizeClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ResizeClusterError::DependentServiceUnavailableFault(inner) => {
                Error::DependentServiceUnavailableFault(inner)
            }
            crate::error::ResizeClusterError::InsufficientClusterCapacityFault(inner) => {
                Error::InsufficientClusterCapacityFault(inner)
            }
            crate::error::ResizeClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ResizeClusterError::InvalidReservedNodeStateFault(inner) => {
                Error::InvalidReservedNodeStateFault(inner)
            }
            crate::error::ResizeClusterError::LimitExceededFault(inner) => {
                Error::LimitExceededFault(inner)
            }
            crate::error::ResizeClusterError::NumberOfNodesPerClusterLimitExceededFault(inner) => {
                Error::NumberOfNodesPerClusterLimitExceededFault(inner)
            }
            crate::error::ResizeClusterError::NumberOfNodesQuotaExceededFault(inner) => {
                Error::NumberOfNodesQuotaExceededFault(inner)
            }
            crate::error::ResizeClusterError::ReservedNodeAlreadyExistsFault(inner) => {
                Error::ReservedNodeAlreadyExistsFault(inner)
            }
            crate::error::ResizeClusterError::ReservedNodeAlreadyMigratedFault(inner) => {
                Error::ReservedNodeAlreadyMigratedFault(inner)
            }
            crate::error::ResizeClusterError::ReservedNodeNotFoundFault(inner) => {
                Error::ReservedNodeNotFoundFault(inner)
            }
            crate::error::ResizeClusterError::ReservedNodeOfferingNotFoundFault(inner) => {
                Error::ReservedNodeOfferingNotFoundFault(inner)
            }
            crate::error::ResizeClusterError::UnauthorizedOperation(inner) => {
                Error::UnauthorizedOperation(inner)
            }
            crate::error::ResizeClusterError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::ResizeClusterError::UnsupportedOptionFault(inner) => {
                Error::UnsupportedOptionFault(inner)
            }
            crate::error::ResizeClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RestoreFromClusterSnapshotError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RestoreFromClusterSnapshotError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RestoreFromClusterSnapshotError> for Error {
    fn from(err: crate::error::RestoreFromClusterSnapshotError) -> Self {
        match err {
            crate::error::RestoreFromClusterSnapshotError::AccessToSnapshotDeniedFault(inner) => Error::AccessToSnapshotDeniedFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterAlreadyExistsFault(inner) => Error::ClusterAlreadyExistsFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterParameterGroupNotFoundFault(inner) => Error::ClusterParameterGroupNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterQuotaExceededFault(inner) => Error::ClusterQuotaExceededFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterSecurityGroupNotFoundFault(inner) => Error::ClusterSecurityGroupNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterSnapshotNotFoundFault(inner) => Error::ClusterSnapshotNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ClusterSubnetGroupNotFoundFault(inner) => Error::ClusterSubnetGroupNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::DependentServiceRequestThrottlingFault(inner) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::RestoreFromClusterSnapshotError::DependentServiceUnavailableFault(inner) => Error::DependentServiceUnavailableFault(inner),
            crate::error::RestoreFromClusterSnapshotError::HsmClientCertificateNotFoundFault(inner) => Error::HsmClientCertificateNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::HsmConfigurationNotFoundFault(inner) => Error::HsmConfigurationNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InsufficientClusterCapacityFault(inner) => Error::InsufficientClusterCapacityFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidClusterSnapshotStateFault(inner) => Error::InvalidClusterSnapshotStateFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidClusterSubnetGroupStateFault(inner) => Error::InvalidClusterSubnetGroupStateFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidClusterTrackFault(inner) => Error::InvalidClusterTrackFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidElasticIpFault(inner) => Error::InvalidElasticIpFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidReservedNodeStateFault(inner) => Error::InvalidReservedNodeStateFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidRestoreFault(inner) => Error::InvalidRestoreFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidSubnet(inner) => Error::InvalidSubnet(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidTagFault(inner) => Error::InvalidTagFault(inner),
            crate::error::RestoreFromClusterSnapshotError::InvalidVpcNetworkStateFault(inner) => Error::InvalidVpcNetworkStateFault(inner),
            crate::error::RestoreFromClusterSnapshotError::LimitExceededFault(inner) => Error::LimitExceededFault(inner),
            crate::error::RestoreFromClusterSnapshotError::NumberOfNodesPerClusterLimitExceededFault(inner) => Error::NumberOfNodesPerClusterLimitExceededFault(inner),
            crate::error::RestoreFromClusterSnapshotError::NumberOfNodesQuotaExceededFault(inner) => Error::NumberOfNodesQuotaExceededFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ReservedNodeAlreadyExistsFault(inner) => Error::ReservedNodeAlreadyExistsFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ReservedNodeAlreadyMigratedFault(inner) => Error::ReservedNodeAlreadyMigratedFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ReservedNodeNotFoundFault(inner) => Error::ReservedNodeNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::ReservedNodeOfferingNotFoundFault(inner) => Error::ReservedNodeOfferingNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::SnapshotScheduleNotFoundFault(inner) => Error::SnapshotScheduleNotFoundFault(inner),
            crate::error::RestoreFromClusterSnapshotError::TagLimitExceededFault(inner) => Error::TagLimitExceededFault(inner),
            crate::error::RestoreFromClusterSnapshotError::UnauthorizedOperation(inner) => Error::UnauthorizedOperation(inner),
            crate::error::RestoreFromClusterSnapshotError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::RestoreFromClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::RestoreTableFromClusterSnapshotError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::RestoreTableFromClusterSnapshotError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RestoreTableFromClusterSnapshotError> for Error {
    fn from(err: crate::error::RestoreTableFromClusterSnapshotError) -> Self {
        match err {
            crate::error::RestoreTableFromClusterSnapshotError::ClusterNotFoundFault(inner) => Error::ClusterNotFoundFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::ClusterSnapshotNotFoundFault(inner) => Error::ClusterSnapshotNotFoundFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::InProgressTableRestoreQuotaExceededFault(inner) => Error::InProgressTableRestoreQuotaExceededFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::InvalidClusterSnapshotStateFault(inner) => Error::InvalidClusterSnapshotStateFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::InvalidClusterStateFault(inner) => Error::InvalidClusterStateFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::InvalidTableRestoreArgumentFault(inner) => Error::InvalidTableRestoreArgumentFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::UnsupportedOperationFault(inner) => Error::UnsupportedOperationFault(inner),
            crate::error::RestoreTableFromClusterSnapshotError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ResumeClusterError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ResumeClusterError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ResumeClusterError> for Error {
    fn from(err: crate::error::ResumeClusterError) -> Self {
        match err {
            crate::error::ResumeClusterError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::ResumeClusterError::InsufficientClusterCapacityFault(inner) => {
                Error::InsufficientClusterCapacityFault(inner)
            }
            crate::error::ResumeClusterError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::ResumeClusterError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::RevokeClusterSecurityGroupIngressError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::RevokeClusterSecurityGroupIngressError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RevokeClusterSecurityGroupIngressError> for Error {
    fn from(err: crate::error::RevokeClusterSecurityGroupIngressError) -> Self {
        match err {
            crate::error::RevokeClusterSecurityGroupIngressError::AuthorizationNotFoundFault(inner) => Error::AuthorizationNotFoundFault(inner),
            crate::error::RevokeClusterSecurityGroupIngressError::ClusterSecurityGroupNotFoundFault(inner) => Error::ClusterSecurityGroupNotFoundFault(inner),
            crate::error::RevokeClusterSecurityGroupIngressError::InvalidClusterSecurityGroupStateFault(inner) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::RevokeClusterSecurityGroupIngressError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RevokeEndpointAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RevokeEndpointAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RevokeEndpointAccessError> for Error {
    fn from(err: crate::error::RevokeEndpointAccessError) -> Self {
        match err {
            crate::error::RevokeEndpointAccessError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::RevokeEndpointAccessError::EndpointAuthorizationNotFoundFault(inner) => {
                Error::EndpointAuthorizationNotFoundFault(inner)
            }
            crate::error::RevokeEndpointAccessError::EndpointNotFoundFault(inner) => {
                Error::EndpointNotFoundFault(inner)
            }
            crate::error::RevokeEndpointAccessError::InvalidAuthorizationStateFault(inner) => {
                Error::InvalidAuthorizationStateFault(inner)
            }
            crate::error::RevokeEndpointAccessError::InvalidClusterSecurityGroupStateFault(
                inner,
            ) => Error::InvalidClusterSecurityGroupStateFault(inner),
            crate::error::RevokeEndpointAccessError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::RevokeEndpointAccessError::InvalidEndpointStateFault(inner) => {
                Error::InvalidEndpointStateFault(inner)
            }
            crate::error::RevokeEndpointAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RevokeSnapshotAccessError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RevokeSnapshotAccessError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RevokeSnapshotAccessError> for Error {
    fn from(err: crate::error::RevokeSnapshotAccessError) -> Self {
        match err {
            crate::error::RevokeSnapshotAccessError::AccessToSnapshotDeniedFault(inner) => {
                Error::AccessToSnapshotDeniedFault(inner)
            }
            crate::error::RevokeSnapshotAccessError::AuthorizationNotFoundFault(inner) => {
                Error::AuthorizationNotFoundFault(inner)
            }
            crate::error::RevokeSnapshotAccessError::ClusterSnapshotNotFoundFault(inner) => {
                Error::ClusterSnapshotNotFoundFault(inner)
            }
            crate::error::RevokeSnapshotAccessError::UnsupportedOperationFault(inner) => {
                Error::UnsupportedOperationFault(inner)
            }
            crate::error::RevokeSnapshotAccessError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RotateEncryptionKeyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RotateEncryptionKeyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RotateEncryptionKeyError> for Error {
    fn from(err: crate::error::RotateEncryptionKeyError) -> Self {
        match err {
            crate::error::RotateEncryptionKeyError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::RotateEncryptionKeyError::DependentServiceRequestThrottlingFault(
                inner,
            ) => Error::DependentServiceRequestThrottlingFault(inner),
            crate::error::RotateEncryptionKeyError::InvalidClusterStateFault(inner) => {
                Error::InvalidClusterStateFault(inner)
            }
            crate::error::RotateEncryptionKeyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePartnerStatusError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdatePartnerStatusError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdatePartnerStatusError> for Error {
    fn from(err: crate::error::UpdatePartnerStatusError) -> Self {
        match err {
            crate::error::UpdatePartnerStatusError::ClusterNotFoundFault(inner) => {
                Error::ClusterNotFoundFault(inner)
            }
            crate::error::UpdatePartnerStatusError::PartnerNotFoundFault(inner) => {
                Error::PartnerNotFoundFault(inner)
            }
            crate::error::UpdatePartnerStatusError::UnauthorizedPartnerIntegrationFault(inner) => {
                Error::UnauthorizedPartnerIntegrationFault(inner)
            }
            crate::error::UpdatePartnerStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessToClusterDeniedFault(e) => e.request_id(),
            Self::AccessToSnapshotDeniedFault(e) => e.request_id(),
            Self::AuthenticationProfileAlreadyExistsFault(e) => e.request_id(),
            Self::AuthenticationProfileNotFoundFault(e) => e.request_id(),
            Self::AuthenticationProfileQuotaExceededFault(e) => e.request_id(),
            Self::AuthorizationAlreadyExistsFault(e) => e.request_id(),
            Self::AuthorizationNotFoundFault(e) => e.request_id(),
            Self::AuthorizationQuotaExceededFault(e) => e.request_id(),
            Self::BatchDeleteRequestSizeExceededFault(e) => e.request_id(),
            Self::BatchModifyClusterSnapshotsLimitExceededFault(e) => e.request_id(),
            Self::BucketNotFoundFault(e) => e.request_id(),
            Self::ClusterAlreadyExistsFault(e) => e.request_id(),
            Self::ClusterNotFoundFault(e) => e.request_id(),
            Self::ClusterOnLatestRevisionFault(e) => e.request_id(),
            Self::ClusterParameterGroupAlreadyExistsFault(e) => e.request_id(),
            Self::ClusterParameterGroupNotFoundFault(e) => e.request_id(),
            Self::ClusterParameterGroupQuotaExceededFault(e) => e.request_id(),
            Self::ClusterQuotaExceededFault(e) => e.request_id(),
            Self::ClusterSecurityGroupAlreadyExistsFault(e) => e.request_id(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.request_id(),
            Self::ClusterSecurityGroupQuotaExceededFault(e) => e.request_id(),
            Self::ClusterSnapshotAlreadyExistsFault(e) => e.request_id(),
            Self::ClusterSnapshotNotFoundFault(e) => e.request_id(),
            Self::ClusterSnapshotQuotaExceededFault(e) => e.request_id(),
            Self::ClusterSubnetGroupAlreadyExistsFault(e) => e.request_id(),
            Self::ClusterSubnetGroupNotFoundFault(e) => e.request_id(),
            Self::ClusterSubnetGroupQuotaExceededFault(e) => e.request_id(),
            Self::ClusterSubnetQuotaExceededFault(e) => e.request_id(),
            Self::CopyToRegionDisabledFault(e) => e.request_id(),
            Self::DependentServiceRequestThrottlingFault(e) => e.request_id(),
            Self::DependentServiceUnavailableFault(e) => e.request_id(),
            Self::EndpointAlreadyExistsFault(e) => e.request_id(),
            Self::EndpointAuthorizationAlreadyExistsFault(e) => e.request_id(),
            Self::EndpointAuthorizationNotFoundFault(e) => e.request_id(),
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(e) => e.request_id(),
            Self::EndpointNotFoundFault(e) => e.request_id(),
            Self::EndpointsPerAuthorizationLimitExceededFault(e) => e.request_id(),
            Self::EndpointsPerClusterLimitExceededFault(e) => e.request_id(),
            Self::EventSubscriptionQuotaExceededFault(e) => e.request_id(),
            Self::HsmClientCertificateAlreadyExistsFault(e) => e.request_id(),
            Self::HsmClientCertificateNotFoundFault(e) => e.request_id(),
            Self::HsmClientCertificateQuotaExceededFault(e) => e.request_id(),
            Self::HsmConfigurationAlreadyExistsFault(e) => e.request_id(),
            Self::HsmConfigurationNotFoundFault(e) => e.request_id(),
            Self::HsmConfigurationQuotaExceededFault(e) => e.request_id(),
            Self::InProgressTableRestoreQuotaExceededFault(e) => e.request_id(),
            Self::IncompatibleOrderableOptions(e) => e.request_id(),
            Self::InsufficientClusterCapacityFault(e) => e.request_id(),
            Self::InsufficientS3BucketPolicyFault(e) => e.request_id(),
            Self::InvalidAuthenticationProfileRequestFault(e) => e.request_id(),
            Self::InvalidAuthorizationStateFault(e) => e.request_id(),
            Self::InvalidClusterParameterGroupStateFault(e) => e.request_id(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.request_id(),
            Self::InvalidClusterSnapshotScheduleStateFault(e) => e.request_id(),
            Self::InvalidClusterSnapshotStateFault(e) => e.request_id(),
            Self::InvalidClusterStateFault(e) => e.request_id(),
            Self::InvalidClusterSubnetGroupStateFault(e) => e.request_id(),
            Self::InvalidClusterSubnetStateFault(e) => e.request_id(),
            Self::InvalidClusterTrackFault(e) => e.request_id(),
            Self::InvalidDataShareFault(e) => e.request_id(),
            Self::InvalidElasticIpFault(e) => e.request_id(),
            Self::InvalidEndpointStateFault(e) => e.request_id(),
            Self::InvalidHsmClientCertificateStateFault(e) => e.request_id(),
            Self::InvalidHsmConfigurationStateFault(e) => e.request_id(),
            Self::InvalidNamespaceFault(e) => e.request_id(),
            Self::InvalidReservedNodeStateFault(e) => e.request_id(),
            Self::InvalidRestoreFault(e) => e.request_id(),
            Self::InvalidRetentionPeriodFault(e) => e.request_id(),
            Self::InvalidS3BucketNameFault(e) => e.request_id(),
            Self::InvalidS3KeyPrefixFault(e) => e.request_id(),
            Self::InvalidScheduleFault(e) => e.request_id(),
            Self::InvalidScheduledActionFault(e) => e.request_id(),
            Self::InvalidSnapshotCopyGrantStateFault(e) => e.request_id(),
            Self::InvalidSubnet(e) => e.request_id(),
            Self::InvalidSubscriptionStateFault(e) => e.request_id(),
            Self::InvalidTableRestoreArgumentFault(e) => e.request_id(),
            Self::InvalidTagFault(e) => e.request_id(),
            Self::InvalidUsageLimitFault(e) => e.request_id(),
            Self::InvalidVpcNetworkStateFault(e) => e.request_id(),
            Self::LimitExceededFault(e) => e.request_id(),
            Self::NumberOfNodesPerClusterLimitExceededFault(e) => e.request_id(),
            Self::NumberOfNodesQuotaExceededFault(e) => e.request_id(),
            Self::PartnerNotFoundFault(e) => e.request_id(),
            Self::ReservedNodeAlreadyExistsFault(e) => e.request_id(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.request_id(),
            Self::ReservedNodeExchangeNotFoundFault(e) => e.request_id(),
            Self::ReservedNodeNotFoundFault(e) => e.request_id(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.request_id(),
            Self::ReservedNodeQuotaExceededFault(e) => e.request_id(),
            Self::ResizeNotFoundFault(e) => e.request_id(),
            Self::ResourceNotFoundFault(e) => e.request_id(),
            Self::SnsInvalidTopicFault(e) => e.request_id(),
            Self::SnsNoAuthorizationFault(e) => e.request_id(),
            Self::SnsTopicArnNotFoundFault(e) => e.request_id(),
            Self::ScheduleDefinitionTypeUnsupportedFault(e) => e.request_id(),
            Self::ScheduledActionAlreadyExistsFault(e) => e.request_id(),
            Self::ScheduledActionNotFoundFault(e) => e.request_id(),
            Self::ScheduledActionQuotaExceededFault(e) => e.request_id(),
            Self::ScheduledActionTypeUnsupportedFault(e) => e.request_id(),
            Self::SnapshotCopyAlreadyDisabledFault(e) => e.request_id(),
            Self::SnapshotCopyAlreadyEnabledFault(e) => e.request_id(),
            Self::SnapshotCopyDisabledFault(e) => e.request_id(),
            Self::SnapshotCopyGrantAlreadyExistsFault(e) => e.request_id(),
            Self::SnapshotCopyGrantNotFoundFault(e) => e.request_id(),
            Self::SnapshotCopyGrantQuotaExceededFault(e) => e.request_id(),
            Self::SnapshotScheduleAlreadyExistsFault(e) => e.request_id(),
            Self::SnapshotScheduleNotFoundFault(e) => e.request_id(),
            Self::SnapshotScheduleQuotaExceededFault(e) => e.request_id(),
            Self::SnapshotScheduleUpdateInProgressFault(e) => e.request_id(),
            Self::SourceNotFoundFault(e) => e.request_id(),
            Self::SubnetAlreadyInUse(e) => e.request_id(),
            Self::SubscriptionAlreadyExistFault(e) => e.request_id(),
            Self::SubscriptionCategoryNotFoundFault(e) => e.request_id(),
            Self::SubscriptionEventIdNotFoundFault(e) => e.request_id(),
            Self::SubscriptionNotFoundFault(e) => e.request_id(),
            Self::SubscriptionSeverityNotFoundFault(e) => e.request_id(),
            Self::TableLimitExceededFault(e) => e.request_id(),
            Self::TableRestoreNotFoundFault(e) => e.request_id(),
            Self::TagLimitExceededFault(e) => e.request_id(),
            Self::UnauthorizedOperation(e) => e.request_id(),
            Self::UnauthorizedPartnerIntegrationFault(e) => e.request_id(),
            Self::UnknownSnapshotCopyRegionFault(e) => e.request_id(),
            Self::UnsupportedOperationFault(e) => e.request_id(),
            Self::UnsupportedOptionFault(e) => e.request_id(),
            Self::UsageLimitAlreadyExistsFault(e) => e.request_id(),
            Self::UsageLimitNotFoundFault(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
