// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn serialize_operation_crate_operation_accept_reserved_node_exchange(
    input: &crate::input::AcceptReservedNodeExchangeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AcceptReservedNodeExchange", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1 = writer.prefix("ReservedNodeId");
    if let Some(var_2) = &input.reserved_node_id {
        scope_1.string(var_2);
    }
    #[allow(unused_mut)]
    let mut scope_3 = writer.prefix("TargetReservedNodeOfferingId");
    if let Some(var_4) = &input.target_reserved_node_offering_id {
        scope_3.string(var_4);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_add_partner(
    input: &crate::input::AddPartnerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AddPartner", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_5 = writer.prefix("AccountId");
    if let Some(var_6) = &input.account_id {
        scope_5.string(var_6);
    }
    #[allow(unused_mut)]
    let mut scope_7 = writer.prefix("ClusterIdentifier");
    if let Some(var_8) = &input.cluster_identifier {
        scope_7.string(var_8);
    }
    #[allow(unused_mut)]
    let mut scope_9 = writer.prefix("DatabaseName");
    if let Some(var_10) = &input.database_name {
        scope_9.string(var_10);
    }
    #[allow(unused_mut)]
    let mut scope_11 = writer.prefix("PartnerName");
    if let Some(var_12) = &input.partner_name {
        scope_11.string(var_12);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_associate_data_share_consumer(
    input: &crate::input::AssociateDataShareConsumerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AssociateDataShareConsumer", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_13 = writer.prefix("DataShareArn");
    if let Some(var_14) = &input.data_share_arn {
        scope_13.string(var_14);
    }
    #[allow(unused_mut)]
    let mut scope_15 = writer.prefix("AssociateEntireAccount");
    if let Some(var_16) = &input.associate_entire_account {
        scope_15.boolean(*var_16);
    }
    #[allow(unused_mut)]
    let mut scope_17 = writer.prefix("ConsumerArn");
    if let Some(var_18) = &input.consumer_arn {
        scope_17.string(var_18);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_authorize_cluster_security_group_ingress(
    input: &crate::input::AuthorizeClusterSecurityGroupIngressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(
        &mut out,
        "AuthorizeClusterSecurityGroupIngress",
        "2012-12-01",
    );
    #[allow(unused_mut)]
    let mut scope_19 = writer.prefix("ClusterSecurityGroupName");
    if let Some(var_20) = &input.cluster_security_group_name {
        scope_19.string(var_20);
    }
    #[allow(unused_mut)]
    let mut scope_21 = writer.prefix("CIDRIP");
    if let Some(var_22) = &input.cidrip {
        scope_21.string(var_22);
    }
    #[allow(unused_mut)]
    let mut scope_23 = writer.prefix("EC2SecurityGroupName");
    if let Some(var_24) = &input.ec2_security_group_name {
        scope_23.string(var_24);
    }
    #[allow(unused_mut)]
    let mut scope_25 = writer.prefix("EC2SecurityGroupOwnerId");
    if let Some(var_26) = &input.ec2_security_group_owner_id {
        scope_25.string(var_26);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_authorize_data_share(
    input: &crate::input::AuthorizeDataShareInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "AuthorizeDataShare", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_27 = writer.prefix("DataShareArn");
    if let Some(var_28) = &input.data_share_arn {
        scope_27.string(var_28);
    }
    #[allow(unused_mut)]
    let mut scope_29 = writer.prefix("ConsumerIdentifier");
    if let Some(var_30) = &input.consumer_identifier {
        scope_29.string(var_30);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_authorize_endpoint_access(
    input: &crate::input::AuthorizeEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AuthorizeEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_31 = writer.prefix("ClusterIdentifier");
    if let Some(var_32) = &input.cluster_identifier {
        scope_31.string(var_32);
    }
    #[allow(unused_mut)]
    let mut scope_33 = writer.prefix("Account");
    if let Some(var_34) = &input.account {
        scope_33.string(var_34);
    }
    #[allow(unused_mut)]
    let mut scope_35 = writer.prefix("VpcIds");
    if let Some(var_36) = &input.vpc_ids {
        let mut list_38 = scope_35.start_list(false, Some("VpcIdentifier"));
        for item_37 in var_36 {
            #[allow(unused_mut)]
            let mut entry_39 = list_38.entry();
            entry_39.string(item_37);
        }
        list_38.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_authorize_snapshot_access(
    input: &crate::input::AuthorizeSnapshotAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "AuthorizeSnapshotAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_40 = writer.prefix("SnapshotIdentifier");
    if let Some(var_41) = &input.snapshot_identifier {
        scope_40.string(var_41);
    }
    #[allow(unused_mut)]
    let mut scope_42 = writer.prefix("SnapshotClusterIdentifier");
    if let Some(var_43) = &input.snapshot_cluster_identifier {
        scope_42.string(var_43);
    }
    #[allow(unused_mut)]
    let mut scope_44 = writer.prefix("AccountWithRestoreAccess");
    if let Some(var_45) = &input.account_with_restore_access {
        scope_44.string(var_45);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_batch_delete_cluster_snapshots(
    input: &crate::input::BatchDeleteClusterSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "BatchDeleteClusterSnapshots", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_46 = writer.prefix("Identifiers");
    if let Some(var_47) = &input.identifiers {
        let mut list_49 = scope_46.start_list(false, Some("DeleteClusterSnapshotMessage"));
        for item_48 in var_47 {
            #[allow(unused_mut)]
            let mut entry_50 = list_49.entry();
            crate::query_ser::serialize_structure_crate_model_delete_cluster_snapshot_message(
                entry_50, item_48,
            );
        }
        list_49.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_batch_modify_cluster_snapshots(
    input: &crate::input::BatchModifyClusterSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "BatchModifyClusterSnapshots", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_51 = writer.prefix("SnapshotIdentifierList");
    if let Some(var_52) = &input.snapshot_identifier_list {
        let mut list_54 = scope_51.start_list(false, Some("String"));
        for item_53 in var_52 {
            #[allow(unused_mut)]
            let mut entry_55 = list_54.entry();
            entry_55.string(item_53);
        }
        list_54.finish();
    }
    #[allow(unused_mut)]
    let mut scope_56 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_57) = &input.manual_snapshot_retention_period {
        scope_56.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_57).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_58 = writer.prefix("Force");
    if input.force {
        scope_58.boolean(input.force);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_cancel_resize(
    input: &crate::input::CancelResizeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CancelResize", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_59 = writer.prefix("ClusterIdentifier");
    if let Some(var_60) = &input.cluster_identifier {
        scope_59.string(var_60);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_copy_cluster_snapshot(
    input: &crate::input::CopyClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CopyClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_61 = writer.prefix("SourceSnapshotIdentifier");
    if let Some(var_62) = &input.source_snapshot_identifier {
        scope_61.string(var_62);
    }
    #[allow(unused_mut)]
    let mut scope_63 = writer.prefix("SourceSnapshotClusterIdentifier");
    if let Some(var_64) = &input.source_snapshot_cluster_identifier {
        scope_63.string(var_64);
    }
    #[allow(unused_mut)]
    let mut scope_65 = writer.prefix("TargetSnapshotIdentifier");
    if let Some(var_66) = &input.target_snapshot_identifier {
        scope_65.string(var_66);
    }
    #[allow(unused_mut)]
    let mut scope_67 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_68) = &input.manual_snapshot_retention_period {
        scope_67.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_68).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_authentication_profile(
    input: &crate::input::CreateAuthenticationProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateAuthenticationProfile", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_69 = writer.prefix("AuthenticationProfileName");
    if let Some(var_70) = &input.authentication_profile_name {
        scope_69.string(var_70);
    }
    #[allow(unused_mut)]
    let mut scope_71 = writer.prefix("AuthenticationProfileContent");
    if let Some(var_72) = &input.authentication_profile_content {
        scope_71.string(var_72);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_cluster(
    input: &crate::input::CreateClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_73 = writer.prefix("DBName");
    if let Some(var_74) = &input.db_name {
        scope_73.string(var_74);
    }
    #[allow(unused_mut)]
    let mut scope_75 = writer.prefix("ClusterIdentifier");
    if let Some(var_76) = &input.cluster_identifier {
        scope_75.string(var_76);
    }
    #[allow(unused_mut)]
    let mut scope_77 = writer.prefix("ClusterType");
    if let Some(var_78) = &input.cluster_type {
        scope_77.string(var_78);
    }
    #[allow(unused_mut)]
    let mut scope_79 = writer.prefix("NodeType");
    if let Some(var_80) = &input.node_type {
        scope_79.string(var_80);
    }
    #[allow(unused_mut)]
    let mut scope_81 = writer.prefix("MasterUsername");
    if let Some(var_82) = &input.master_username {
        scope_81.string(var_82);
    }
    #[allow(unused_mut)]
    let mut scope_83 = writer.prefix("MasterUserPassword");
    if let Some(var_84) = &input.master_user_password {
        scope_83.string(var_84);
    }
    #[allow(unused_mut)]
    let mut scope_85 = writer.prefix("ClusterSecurityGroups");
    if let Some(var_86) = &input.cluster_security_groups {
        let mut list_88 = scope_85.start_list(false, Some("ClusterSecurityGroupName"));
        for item_87 in var_86 {
            #[allow(unused_mut)]
            let mut entry_89 = list_88.entry();
            entry_89.string(item_87);
        }
        list_88.finish();
    }
    #[allow(unused_mut)]
    let mut scope_90 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_91) = &input.vpc_security_group_ids {
        let mut list_93 = scope_90.start_list(false, Some("VpcSecurityGroupId"));
        for item_92 in var_91 {
            #[allow(unused_mut)]
            let mut entry_94 = list_93.entry();
            entry_94.string(item_92);
        }
        list_93.finish();
    }
    #[allow(unused_mut)]
    let mut scope_95 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_96) = &input.cluster_subnet_group_name {
        scope_95.string(var_96);
    }
    #[allow(unused_mut)]
    let mut scope_97 = writer.prefix("AvailabilityZone");
    if let Some(var_98) = &input.availability_zone {
        scope_97.string(var_98);
    }
    #[allow(unused_mut)]
    let mut scope_99 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_100) = &input.preferred_maintenance_window {
        scope_99.string(var_100);
    }
    #[allow(unused_mut)]
    let mut scope_101 = writer.prefix("ClusterParameterGroupName");
    if let Some(var_102) = &input.cluster_parameter_group_name {
        scope_101.string(var_102);
    }
    #[allow(unused_mut)]
    let mut scope_103 = writer.prefix("AutomatedSnapshotRetentionPeriod");
    if let Some(var_104) = &input.automated_snapshot_retention_period {
        scope_103.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_104).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_105 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_106) = &input.manual_snapshot_retention_period {
        scope_105.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_106).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_107 = writer.prefix("Port");
    if let Some(var_108) = &input.port {
        scope_107.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_108).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_109 = writer.prefix("ClusterVersion");
    if let Some(var_110) = &input.cluster_version {
        scope_109.string(var_110);
    }
    #[allow(unused_mut)]
    let mut scope_111 = writer.prefix("AllowVersionUpgrade");
    if let Some(var_112) = &input.allow_version_upgrade {
        scope_111.boolean(*var_112);
    }
    #[allow(unused_mut)]
    let mut scope_113 = writer.prefix("NumberOfNodes");
    if let Some(var_114) = &input.number_of_nodes {
        scope_113.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_114).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_115 = writer.prefix("PubliclyAccessible");
    if let Some(var_116) = &input.publicly_accessible {
        scope_115.boolean(*var_116);
    }
    #[allow(unused_mut)]
    let mut scope_117 = writer.prefix("Encrypted");
    if let Some(var_118) = &input.encrypted {
        scope_117.boolean(*var_118);
    }
    #[allow(unused_mut)]
    let mut scope_119 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_120) = &input.hsm_client_certificate_identifier {
        scope_119.string(var_120);
    }
    #[allow(unused_mut)]
    let mut scope_121 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_122) = &input.hsm_configuration_identifier {
        scope_121.string(var_122);
    }
    #[allow(unused_mut)]
    let mut scope_123 = writer.prefix("ElasticIp");
    if let Some(var_124) = &input.elastic_ip {
        scope_123.string(var_124);
    }
    #[allow(unused_mut)]
    let mut scope_125 = writer.prefix("Tags");
    if let Some(var_126) = &input.tags {
        let mut list_128 = scope_125.start_list(false, Some("Tag"));
        for item_127 in var_126 {
            #[allow(unused_mut)]
            let mut entry_129 = list_128.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_129, item_127);
        }
        list_128.finish();
    }
    #[allow(unused_mut)]
    let mut scope_130 = writer.prefix("KmsKeyId");
    if let Some(var_131) = &input.kms_key_id {
        scope_130.string(var_131);
    }
    #[allow(unused_mut)]
    let mut scope_132 = writer.prefix("EnhancedVpcRouting");
    if let Some(var_133) = &input.enhanced_vpc_routing {
        scope_132.boolean(*var_133);
    }
    #[allow(unused_mut)]
    let mut scope_134 = writer.prefix("AdditionalInfo");
    if let Some(var_135) = &input.additional_info {
        scope_134.string(var_135);
    }
    #[allow(unused_mut)]
    let mut scope_136 = writer.prefix("IamRoles");
    if let Some(var_137) = &input.iam_roles {
        let mut list_139 = scope_136.start_list(false, Some("IamRoleArn"));
        for item_138 in var_137 {
            #[allow(unused_mut)]
            let mut entry_140 = list_139.entry();
            entry_140.string(item_138);
        }
        list_139.finish();
    }
    #[allow(unused_mut)]
    let mut scope_141 = writer.prefix("MaintenanceTrackName");
    if let Some(var_142) = &input.maintenance_track_name {
        scope_141.string(var_142);
    }
    #[allow(unused_mut)]
    let mut scope_143 = writer.prefix("SnapshotScheduleIdentifier");
    if let Some(var_144) = &input.snapshot_schedule_identifier {
        scope_143.string(var_144);
    }
    #[allow(unused_mut)]
    let mut scope_145 = writer.prefix("AvailabilityZoneRelocation");
    if let Some(var_146) = &input.availability_zone_relocation {
        scope_145.boolean(*var_146);
    }
    #[allow(unused_mut)]
    let mut scope_147 = writer.prefix("AquaConfigurationStatus");
    if let Some(var_148) = &input.aqua_configuration_status {
        scope_147.string(var_148.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_cluster_parameter_group(
    input: &crate::input::CreateClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateClusterParameterGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_149 = writer.prefix("ParameterGroupName");
    if let Some(var_150) = &input.parameter_group_name {
        scope_149.string(var_150);
    }
    #[allow(unused_mut)]
    let mut scope_151 = writer.prefix("ParameterGroupFamily");
    if let Some(var_152) = &input.parameter_group_family {
        scope_151.string(var_152);
    }
    #[allow(unused_mut)]
    let mut scope_153 = writer.prefix("Description");
    if let Some(var_154) = &input.description {
        scope_153.string(var_154);
    }
    #[allow(unused_mut)]
    let mut scope_155 = writer.prefix("Tags");
    if let Some(var_156) = &input.tags {
        let mut list_158 = scope_155.start_list(false, Some("Tag"));
        for item_157 in var_156 {
            #[allow(unused_mut)]
            let mut entry_159 = list_158.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_159, item_157);
        }
        list_158.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_cluster_security_group(
    input: &crate::input::CreateClusterSecurityGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateClusterSecurityGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_160 = writer.prefix("ClusterSecurityGroupName");
    if let Some(var_161) = &input.cluster_security_group_name {
        scope_160.string(var_161);
    }
    #[allow(unused_mut)]
    let mut scope_162 = writer.prefix("Description");
    if let Some(var_163) = &input.description {
        scope_162.string(var_163);
    }
    #[allow(unused_mut)]
    let mut scope_164 = writer.prefix("Tags");
    if let Some(var_165) = &input.tags {
        let mut list_167 = scope_164.start_list(false, Some("Tag"));
        for item_166 in var_165 {
            #[allow(unused_mut)]
            let mut entry_168 = list_167.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_168, item_166);
        }
        list_167.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_cluster_snapshot(
    input: &crate::input::CreateClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_169 = writer.prefix("SnapshotIdentifier");
    if let Some(var_170) = &input.snapshot_identifier {
        scope_169.string(var_170);
    }
    #[allow(unused_mut)]
    let mut scope_171 = writer.prefix("ClusterIdentifier");
    if let Some(var_172) = &input.cluster_identifier {
        scope_171.string(var_172);
    }
    #[allow(unused_mut)]
    let mut scope_173 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_174) = &input.manual_snapshot_retention_period {
        scope_173.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_174).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_175 = writer.prefix("Tags");
    if let Some(var_176) = &input.tags {
        let mut list_178 = scope_175.start_list(false, Some("Tag"));
        for item_177 in var_176 {
            #[allow(unused_mut)]
            let mut entry_179 = list_178.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_179, item_177);
        }
        list_178.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_cluster_subnet_group(
    input: &crate::input::CreateClusterSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateClusterSubnetGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_180 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_181) = &input.cluster_subnet_group_name {
        scope_180.string(var_181);
    }
    #[allow(unused_mut)]
    let mut scope_182 = writer.prefix("Description");
    if let Some(var_183) = &input.description {
        scope_182.string(var_183);
    }
    #[allow(unused_mut)]
    let mut scope_184 = writer.prefix("SubnetIds");
    if let Some(var_185) = &input.subnet_ids {
        let mut list_187 = scope_184.start_list(false, Some("SubnetIdentifier"));
        for item_186 in var_185 {
            #[allow(unused_mut)]
            let mut entry_188 = list_187.entry();
            entry_188.string(item_186);
        }
        list_187.finish();
    }
    #[allow(unused_mut)]
    let mut scope_189 = writer.prefix("Tags");
    if let Some(var_190) = &input.tags {
        let mut list_192 = scope_189.start_list(false, Some("Tag"));
        for item_191 in var_190 {
            #[allow(unused_mut)]
            let mut entry_193 = list_192.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_193, item_191);
        }
        list_192.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_endpoint_access(
    input: &crate::input::CreateEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_194 = writer.prefix("ClusterIdentifier");
    if let Some(var_195) = &input.cluster_identifier {
        scope_194.string(var_195);
    }
    #[allow(unused_mut)]
    let mut scope_196 = writer.prefix("ResourceOwner");
    if let Some(var_197) = &input.resource_owner {
        scope_196.string(var_197);
    }
    #[allow(unused_mut)]
    let mut scope_198 = writer.prefix("EndpointName");
    if let Some(var_199) = &input.endpoint_name {
        scope_198.string(var_199);
    }
    #[allow(unused_mut)]
    let mut scope_200 = writer.prefix("SubnetGroupName");
    if let Some(var_201) = &input.subnet_group_name {
        scope_200.string(var_201);
    }
    #[allow(unused_mut)]
    let mut scope_202 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_203) = &input.vpc_security_group_ids {
        let mut list_205 = scope_202.start_list(false, Some("VpcSecurityGroupId"));
        for item_204 in var_203 {
            #[allow(unused_mut)]
            let mut entry_206 = list_205.entry();
            entry_206.string(item_204);
        }
        list_205.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_event_subscription(
    input: &crate::input::CreateEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateEventSubscription", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_207 = writer.prefix("SubscriptionName");
    if let Some(var_208) = &input.subscription_name {
        scope_207.string(var_208);
    }
    #[allow(unused_mut)]
    let mut scope_209 = writer.prefix("SnsTopicArn");
    if let Some(var_210) = &input.sns_topic_arn {
        scope_209.string(var_210);
    }
    #[allow(unused_mut)]
    let mut scope_211 = writer.prefix("SourceType");
    if let Some(var_212) = &input.source_type {
        scope_211.string(var_212);
    }
    #[allow(unused_mut)]
    let mut scope_213 = writer.prefix("SourceIds");
    if let Some(var_214) = &input.source_ids {
        let mut list_216 = scope_213.start_list(false, Some("SourceId"));
        for item_215 in var_214 {
            #[allow(unused_mut)]
            let mut entry_217 = list_216.entry();
            entry_217.string(item_215);
        }
        list_216.finish();
    }
    #[allow(unused_mut)]
    let mut scope_218 = writer.prefix("EventCategories");
    if let Some(var_219) = &input.event_categories {
        let mut list_221 = scope_218.start_list(false, Some("EventCategory"));
        for item_220 in var_219 {
            #[allow(unused_mut)]
            let mut entry_222 = list_221.entry();
            entry_222.string(item_220);
        }
        list_221.finish();
    }
    #[allow(unused_mut)]
    let mut scope_223 = writer.prefix("Severity");
    if let Some(var_224) = &input.severity {
        scope_223.string(var_224);
    }
    #[allow(unused_mut)]
    let mut scope_225 = writer.prefix("Enabled");
    if let Some(var_226) = &input.enabled {
        scope_225.boolean(*var_226);
    }
    #[allow(unused_mut)]
    let mut scope_227 = writer.prefix("Tags");
    if let Some(var_228) = &input.tags {
        let mut list_230 = scope_227.start_list(false, Some("Tag"));
        for item_229 in var_228 {
            #[allow(unused_mut)]
            let mut entry_231 = list_230.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_231, item_229);
        }
        list_230.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_hsm_client_certificate(
    input: &crate::input::CreateHsmClientCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateHsmClientCertificate", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_232 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_233) = &input.hsm_client_certificate_identifier {
        scope_232.string(var_233);
    }
    #[allow(unused_mut)]
    let mut scope_234 = writer.prefix("Tags");
    if let Some(var_235) = &input.tags {
        let mut list_237 = scope_234.start_list(false, Some("Tag"));
        for item_236 in var_235 {
            #[allow(unused_mut)]
            let mut entry_238 = list_237.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_238, item_236);
        }
        list_237.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_hsm_configuration(
    input: &crate::input::CreateHsmConfigurationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateHsmConfiguration", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_239 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_240) = &input.hsm_configuration_identifier {
        scope_239.string(var_240);
    }
    #[allow(unused_mut)]
    let mut scope_241 = writer.prefix("Description");
    if let Some(var_242) = &input.description {
        scope_241.string(var_242);
    }
    #[allow(unused_mut)]
    let mut scope_243 = writer.prefix("HsmIpAddress");
    if let Some(var_244) = &input.hsm_ip_address {
        scope_243.string(var_244);
    }
    #[allow(unused_mut)]
    let mut scope_245 = writer.prefix("HsmPartitionName");
    if let Some(var_246) = &input.hsm_partition_name {
        scope_245.string(var_246);
    }
    #[allow(unused_mut)]
    let mut scope_247 = writer.prefix("HsmPartitionPassword");
    if let Some(var_248) = &input.hsm_partition_password {
        scope_247.string(var_248);
    }
    #[allow(unused_mut)]
    let mut scope_249 = writer.prefix("HsmServerPublicCertificate");
    if let Some(var_250) = &input.hsm_server_public_certificate {
        scope_249.string(var_250);
    }
    #[allow(unused_mut)]
    let mut scope_251 = writer.prefix("Tags");
    if let Some(var_252) = &input.tags {
        let mut list_254 = scope_251.start_list(false, Some("Tag"));
        for item_253 in var_252 {
            #[allow(unused_mut)]
            let mut entry_255 = list_254.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_255, item_253);
        }
        list_254.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_scheduled_action(
    input: &crate::input::CreateScheduledActionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateScheduledAction", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_256 = writer.prefix("ScheduledActionName");
    if let Some(var_257) = &input.scheduled_action_name {
        scope_256.string(var_257);
    }
    #[allow(unused_mut)]
    let mut scope_258 = writer.prefix("TargetAction");
    if let Some(var_259) = &input.target_action {
        crate::query_ser::serialize_structure_crate_model_scheduled_action_type(scope_258, var_259);
    }
    #[allow(unused_mut)]
    let mut scope_260 = writer.prefix("Schedule");
    if let Some(var_261) = &input.schedule {
        scope_260.string(var_261);
    }
    #[allow(unused_mut)]
    let mut scope_262 = writer.prefix("IamRole");
    if let Some(var_263) = &input.iam_role {
        scope_262.string(var_263);
    }
    #[allow(unused_mut)]
    let mut scope_264 = writer.prefix("ScheduledActionDescription");
    if let Some(var_265) = &input.scheduled_action_description {
        scope_264.string(var_265);
    }
    #[allow(unused_mut)]
    let mut scope_266 = writer.prefix("StartTime");
    if let Some(var_267) = &input.start_time {
        scope_266.instant(var_267, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_268 = writer.prefix("EndTime");
    if let Some(var_269) = &input.end_time {
        scope_268.instant(var_269, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_270 = writer.prefix("Enable");
    if let Some(var_271) = &input.enable {
        scope_270.boolean(*var_271);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_snapshot_copy_grant(
    input: &crate::input::CreateSnapshotCopyGrantInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateSnapshotCopyGrant", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_272 = writer.prefix("SnapshotCopyGrantName");
    if let Some(var_273) = &input.snapshot_copy_grant_name {
        scope_272.string(var_273);
    }
    #[allow(unused_mut)]
    let mut scope_274 = writer.prefix("KmsKeyId");
    if let Some(var_275) = &input.kms_key_id {
        scope_274.string(var_275);
    }
    #[allow(unused_mut)]
    let mut scope_276 = writer.prefix("Tags");
    if let Some(var_277) = &input.tags {
        let mut list_279 = scope_276.start_list(false, Some("Tag"));
        for item_278 in var_277 {
            #[allow(unused_mut)]
            let mut entry_280 = list_279.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_280, item_278);
        }
        list_279.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_snapshot_schedule(
    input: &crate::input::CreateSnapshotScheduleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "CreateSnapshotSchedule", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_281 = writer.prefix("ScheduleDefinitions");
    if let Some(var_282) = &input.schedule_definitions {
        let mut list_284 = scope_281.start_list(false, Some("ScheduleDefinition"));
        for item_283 in var_282 {
            #[allow(unused_mut)]
            let mut entry_285 = list_284.entry();
            entry_285.string(item_283);
        }
        list_284.finish();
    }
    #[allow(unused_mut)]
    let mut scope_286 = writer.prefix("ScheduleIdentifier");
    if let Some(var_287) = &input.schedule_identifier {
        scope_286.string(var_287);
    }
    #[allow(unused_mut)]
    let mut scope_288 = writer.prefix("ScheduleDescription");
    if let Some(var_289) = &input.schedule_description {
        scope_288.string(var_289);
    }
    #[allow(unused_mut)]
    let mut scope_290 = writer.prefix("Tags");
    if let Some(var_291) = &input.tags {
        let mut list_293 = scope_290.start_list(false, Some("Tag"));
        for item_292 in var_291 {
            #[allow(unused_mut)]
            let mut entry_294 = list_293.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_294, item_292);
        }
        list_293.finish();
    }
    #[allow(unused_mut)]
    let mut scope_295 = writer.prefix("DryRun");
    if let Some(var_296) = &input.dry_run {
        scope_295.boolean(*var_296);
    }
    #[allow(unused_mut)]
    let mut scope_297 = writer.prefix("NextInvocations");
    if let Some(var_298) = &input.next_invocations {
        scope_297.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_298).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_tags(
    input: &crate::input::CreateTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateTags", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_299 = writer.prefix("ResourceName");
    if let Some(var_300) = &input.resource_name {
        scope_299.string(var_300);
    }
    #[allow(unused_mut)]
    let mut scope_301 = writer.prefix("Tags");
    if let Some(var_302) = &input.tags {
        let mut list_304 = scope_301.start_list(false, Some("Tag"));
        for item_303 in var_302 {
            #[allow(unused_mut)]
            let mut entry_305 = list_304.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_305, item_303);
        }
        list_304.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_create_usage_limit(
    input: &crate::input::CreateUsageLimitInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "CreateUsageLimit", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_306 = writer.prefix("ClusterIdentifier");
    if let Some(var_307) = &input.cluster_identifier {
        scope_306.string(var_307);
    }
    #[allow(unused_mut)]
    let mut scope_308 = writer.prefix("FeatureType");
    if let Some(var_309) = &input.feature_type {
        scope_308.string(var_309.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_310 = writer.prefix("LimitType");
    if let Some(var_311) = &input.limit_type {
        scope_310.string(var_311.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_312 = writer.prefix("Amount");
    {
        scope_312.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.amount).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_313 = writer.prefix("Period");
    if let Some(var_314) = &input.period {
        scope_313.string(var_314.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_315 = writer.prefix("BreachAction");
    if let Some(var_316) = &input.breach_action {
        scope_315.string(var_316.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_317 = writer.prefix("Tags");
    if let Some(var_318) = &input.tags {
        let mut list_320 = scope_317.start_list(false, Some("Tag"));
        for item_319 in var_318 {
            #[allow(unused_mut)]
            let mut entry_321 = list_320.entry();
            crate::query_ser::serialize_structure_crate_model_tag(entry_321, item_319);
        }
        list_320.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_deauthorize_data_share(
    input: &crate::input::DeauthorizeDataShareInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeauthorizeDataShare", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_322 = writer.prefix("DataShareArn");
    if let Some(var_323) = &input.data_share_arn {
        scope_322.string(var_323);
    }
    #[allow(unused_mut)]
    let mut scope_324 = writer.prefix("ConsumerIdentifier");
    if let Some(var_325) = &input.consumer_identifier {
        scope_324.string(var_325);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_authentication_profile(
    input: &crate::input::DeleteAuthenticationProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteAuthenticationProfile", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_326 = writer.prefix("AuthenticationProfileName");
    if let Some(var_327) = &input.authentication_profile_name {
        scope_326.string(var_327);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_cluster(
    input: &crate::input::DeleteClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_328 = writer.prefix("ClusterIdentifier");
    if let Some(var_329) = &input.cluster_identifier {
        scope_328.string(var_329);
    }
    #[allow(unused_mut)]
    let mut scope_330 = writer.prefix("SkipFinalClusterSnapshot");
    if input.skip_final_cluster_snapshot {
        scope_330.boolean(input.skip_final_cluster_snapshot);
    }
    #[allow(unused_mut)]
    let mut scope_331 = writer.prefix("FinalClusterSnapshotIdentifier");
    if let Some(var_332) = &input.final_cluster_snapshot_identifier {
        scope_331.string(var_332);
    }
    #[allow(unused_mut)]
    let mut scope_333 = writer.prefix("FinalClusterSnapshotRetentionPeriod");
    if let Some(var_334) = &input.final_cluster_snapshot_retention_period {
        scope_333.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_334).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_cluster_parameter_group(
    input: &crate::input::DeleteClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteClusterParameterGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_335 = writer.prefix("ParameterGroupName");
    if let Some(var_336) = &input.parameter_group_name {
        scope_335.string(var_336);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_cluster_security_group(
    input: &crate::input::DeleteClusterSecurityGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteClusterSecurityGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_337 = writer.prefix("ClusterSecurityGroupName");
    if let Some(var_338) = &input.cluster_security_group_name {
        scope_337.string(var_338);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_cluster_snapshot(
    input: &crate::input::DeleteClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_339 = writer.prefix("SnapshotIdentifier");
    if let Some(var_340) = &input.snapshot_identifier {
        scope_339.string(var_340);
    }
    #[allow(unused_mut)]
    let mut scope_341 = writer.prefix("SnapshotClusterIdentifier");
    if let Some(var_342) = &input.snapshot_cluster_identifier {
        scope_341.string(var_342);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_cluster_subnet_group(
    input: &crate::input::DeleteClusterSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteClusterSubnetGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_343 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_344) = &input.cluster_subnet_group_name {
        scope_343.string(var_344);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_endpoint_access(
    input: &crate::input::DeleteEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_345 = writer.prefix("EndpointName");
    if let Some(var_346) = &input.endpoint_name {
        scope_345.string(var_346);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_event_subscription(
    input: &crate::input::DeleteEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteEventSubscription", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_347 = writer.prefix("SubscriptionName");
    if let Some(var_348) = &input.subscription_name {
        scope_347.string(var_348);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_hsm_client_certificate(
    input: &crate::input::DeleteHsmClientCertificateInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteHsmClientCertificate", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_349 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_350) = &input.hsm_client_certificate_identifier {
        scope_349.string(var_350);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_hsm_configuration(
    input: &crate::input::DeleteHsmConfigurationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteHsmConfiguration", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_351 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_352) = &input.hsm_configuration_identifier {
        scope_351.string(var_352);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_partner(
    input: &crate::input::DeletePartnerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeletePartner", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_353 = writer.prefix("AccountId");
    if let Some(var_354) = &input.account_id {
        scope_353.string(var_354);
    }
    #[allow(unused_mut)]
    let mut scope_355 = writer.prefix("ClusterIdentifier");
    if let Some(var_356) = &input.cluster_identifier {
        scope_355.string(var_356);
    }
    #[allow(unused_mut)]
    let mut scope_357 = writer.prefix("DatabaseName");
    if let Some(var_358) = &input.database_name {
        scope_357.string(var_358);
    }
    #[allow(unused_mut)]
    let mut scope_359 = writer.prefix("PartnerName");
    if let Some(var_360) = &input.partner_name {
        scope_359.string(var_360);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_scheduled_action(
    input: &crate::input::DeleteScheduledActionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteScheduledAction", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_361 = writer.prefix("ScheduledActionName");
    if let Some(var_362) = &input.scheduled_action_name {
        scope_361.string(var_362);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_snapshot_copy_grant(
    input: &crate::input::DeleteSnapshotCopyGrantInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteSnapshotCopyGrant", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_363 = writer.prefix("SnapshotCopyGrantName");
    if let Some(var_364) = &input.snapshot_copy_grant_name {
        scope_363.string(var_364);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_snapshot_schedule(
    input: &crate::input::DeleteSnapshotScheduleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DeleteSnapshotSchedule", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_365 = writer.prefix("ScheduleIdentifier");
    if let Some(var_366) = &input.schedule_identifier {
        scope_365.string(var_366);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_tags(
    input: &crate::input::DeleteTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteTags", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_367 = writer.prefix("ResourceName");
    if let Some(var_368) = &input.resource_name {
        scope_367.string(var_368);
    }
    #[allow(unused_mut)]
    let mut scope_369 = writer.prefix("TagKeys");
    if let Some(var_370) = &input.tag_keys {
        let mut list_372 = scope_369.start_list(false, Some("TagKey"));
        for item_371 in var_370 {
            #[allow(unused_mut)]
            let mut entry_373 = list_372.entry();
            entry_373.string(item_371);
        }
        list_372.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_delete_usage_limit(
    input: &crate::input::DeleteUsageLimitInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DeleteUsageLimit", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_374 = writer.prefix("UsageLimitId");
    if let Some(var_375) = &input.usage_limit_id {
        scope_374.string(var_375);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_account_attributes(
    input: &crate::input::DescribeAccountAttributesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeAccountAttributes", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_376 = writer.prefix("AttributeNames");
    if let Some(var_377) = &input.attribute_names {
        let mut list_379 = scope_376.start_list(false, Some("AttributeName"));
        for item_378 in var_377 {
            #[allow(unused_mut)]
            let mut entry_380 = list_379.entry();
            entry_380.string(item_378);
        }
        list_379.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_authentication_profiles(
    input: &crate::input::DescribeAuthenticationProfilesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeAuthenticationProfiles", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_381 = writer.prefix("AuthenticationProfileName");
    if let Some(var_382) = &input.authentication_profile_name {
        scope_381.string(var_382);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_db_revisions(
    input: &crate::input::DescribeClusterDbRevisionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterDbRevisions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_383 = writer.prefix("ClusterIdentifier");
    if let Some(var_384) = &input.cluster_identifier {
        scope_383.string(var_384);
    }
    #[allow(unused_mut)]
    let mut scope_385 = writer.prefix("MaxRecords");
    if let Some(var_386) = &input.max_records {
        scope_385.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_386).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_387 = writer.prefix("Marker");
    if let Some(var_388) = &input.marker {
        scope_387.string(var_388);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_parameter_groups(
    input: &crate::input::DescribeClusterParameterGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterParameterGroups", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_389 = writer.prefix("ParameterGroupName");
    if let Some(var_390) = &input.parameter_group_name {
        scope_389.string(var_390);
    }
    #[allow(unused_mut)]
    let mut scope_391 = writer.prefix("MaxRecords");
    if let Some(var_392) = &input.max_records {
        scope_391.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_392).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_393 = writer.prefix("Marker");
    if let Some(var_394) = &input.marker {
        scope_393.string(var_394);
    }
    #[allow(unused_mut)]
    let mut scope_395 = writer.prefix("TagKeys");
    if let Some(var_396) = &input.tag_keys {
        let mut list_398 = scope_395.start_list(false, Some("TagKey"));
        for item_397 in var_396 {
            #[allow(unused_mut)]
            let mut entry_399 = list_398.entry();
            entry_399.string(item_397);
        }
        list_398.finish();
    }
    #[allow(unused_mut)]
    let mut scope_400 = writer.prefix("TagValues");
    if let Some(var_401) = &input.tag_values {
        let mut list_403 = scope_400.start_list(false, Some("TagValue"));
        for item_402 in var_401 {
            #[allow(unused_mut)]
            let mut entry_404 = list_403.entry();
            entry_404.string(item_402);
        }
        list_403.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_parameters(
    input: &crate::input::DescribeClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterParameters", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_405 = writer.prefix("ParameterGroupName");
    if let Some(var_406) = &input.parameter_group_name {
        scope_405.string(var_406);
    }
    #[allow(unused_mut)]
    let mut scope_407 = writer.prefix("Source");
    if let Some(var_408) = &input.source {
        scope_407.string(var_408);
    }
    #[allow(unused_mut)]
    let mut scope_409 = writer.prefix("MaxRecords");
    if let Some(var_410) = &input.max_records {
        scope_409.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_410).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_411 = writer.prefix("Marker");
    if let Some(var_412) = &input.marker {
        scope_411.string(var_412);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_clusters(
    input: &crate::input::DescribeClustersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeClusters", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_413 = writer.prefix("ClusterIdentifier");
    if let Some(var_414) = &input.cluster_identifier {
        scope_413.string(var_414);
    }
    #[allow(unused_mut)]
    let mut scope_415 = writer.prefix("MaxRecords");
    if let Some(var_416) = &input.max_records {
        scope_415.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_416).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_417 = writer.prefix("Marker");
    if let Some(var_418) = &input.marker {
        scope_417.string(var_418);
    }
    #[allow(unused_mut)]
    let mut scope_419 = writer.prefix("TagKeys");
    if let Some(var_420) = &input.tag_keys {
        let mut list_422 = scope_419.start_list(false, Some("TagKey"));
        for item_421 in var_420 {
            #[allow(unused_mut)]
            let mut entry_423 = list_422.entry();
            entry_423.string(item_421);
        }
        list_422.finish();
    }
    #[allow(unused_mut)]
    let mut scope_424 = writer.prefix("TagValues");
    if let Some(var_425) = &input.tag_values {
        let mut list_427 = scope_424.start_list(false, Some("TagValue"));
        for item_426 in var_425 {
            #[allow(unused_mut)]
            let mut entry_428 = list_427.entry();
            entry_428.string(item_426);
        }
        list_427.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_security_groups(
    input: &crate::input::DescribeClusterSecurityGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterSecurityGroups", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_429 = writer.prefix("ClusterSecurityGroupName");
    if let Some(var_430) = &input.cluster_security_group_name {
        scope_429.string(var_430);
    }
    #[allow(unused_mut)]
    let mut scope_431 = writer.prefix("MaxRecords");
    if let Some(var_432) = &input.max_records {
        scope_431.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_432).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_433 = writer.prefix("Marker");
    if let Some(var_434) = &input.marker {
        scope_433.string(var_434);
    }
    #[allow(unused_mut)]
    let mut scope_435 = writer.prefix("TagKeys");
    if let Some(var_436) = &input.tag_keys {
        let mut list_438 = scope_435.start_list(false, Some("TagKey"));
        for item_437 in var_436 {
            #[allow(unused_mut)]
            let mut entry_439 = list_438.entry();
            entry_439.string(item_437);
        }
        list_438.finish();
    }
    #[allow(unused_mut)]
    let mut scope_440 = writer.prefix("TagValues");
    if let Some(var_441) = &input.tag_values {
        let mut list_443 = scope_440.start_list(false, Some("TagValue"));
        for item_442 in var_441 {
            #[allow(unused_mut)]
            let mut entry_444 = list_443.entry();
            entry_444.string(item_442);
        }
        list_443.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_snapshots(
    input: &crate::input::DescribeClusterSnapshotsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterSnapshots", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_445 = writer.prefix("ClusterIdentifier");
    if let Some(var_446) = &input.cluster_identifier {
        scope_445.string(var_446);
    }
    #[allow(unused_mut)]
    let mut scope_447 = writer.prefix("SnapshotIdentifier");
    if let Some(var_448) = &input.snapshot_identifier {
        scope_447.string(var_448);
    }
    #[allow(unused_mut)]
    let mut scope_449 = writer.prefix("SnapshotType");
    if let Some(var_450) = &input.snapshot_type {
        scope_449.string(var_450);
    }
    #[allow(unused_mut)]
    let mut scope_451 = writer.prefix("StartTime");
    if let Some(var_452) = &input.start_time {
        scope_451.instant(var_452, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_453 = writer.prefix("EndTime");
    if let Some(var_454) = &input.end_time {
        scope_453.instant(var_454, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_455 = writer.prefix("MaxRecords");
    if let Some(var_456) = &input.max_records {
        scope_455.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_456).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_457 = writer.prefix("Marker");
    if let Some(var_458) = &input.marker {
        scope_457.string(var_458);
    }
    #[allow(unused_mut)]
    let mut scope_459 = writer.prefix("OwnerAccount");
    if let Some(var_460) = &input.owner_account {
        scope_459.string(var_460);
    }
    #[allow(unused_mut)]
    let mut scope_461 = writer.prefix("TagKeys");
    if let Some(var_462) = &input.tag_keys {
        let mut list_464 = scope_461.start_list(false, Some("TagKey"));
        for item_463 in var_462 {
            #[allow(unused_mut)]
            let mut entry_465 = list_464.entry();
            entry_465.string(item_463);
        }
        list_464.finish();
    }
    #[allow(unused_mut)]
    let mut scope_466 = writer.prefix("TagValues");
    if let Some(var_467) = &input.tag_values {
        let mut list_469 = scope_466.start_list(false, Some("TagValue"));
        for item_468 in var_467 {
            #[allow(unused_mut)]
            let mut entry_470 = list_469.entry();
            entry_470.string(item_468);
        }
        list_469.finish();
    }
    #[allow(unused_mut)]
    let mut scope_471 = writer.prefix("ClusterExists");
    if let Some(var_472) = &input.cluster_exists {
        scope_471.boolean(*var_472);
    }
    #[allow(unused_mut)]
    let mut scope_473 = writer.prefix("SortingEntities");
    if let Some(var_474) = &input.sorting_entities {
        let mut list_476 = scope_473.start_list(false, Some("SnapshotSortingEntity"));
        for item_475 in var_474 {
            #[allow(unused_mut)]
            let mut entry_477 = list_476.entry();
            crate::query_ser::serialize_structure_crate_model_snapshot_sorting_entity(
                entry_477, item_475,
            );
        }
        list_476.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_subnet_groups(
    input: &crate::input::DescribeClusterSubnetGroupsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterSubnetGroups", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_478 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_479) = &input.cluster_subnet_group_name {
        scope_478.string(var_479);
    }
    #[allow(unused_mut)]
    let mut scope_480 = writer.prefix("MaxRecords");
    if let Some(var_481) = &input.max_records {
        scope_480.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_481).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_482 = writer.prefix("Marker");
    if let Some(var_483) = &input.marker {
        scope_482.string(var_483);
    }
    #[allow(unused_mut)]
    let mut scope_484 = writer.prefix("TagKeys");
    if let Some(var_485) = &input.tag_keys {
        let mut list_487 = scope_484.start_list(false, Some("TagKey"));
        for item_486 in var_485 {
            #[allow(unused_mut)]
            let mut entry_488 = list_487.entry();
            entry_488.string(item_486);
        }
        list_487.finish();
    }
    #[allow(unused_mut)]
    let mut scope_489 = writer.prefix("TagValues");
    if let Some(var_490) = &input.tag_values {
        let mut list_492 = scope_489.start_list(false, Some("TagValue"));
        for item_491 in var_490 {
            #[allow(unused_mut)]
            let mut entry_493 = list_492.entry();
            entry_493.string(item_491);
        }
        list_492.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_tracks(
    input: &crate::input::DescribeClusterTracksInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterTracks", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_494 = writer.prefix("MaintenanceTrackName");
    if let Some(var_495) = &input.maintenance_track_name {
        scope_494.string(var_495);
    }
    #[allow(unused_mut)]
    let mut scope_496 = writer.prefix("MaxRecords");
    if let Some(var_497) = &input.max_records {
        scope_496.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_497).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_498 = writer.prefix("Marker");
    if let Some(var_499) = &input.marker {
        scope_498.string(var_499);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_cluster_versions(
    input: &crate::input::DescribeClusterVersionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeClusterVersions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_500 = writer.prefix("ClusterVersion");
    if let Some(var_501) = &input.cluster_version {
        scope_500.string(var_501);
    }
    #[allow(unused_mut)]
    let mut scope_502 = writer.prefix("ClusterParameterGroupFamily");
    if let Some(var_503) = &input.cluster_parameter_group_family {
        scope_502.string(var_503);
    }
    #[allow(unused_mut)]
    let mut scope_504 = writer.prefix("MaxRecords");
    if let Some(var_505) = &input.max_records {
        scope_504.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_505).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_506 = writer.prefix("Marker");
    if let Some(var_507) = &input.marker {
        scope_506.string(var_507);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_data_shares(
    input: &crate::input::DescribeDataSharesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeDataShares", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_508 = writer.prefix("DataShareArn");
    if let Some(var_509) = &input.data_share_arn {
        scope_508.string(var_509);
    }
    #[allow(unused_mut)]
    let mut scope_510 = writer.prefix("MaxRecords");
    if let Some(var_511) = &input.max_records {
        scope_510.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_511).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_512 = writer.prefix("Marker");
    if let Some(var_513) = &input.marker {
        scope_512.string(var_513);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_data_shares_for_consumer(
    input: &crate::input::DescribeDataSharesForConsumerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDataSharesForConsumer", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_514 = writer.prefix("ConsumerArn");
    if let Some(var_515) = &input.consumer_arn {
        scope_514.string(var_515);
    }
    #[allow(unused_mut)]
    let mut scope_516 = writer.prefix("Status");
    if let Some(var_517) = &input.status {
        scope_516.string(var_517.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_518 = writer.prefix("MaxRecords");
    if let Some(var_519) = &input.max_records {
        scope_518.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_519).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_520 = writer.prefix("Marker");
    if let Some(var_521) = &input.marker {
        scope_520.string(var_521);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_data_shares_for_producer(
    input: &crate::input::DescribeDataSharesForProducerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDataSharesForProducer", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_522 = writer.prefix("ProducerArn");
    if let Some(var_523) = &input.producer_arn {
        scope_522.string(var_523);
    }
    #[allow(unused_mut)]
    let mut scope_524 = writer.prefix("Status");
    if let Some(var_525) = &input.status {
        scope_524.string(var_525.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_526 = writer.prefix("MaxRecords");
    if let Some(var_527) = &input.max_records {
        scope_526.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_527).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_528 = writer.prefix("Marker");
    if let Some(var_529) = &input.marker {
        scope_528.string(var_529);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_default_cluster_parameters(
    input: &crate::input::DescribeDefaultClusterParametersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeDefaultClusterParameters", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_530 = writer.prefix("ParameterGroupFamily");
    if let Some(var_531) = &input.parameter_group_family {
        scope_530.string(var_531);
    }
    #[allow(unused_mut)]
    let mut scope_532 = writer.prefix("MaxRecords");
    if let Some(var_533) = &input.max_records {
        scope_532.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_533).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_534 = writer.prefix("Marker");
    if let Some(var_535) = &input.marker {
        scope_534.string(var_535);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_endpoint_access(
    input: &crate::input::DescribeEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_536 = writer.prefix("ClusterIdentifier");
    if let Some(var_537) = &input.cluster_identifier {
        scope_536.string(var_537);
    }
    #[allow(unused_mut)]
    let mut scope_538 = writer.prefix("ResourceOwner");
    if let Some(var_539) = &input.resource_owner {
        scope_538.string(var_539);
    }
    #[allow(unused_mut)]
    let mut scope_540 = writer.prefix("EndpointName");
    if let Some(var_541) = &input.endpoint_name {
        scope_540.string(var_541);
    }
    #[allow(unused_mut)]
    let mut scope_542 = writer.prefix("VpcId");
    if let Some(var_543) = &input.vpc_id {
        scope_542.string(var_543);
    }
    #[allow(unused_mut)]
    let mut scope_544 = writer.prefix("MaxRecords");
    if let Some(var_545) = &input.max_records {
        scope_544.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_545).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_546 = writer.prefix("Marker");
    if let Some(var_547) = &input.marker {
        scope_546.string(var_547);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_endpoint_authorization(
    input: &crate::input::DescribeEndpointAuthorizationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEndpointAuthorization", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_548 = writer.prefix("ClusterIdentifier");
    if let Some(var_549) = &input.cluster_identifier {
        scope_548.string(var_549);
    }
    #[allow(unused_mut)]
    let mut scope_550 = writer.prefix("Account");
    if let Some(var_551) = &input.account {
        scope_550.string(var_551);
    }
    #[allow(unused_mut)]
    let mut scope_552 = writer.prefix("Grantee");
    if let Some(var_553) = &input.grantee {
        scope_552.boolean(*var_553);
    }
    #[allow(unused_mut)]
    let mut scope_554 = writer.prefix("MaxRecords");
    if let Some(var_555) = &input.max_records {
        scope_554.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_555).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_556 = writer.prefix("Marker");
    if let Some(var_557) = &input.marker {
        scope_556.string(var_557);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_categories(
    input: &crate::input::DescribeEventCategoriesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventCategories", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_558 = writer.prefix("SourceType");
    if let Some(var_559) = &input.source_type {
        scope_558.string(var_559);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_events(
    input: &crate::input::DescribeEventsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeEvents", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_560 = writer.prefix("SourceIdentifier");
    if let Some(var_561) = &input.source_identifier {
        scope_560.string(var_561);
    }
    #[allow(unused_mut)]
    let mut scope_562 = writer.prefix("SourceType");
    if let Some(var_563) = &input.source_type {
        scope_562.string(var_563.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_564 = writer.prefix("StartTime");
    if let Some(var_565) = &input.start_time {
        scope_564.instant(var_565, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_566 = writer.prefix("EndTime");
    if let Some(var_567) = &input.end_time {
        scope_566.instant(var_567, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_568 = writer.prefix("Duration");
    if let Some(var_569) = &input.duration {
        scope_568.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_569).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_570 = writer.prefix("MaxRecords");
    if let Some(var_571) = &input.max_records {
        scope_570.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_571).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_572 = writer.prefix("Marker");
    if let Some(var_573) = &input.marker {
        scope_572.string(var_573);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_event_subscriptions(
    input: &crate::input::DescribeEventSubscriptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeEventSubscriptions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_574 = writer.prefix("SubscriptionName");
    if let Some(var_575) = &input.subscription_name {
        scope_574.string(var_575);
    }
    #[allow(unused_mut)]
    let mut scope_576 = writer.prefix("MaxRecords");
    if let Some(var_577) = &input.max_records {
        scope_576.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_577).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_578 = writer.prefix("Marker");
    if let Some(var_579) = &input.marker {
        scope_578.string(var_579);
    }
    #[allow(unused_mut)]
    let mut scope_580 = writer.prefix("TagKeys");
    if let Some(var_581) = &input.tag_keys {
        let mut list_583 = scope_580.start_list(false, Some("TagKey"));
        for item_582 in var_581 {
            #[allow(unused_mut)]
            let mut entry_584 = list_583.entry();
            entry_584.string(item_582);
        }
        list_583.finish();
    }
    #[allow(unused_mut)]
    let mut scope_585 = writer.prefix("TagValues");
    if let Some(var_586) = &input.tag_values {
        let mut list_588 = scope_585.start_list(false, Some("TagValue"));
        for item_587 in var_586 {
            #[allow(unused_mut)]
            let mut entry_589 = list_588.entry();
            entry_589.string(item_587);
        }
        list_588.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_hsm_client_certificates(
    input: &crate::input::DescribeHsmClientCertificatesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeHsmClientCertificates", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_590 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_591) = &input.hsm_client_certificate_identifier {
        scope_590.string(var_591);
    }
    #[allow(unused_mut)]
    let mut scope_592 = writer.prefix("MaxRecords");
    if let Some(var_593) = &input.max_records {
        scope_592.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_593).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_594 = writer.prefix("Marker");
    if let Some(var_595) = &input.marker {
        scope_594.string(var_595);
    }
    #[allow(unused_mut)]
    let mut scope_596 = writer.prefix("TagKeys");
    if let Some(var_597) = &input.tag_keys {
        let mut list_599 = scope_596.start_list(false, Some("TagKey"));
        for item_598 in var_597 {
            #[allow(unused_mut)]
            let mut entry_600 = list_599.entry();
            entry_600.string(item_598);
        }
        list_599.finish();
    }
    #[allow(unused_mut)]
    let mut scope_601 = writer.prefix("TagValues");
    if let Some(var_602) = &input.tag_values {
        let mut list_604 = scope_601.start_list(false, Some("TagValue"));
        for item_603 in var_602 {
            #[allow(unused_mut)]
            let mut entry_605 = list_604.entry();
            entry_605.string(item_603);
        }
        list_604.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_hsm_configurations(
    input: &crate::input::DescribeHsmConfigurationsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeHsmConfigurations", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_606 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_607) = &input.hsm_configuration_identifier {
        scope_606.string(var_607);
    }
    #[allow(unused_mut)]
    let mut scope_608 = writer.prefix("MaxRecords");
    if let Some(var_609) = &input.max_records {
        scope_608.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_609).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_610 = writer.prefix("Marker");
    if let Some(var_611) = &input.marker {
        scope_610.string(var_611);
    }
    #[allow(unused_mut)]
    let mut scope_612 = writer.prefix("TagKeys");
    if let Some(var_613) = &input.tag_keys {
        let mut list_615 = scope_612.start_list(false, Some("TagKey"));
        for item_614 in var_613 {
            #[allow(unused_mut)]
            let mut entry_616 = list_615.entry();
            entry_616.string(item_614);
        }
        list_615.finish();
    }
    #[allow(unused_mut)]
    let mut scope_617 = writer.prefix("TagValues");
    if let Some(var_618) = &input.tag_values {
        let mut list_620 = scope_617.start_list(false, Some("TagValue"));
        for item_619 in var_618 {
            #[allow(unused_mut)]
            let mut entry_621 = list_620.entry();
            entry_621.string(item_619);
        }
        list_620.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_logging_status(
    input: &crate::input::DescribeLoggingStatusInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeLoggingStatus", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_622 = writer.prefix("ClusterIdentifier");
    if let Some(var_623) = &input.cluster_identifier {
        scope_622.string(var_623);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_node_configuration_options(
    input: &crate::input::DescribeNodeConfigurationOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeNodeConfigurationOptions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_624 = writer.prefix("ActionType");
    if let Some(var_625) = &input.action_type {
        scope_624.string(var_625.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_626 = writer.prefix("ClusterIdentifier");
    if let Some(var_627) = &input.cluster_identifier {
        scope_626.string(var_627);
    }
    #[allow(unused_mut)]
    let mut scope_628 = writer.prefix("SnapshotIdentifier");
    if let Some(var_629) = &input.snapshot_identifier {
        scope_628.string(var_629);
    }
    #[allow(unused_mut)]
    let mut scope_630 = writer.prefix("OwnerAccount");
    if let Some(var_631) = &input.owner_account {
        scope_630.string(var_631);
    }
    #[allow(unused_mut)]
    let mut scope_632 = writer.prefix("Filter");
    if let Some(var_633) = &input.filters {
        let mut list_635 = scope_632.start_list(false, Some("NodeConfigurationOptionsFilter"));
        for item_634 in var_633 {
            #[allow(unused_mut)]
            let mut entry_636 = list_635.entry();
            crate::query_ser::serialize_structure_crate_model_node_configuration_options_filter(
                entry_636, item_634,
            );
        }
        list_635.finish();
    }
    #[allow(unused_mut)]
    let mut scope_637 = writer.prefix("Marker");
    if let Some(var_638) = &input.marker {
        scope_637.string(var_638);
    }
    #[allow(unused_mut)]
    let mut scope_639 = writer.prefix("MaxRecords");
    if let Some(var_640) = &input.max_records {
        scope_639.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_640).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_orderable_cluster_options(
    input: &crate::input::DescribeOrderableClusterOptionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeOrderableClusterOptions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_641 = writer.prefix("ClusterVersion");
    if let Some(var_642) = &input.cluster_version {
        scope_641.string(var_642);
    }
    #[allow(unused_mut)]
    let mut scope_643 = writer.prefix("NodeType");
    if let Some(var_644) = &input.node_type {
        scope_643.string(var_644);
    }
    #[allow(unused_mut)]
    let mut scope_645 = writer.prefix("MaxRecords");
    if let Some(var_646) = &input.max_records {
        scope_645.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_646).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_647 = writer.prefix("Marker");
    if let Some(var_648) = &input.marker {
        scope_647.string(var_648);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_partners(
    input: &crate::input::DescribePartnersInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribePartners", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_649 = writer.prefix("AccountId");
    if let Some(var_650) = &input.account_id {
        scope_649.string(var_650);
    }
    #[allow(unused_mut)]
    let mut scope_651 = writer.prefix("ClusterIdentifier");
    if let Some(var_652) = &input.cluster_identifier {
        scope_651.string(var_652);
    }
    #[allow(unused_mut)]
    let mut scope_653 = writer.prefix("DatabaseName");
    if let Some(var_654) = &input.database_name {
        scope_653.string(var_654);
    }
    #[allow(unused_mut)]
    let mut scope_655 = writer.prefix("PartnerName");
    if let Some(var_656) = &input.partner_name {
        scope_655.string(var_656);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_reserved_node_offerings(
    input: &crate::input::DescribeReservedNodeOfferingsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeReservedNodeOfferings", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_657 = writer.prefix("ReservedNodeOfferingId");
    if let Some(var_658) = &input.reserved_node_offering_id {
        scope_657.string(var_658);
    }
    #[allow(unused_mut)]
    let mut scope_659 = writer.prefix("MaxRecords");
    if let Some(var_660) = &input.max_records {
        scope_659.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_660).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_661 = writer.prefix("Marker");
    if let Some(var_662) = &input.marker {
        scope_661.string(var_662);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_reserved_nodes(
    input: &crate::input::DescribeReservedNodesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeReservedNodes", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_663 = writer.prefix("ReservedNodeId");
    if let Some(var_664) = &input.reserved_node_id {
        scope_663.string(var_664);
    }
    #[allow(unused_mut)]
    let mut scope_665 = writer.prefix("MaxRecords");
    if let Some(var_666) = &input.max_records {
        scope_665.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_666).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_667 = writer.prefix("Marker");
    if let Some(var_668) = &input.marker {
        scope_667.string(var_668);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_resize(
    input: &crate::input::DescribeResizeInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeResize", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_669 = writer.prefix("ClusterIdentifier");
    if let Some(var_670) = &input.cluster_identifier {
        scope_669.string(var_670);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_scheduled_actions(
    input: &crate::input::DescribeScheduledActionsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeScheduledActions", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_671 = writer.prefix("ScheduledActionName");
    if let Some(var_672) = &input.scheduled_action_name {
        scope_671.string(var_672);
    }
    #[allow(unused_mut)]
    let mut scope_673 = writer.prefix("TargetActionType");
    if let Some(var_674) = &input.target_action_type {
        scope_673.string(var_674.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_675 = writer.prefix("StartTime");
    if let Some(var_676) = &input.start_time {
        scope_675.instant(var_676, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_677 = writer.prefix("EndTime");
    if let Some(var_678) = &input.end_time {
        scope_677.instant(var_678, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_679 = writer.prefix("Active");
    if let Some(var_680) = &input.active {
        scope_679.boolean(*var_680);
    }
    #[allow(unused_mut)]
    let mut scope_681 = writer.prefix("Filters");
    if let Some(var_682) = &input.filters {
        let mut list_684 = scope_681.start_list(false, Some("ScheduledActionFilter"));
        for item_683 in var_682 {
            #[allow(unused_mut)]
            let mut entry_685 = list_684.entry();
            crate::query_ser::serialize_structure_crate_model_scheduled_action_filter(
                entry_685, item_683,
            );
        }
        list_684.finish();
    }
    #[allow(unused_mut)]
    let mut scope_686 = writer.prefix("Marker");
    if let Some(var_687) = &input.marker {
        scope_686.string(var_687);
    }
    #[allow(unused_mut)]
    let mut scope_688 = writer.prefix("MaxRecords");
    if let Some(var_689) = &input.max_records {
        scope_688.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_689).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_snapshot_copy_grants(
    input: &crate::input::DescribeSnapshotCopyGrantsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeSnapshotCopyGrants", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_690 = writer.prefix("SnapshotCopyGrantName");
    if let Some(var_691) = &input.snapshot_copy_grant_name {
        scope_690.string(var_691);
    }
    #[allow(unused_mut)]
    let mut scope_692 = writer.prefix("MaxRecords");
    if let Some(var_693) = &input.max_records {
        scope_692.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_693).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_694 = writer.prefix("Marker");
    if let Some(var_695) = &input.marker {
        scope_694.string(var_695);
    }
    #[allow(unused_mut)]
    let mut scope_696 = writer.prefix("TagKeys");
    if let Some(var_697) = &input.tag_keys {
        let mut list_699 = scope_696.start_list(false, Some("TagKey"));
        for item_698 in var_697 {
            #[allow(unused_mut)]
            let mut entry_700 = list_699.entry();
            entry_700.string(item_698);
        }
        list_699.finish();
    }
    #[allow(unused_mut)]
    let mut scope_701 = writer.prefix("TagValues");
    if let Some(var_702) = &input.tag_values {
        let mut list_704 = scope_701.start_list(false, Some("TagValue"));
        for item_703 in var_702 {
            #[allow(unused_mut)]
            let mut entry_705 = list_704.entry();
            entry_705.string(item_703);
        }
        list_704.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_snapshot_schedules(
    input: &crate::input::DescribeSnapshotSchedulesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeSnapshotSchedules", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_706 = writer.prefix("ClusterIdentifier");
    if let Some(var_707) = &input.cluster_identifier {
        scope_706.string(var_707);
    }
    #[allow(unused_mut)]
    let mut scope_708 = writer.prefix("ScheduleIdentifier");
    if let Some(var_709) = &input.schedule_identifier {
        scope_708.string(var_709);
    }
    #[allow(unused_mut)]
    let mut scope_710 = writer.prefix("TagKeys");
    if let Some(var_711) = &input.tag_keys {
        let mut list_713 = scope_710.start_list(false, Some("TagKey"));
        for item_712 in var_711 {
            #[allow(unused_mut)]
            let mut entry_714 = list_713.entry();
            entry_714.string(item_712);
        }
        list_713.finish();
    }
    #[allow(unused_mut)]
    let mut scope_715 = writer.prefix("TagValues");
    if let Some(var_716) = &input.tag_values {
        let mut list_718 = scope_715.start_list(false, Some("TagValue"));
        for item_717 in var_716 {
            #[allow(unused_mut)]
            let mut entry_719 = list_718.entry();
            entry_719.string(item_717);
        }
        list_718.finish();
    }
    #[allow(unused_mut)]
    let mut scope_720 = writer.prefix("Marker");
    if let Some(var_721) = &input.marker {
        scope_720.string(var_721);
    }
    #[allow(unused_mut)]
    let mut scope_722 = writer.prefix("MaxRecords");
    if let Some(var_723) = &input.max_records {
        scope_722.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_723).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_storage(
    input: &crate::input::DescribeStorageInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let _ = input;
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeStorage", "2012-12-01");
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_table_restore_status(
    input: &crate::input::DescribeTableRestoreStatusInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DescribeTableRestoreStatus", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_724 = writer.prefix("ClusterIdentifier");
    if let Some(var_725) = &input.cluster_identifier {
        scope_724.string(var_725);
    }
    #[allow(unused_mut)]
    let mut scope_726 = writer.prefix("TableRestoreRequestId");
    if let Some(var_727) = &input.table_restore_request_id {
        scope_726.string(var_727);
    }
    #[allow(unused_mut)]
    let mut scope_728 = writer.prefix("MaxRecords");
    if let Some(var_729) = &input.max_records {
        scope_728.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_729).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_730 = writer.prefix("Marker");
    if let Some(var_731) = &input.marker {
        scope_730.string(var_731);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_tags(
    input: &crate::input::DescribeTagsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeTags", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_732 = writer.prefix("ResourceName");
    if let Some(var_733) = &input.resource_name {
        scope_732.string(var_733);
    }
    #[allow(unused_mut)]
    let mut scope_734 = writer.prefix("ResourceType");
    if let Some(var_735) = &input.resource_type {
        scope_734.string(var_735);
    }
    #[allow(unused_mut)]
    let mut scope_736 = writer.prefix("MaxRecords");
    if let Some(var_737) = &input.max_records {
        scope_736.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_737).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_738 = writer.prefix("Marker");
    if let Some(var_739) = &input.marker {
        scope_738.string(var_739);
    }
    #[allow(unused_mut)]
    let mut scope_740 = writer.prefix("TagKeys");
    if let Some(var_741) = &input.tag_keys {
        let mut list_743 = scope_740.start_list(false, Some("TagKey"));
        for item_742 in var_741 {
            #[allow(unused_mut)]
            let mut entry_744 = list_743.entry();
            entry_744.string(item_742);
        }
        list_743.finish();
    }
    #[allow(unused_mut)]
    let mut scope_745 = writer.prefix("TagValues");
    if let Some(var_746) = &input.tag_values {
        let mut list_748 = scope_745.start_list(false, Some("TagValue"));
        for item_747 in var_746 {
            #[allow(unused_mut)]
            let mut entry_749 = list_748.entry();
            entry_749.string(item_747);
        }
        list_748.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_describe_usage_limits(
    input: &crate::input::DescribeUsageLimitsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DescribeUsageLimits", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_750 = writer.prefix("UsageLimitId");
    if let Some(var_751) = &input.usage_limit_id {
        scope_750.string(var_751);
    }
    #[allow(unused_mut)]
    let mut scope_752 = writer.prefix("ClusterIdentifier");
    if let Some(var_753) = &input.cluster_identifier {
        scope_752.string(var_753);
    }
    #[allow(unused_mut)]
    let mut scope_754 = writer.prefix("FeatureType");
    if let Some(var_755) = &input.feature_type {
        scope_754.string(var_755.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_756 = writer.prefix("MaxRecords");
    if let Some(var_757) = &input.max_records {
        scope_756.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_757).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_758 = writer.prefix("Marker");
    if let Some(var_759) = &input.marker {
        scope_758.string(var_759);
    }
    #[allow(unused_mut)]
    let mut scope_760 = writer.prefix("TagKeys");
    if let Some(var_761) = &input.tag_keys {
        let mut list_763 = scope_760.start_list(false, Some("TagKey"));
        for item_762 in var_761 {
            #[allow(unused_mut)]
            let mut entry_764 = list_763.entry();
            entry_764.string(item_762);
        }
        list_763.finish();
    }
    #[allow(unused_mut)]
    let mut scope_765 = writer.prefix("TagValues");
    if let Some(var_766) = &input.tag_values {
        let mut list_768 = scope_765.start_list(false, Some("TagValue"));
        for item_767 in var_766 {
            #[allow(unused_mut)]
            let mut entry_769 = list_768.entry();
            entry_769.string(item_767);
        }
        list_768.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_disable_logging(
    input: &crate::input::DisableLoggingInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DisableLogging", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_770 = writer.prefix("ClusterIdentifier");
    if let Some(var_771) = &input.cluster_identifier {
        scope_770.string(var_771);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_disable_snapshot_copy(
    input: &crate::input::DisableSnapshotCopyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "DisableSnapshotCopy", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_772 = writer.prefix("ClusterIdentifier");
    if let Some(var_773) = &input.cluster_identifier {
        scope_772.string(var_773);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_disassociate_data_share_consumer(
    input: &crate::input::DisassociateDataShareConsumerInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "DisassociateDataShareConsumer", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_774 = writer.prefix("DataShareArn");
    if let Some(var_775) = &input.data_share_arn {
        scope_774.string(var_775);
    }
    #[allow(unused_mut)]
    let mut scope_776 = writer.prefix("DisassociateEntireAccount");
    if let Some(var_777) = &input.disassociate_entire_account {
        scope_776.boolean(*var_777);
    }
    #[allow(unused_mut)]
    let mut scope_778 = writer.prefix("ConsumerArn");
    if let Some(var_779) = &input.consumer_arn {
        scope_778.string(var_779);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_enable_logging(
    input: &crate::input::EnableLoggingInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "EnableLogging", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_780 = writer.prefix("ClusterIdentifier");
    if let Some(var_781) = &input.cluster_identifier {
        scope_780.string(var_781);
    }
    #[allow(unused_mut)]
    let mut scope_782 = writer.prefix("BucketName");
    if let Some(var_783) = &input.bucket_name {
        scope_782.string(var_783);
    }
    #[allow(unused_mut)]
    let mut scope_784 = writer.prefix("S3KeyPrefix");
    if let Some(var_785) = &input.s3_key_prefix {
        scope_784.string(var_785);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_enable_snapshot_copy(
    input: &crate::input::EnableSnapshotCopyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "EnableSnapshotCopy", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_786 = writer.prefix("ClusterIdentifier");
    if let Some(var_787) = &input.cluster_identifier {
        scope_786.string(var_787);
    }
    #[allow(unused_mut)]
    let mut scope_788 = writer.prefix("DestinationRegion");
    if let Some(var_789) = &input.destination_region {
        scope_788.string(var_789);
    }
    #[allow(unused_mut)]
    let mut scope_790 = writer.prefix("RetentionPeriod");
    if let Some(var_791) = &input.retention_period {
        scope_790.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_791).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_792 = writer.prefix("SnapshotCopyGrantName");
    if let Some(var_793) = &input.snapshot_copy_grant_name {
        scope_792.string(var_793);
    }
    #[allow(unused_mut)]
    let mut scope_794 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_795) = &input.manual_snapshot_retention_period {
        scope_794.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_795).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_cluster_credentials(
    input: &crate::input::GetClusterCredentialsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetClusterCredentials", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_796 = writer.prefix("DbUser");
    if let Some(var_797) = &input.db_user {
        scope_796.string(var_797);
    }
    #[allow(unused_mut)]
    let mut scope_798 = writer.prefix("DbName");
    if let Some(var_799) = &input.db_name {
        scope_798.string(var_799);
    }
    #[allow(unused_mut)]
    let mut scope_800 = writer.prefix("ClusterIdentifier");
    if let Some(var_801) = &input.cluster_identifier {
        scope_800.string(var_801);
    }
    #[allow(unused_mut)]
    let mut scope_802 = writer.prefix("DurationSeconds");
    if let Some(var_803) = &input.duration_seconds {
        scope_802.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_803).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_804 = writer.prefix("AutoCreate");
    if let Some(var_805) = &input.auto_create {
        scope_804.boolean(*var_805);
    }
    #[allow(unused_mut)]
    let mut scope_806 = writer.prefix("DbGroups");
    if let Some(var_807) = &input.db_groups {
        let mut list_809 = scope_806.start_list(false, Some("DbGroup"));
        for item_808 in var_807 {
            #[allow(unused_mut)]
            let mut entry_810 = list_809.entry();
            entry_810.string(item_808);
        }
        list_809.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_get_reserved_node_exchange_offerings(
    input: &crate::input::GetReservedNodeExchangeOfferingsInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "GetReservedNodeExchangeOfferings", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_811 = writer.prefix("ReservedNodeId");
    if let Some(var_812) = &input.reserved_node_id {
        scope_811.string(var_812);
    }
    #[allow(unused_mut)]
    let mut scope_813 = writer.prefix("MaxRecords");
    if let Some(var_814) = &input.max_records {
        scope_813.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_814).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_815 = writer.prefix("Marker");
    if let Some(var_816) = &input.marker {
        scope_815.string(var_816);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_aqua_configuration(
    input: &crate::input::ModifyAquaConfigurationInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyAquaConfiguration", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_817 = writer.prefix("ClusterIdentifier");
    if let Some(var_818) = &input.cluster_identifier {
        scope_817.string(var_818);
    }
    #[allow(unused_mut)]
    let mut scope_819 = writer.prefix("AquaConfigurationStatus");
    if let Some(var_820) = &input.aqua_configuration_status {
        scope_819.string(var_820.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_authentication_profile(
    input: &crate::input::ModifyAuthenticationProfileInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyAuthenticationProfile", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_821 = writer.prefix("AuthenticationProfileName");
    if let Some(var_822) = &input.authentication_profile_name {
        scope_821.string(var_822);
    }
    #[allow(unused_mut)]
    let mut scope_823 = writer.prefix("AuthenticationProfileContent");
    if let Some(var_824) = &input.authentication_profile_content {
        scope_823.string(var_824);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster(
    input: &crate::input::ModifyClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_825 = writer.prefix("ClusterIdentifier");
    if let Some(var_826) = &input.cluster_identifier {
        scope_825.string(var_826);
    }
    #[allow(unused_mut)]
    let mut scope_827 = writer.prefix("ClusterType");
    if let Some(var_828) = &input.cluster_type {
        scope_827.string(var_828);
    }
    #[allow(unused_mut)]
    let mut scope_829 = writer.prefix("NodeType");
    if let Some(var_830) = &input.node_type {
        scope_829.string(var_830);
    }
    #[allow(unused_mut)]
    let mut scope_831 = writer.prefix("NumberOfNodes");
    if let Some(var_832) = &input.number_of_nodes {
        scope_831.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_832).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_833 = writer.prefix("ClusterSecurityGroups");
    if let Some(var_834) = &input.cluster_security_groups {
        let mut list_836 = scope_833.start_list(false, Some("ClusterSecurityGroupName"));
        for item_835 in var_834 {
            #[allow(unused_mut)]
            let mut entry_837 = list_836.entry();
            entry_837.string(item_835);
        }
        list_836.finish();
    }
    #[allow(unused_mut)]
    let mut scope_838 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_839) = &input.vpc_security_group_ids {
        let mut list_841 = scope_838.start_list(false, Some("VpcSecurityGroupId"));
        for item_840 in var_839 {
            #[allow(unused_mut)]
            let mut entry_842 = list_841.entry();
            entry_842.string(item_840);
        }
        list_841.finish();
    }
    #[allow(unused_mut)]
    let mut scope_843 = writer.prefix("MasterUserPassword");
    if let Some(var_844) = &input.master_user_password {
        scope_843.string(var_844);
    }
    #[allow(unused_mut)]
    let mut scope_845 = writer.prefix("ClusterParameterGroupName");
    if let Some(var_846) = &input.cluster_parameter_group_name {
        scope_845.string(var_846);
    }
    #[allow(unused_mut)]
    let mut scope_847 = writer.prefix("AutomatedSnapshotRetentionPeriod");
    if let Some(var_848) = &input.automated_snapshot_retention_period {
        scope_847.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_848).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_849 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_850) = &input.manual_snapshot_retention_period {
        scope_849.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_850).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_851 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_852) = &input.preferred_maintenance_window {
        scope_851.string(var_852);
    }
    #[allow(unused_mut)]
    let mut scope_853 = writer.prefix("ClusterVersion");
    if let Some(var_854) = &input.cluster_version {
        scope_853.string(var_854);
    }
    #[allow(unused_mut)]
    let mut scope_855 = writer.prefix("AllowVersionUpgrade");
    if let Some(var_856) = &input.allow_version_upgrade {
        scope_855.boolean(*var_856);
    }
    #[allow(unused_mut)]
    let mut scope_857 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_858) = &input.hsm_client_certificate_identifier {
        scope_857.string(var_858);
    }
    #[allow(unused_mut)]
    let mut scope_859 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_860) = &input.hsm_configuration_identifier {
        scope_859.string(var_860);
    }
    #[allow(unused_mut)]
    let mut scope_861 = writer.prefix("NewClusterIdentifier");
    if let Some(var_862) = &input.new_cluster_identifier {
        scope_861.string(var_862);
    }
    #[allow(unused_mut)]
    let mut scope_863 = writer.prefix("PubliclyAccessible");
    if let Some(var_864) = &input.publicly_accessible {
        scope_863.boolean(*var_864);
    }
    #[allow(unused_mut)]
    let mut scope_865 = writer.prefix("ElasticIp");
    if let Some(var_866) = &input.elastic_ip {
        scope_865.string(var_866);
    }
    #[allow(unused_mut)]
    let mut scope_867 = writer.prefix("EnhancedVpcRouting");
    if let Some(var_868) = &input.enhanced_vpc_routing {
        scope_867.boolean(*var_868);
    }
    #[allow(unused_mut)]
    let mut scope_869 = writer.prefix("MaintenanceTrackName");
    if let Some(var_870) = &input.maintenance_track_name {
        scope_869.string(var_870);
    }
    #[allow(unused_mut)]
    let mut scope_871 = writer.prefix("Encrypted");
    if let Some(var_872) = &input.encrypted {
        scope_871.boolean(*var_872);
    }
    #[allow(unused_mut)]
    let mut scope_873 = writer.prefix("KmsKeyId");
    if let Some(var_874) = &input.kms_key_id {
        scope_873.string(var_874);
    }
    #[allow(unused_mut)]
    let mut scope_875 = writer.prefix("AvailabilityZoneRelocation");
    if let Some(var_876) = &input.availability_zone_relocation {
        scope_875.boolean(*var_876);
    }
    #[allow(unused_mut)]
    let mut scope_877 = writer.prefix("AvailabilityZone");
    if let Some(var_878) = &input.availability_zone {
        scope_877.string(var_878);
    }
    #[allow(unused_mut)]
    let mut scope_879 = writer.prefix("Port");
    if let Some(var_880) = &input.port {
        scope_879.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_880).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_db_revision(
    input: &crate::input::ModifyClusterDbRevisionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterDbRevision", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_881 = writer.prefix("ClusterIdentifier");
    if let Some(var_882) = &input.cluster_identifier {
        scope_881.string(var_882);
    }
    #[allow(unused_mut)]
    let mut scope_883 = writer.prefix("RevisionTarget");
    if let Some(var_884) = &input.revision_target {
        scope_883.string(var_884);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_iam_roles(
    input: &crate::input::ModifyClusterIamRolesInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterIamRoles", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_885 = writer.prefix("ClusterIdentifier");
    if let Some(var_886) = &input.cluster_identifier {
        scope_885.string(var_886);
    }
    #[allow(unused_mut)]
    let mut scope_887 = writer.prefix("AddIamRoles");
    if let Some(var_888) = &input.add_iam_roles {
        let mut list_890 = scope_887.start_list(false, Some("IamRoleArn"));
        for item_889 in var_888 {
            #[allow(unused_mut)]
            let mut entry_891 = list_890.entry();
            entry_891.string(item_889);
        }
        list_890.finish();
    }
    #[allow(unused_mut)]
    let mut scope_892 = writer.prefix("RemoveIamRoles");
    if let Some(var_893) = &input.remove_iam_roles {
        let mut list_895 = scope_892.start_list(false, Some("IamRoleArn"));
        for item_894 in var_893 {
            #[allow(unused_mut)]
            let mut entry_896 = list_895.entry();
            entry_896.string(item_894);
        }
        list_895.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_maintenance(
    input: &crate::input::ModifyClusterMaintenanceInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterMaintenance", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_897 = writer.prefix("ClusterIdentifier");
    if let Some(var_898) = &input.cluster_identifier {
        scope_897.string(var_898);
    }
    #[allow(unused_mut)]
    let mut scope_899 = writer.prefix("DeferMaintenance");
    if let Some(var_900) = &input.defer_maintenance {
        scope_899.boolean(*var_900);
    }
    #[allow(unused_mut)]
    let mut scope_901 = writer.prefix("DeferMaintenanceIdentifier");
    if let Some(var_902) = &input.defer_maintenance_identifier {
        scope_901.string(var_902);
    }
    #[allow(unused_mut)]
    let mut scope_903 = writer.prefix("DeferMaintenanceStartTime");
    if let Some(var_904) = &input.defer_maintenance_start_time {
        scope_903.instant(var_904, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_905 = writer.prefix("DeferMaintenanceEndTime");
    if let Some(var_906) = &input.defer_maintenance_end_time {
        scope_905.instant(var_906, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_907 = writer.prefix("DeferMaintenanceDuration");
    if let Some(var_908) = &input.defer_maintenance_duration {
        scope_907.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_908).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_parameter_group(
    input: &crate::input::ModifyClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterParameterGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_909 = writer.prefix("ParameterGroupName");
    if let Some(var_910) = &input.parameter_group_name {
        scope_909.string(var_910);
    }
    #[allow(unused_mut)]
    let mut scope_911 = writer.prefix("Parameters");
    if let Some(var_912) = &input.parameters {
        let mut list_914 = scope_911.start_list(false, Some("Parameter"));
        for item_913 in var_912 {
            #[allow(unused_mut)]
            let mut entry_915 = list_914.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_915, item_913);
        }
        list_914.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_snapshot(
    input: &crate::input::ModifyClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_916 = writer.prefix("SnapshotIdentifier");
    if let Some(var_917) = &input.snapshot_identifier {
        scope_916.string(var_917);
    }
    #[allow(unused_mut)]
    let mut scope_918 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_919) = &input.manual_snapshot_retention_period {
        scope_918.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_919).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_920 = writer.prefix("Force");
    if input.force {
        scope_920.boolean(input.force);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_snapshot_schedule(
    input: &crate::input::ModifyClusterSnapshotScheduleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterSnapshotSchedule", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_921 = writer.prefix("ClusterIdentifier");
    if let Some(var_922) = &input.cluster_identifier {
        scope_921.string(var_922);
    }
    #[allow(unused_mut)]
    let mut scope_923 = writer.prefix("ScheduleIdentifier");
    if let Some(var_924) = &input.schedule_identifier {
        scope_923.string(var_924);
    }
    #[allow(unused_mut)]
    let mut scope_925 = writer.prefix("DisassociateSchedule");
    if let Some(var_926) = &input.disassociate_schedule {
        scope_925.boolean(*var_926);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_cluster_subnet_group(
    input: &crate::input::ModifyClusterSubnetGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyClusterSubnetGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_927 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_928) = &input.cluster_subnet_group_name {
        scope_927.string(var_928);
    }
    #[allow(unused_mut)]
    let mut scope_929 = writer.prefix("Description");
    if let Some(var_930) = &input.description {
        scope_929.string(var_930);
    }
    #[allow(unused_mut)]
    let mut scope_931 = writer.prefix("SubnetIds");
    if let Some(var_932) = &input.subnet_ids {
        let mut list_934 = scope_931.start_list(false, Some("SubnetIdentifier"));
        for item_933 in var_932 {
            #[allow(unused_mut)]
            let mut entry_935 = list_934.entry();
            entry_935.string(item_933);
        }
        list_934.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_endpoint_access(
    input: &crate::input::ModifyEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_936 = writer.prefix("EndpointName");
    if let Some(var_937) = &input.endpoint_name {
        scope_936.string(var_937);
    }
    #[allow(unused_mut)]
    let mut scope_938 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_939) = &input.vpc_security_group_ids {
        let mut list_941 = scope_938.start_list(false, Some("VpcSecurityGroupId"));
        for item_940 in var_939 {
            #[allow(unused_mut)]
            let mut entry_942 = list_941.entry();
            entry_942.string(item_940);
        }
        list_941.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_event_subscription(
    input: &crate::input::ModifyEventSubscriptionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyEventSubscription", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_943 = writer.prefix("SubscriptionName");
    if let Some(var_944) = &input.subscription_name {
        scope_943.string(var_944);
    }
    #[allow(unused_mut)]
    let mut scope_945 = writer.prefix("SnsTopicArn");
    if let Some(var_946) = &input.sns_topic_arn {
        scope_945.string(var_946);
    }
    #[allow(unused_mut)]
    let mut scope_947 = writer.prefix("SourceType");
    if let Some(var_948) = &input.source_type {
        scope_947.string(var_948);
    }
    #[allow(unused_mut)]
    let mut scope_949 = writer.prefix("SourceIds");
    if let Some(var_950) = &input.source_ids {
        let mut list_952 = scope_949.start_list(false, Some("SourceId"));
        for item_951 in var_950 {
            #[allow(unused_mut)]
            let mut entry_953 = list_952.entry();
            entry_953.string(item_951);
        }
        list_952.finish();
    }
    #[allow(unused_mut)]
    let mut scope_954 = writer.prefix("EventCategories");
    if let Some(var_955) = &input.event_categories {
        let mut list_957 = scope_954.start_list(false, Some("EventCategory"));
        for item_956 in var_955 {
            #[allow(unused_mut)]
            let mut entry_958 = list_957.entry();
            entry_958.string(item_956);
        }
        list_957.finish();
    }
    #[allow(unused_mut)]
    let mut scope_959 = writer.prefix("Severity");
    if let Some(var_960) = &input.severity {
        scope_959.string(var_960);
    }
    #[allow(unused_mut)]
    let mut scope_961 = writer.prefix("Enabled");
    if let Some(var_962) = &input.enabled {
        scope_961.boolean(*var_962);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_scheduled_action(
    input: &crate::input::ModifyScheduledActionInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifyScheduledAction", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_963 = writer.prefix("ScheduledActionName");
    if let Some(var_964) = &input.scheduled_action_name {
        scope_963.string(var_964);
    }
    #[allow(unused_mut)]
    let mut scope_965 = writer.prefix("TargetAction");
    if let Some(var_966) = &input.target_action {
        crate::query_ser::serialize_structure_crate_model_scheduled_action_type(scope_965, var_966);
    }
    #[allow(unused_mut)]
    let mut scope_967 = writer.prefix("Schedule");
    if let Some(var_968) = &input.schedule {
        scope_967.string(var_968);
    }
    #[allow(unused_mut)]
    let mut scope_969 = writer.prefix("IamRole");
    if let Some(var_970) = &input.iam_role {
        scope_969.string(var_970);
    }
    #[allow(unused_mut)]
    let mut scope_971 = writer.prefix("ScheduledActionDescription");
    if let Some(var_972) = &input.scheduled_action_description {
        scope_971.string(var_972);
    }
    #[allow(unused_mut)]
    let mut scope_973 = writer.prefix("StartTime");
    if let Some(var_974) = &input.start_time {
        scope_973.instant(var_974, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_975 = writer.prefix("EndTime");
    if let Some(var_976) = &input.end_time {
        scope_975.instant(var_976, smithy_types::instant::Format::DateTime);
    }
    #[allow(unused_mut)]
    let mut scope_977 = writer.prefix("Enable");
    if let Some(var_978) = &input.enable {
        scope_977.boolean(*var_978);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_snapshot_copy_retention_period(
    input: &crate::input::ModifySnapshotCopyRetentionPeriodInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifySnapshotCopyRetentionPeriod", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_979 = writer.prefix("ClusterIdentifier");
    if let Some(var_980) = &input.cluster_identifier {
        scope_979.string(var_980);
    }
    #[allow(unused_mut)]
    let mut scope_981 = writer.prefix("RetentionPeriod");
    {
        scope_981.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((input.retention_period).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_982 = writer.prefix("Manual");
    if input.manual {
        scope_982.boolean(input.manual);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_snapshot_schedule(
    input: &crate::input::ModifySnapshotScheduleInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ModifySnapshotSchedule", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_983 = writer.prefix("ScheduleIdentifier");
    if let Some(var_984) = &input.schedule_identifier {
        scope_983.string(var_984);
    }
    #[allow(unused_mut)]
    let mut scope_985 = writer.prefix("ScheduleDefinitions");
    if let Some(var_986) = &input.schedule_definitions {
        let mut list_988 = scope_985.start_list(false, Some("ScheduleDefinition"));
        for item_987 in var_986 {
            #[allow(unused_mut)]
            let mut entry_989 = list_988.entry();
            entry_989.string(item_987);
        }
        list_988.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_modify_usage_limit(
    input: &crate::input::ModifyUsageLimitInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ModifyUsageLimit", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_990 = writer.prefix("UsageLimitId");
    if let Some(var_991) = &input.usage_limit_id {
        scope_990.string(var_991);
    }
    #[allow(unused_mut)]
    let mut scope_992 = writer.prefix("Amount");
    if let Some(var_993) = &input.amount {
        scope_992.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_993).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_994 = writer.prefix("BreachAction");
    if let Some(var_995) = &input.breach_action {
        scope_994.string(var_995.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_pause_cluster(
    input: &crate::input::PauseClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "PauseCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_996 = writer.prefix("ClusterIdentifier");
    if let Some(var_997) = &input.cluster_identifier {
        scope_996.string(var_997);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_purchase_reserved_node_offering(
    input: &crate::input::PurchaseReservedNodeOfferingInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "PurchaseReservedNodeOffering", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_998 = writer.prefix("ReservedNodeOfferingId");
    if let Some(var_999) = &input.reserved_node_offering_id {
        scope_998.string(var_999);
    }
    #[allow(unused_mut)]
    let mut scope_1000 = writer.prefix("NodeCount");
    if let Some(var_1001) = &input.node_count {
        scope_1000.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1001).into()),
        );
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reboot_cluster(
    input: &crate::input::RebootClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RebootCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1002 = writer.prefix("ClusterIdentifier");
    if let Some(var_1003) = &input.cluster_identifier {
        scope_1002.string(var_1003);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reject_data_share(
    input: &crate::input::RejectDataShareInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RejectDataShare", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1004 = writer.prefix("DataShareArn");
    if let Some(var_1005) = &input.data_share_arn {
        scope_1004.string(var_1005);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_reset_cluster_parameter_group(
    input: &crate::input::ResetClusterParameterGroupInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "ResetClusterParameterGroup", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1006 = writer.prefix("ParameterGroupName");
    if let Some(var_1007) = &input.parameter_group_name {
        scope_1006.string(var_1007);
    }
    #[allow(unused_mut)]
    let mut scope_1008 = writer.prefix("ResetAllParameters");
    if input.reset_all_parameters {
        scope_1008.boolean(input.reset_all_parameters);
    }
    #[allow(unused_mut)]
    let mut scope_1009 = writer.prefix("Parameters");
    if let Some(var_1010) = &input.parameters {
        let mut list_1012 = scope_1009.start_list(false, Some("Parameter"));
        for item_1011 in var_1010 {
            #[allow(unused_mut)]
            let mut entry_1013 = list_1012.entry();
            crate::query_ser::serialize_structure_crate_model_parameter(entry_1013, item_1011);
        }
        list_1012.finish();
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_resize_cluster(
    input: &crate::input::ResizeClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ResizeCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1014 = writer.prefix("ClusterIdentifier");
    if let Some(var_1015) = &input.cluster_identifier {
        scope_1014.string(var_1015);
    }
    #[allow(unused_mut)]
    let mut scope_1016 = writer.prefix("ClusterType");
    if let Some(var_1017) = &input.cluster_type {
        scope_1016.string(var_1017);
    }
    #[allow(unused_mut)]
    let mut scope_1018 = writer.prefix("NodeType");
    if let Some(var_1019) = &input.node_type {
        scope_1018.string(var_1019);
    }
    #[allow(unused_mut)]
    let mut scope_1020 = writer.prefix("NumberOfNodes");
    if let Some(var_1021) = &input.number_of_nodes {
        scope_1020.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1021).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1022 = writer.prefix("Classic");
    if let Some(var_1023) = &input.classic {
        scope_1022.boolean(*var_1023);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_from_cluster_snapshot(
    input: &crate::input::RestoreFromClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreFromClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1024 = writer.prefix("ClusterIdentifier");
    if let Some(var_1025) = &input.cluster_identifier {
        scope_1024.string(var_1025);
    }
    #[allow(unused_mut)]
    let mut scope_1026 = writer.prefix("SnapshotIdentifier");
    if let Some(var_1027) = &input.snapshot_identifier {
        scope_1026.string(var_1027);
    }
    #[allow(unused_mut)]
    let mut scope_1028 = writer.prefix("SnapshotClusterIdentifier");
    if let Some(var_1029) = &input.snapshot_cluster_identifier {
        scope_1028.string(var_1029);
    }
    #[allow(unused_mut)]
    let mut scope_1030 = writer.prefix("Port");
    if let Some(var_1031) = &input.port {
        scope_1030.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1031).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1032 = writer.prefix("AvailabilityZone");
    if let Some(var_1033) = &input.availability_zone {
        scope_1032.string(var_1033);
    }
    #[allow(unused_mut)]
    let mut scope_1034 = writer.prefix("AllowVersionUpgrade");
    if let Some(var_1035) = &input.allow_version_upgrade {
        scope_1034.boolean(*var_1035);
    }
    #[allow(unused_mut)]
    let mut scope_1036 = writer.prefix("ClusterSubnetGroupName");
    if let Some(var_1037) = &input.cluster_subnet_group_name {
        scope_1036.string(var_1037);
    }
    #[allow(unused_mut)]
    let mut scope_1038 = writer.prefix("PubliclyAccessible");
    if let Some(var_1039) = &input.publicly_accessible {
        scope_1038.boolean(*var_1039);
    }
    #[allow(unused_mut)]
    let mut scope_1040 = writer.prefix("OwnerAccount");
    if let Some(var_1041) = &input.owner_account {
        scope_1040.string(var_1041);
    }
    #[allow(unused_mut)]
    let mut scope_1042 = writer.prefix("HsmClientCertificateIdentifier");
    if let Some(var_1043) = &input.hsm_client_certificate_identifier {
        scope_1042.string(var_1043);
    }
    #[allow(unused_mut)]
    let mut scope_1044 = writer.prefix("HsmConfigurationIdentifier");
    if let Some(var_1045) = &input.hsm_configuration_identifier {
        scope_1044.string(var_1045);
    }
    #[allow(unused_mut)]
    let mut scope_1046 = writer.prefix("ElasticIp");
    if let Some(var_1047) = &input.elastic_ip {
        scope_1046.string(var_1047);
    }
    #[allow(unused_mut)]
    let mut scope_1048 = writer.prefix("ClusterParameterGroupName");
    if let Some(var_1049) = &input.cluster_parameter_group_name {
        scope_1048.string(var_1049);
    }
    #[allow(unused_mut)]
    let mut scope_1050 = writer.prefix("ClusterSecurityGroups");
    if let Some(var_1051) = &input.cluster_security_groups {
        let mut list_1053 = scope_1050.start_list(false, Some("ClusterSecurityGroupName"));
        for item_1052 in var_1051 {
            #[allow(unused_mut)]
            let mut entry_1054 = list_1053.entry();
            entry_1054.string(item_1052);
        }
        list_1053.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1055 = writer.prefix("VpcSecurityGroupIds");
    if let Some(var_1056) = &input.vpc_security_group_ids {
        let mut list_1058 = scope_1055.start_list(false, Some("VpcSecurityGroupId"));
        for item_1057 in var_1056 {
            #[allow(unused_mut)]
            let mut entry_1059 = list_1058.entry();
            entry_1059.string(item_1057);
        }
        list_1058.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1060 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_1061) = &input.preferred_maintenance_window {
        scope_1060.string(var_1061);
    }
    #[allow(unused_mut)]
    let mut scope_1062 = writer.prefix("AutomatedSnapshotRetentionPeriod");
    if let Some(var_1063) = &input.automated_snapshot_retention_period {
        scope_1062.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1063).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1064 = writer.prefix("ManualSnapshotRetentionPeriod");
    if let Some(var_1065) = &input.manual_snapshot_retention_period {
        scope_1064.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1065).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1066 = writer.prefix("KmsKeyId");
    if let Some(var_1067) = &input.kms_key_id {
        scope_1066.string(var_1067);
    }
    #[allow(unused_mut)]
    let mut scope_1068 = writer.prefix("NodeType");
    if let Some(var_1069) = &input.node_type {
        scope_1068.string(var_1069);
    }
    #[allow(unused_mut)]
    let mut scope_1070 = writer.prefix("EnhancedVpcRouting");
    if let Some(var_1071) = &input.enhanced_vpc_routing {
        scope_1070.boolean(*var_1071);
    }
    #[allow(unused_mut)]
    let mut scope_1072 = writer.prefix("AdditionalInfo");
    if let Some(var_1073) = &input.additional_info {
        scope_1072.string(var_1073);
    }
    #[allow(unused_mut)]
    let mut scope_1074 = writer.prefix("IamRoles");
    if let Some(var_1075) = &input.iam_roles {
        let mut list_1077 = scope_1074.start_list(false, Some("IamRoleArn"));
        for item_1076 in var_1075 {
            #[allow(unused_mut)]
            let mut entry_1078 = list_1077.entry();
            entry_1078.string(item_1076);
        }
        list_1077.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1079 = writer.prefix("MaintenanceTrackName");
    if let Some(var_1080) = &input.maintenance_track_name {
        scope_1079.string(var_1080);
    }
    #[allow(unused_mut)]
    let mut scope_1081 = writer.prefix("SnapshotScheduleIdentifier");
    if let Some(var_1082) = &input.snapshot_schedule_identifier {
        scope_1081.string(var_1082);
    }
    #[allow(unused_mut)]
    let mut scope_1083 = writer.prefix("NumberOfNodes");
    if let Some(var_1084) = &input.number_of_nodes {
        scope_1083.number(
            #[allow(clippy::useless_conversion)]
            smithy_types::Number::NegInt((*var_1084).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_1085 = writer.prefix("AvailabilityZoneRelocation");
    if let Some(var_1086) = &input.availability_zone_relocation {
        scope_1085.boolean(*var_1086);
    }
    #[allow(unused_mut)]
    let mut scope_1087 = writer.prefix("AquaConfigurationStatus");
    if let Some(var_1088) = &input.aqua_configuration_status {
        scope_1087.string(var_1088.as_str());
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_restore_table_from_cluster_snapshot(
    input: &crate::input::RestoreTableFromClusterSnapshotInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RestoreTableFromClusterSnapshot", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1089 = writer.prefix("ClusterIdentifier");
    if let Some(var_1090) = &input.cluster_identifier {
        scope_1089.string(var_1090);
    }
    #[allow(unused_mut)]
    let mut scope_1091 = writer.prefix("SnapshotIdentifier");
    if let Some(var_1092) = &input.snapshot_identifier {
        scope_1091.string(var_1092);
    }
    #[allow(unused_mut)]
    let mut scope_1093 = writer.prefix("SourceDatabaseName");
    if let Some(var_1094) = &input.source_database_name {
        scope_1093.string(var_1094);
    }
    #[allow(unused_mut)]
    let mut scope_1095 = writer.prefix("SourceSchemaName");
    if let Some(var_1096) = &input.source_schema_name {
        scope_1095.string(var_1096);
    }
    #[allow(unused_mut)]
    let mut scope_1097 = writer.prefix("SourceTableName");
    if let Some(var_1098) = &input.source_table_name {
        scope_1097.string(var_1098);
    }
    #[allow(unused_mut)]
    let mut scope_1099 = writer.prefix("TargetDatabaseName");
    if let Some(var_1100) = &input.target_database_name {
        scope_1099.string(var_1100);
    }
    #[allow(unused_mut)]
    let mut scope_1101 = writer.prefix("TargetSchemaName");
    if let Some(var_1102) = &input.target_schema_name {
        scope_1101.string(var_1102);
    }
    #[allow(unused_mut)]
    let mut scope_1103 = writer.prefix("NewTableName");
    if let Some(var_1104) = &input.new_table_name {
        scope_1103.string(var_1104);
    }
    #[allow(unused_mut)]
    let mut scope_1105 = writer.prefix("EnableCaseSensitiveIdentifier");
    if let Some(var_1106) = &input.enable_case_sensitive_identifier {
        scope_1105.boolean(*var_1106);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_resume_cluster(
    input: &crate::input::ResumeClusterInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "ResumeCluster", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1107 = writer.prefix("ClusterIdentifier");
    if let Some(var_1108) = &input.cluster_identifier {
        scope_1107.string(var_1108);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_revoke_cluster_security_group_ingress(
    input: &crate::input::RevokeClusterSecurityGroupIngressInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        smithy_query::QueryWriter::new(&mut out, "RevokeClusterSecurityGroupIngress", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1109 = writer.prefix("ClusterSecurityGroupName");
    if let Some(var_1110) = &input.cluster_security_group_name {
        scope_1109.string(var_1110);
    }
    #[allow(unused_mut)]
    let mut scope_1111 = writer.prefix("CIDRIP");
    if let Some(var_1112) = &input.cidrip {
        scope_1111.string(var_1112);
    }
    #[allow(unused_mut)]
    let mut scope_1113 = writer.prefix("EC2SecurityGroupName");
    if let Some(var_1114) = &input.ec2_security_group_name {
        scope_1113.string(var_1114);
    }
    #[allow(unused_mut)]
    let mut scope_1115 = writer.prefix("EC2SecurityGroupOwnerId");
    if let Some(var_1116) = &input.ec2_security_group_owner_id {
        scope_1115.string(var_1116);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_revoke_endpoint_access(
    input: &crate::input::RevokeEndpointAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RevokeEndpointAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1117 = writer.prefix("ClusterIdentifier");
    if let Some(var_1118) = &input.cluster_identifier {
        scope_1117.string(var_1118);
    }
    #[allow(unused_mut)]
    let mut scope_1119 = writer.prefix("Account");
    if let Some(var_1120) = &input.account {
        scope_1119.string(var_1120);
    }
    #[allow(unused_mut)]
    let mut scope_1121 = writer.prefix("VpcIds");
    if let Some(var_1122) = &input.vpc_ids {
        let mut list_1124 = scope_1121.start_list(false, Some("VpcIdentifier"));
        for item_1123 in var_1122 {
            #[allow(unused_mut)]
            let mut entry_1125 = list_1124.entry();
            entry_1125.string(item_1123);
        }
        list_1124.finish();
    }
    #[allow(unused_mut)]
    let mut scope_1126 = writer.prefix("Force");
    if input.force {
        scope_1126.boolean(input.force);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_revoke_snapshot_access(
    input: &crate::input::RevokeSnapshotAccessInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RevokeSnapshotAccess", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1127 = writer.prefix("SnapshotIdentifier");
    if let Some(var_1128) = &input.snapshot_identifier {
        scope_1127.string(var_1128);
    }
    #[allow(unused_mut)]
    let mut scope_1129 = writer.prefix("SnapshotClusterIdentifier");
    if let Some(var_1130) = &input.snapshot_cluster_identifier {
        scope_1129.string(var_1130);
    }
    #[allow(unused_mut)]
    let mut scope_1131 = writer.prefix("AccountWithRestoreAccess");
    if let Some(var_1132) = &input.account_with_restore_access {
        scope_1131.string(var_1132);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_rotate_encryption_key(
    input: &crate::input::RotateEncryptionKeyInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "RotateEncryptionKey", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1133 = writer.prefix("ClusterIdentifier");
    if let Some(var_1134) = &input.cluster_identifier {
        scope_1133.string(var_1134);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

pub fn serialize_operation_crate_operation_update_partner_status(
    input: &crate::input::UpdatePartnerStatusInput,
) -> Result<smithy_http::body::SdkBody, std::convert::Infallible> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = smithy_query::QueryWriter::new(&mut out, "UpdatePartnerStatus", "2012-12-01");
    #[allow(unused_mut)]
    let mut scope_1135 = writer.prefix("AccountId");
    if let Some(var_1136) = &input.account_id {
        scope_1135.string(var_1136);
    }
    #[allow(unused_mut)]
    let mut scope_1137 = writer.prefix("ClusterIdentifier");
    if let Some(var_1138) = &input.cluster_identifier {
        scope_1137.string(var_1138);
    }
    #[allow(unused_mut)]
    let mut scope_1139 = writer.prefix("DatabaseName");
    if let Some(var_1140) = &input.database_name {
        scope_1139.string(var_1140);
    }
    #[allow(unused_mut)]
    let mut scope_1141 = writer.prefix("PartnerName");
    if let Some(var_1142) = &input.partner_name {
        scope_1141.string(var_1142);
    }
    #[allow(unused_mut)]
    let mut scope_1143 = writer.prefix("Status");
    if let Some(var_1144) = &input.status {
        scope_1143.string(var_1144.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_1145 = writer.prefix("StatusMessage");
    if let Some(var_1146) = &input.status_message {
        scope_1145.string(var_1146);
    }
    writer.finish();
    Ok(smithy_http::body::SdkBody::from(out))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_node_exchange_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptReservedNodeExchangeOutput,
    crate::error::AcceptReservedNodeExchangeError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AcceptReservedNodeExchangeError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DependentServiceUnavailableFault" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind:
                crate::error::AcceptReservedNodeExchangeErrorKind::DependentServiceUnavailableFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::dependent_service_unavailable_fault::Builder::default(
                                );
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_dependent_service_unavailable_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidReservedNodeState" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind: crate::error::AcceptReservedNodeExchangeErrorKind::InvalidReservedNodeStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_reserved_node_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_reserved_node_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ReservedNodeAlreadyExists" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind: crate::error::AcceptReservedNodeExchangeErrorKind::ReservedNodeAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::reserved_node_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_reserved_node_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ReservedNodeAlreadyMigrated" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind:
                crate::error::AcceptReservedNodeExchangeErrorKind::ReservedNodeAlreadyMigratedFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::reserved_node_already_migrated_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_reserved_node_already_migrated_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "ReservedNodeNotFound" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind: crate::error::AcceptReservedNodeExchangeErrorKind::ReservedNodeNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reserved_node_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReservedNodeOfferingNotFound" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind:
                crate::error::AcceptReservedNodeExchangeErrorKind::ReservedNodeOfferingNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::reserved_node_offering_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_reserved_node_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "UnsupportedOperation" => crate::error::AcceptReservedNodeExchangeError {
            meta: generic,
            kind: crate::error::AcceptReservedNodeExchangeErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AcceptReservedNodeExchangeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_reserved_node_exchange_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptReservedNodeExchangeOutput,
    crate::error::AcceptReservedNodeExchangeError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_reserved_node_exchange_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_accept_reserved_node_exchange(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AcceptReservedNodeExchangeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_partner_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddPartnerOutput, crate::error::AddPartnerError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AddPartnerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddPartnerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::AddPartnerError {
            meta: generic,
            kind: crate::error::AddPartnerErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddPartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PartnerNotFound" => crate::error::AddPartnerError {
            meta: generic,
            kind: crate::error::AddPartnerErrorKind::PartnerNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::partner_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_partner_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddPartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedPartnerIntegration" => crate::error::AddPartnerError {
            meta: generic,
            kind: crate::error::AddPartnerErrorKind::UnauthorizedPartnerIntegrationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_partner_integration_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_partner_integration_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AddPartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddPartnerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_partner_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddPartnerOutput, crate::error::AddPartnerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_partner_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_add_partner(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddPartnerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_data_share_consumer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateDataShareConsumerOutput,
    crate::error::AssociateDataShareConsumerError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateDataShareConsumerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateDataShareConsumerError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::AssociateDataShareConsumerError {
            meta: generic,
            kind: crate::error::AssociateDataShareConsumerErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateDataShareConsumerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNamespaceFault" => crate::error::AssociateDataShareConsumerError {
            meta: generic,
            kind: crate::error::AssociateDataShareConsumerErrorKind::InvalidNamespaceFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_namespace_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_namespace_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AssociateDataShareConsumerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AssociateDataShareConsumerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_data_share_consumer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateDataShareConsumerOutput,
    crate::error::AssociateDataShareConsumerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_data_share_consumer_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_associate_data_share_consumer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateDataShareConsumerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_cluster_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeClusterSecurityGroupIngressOutput,
    crate::error::AuthorizeClusterSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationAlreadyExists" => crate::error::AuthorizeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeClusterSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AuthorizationQuotaExceeded" => crate::error::AuthorizeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeClusterSecurityGroupIngressErrorKind::AuthorizationQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSecurityGroupNotFound" => crate::error::AuthorizeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeClusterSecurityGroupIngressErrorKind::ClusterSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSecurityGroupState" => crate::error::AuthorizeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::AuthorizeClusterSecurityGroupIngressErrorKind::InvalidClusterSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AuthorizeClusterSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_cluster_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeClusterSecurityGroupIngressOutput,
    crate::error::AuthorizeClusterSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::authorize_cluster_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_cluster_security_group_ingress(response.body().as_ref(), output).map_err(crate::error::AuthorizeClusterSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_data_share_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDataShareOutput,
    crate::error::AuthorizeDataShareError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AuthorizeDataShareError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AuthorizeDataShareError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::AuthorizeDataShareError {
            meta: generic,
            kind: crate::error::AuthorizeDataShareErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeDataShareError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AuthorizeDataShareError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_data_share_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeDataShareOutput,
    crate::error::AuthorizeDataShareError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_data_share_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_data_share(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeDataShareError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeEndpointAccessOutput,
    crate::error::AuthorizeEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AuthorizeEndpointAccessError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EndpointAuthorizationAlreadyExists" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::EndpointAuthorizationAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::endpoint_authorization_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_authorization_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EndpointAuthorizationsPerClusterLimitExceeded" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::EndpointAuthorizationsPerClusterLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::endpoint_authorizations_per_cluster_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_authorizations_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthorizationState" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::InvalidAuthorizationStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_authorization_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authorization_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterState" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::InvalidClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::AuthorizeEndpointAccessError { meta: generic, kind: crate::error::AuthorizeEndpointAccessErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AuthorizeEndpointAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeEndpointAccessOutput,
    crate::error::AuthorizeEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_snapshot_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSnapshotAccessOutput,
    crate::error::AuthorizeSnapshotAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AuthorizeSnapshotAccessError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationAlreadyExists" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::AuthorizationAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AuthorizationQuotaExceeded" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::AuthorizationQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSnapshotNotFound" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::ClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DependentServiceRequestThrottlingFault" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::DependentServiceRequestThrottlingFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSnapshotState" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::InvalidClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededFault" => crate::error::AuthorizeSnapshotAccessError { meta: generic, kind: crate::error::AuthorizeSnapshotAccessErrorKind::LimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AuthorizeSnapshotAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_authorize_snapshot_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AuthorizeSnapshotAccessOutput,
    crate::error::AuthorizeSnapshotAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::authorize_snapshot_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_authorize_snapshot_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AuthorizeSnapshotAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDeleteClusterSnapshotsOutput,
    crate::error::BatchDeleteClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchDeleteClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::BatchDeleteClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BatchDeleteRequestSizeExceeded" => crate::error::BatchDeleteClusterSnapshotsError { meta: generic, kind: crate::error::BatchDeleteClusterSnapshotsErrorKind::BatchDeleteRequestSizeExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::batch_delete_request_size_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_batch_delete_request_size_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::BatchDeleteClusterSnapshotsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDeleteClusterSnapshotsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_delete_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDeleteClusterSnapshotsOutput,
    crate::error::BatchDeleteClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_delete_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_batch_delete_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchDeleteClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_modify_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchModifyClusterSnapshotsOutput,
    crate::error::BatchModifyClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchModifyClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::BatchModifyClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BatchModifyClusterSnapshotsLimitExceededFault" => crate::error::BatchModifyClusterSnapshotsError { meta: generic, kind: crate::error::BatchModifyClusterSnapshotsErrorKind::BatchModifyClusterSnapshotsLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::batch_modify_cluster_snapshots_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_batch_modify_cluster_snapshots_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::BatchModifyClusterSnapshotsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRetentionPeriodFault" => crate::error::BatchModifyClusterSnapshotsError { meta: generic, kind: crate::error::BatchModifyClusterSnapshotsErrorKind::InvalidRetentionPeriodFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::BatchModifyClusterSnapshotsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchModifyClusterSnapshotsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_modify_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchModifyClusterSnapshotsOutput,
    crate::error::BatchModifyClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_modify_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_batch_modify_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchModifyClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_resize_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelResizeOutput, crate::error::CancelResizeError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CancelResizeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelResizeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::CancelResizeError {
            meta: generic,
            kind: crate::error::CancelResizeErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::CancelResizeError {
            meta: generic,
            kind: crate::error::CancelResizeErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResizeNotFound" => crate::error::CancelResizeError {
            meta: generic,
            kind: crate::error::CancelResizeErrorKind::ResizeNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resize_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resize_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::CancelResizeError {
            meta: generic,
            kind: crate::error::CancelResizeErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CancelResizeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_resize_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelResizeOutput, crate::error::CancelResizeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_resize_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_cancel_resize(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CancelResizeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyClusterSnapshotOutput,
    crate::error::CopyClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CopyClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSnapshotAlreadyExists" => crate::error::CopyClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyClusterSnapshotErrorKind::ClusterSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotNotFound" => crate::error::CopyClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyClusterSnapshotErrorKind::ClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotQuotaExceeded" => crate::error::CopyClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyClusterSnapshotErrorKind::ClusterSnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSnapshotState" => crate::error::CopyClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyClusterSnapshotErrorKind::InvalidClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::CopyClusterSnapshotError {
            meta: generic,
            kind: crate::error::CopyClusterSnapshotErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CopyClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_copy_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CopyClusterSnapshotOutput,
    crate::error::CopyClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::copy_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_copy_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CopyClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_authentication_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAuthenticationProfileOutput,
    crate::error::CreateAuthenticationProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateAuthenticationProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateAuthenticationProfileError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthenticationProfileAlreadyExistsFault" => crate::error::CreateAuthenticationProfileError { meta: generic, kind: crate::error::CreateAuthenticationProfileErrorKind::AuthenticationProfileAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AuthenticationProfileQuotaExceededFault" => crate::error::CreateAuthenticationProfileError { meta: generic, kind: crate::error::CreateAuthenticationProfileErrorKind::AuthenticationProfileQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthenticationProfileRequestFault" => crate::error::CreateAuthenticationProfileError { meta: generic, kind: crate::error::CreateAuthenticationProfileErrorKind::InvalidAuthenticationProfileRequestFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_authentication_profile_request_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_profile_request_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateAuthenticationProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_authentication_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateAuthenticationProfileOutput,
    crate::error::CreateAuthenticationProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_authentication_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_authentication_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateAuthenticationProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterAlreadyExists" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::ClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterParameterGroupNotFound" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::ClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterQuotaExceeded" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::ClusterQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSecurityGroupNotFound" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::ClusterSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSubnetGroupNotFoundFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::ClusterSubnetGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DependentServiceRequestThrottlingFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::DependentServiceRequestThrottlingFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::dependent_service_request_throttling_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "HsmClientCertificateNotFoundFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::HsmClientCertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hsm_client_certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "HsmConfigurationNotFoundFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::HsmConfigurationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hsm_configuration_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientClusterCapacity" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InsufficientClusterCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSubnetGroupStateFault" => {
            crate::error::CreateClusterError {
                meta: generic,
                kind: crate::error::CreateClusterErrorKind::InvalidClusterSubnetGroupStateFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_subnet_group_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidClusterTrack" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InvalidClusterTrackFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_track_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_track_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidElasticIpFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InvalidElasticIpFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_elastic_ip_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_elastic_ip_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSubnet" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InvalidSubnet({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagFault" => {
            crate::error::CreateClusterError {
                meta: generic,
                kind: crate::error::CreateClusterErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidVPCNetworkStateFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::InvalidVpcNetworkStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededFault" => {
            crate::error::CreateClusterError {
                meta: generic,
                kind: crate::error::CreateClusterErrorKind::LimitExceededFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "NumberOfNodesPerClusterLimitExceeded" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::NumberOfNodesPerClusterLimitExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NumberOfNodesQuotaExceeded" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::NumberOfNodesQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::number_of_nodes_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotScheduleNotFound" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::SnapshotScheduleNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_schedule_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagLimitExceededFault" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::CreateClusterError {
            meta: generic,
            kind: crate::error::CreateClusterErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterParameterGroupOutput,
    crate::error::CreateClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupAlreadyExists" => crate::error::CreateClusterParameterGroupError { meta: generic, kind: crate::error::CreateClusterParameterGroupErrorKind::ClusterParameterGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterParameterGroupQuotaExceeded" => crate::error::CreateClusterParameterGroupError { meta: generic, kind: crate::error::CreateClusterParameterGroupErrorKind::ClusterParameterGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateClusterParameterGroupError { meta: generic, kind: crate::error::CreateClusterParameterGroupErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateClusterParameterGroupError { meta: generic, kind: crate::error::CreateClusterParameterGroupErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterParameterGroupOutput,
    crate::error::CreateClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSecurityGroupOutput,
    crate::error::CreateClusterSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateClusterSecurityGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSecurityGroupAlreadyExists" => crate::error::CreateClusterSecurityGroupError { meta: generic, kind: crate::error::CreateClusterSecurityGroupErrorKind::ClusterSecurityGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "QuotaExceeded.ClusterSecurityGroup" => crate::error::CreateClusterSecurityGroupError { meta: generic, kind: crate::error::CreateClusterSecurityGroupErrorKind::ClusterSecurityGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateClusterSecurityGroupError { meta: generic, kind: crate::error::CreateClusterSecurityGroupErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateClusterSecurityGroupError { meta: generic, kind: crate::error::CreateClusterSecurityGroupErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateClusterSecurityGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSecurityGroupOutput,
    crate::error::CreateClusterSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cluster_security_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cluster_security_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClusterSecurityGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSnapshotOutput,
    crate::error::CreateClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotAlreadyExists" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::ClusterSnapshotAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::cluster_snapshot_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ClusterSnapshotQuotaExceeded" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::ClusterSnapshotQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::cluster_snapshot_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidClusterState" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagFault" => {
            crate::error::CreateClusterSnapshotError {
                meta: generic,
                kind: crate::error::CreateClusterSnapshotErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TagLimitExceededFault" => crate::error::CreateClusterSnapshotError {
            meta: generic,
            kind: crate::error::CreateClusterSnapshotErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSnapshotOutput,
    crate::error::CreateClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSubnetGroupOutput,
    crate::error::CreateClusterSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateClusterSubnetGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSubnetGroupAlreadyExists" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::ClusterSubnetGroupAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSubnetGroupQuotaExceeded" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::ClusterSubnetGroupQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSubnetQuotaExceededFault" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::ClusterSubnetQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DependentServiceRequestThrottlingFault" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::DependentServiceRequestThrottlingFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperation" => crate::error::CreateClusterSubnetGroupError { meta: generic, kind: crate::error::CreateClusterSubnetGroupErrorKind::UnauthorizedOperation({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateClusterSubnetGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cluster_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateClusterSubnetGroupOutput,
    crate::error::CreateClusterSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_cluster_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_cluster_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateClusterSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEndpointAccessOutput,
    crate::error::CreateEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateEndpointAccessError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessToClusterDenied" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::AccessToClusterDeniedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::access_to_cluster_denied_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_to_cluster_denied_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterNotFound" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSubnetGroupNotFoundFault" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::ClusterSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EndpointAlreadyExists" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::EndpointAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::endpoint_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EndpointsPerAuthorizationLimitExceeded" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::EndpointsPerAuthorizationLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::endpoints_per_authorization_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoints_per_authorization_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EndpointsPerClusterLimitExceeded" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::EndpointsPerClusterLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::endpoints_per_cluster_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoints_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSecurityGroupState" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::InvalidClusterSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterState" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::InvalidClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperation" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::UnauthorizedOperation({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::CreateEndpointAccessError { meta: generic, kind: crate::error::CreateEndpointAccessErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEndpointAccessError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateEndpointAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEndpointAccessOutput,
    crate::error::CreateEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EventSubscriptionQuotaExceeded" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind:
                crate::error::CreateEventSubscriptionErrorKind::EventSubscriptionQuotaExceededFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::event_subscription_quota_exceeded_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_event_subscription_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidTagFault" => {
            crate::error::CreateEventSubscriptionError {
                meta: generic,
                kind: crate::error::CreateEventSubscriptionErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "SNSInvalidTopic" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionAlreadyExist" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionAlreadyExistFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::subscription_already_exist_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_already_exist_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionEventIdNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionEventIdNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_event_id_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_event_id_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionSeverityNotFound" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::SubscriptionSeverityNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_severity_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_severity_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TagLimitExceededFault" => crate::error::CreateEventSubscriptionError {
            meta: generic,
            kind: crate::error::CreateEventSubscriptionErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEventSubscriptionOutput,
    crate::error::CreateEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hsm_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHsmClientCertificateOutput,
    crate::error::CreateHsmClientCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateHsmClientCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmClientCertificateAlreadyExistsFault" => crate::error::CreateHsmClientCertificateError { meta: generic, kind: crate::error::CreateHsmClientCertificateErrorKind::HsmClientCertificateAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_client_certificate_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "HsmClientCertificateQuotaExceededFault" => crate::error::CreateHsmClientCertificateError { meta: generic, kind: crate::error::CreateHsmClientCertificateErrorKind::HsmClientCertificateQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_client_certificate_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateHsmClientCertificateError { meta: generic, kind: crate::error::CreateHsmClientCertificateErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateHsmClientCertificateError { meta: generic, kind: crate::error::CreateHsmClientCertificateErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateHsmClientCertificateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hsm_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHsmClientCertificateOutput,
    crate::error::CreateHsmClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_hsm_client_certificate_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_hsm_client_certificate(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHsmClientCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hsm_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHsmConfigurationOutput,
    crate::error::CreateHsmConfigurationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateHsmConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmConfigurationAlreadyExistsFault" => crate::error::CreateHsmConfigurationError {
            meta: generic,
            kind: crate::error::CreateHsmConfigurationErrorKind::HsmConfigurationAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::hsm_configuration_already_exists_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "HsmConfigurationQuotaExceededFault" => crate::error::CreateHsmConfigurationError {
            meta: generic,
            kind: crate::error::CreateHsmConfigurationErrorKind::HsmConfigurationQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::hsm_configuration_quota_exceeded_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidTagFault" => {
            crate::error::CreateHsmConfigurationError {
                meta: generic,
                kind: crate::error::CreateHsmConfigurationErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TagLimitExceededFault" => crate::error::CreateHsmConfigurationError {
            meta: generic,
            kind: crate::error::CreateHsmConfigurationErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateHsmConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_hsm_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateHsmConfigurationOutput,
    crate::error::CreateHsmConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_hsm_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_hsm_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateHsmConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_scheduled_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateScheduledActionOutput,
    crate::error::CreateScheduledActionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateScheduledActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateScheduledActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidScheduledAction" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::InvalidScheduledActionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_scheduled_action_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_scheduled_action_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSchedule" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::InvalidScheduleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_schedule_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ScheduledActionAlreadyExists" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::ScheduledActionAlreadyExistsFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::scheduled_action_already_exists_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_scheduled_action_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ScheduledActionQuotaExceeded" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::ScheduledActionQuotaExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::scheduled_action_quota_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_scheduled_action_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "ScheduledActionTypeUnsupported" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::ScheduledActionTypeUnsupportedFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::scheduled_action_type_unsupported_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_scheduled_action_type_unsupported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "UnauthorizedOperation" => crate::error::CreateScheduledActionError {
            meta: generic,
            kind: crate::error::CreateScheduledActionErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateScheduledActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_scheduled_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateScheduledActionOutput,
    crate::error::CreateScheduledActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_scheduled_action_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_scheduled_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateScheduledActionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_copy_grant_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSnapshotCopyGrantOutput,
    crate::error::CreateSnapshotCopyGrantError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSnapshotCopyGrantError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DependentServiceRequestThrottlingFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::DependentServiceRequestThrottlingFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::LimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotCopyGrantAlreadyExistsFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::SnapshotCopyGrantAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_copy_grant_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_grant_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotCopyGrantQuotaExceededFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::SnapshotCopyGrantQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_copy_grant_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_grant_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateSnapshotCopyGrantError { meta: generic, kind: crate::error::CreateSnapshotCopyGrantErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateSnapshotCopyGrantError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_copy_grant_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSnapshotCopyGrantOutput,
    crate::error::CreateSnapshotCopyGrantError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshot_copy_grant_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshot_copy_grant(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSnapshotCopyGrantError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSnapshotScheduleOutput,
    crate::error::CreateSnapshotScheduleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSnapshotScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidSchedule" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::InvalidScheduleFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_schedule_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_schedule_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ScheduleDefinitionTypeUnsupported" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::ScheduleDefinitionTypeUnsupportedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::schedule_definition_type_unsupported_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_schedule_definition_type_unsupported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotScheduleAlreadyExists" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::SnapshotScheduleAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotScheduleQuotaExceeded" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::SnapshotScheduleQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::CreateSnapshotScheduleError { meta: generic, kind: crate::error::CreateSnapshotScheduleErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateSnapshotScheduleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_snapshot_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSnapshotScheduleOutput,
    crate::error::CreateSnapshotScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_snapshot_schedule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_snapshot_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSnapshotScheduleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidClusterState" => crate::error::CreateTagsError {
            meta: generic,
            kind: crate::error::CreateTagsErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagFault" => {
            crate::error::CreateTagsError {
                meta: generic,
                kind: crate::error::CreateTagsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ResourceNotFoundFault" => crate::error::CreateTagsError {
            meta: generic,
            kind: crate::error::CreateTagsErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagLimitExceededFault" => crate::error::CreateTagsError {
            meta: generic,
            kind: crate::error::CreateTagsErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUsageLimitOutput, crate::error::CreateUsageLimitError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateUsageLimitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUsageLimitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidUsageLimit" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::InvalidUsageLimitFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_usage_limit_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_usage_limit_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededFault" => {
            crate::error::CreateUsageLimitError {
                meta: generic,
                kind: crate::error::CreateUsageLimitErrorKind::LimitExceededFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TagLimitExceededFault" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::TagLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UsageLimitAlreadyExists" => crate::error::CreateUsageLimitError {
            meta: generic,
            kind: crate::error::CreateUsageLimitErrorKind::UsageLimitAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::usage_limit_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_usage_limit_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateUsageLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUsageLimitOutput, crate::error::CreateUsageLimitError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_usage_limit_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_usage_limit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUsageLimitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deauthorize_data_share_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeauthorizeDataShareOutput,
    crate::error::DeauthorizeDataShareError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeauthorizeDataShareError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeauthorizeDataShareError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::DeauthorizeDataShareError {
            meta: generic,
            kind: crate::error::DeauthorizeDataShareErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeauthorizeDataShareError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeauthorizeDataShareError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deauthorize_data_share_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeauthorizeDataShareOutput,
    crate::error::DeauthorizeDataShareError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deauthorize_data_share_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_deauthorize_data_share(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeauthorizeDataShareError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_authentication_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAuthenticationProfileOutput,
    crate::error::DeleteAuthenticationProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteAuthenticationProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteAuthenticationProfileError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthenticationProfileNotFoundFault" => crate::error::DeleteAuthenticationProfileError { meta: generic, kind: crate::error::DeleteAuthenticationProfileErrorKind::AuthenticationProfileNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthenticationProfileRequestFault" => crate::error::DeleteAuthenticationProfileError { meta: generic, kind: crate::error::DeleteAuthenticationProfileErrorKind::InvalidAuthenticationProfileRequestFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_authentication_profile_request_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_profile_request_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteAuthenticationProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_authentication_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteAuthenticationProfileOutput,
    crate::error::DeleteAuthenticationProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_authentication_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_authentication_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteAuthenticationProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DeleteClusterError {
            meta: generic,
            kind: crate::error::DeleteClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotAlreadyExists" => crate::error::DeleteClusterError {
            meta: generic,
            kind: crate::error::DeleteClusterErrorKind::ClusterSnapshotAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotQuotaExceeded" => crate::error::DeleteClusterError {
            meta: generic,
            kind: crate::error::DeleteClusterErrorKind::ClusterSnapshotQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::DeleteClusterError {
            meta: generic,
            kind: crate::error::DeleteClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::DeleteClusterError {
            meta: generic,
            kind: crate::error::DeleteClusterErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterParameterGroupOutput,
    crate::error::DeleteClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupNotFound" => crate::error::DeleteClusterParameterGroupError { meta: generic, kind: crate::error::DeleteClusterParameterGroupErrorKind::ClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterParameterGroupState" => crate::error::DeleteClusterParameterGroupError { meta: generic, kind: crate::error::DeleteClusterParameterGroupErrorKind::InvalidClusterParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterParameterGroupOutput,
    crate::error::DeleteClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_security_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSecurityGroupOutput,
    crate::error::DeleteClusterSecurityGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteClusterSecurityGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteClusterSecurityGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSecurityGroupNotFound" => crate::error::DeleteClusterSecurityGroupError { meta: generic, kind: crate::error::DeleteClusterSecurityGroupErrorKind::ClusterSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSecurityGroupState" => crate::error::DeleteClusterSecurityGroupError { meta: generic, kind: crate::error::DeleteClusterSecurityGroupErrorKind::InvalidClusterSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSecurityGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteClusterSecurityGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_security_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSecurityGroupOutput,
    crate::error::DeleteClusterSecurityGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cluster_security_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSnapshotOutput,
    crate::error::DeleteClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSnapshotNotFound" => crate::error::DeleteClusterSnapshotError {
            meta: generic,
            kind: crate::error::DeleteClusterSnapshotErrorKind::ClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSnapshotState" => crate::error::DeleteClusterSnapshotError {
            meta: generic,
            kind: crate::error::DeleteClusterSnapshotErrorKind::InvalidClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSnapshotOutput,
    crate::error::DeleteClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSubnetGroupOutput,
    crate::error::DeleteClusterSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteClusterSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteClusterSubnetGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSubnetGroupNotFoundFault" => crate::error::DeleteClusterSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteClusterSubnetGroupErrorKind::ClusterSubnetGroupNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSubnetGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidClusterSubnetGroupStateFault" => crate::error::DeleteClusterSubnetGroupError {
            meta: generic,
            kind:
                crate::error::DeleteClusterSubnetGroupErrorKind::InvalidClusterSubnetGroupStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_subnet_group_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSubnetGroupError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidClusterSubnetStateFault" => crate::error::DeleteClusterSubnetGroupError {
            meta: generic,
            kind: crate::error::DeleteClusterSubnetGroupErrorKind::InvalidClusterSubnetStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_cluster_subnet_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_subnet_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteClusterSubnetGroupError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DeleteClusterSubnetGroupError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_cluster_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClusterSubnetGroupOutput,
    crate::error::DeleteClusterSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_cluster_subnet_group_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEndpointAccessOutput,
    crate::error::DeleteEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteEndpointAccessError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DeleteEndpointAccessError {
            meta: generic,
            kind: crate::error::DeleteEndpointAccessErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EndpointNotFound" => crate::error::DeleteEndpointAccessError {
            meta: generic,
            kind: crate::error::DeleteEndpointAccessErrorKind::EndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSecurityGroupState" => crate::error::DeleteEndpointAccessError {
            meta: generic,
            kind:
                crate::error::DeleteEndpointAccessErrorKind::InvalidClusterSecurityGroupStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidClusterState" => crate::error::DeleteEndpointAccessError {
            meta: generic,
            kind: crate::error::DeleteEndpointAccessErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidEndpointState" => crate::error::DeleteEndpointAccessError {
            meta: generic,
            kind: crate::error::DeleteEndpointAccessErrorKind::InvalidEndpointStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_endpoint_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteEndpointAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEndpointAccessOutput,
    crate::error::DeleteEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidSubscriptionStateFault" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind: crate::error::DeleteEventSubscriptionErrorKind::InvalidSubscriptionStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_subscription_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subscription_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionNotFound" => crate::error::DeleteEventSubscriptionError {
            meta: generic,
            kind: crate::error::DeleteEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEventSubscriptionOutput,
    crate::error::DeleteEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_event_subscription_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hsm_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteHsmClientCertificateOutput,
    crate::error::DeleteHsmClientCertificateError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteHsmClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteHsmClientCertificateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmClientCertificateNotFoundFault" => crate::error::DeleteHsmClientCertificateError { meta: generic, kind: crate::error::DeleteHsmClientCertificateErrorKind::HsmClientCertificateNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_client_certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidHsmClientCertificateStateFault" => crate::error::DeleteHsmClientCertificateError { meta: generic, kind: crate::error::DeleteHsmClientCertificateErrorKind::InvalidHsmClientCertificateStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_hsm_client_certificate_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_hsm_client_certificate_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHsmClientCertificateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteHsmClientCertificateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hsm_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteHsmClientCertificateOutput,
    crate::error::DeleteHsmClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_hsm_client_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hsm_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteHsmConfigurationOutput,
    crate::error::DeleteHsmConfigurationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteHsmConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteHsmConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmConfigurationNotFoundFault" => crate::error::DeleteHsmConfigurationError {
            meta: generic,
            kind: crate::error::DeleteHsmConfigurationErrorKind::HsmConfigurationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hsm_configuration_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHsmConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidHsmConfigurationStateFault" => crate::error::DeleteHsmConfigurationError {
            meta: generic,
            kind: crate::error::DeleteHsmConfigurationErrorKind::InvalidHsmConfigurationStateFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_hsm_configuration_state_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_hsm_configuration_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteHsmConfigurationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DeleteHsmConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_hsm_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteHsmConfigurationOutput,
    crate::error::DeleteHsmConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_hsm_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_partner_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePartnerOutput, crate::error::DeletePartnerError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePartnerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeletePartnerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DeletePartnerError {
            meta: generic,
            kind: crate::error::DeletePartnerErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PartnerNotFound" => crate::error::DeletePartnerError {
            meta: generic,
            kind: crate::error::DeletePartnerErrorKind::PartnerNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::partner_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_partner_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedPartnerIntegration" => crate::error::DeletePartnerError {
            meta: generic,
            kind: crate::error::DeletePartnerErrorKind::UnauthorizedPartnerIntegrationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_partner_integration_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_partner_integration_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeletePartnerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeletePartnerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_partner_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeletePartnerOutput, crate::error::DeletePartnerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_partner_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_partner(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePartnerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_scheduled_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteScheduledActionOutput,
    crate::error::DeleteScheduledActionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteScheduledActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteScheduledActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ScheduledActionNotFound" => crate::error::DeleteScheduledActionError {
            meta: generic,
            kind: crate::error::DeleteScheduledActionErrorKind::ScheduledActionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::scheduled_action_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_scheduled_action_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::DeleteScheduledActionError {
            meta: generic,
            kind: crate::error::DeleteScheduledActionErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteScheduledActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_scheduled_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteScheduledActionOutput,
    crate::error::DeleteScheduledActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_scheduled_action_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_copy_grant_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSnapshotCopyGrantOutput,
    crate::error::DeleteSnapshotCopyGrantError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteSnapshotCopyGrantError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSnapshotCopyGrantError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidSnapshotCopyGrantStateFault" => crate::error::DeleteSnapshotCopyGrantError {
            meta: generic,
            kind:
                crate::error::DeleteSnapshotCopyGrantErrorKind::InvalidSnapshotCopyGrantStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_snapshot_copy_grant_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_snapshot_copy_grant_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSnapshotCopyGrantError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "SnapshotCopyGrantNotFoundFault" => crate::error::DeleteSnapshotCopyGrantError {
            meta: generic,
            kind: crate::error::DeleteSnapshotCopyGrantErrorKind::SnapshotCopyGrantNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_copy_grant_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_grant_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSnapshotCopyGrantError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSnapshotCopyGrantError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_copy_grant_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSnapshotCopyGrantOutput,
    crate::error::DeleteSnapshotCopyGrantError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_snapshot_copy_grant_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSnapshotScheduleOutput,
    crate::error::DeleteSnapshotScheduleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteSnapshotScheduleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSnapshotScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidClusterSnapshotScheduleState" => crate::error::DeleteSnapshotScheduleError { meta: generic, kind: crate::error::DeleteSnapshotScheduleErrorKind::InvalidClusterSnapshotScheduleStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_schedule_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_schedule_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotScheduleNotFound" => crate::error::DeleteSnapshotScheduleError { meta: generic, kind: crate::error::DeleteSnapshotScheduleErrorKind::SnapshotScheduleNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteSnapshotScheduleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_snapshot_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSnapshotScheduleOutput,
    crate::error::DeleteSnapshotScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_snapshot_schedule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidTagFault" => {
            crate::error::DeleteTagsError {
                meta: generic,
                kind: crate::error::DeleteTagsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ResourceNotFoundFault" => crate::error::DeleteTagsError {
            meta: generic,
            kind: crate::error::DeleteTagsErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUsageLimitOutput, crate::error::DeleteUsageLimitError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteUsageLimitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUsageLimitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "UnsupportedOperation" => crate::error::DeleteUsageLimitError {
            meta: generic,
            kind: crate::error::DeleteUsageLimitErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UsageLimitNotFound" => crate::error::DeleteUsageLimitError {
            meta: generic,
            kind: crate::error::DeleteUsageLimitErrorKind::UsageLimitNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::usage_limit_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_usage_limit_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUsageLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUsageLimitOutput, crate::error::DeleteUsageLimitError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_usage_limit_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
    Err(crate::error::DescribeAccountAttributesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountAttributesOutput,
    crate::error::DescribeAccountAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_attributes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_account_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAccountAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_authentication_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAuthenticationProfilesOutput,
    crate::error::DescribeAuthenticationProfilesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeAuthenticationProfilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeAuthenticationProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthenticationProfileNotFoundFault" => crate::error::DescribeAuthenticationProfilesError { meta: generic, kind: crate::error::DescribeAuthenticationProfilesErrorKind::AuthenticationProfileNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeAuthenticationProfilesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthenticationProfileRequestFault" => crate::error::DescribeAuthenticationProfilesError { meta: generic, kind: crate::error::DescribeAuthenticationProfilesErrorKind::InvalidAuthenticationProfileRequestFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_authentication_profile_request_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_profile_request_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeAuthenticationProfilesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAuthenticationProfilesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_authentication_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAuthenticationProfilesOutput,
    crate::error::DescribeAuthenticationProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_authentication_profiles_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_authentication_profiles(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeAuthenticationProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_db_revisions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterDbRevisionsOutput,
    crate::error::DescribeClusterDbRevisionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterDbRevisionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeClusterDbRevisionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeClusterDbRevisionsError {
            meta: generic,
            kind: crate::error::DescribeClusterDbRevisionsErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterDbRevisionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::DescribeClusterDbRevisionsError {
            meta: generic,
            kind: crate::error::DescribeClusterDbRevisionsErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterDbRevisionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeClusterDbRevisionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_db_revisions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterDbRevisionsOutput,
    crate::error::DescribeClusterDbRevisionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_db_revisions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_db_revisions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterDbRevisionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_parameter_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterParameterGroupsOutput,
    crate::error::DescribeClusterParameterGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterParameterGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeClusterParameterGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupNotFound" => crate::error::DescribeClusterParameterGroupsError { meta: generic, kind: crate::error::DescribeClusterParameterGroupsErrorKind::ClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterParameterGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::DescribeClusterParameterGroupsError { meta: generic, kind: crate::error::DescribeClusterParameterGroupsErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterParameterGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeClusterParameterGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_parameter_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterParameterGroupsOutput,
    crate::error::DescribeClusterParameterGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_cluster_parameter_groups_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_cluster_parameter_groups(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeClusterParameterGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterParametersOutput,
    crate::error::DescribeClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterParametersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeClusterParametersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupNotFound" => crate::error::DescribeClusterParametersError {
            meta: generic,
            kind:
                crate::error::DescribeClusterParametersErrorKind::ClusterParameterGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterParametersError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeClusterParametersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterParametersOutput,
    crate::error::DescribeClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_parameters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_parameters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeClustersOutput, crate::error::DescribeClustersError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeClustersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeClustersError {
            meta: generic,
            kind: crate::error::DescribeClustersErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagFault" => {
            crate::error::DescribeClustersError {
                meta: generic,
                kind: crate::error::DescribeClustersErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClustersError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeClustersOutput, crate::error::DescribeClustersError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_clusters_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_clusters(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_security_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSecurityGroupsOutput,
    crate::error::DescribeClusterSecurityGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterSecurityGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeClusterSecurityGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSecurityGroupNotFound" => crate::error::DescribeClusterSecurityGroupsError { meta: generic, kind: crate::error::DescribeClusterSecurityGroupsErrorKind::ClusterSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSecurityGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::DescribeClusterSecurityGroupsError { meta: generic, kind: crate::error::DescribeClusterSecurityGroupsErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSecurityGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeClusterSecurityGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_security_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSecurityGroupsOutput,
    crate::error::DescribeClusterSecurityGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_security_groups_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_cluster_security_groups(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeClusterSecurityGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_snapshots_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSnapshotsOutput,
    crate::error::DescribeClusterSnapshotsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterSnapshotsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeClusterSnapshotsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeClusterSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeClusterSnapshotsErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSnapshotsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotNotFound" => crate::error::DescribeClusterSnapshotsError {
            meta: generic,
            kind: crate::error::DescribeClusterSnapshotsErrorKind::ClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSnapshotsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagFault" => {
            crate::error::DescribeClusterSnapshotsError {
                meta: generic,
                kind: crate::error::DescribeClusterSnapshotsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSnapshotsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeClusterSnapshotsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_snapshots_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSnapshotsOutput,
    crate::error::DescribeClusterSnapshotsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_snapshots_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_snapshots(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterSnapshotsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_subnet_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSubnetGroupsOutput,
    crate::error::DescribeClusterSubnetGroupsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterSubnetGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeClusterSubnetGroupsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSubnetGroupNotFoundFault" => crate::error::DescribeClusterSubnetGroupsError {
            meta: generic,
            kind:
                crate::error::DescribeClusterSubnetGroupsErrorKind::ClusterSubnetGroupNotFoundFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSubnetGroupsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidTagFault" => {
            crate::error::DescribeClusterSubnetGroupsError {
                meta: generic,
                kind: crate::error::DescribeClusterSubnetGroupsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterSubnetGroupsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeClusterSubnetGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_subnet_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterSubnetGroupsOutput,
    crate::error::DescribeClusterSubnetGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_subnet_groups_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_subnet_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterSubnetGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_tracks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterTracksOutput,
    crate::error::DescribeClusterTracksError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterTracksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeClusterTracksError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidClusterTrack" => crate::error::DescribeClusterTracksError {
            meta: generic,
            kind: crate::error::DescribeClusterTracksErrorKind::InvalidClusterTrackFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_track_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_track_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterTracksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::DescribeClusterTracksError {
            meta: generic,
            kind: crate::error::DescribeClusterTracksErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterTracksError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeClusterTracksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_tracks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterTracksOutput,
    crate::error::DescribeClusterTracksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_tracks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_tracks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterTracksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterVersionsOutput,
    crate::error::DescribeClusterVersionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeClusterVersionsError::unhandled)?;
    Err(crate::error::DescribeClusterVersionsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeClusterVersionsOutput,
    crate::error::DescribeClusterVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_cluster_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeClusterVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesOutput,
    crate::error::DescribeDataSharesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDataSharesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeDataSharesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::DescribeDataSharesError {
            meta: generic,
            kind: crate::error::DescribeDataSharesErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDataSharesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDataSharesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesOutput,
    crate::error::DescribeDataSharesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_data_shares_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_data_shares(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDataSharesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_for_consumer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesForConsumerOutput,
    crate::error::DescribeDataSharesForConsumerError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDataSharesForConsumerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDataSharesForConsumerError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNamespaceFault" => crate::error::DescribeDataSharesForConsumerError {
            meta: generic,
            kind: crate::error::DescribeDataSharesForConsumerErrorKind::InvalidNamespaceFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_namespace_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_namespace_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDataSharesForConsumerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDataSharesForConsumerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_for_consumer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesForConsumerOutput,
    crate::error::DescribeDataSharesForConsumerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_data_shares_for_consumer_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_data_shares_for_consumer(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDataSharesForConsumerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_for_producer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesForProducerOutput,
    crate::error::DescribeDataSharesForProducerError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDataSharesForProducerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDataSharesForProducerError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidNamespaceFault" => crate::error::DescribeDataSharesForProducerError {
            meta: generic,
            kind: crate::error::DescribeDataSharesForProducerErrorKind::InvalidNamespaceFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_namespace_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_namespace_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeDataSharesForProducerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeDataSharesForProducerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_data_shares_for_producer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDataSharesForProducerOutput,
    crate::error::DescribeDataSharesForProducerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_data_shares_for_producer_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_data_shares_for_producer(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDataSharesForProducerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_default_cluster_parameters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDefaultClusterParametersOutput,
    crate::error::DescribeDefaultClusterParametersError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDefaultClusterParametersError::unhandled)?;
    Err(crate::error::DescribeDefaultClusterParametersError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_default_cluster_parameters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDefaultClusterParametersOutput,
    crate::error::DescribeDefaultClusterParametersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_default_cluster_parameters_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_default_cluster_parameters(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDefaultClusterParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointAccessOutput,
    crate::error::DescribeEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEndpointAccessError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeEndpointAccessError {
            meta: generic,
            kind: crate::error::DescribeEndpointAccessErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EndpointNotFound" => crate::error::DescribeEndpointAccessError {
            meta: generic,
            kind: crate::error::DescribeEndpointAccessErrorKind::EndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::DescribeEndpointAccessError {
            meta: generic,
            kind: crate::error::DescribeEndpointAccessErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeEndpointAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointAccessOutput,
    crate::error::DescribeEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_authorization_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointAuthorizationOutput,
    crate::error::DescribeEndpointAuthorizationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEndpointAuthorizationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEndpointAuthorizationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeEndpointAuthorizationError {
            meta: generic,
            kind: crate::error::DescribeEndpointAuthorizationErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEndpointAuthorizationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::DescribeEndpointAuthorizationError {
            meta: generic,
            kind: crate::error::DescribeEndpointAuthorizationErrorKind::UnsupportedOperationFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::unsupported_operation_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEndpointAuthorizationError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeEndpointAuthorizationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_endpoint_authorization_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEndpointAuthorizationOutput,
    crate::error::DescribeEndpointAuthorizationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_endpoint_authorization_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_endpoint_authorization(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEndpointAuthorizationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
    Err(crate::error::DescribeEventCategoriesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_categories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventCategoriesOutput,
    crate::error::DescribeEventCategoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_categories_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_categories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventCategoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventsError::unhandled)?;
    Err(crate::error::DescribeEventsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_events_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeEventSubscriptionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidTagFault" => {
            crate::error::DescribeEventSubscriptionsError {
                meta: generic,
                kind: crate::error::DescribeEventSubscriptionsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "SubscriptionNotFound" => crate::error::DescribeEventSubscriptionsError {
            meta: generic,
            kind: crate::error::DescribeEventSubscriptionsErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeEventSubscriptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_event_subscriptions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeEventSubscriptionsOutput,
    crate::error::DescribeEventSubscriptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_event_subscriptions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_event_subscriptions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeEventSubscriptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hsm_client_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHsmClientCertificatesOutput,
    crate::error::DescribeHsmClientCertificatesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeHsmClientCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeHsmClientCertificatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmClientCertificateNotFoundFault" => crate::error::DescribeHsmClientCertificatesError { meta: generic, kind: crate::error::DescribeHsmClientCertificatesErrorKind::HsmClientCertificateNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_client_certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeHsmClientCertificatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::DescribeHsmClientCertificatesError { meta: generic, kind: crate::error::DescribeHsmClientCertificatesErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeHsmClientCertificatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeHsmClientCertificatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hsm_client_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHsmClientCertificatesOutput,
    crate::error::DescribeHsmClientCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hsm_client_certificates_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_hsm_client_certificates(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeHsmClientCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hsm_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHsmConfigurationsOutput,
    crate::error::DescribeHsmConfigurationsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeHsmConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeHsmConfigurationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "HsmConfigurationNotFoundFault" => crate::error::DescribeHsmConfigurationsError {
            meta: generic,
            kind: crate::error::DescribeHsmConfigurationsErrorKind::HsmConfigurationNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::hsm_configuration_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeHsmConfigurationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidTagFault" => {
            crate::error::DescribeHsmConfigurationsError {
                meta: generic,
                kind: crate::error::DescribeHsmConfigurationsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeHsmConfigurationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeHsmConfigurationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hsm_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHsmConfigurationsOutput,
    crate::error::DescribeHsmConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hsm_configurations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_hsm_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHsmConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_logging_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLoggingStatusOutput,
    crate::error::DescribeLoggingStatusError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeLoggingStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLoggingStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeLoggingStatusError {
            meta: generic,
            kind: crate::error::DescribeLoggingStatusErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoggingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeLoggingStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_logging_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeLoggingStatusOutput,
    crate::error::DescribeLoggingStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_logging_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_logging_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLoggingStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_node_configuration_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNodeConfigurationOptionsOutput,
    crate::error::DescribeNodeConfigurationOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeNodeConfigurationOptionsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessToSnapshotDenied" => crate::error::DescribeNodeConfigurationOptionsError { meta: generic, kind: crate::error::DescribeNodeConfigurationOptionsErrorKind::AccessToSnapshotDeniedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::access_to_snapshot_denied_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_to_snapshot_denied_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterNotFound" => crate::error::DescribeNodeConfigurationOptionsError { meta: generic, kind: crate::error::DescribeNodeConfigurationOptionsErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSnapshotNotFound" => crate::error::DescribeNodeConfigurationOptionsError { meta: generic, kind: crate::error::DescribeNodeConfigurationOptionsErrorKind::ClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSnapshotState" => crate::error::DescribeNodeConfigurationOptionsError { meta: generic, kind: crate::error::DescribeNodeConfigurationOptionsErrorKind::InvalidClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeNodeConfigurationOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_node_configuration_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNodeConfigurationOptionsOutput,
    crate::error::DescribeNodeConfigurationOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_node_configuration_options_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_node_configuration_options(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeNodeConfigurationOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_cluster_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableClusterOptionsOutput,
    crate::error::DescribeOrderableClusterOptionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeOrderableClusterOptionsError::unhandled)?;
    Err(crate::error::DescribeOrderableClusterOptionsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_orderable_cluster_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeOrderableClusterOptionsOutput,
    crate::error::DescribeOrderableClusterOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_orderable_cluster_options_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_orderable_cluster_options(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeOrderableClusterOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_partners_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePartnersOutput, crate::error::DescribePartnersError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePartnersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribePartnersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribePartnersError {
            meta: generic,
            kind: crate::error::DescribePartnersErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribePartnersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedPartnerIntegration" => crate::error::DescribePartnersError {
            meta: generic,
            kind: crate::error::DescribePartnersErrorKind::UnauthorizedPartnerIntegrationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unauthorized_partner_integration_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_partner_integration_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribePartnersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribePartnersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_partners_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePartnersOutput, crate::error::DescribePartnersError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_partners_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_partners(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePartnersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_node_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedNodeOfferingsOutput,
    crate::error::DescribeReservedNodeOfferingsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReservedNodeOfferingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeReservedNodeOfferingsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DependentServiceUnavailableFault" => crate::error::DescribeReservedNodeOfferingsError { meta: generic, kind: crate::error::DescribeReservedNodeOfferingsErrorKind::DependentServiceUnavailableFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_unavailable_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_unavailable_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedNodeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeOfferingNotFound" => crate::error::DescribeReservedNodeOfferingsError { meta: generic, kind: crate::error::DescribeReservedNodeOfferingsErrorKind::ReservedNodeOfferingNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_offering_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedNodeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::DescribeReservedNodeOfferingsError { meta: generic, kind: crate::error::DescribeReservedNodeOfferingsErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedNodeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeReservedNodeOfferingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_node_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedNodeOfferingsOutput,
    crate::error::DescribeReservedNodeOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_node_offerings_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_describe_reserved_node_offerings(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeReservedNodeOfferingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_nodes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedNodesOutput,
    crate::error::DescribeReservedNodesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeReservedNodesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeReservedNodesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DependentServiceUnavailableFault" => crate::error::DescribeReservedNodesError {
            meta: generic,
            kind: crate::error::DescribeReservedNodesErrorKind::DependentServiceUnavailableFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::dependent_service_unavailable_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_unavailable_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedNodesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReservedNodeNotFound" => crate::error::DescribeReservedNodesError {
            meta: generic,
            kind: crate::error::DescribeReservedNodesErrorKind::ReservedNodeNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reserved_node_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeReservedNodesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeReservedNodesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_reserved_nodes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeReservedNodesOutput,
    crate::error::DescribeReservedNodesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_reserved_nodes_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_reserved_nodes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeReservedNodesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_resize_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeResizeOutput, crate::error::DescribeResizeError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeResizeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeResizeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeResizeError {
            meta: generic,
            kind: crate::error::DescribeResizeErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResizeNotFound" => crate::error::DescribeResizeError {
            meta: generic,
            kind: crate::error::DescribeResizeErrorKind::ResizeNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resize_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resize_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeResizeError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeResizeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_resize_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeResizeOutput, crate::error::DescribeResizeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_resize_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_resize(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeResizeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledActionsOutput,
    crate::error::DescribeScheduledActionsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeScheduledActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeScheduledActionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ScheduledActionNotFound" => crate::error::DescribeScheduledActionsError {
            meta: generic,
            kind: crate::error::DescribeScheduledActionsErrorKind::ScheduledActionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::scheduled_action_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_scheduled_action_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeScheduledActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::DescribeScheduledActionsError {
            meta: generic,
            kind: crate::error::DescribeScheduledActionsErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeScheduledActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeScheduledActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_scheduled_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeScheduledActionsOutput,
    crate::error::DescribeScheduledActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_scheduled_actions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_scheduled_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeScheduledActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_copy_grants_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotCopyGrantsOutput,
    crate::error::DescribeSnapshotCopyGrantsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeSnapshotCopyGrantsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeSnapshotCopyGrantsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidTagFault" => {
            crate::error::DescribeSnapshotCopyGrantsError {
                meta: generic,
                kind: crate::error::DescribeSnapshotCopyGrantsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeSnapshotCopyGrantsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "SnapshotCopyGrantNotFoundFault" => crate::error::DescribeSnapshotCopyGrantsError {
            meta: generic,
            kind: crate::error::DescribeSnapshotCopyGrantsErrorKind::SnapshotCopyGrantNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::snapshot_copy_grant_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_grant_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeSnapshotCopyGrantsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DescribeSnapshotCopyGrantsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_copy_grants_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotCopyGrantsOutput,
    crate::error::DescribeSnapshotCopyGrantsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_copy_grants_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_copy_grants(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSnapshotCopyGrantsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_schedules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotSchedulesOutput,
    crate::error::DescribeSnapshotSchedulesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeSnapshotSchedulesError::unhandled)?;
    Err(crate::error::DescribeSnapshotSchedulesError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_snapshot_schedules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSnapshotSchedulesOutput,
    crate::error::DescribeSnapshotSchedulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_snapshot_schedules_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_snapshot_schedules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSnapshotSchedulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_storage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStorageOutput, crate::error::DescribeStorageError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeStorageError::unhandled)?;
    Err(crate::error::DescribeStorageError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_storage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStorageOutput, crate::error::DescribeStorageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_storage_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_storage(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStorageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_table_restore_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTableRestoreStatusOutput,
    crate::error::DescribeTableRestoreStatusError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeTableRestoreStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeTableRestoreStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeTableRestoreStatusError {
            meta: generic,
            kind: crate::error::DescribeTableRestoreStatusErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTableRestoreStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TableRestoreNotFoundFault" => crate::error::DescribeTableRestoreStatusError {
            meta: generic,
            kind: crate::error::DescribeTableRestoreStatusErrorKind::TableRestoreNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::table_restore_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_table_restore_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTableRestoreStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeTableRestoreStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_table_restore_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTableRestoreStatusOutput,
    crate::error::DescribeTableRestoreStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_table_restore_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_table_restore_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTableRestoreStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidTagFault" => {
            crate::error::DescribeTagsError {
                meta: generic,
                kind: crate::error::DescribeTagsErrorKind::InvalidTagFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_tag_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ResourceNotFoundFault" => crate::error::DescribeTagsError {
            meta: generic,
            kind: crate::error::DescribeTagsErrorKind::ResourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_resource_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_tags_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_usage_limits_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeUsageLimitsOutput,
    crate::error::DescribeUsageLimitsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeUsageLimitsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeUsageLimitsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DescribeUsageLimitsError {
            meta: generic,
            kind: crate::error::DescribeUsageLimitsErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsageLimitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::DescribeUsageLimitsError {
            meta: generic,
            kind: crate::error::DescribeUsageLimitsErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeUsageLimitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeUsageLimitsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_usage_limits_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeUsageLimitsOutput,
    crate::error::DescribeUsageLimitsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_usage_limits_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_usage_limits(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeUsageLimitsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_logging_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DisableLoggingOutput, crate::error::DisableLoggingError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisableLoggingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisableLoggingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DisableLoggingError {
            meta: generic,
            kind: crate::error::DisableLoggingErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::DisableLoggingError {
            meta: generic,
            kind: crate::error::DisableLoggingErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DisableLoggingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_logging_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DisableLoggingOutput, crate::error::DisableLoggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_logging_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_logging(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableLoggingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_snapshot_copy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSnapshotCopyOutput,
    crate::error::DisableSnapshotCopyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisableSnapshotCopyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::DisableSnapshotCopyError {
            meta: generic,
            kind: crate::error::DisableSnapshotCopyErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::DisableSnapshotCopyError {
            meta: generic,
            kind: crate::error::DisableSnapshotCopyErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotCopyAlreadyDisabledFault" => crate::error::DisableSnapshotCopyError {
            meta: generic,
            kind: crate::error::DisableSnapshotCopyErrorKind::SnapshotCopyAlreadyDisabledFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_copy_already_disabled_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_already_disabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::DisableSnapshotCopyError {
            meta: generic,
            kind: crate::error::DisableSnapshotCopyErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DisableSnapshotCopyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disable_snapshot_copy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisableSnapshotCopyOutput,
    crate::error::DisableSnapshotCopyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disable_snapshot_copy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_disable_snapshot_copy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisableSnapshotCopyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_data_share_consumer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateDataShareConsumerOutput,
    crate::error::DisassociateDataShareConsumerError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisassociateDataShareConsumerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateDataShareConsumerError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::DisassociateDataShareConsumerError {
            meta: generic,
            kind: crate::error::DisassociateDataShareConsumerErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisassociateDataShareConsumerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidNamespaceFault" => crate::error::DisassociateDataShareConsumerError {
            meta: generic,
            kind: crate::error::DisassociateDataShareConsumerErrorKind::InvalidNamespaceFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_namespace_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_namespace_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::DisassociateDataShareConsumerError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DisassociateDataShareConsumerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_data_share_consumer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateDataShareConsumerOutput,
    crate::error::DisassociateDataShareConsumerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_data_share_consumer_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_disassociate_data_share_consumer(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisassociateDataShareConsumerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_logging_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableLoggingOutput, crate::error::EnableLoggingError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::EnableLoggingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::EnableLoggingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BucketNotFoundFault" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::BucketNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::bucket_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_bucket_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterNotFound" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientS3BucketPolicyFault" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::InsufficientS3BucketPolicyFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_s3_bucket_policy_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_s3_bucket_policy_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidS3BucketNameFault" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::InvalidS3BucketNameFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_s3_bucket_name_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_bucket_name_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidS3KeyPrefixFault" => crate::error::EnableLoggingError {
            meta: generic,
            kind: crate::error::EnableLoggingErrorKind::InvalidS3KeyPrefixFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_s3_key_prefix_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_s3_key_prefix_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableLoggingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::EnableLoggingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_logging_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::EnableLoggingOutput, crate::error::EnableLoggingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_logging_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_logging(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableLoggingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_snapshot_copy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSnapshotCopyOutput,
    crate::error::EnableSnapshotCopyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::EnableSnapshotCopyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CopyToRegionDisabledFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::CopyToRegionDisabledFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::copy_to_region_disabled_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_copy_to_region_disabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DependentServiceRequestThrottlingFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::DependentServiceRequestThrottlingFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "IncompatibleOrderableOptions" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::IncompatibleOrderableOptions({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::incompatible_orderable_options::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_incompatible_orderable_options_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededFault" => {
            crate::error::EnableSnapshotCopyError {
                meta: generic,
                kind: crate::error::EnableSnapshotCopyErrorKind::LimitExceededFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "SnapshotCopyAlreadyEnabledFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::SnapshotCopyAlreadyEnabledFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_copy_already_enabled_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_already_enabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotCopyGrantNotFoundFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::SnapshotCopyGrantNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_copy_grant_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_grant_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnknownSnapshotCopyRegionFault" => crate::error::EnableSnapshotCopyError {
            meta: generic,
            kind: crate::error::EnableSnapshotCopyErrorKind::UnknownSnapshotCopyRegionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::unknown_snapshot_copy_region_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unknown_snapshot_copy_region_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::EnableSnapshotCopyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_enable_snapshot_copy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EnableSnapshotCopyOutput,
    crate::error::EnableSnapshotCopyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::enable_snapshot_copy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_enable_snapshot_copy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EnableSnapshotCopyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cluster_credentials_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClusterCredentialsOutput,
    crate::error::GetClusterCredentialsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetClusterCredentialsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetClusterCredentialsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::GetClusterCredentialsError {
            meta: generic,
            kind: crate::error::GetClusterCredentialsErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetClusterCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::GetClusterCredentialsError {
            meta: generic,
            kind: crate::error::GetClusterCredentialsErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetClusterCredentialsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetClusterCredentialsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cluster_credentials_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClusterCredentialsOutput,
    crate::error::GetClusterCredentialsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_cluster_credentials_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_cluster_credentials(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetClusterCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_node_exchange_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReservedNodeExchangeOfferingsOutput,
    crate::error::GetReservedNodeExchangeOfferingsError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DependentServiceUnavailableFault" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::DependentServiceUnavailableFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_unavailable_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_unavailable_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReservedNodeState" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::InvalidReservedNodeStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_reserved_node_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_reserved_node_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeAlreadyMigrated" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::ReservedNodeAlreadyMigratedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_already_migrated_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_already_migrated_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeNotFound" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::ReservedNodeNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeOfferingNotFound" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::ReservedNodeOfferingNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_offering_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::GetReservedNodeExchangeOfferingsError { meta: generic, kind: crate::error::GetReservedNodeExchangeOfferingsErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetReservedNodeExchangeOfferingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_reserved_node_exchange_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetReservedNodeExchangeOfferingsOutput,
    crate::error::GetReservedNodeExchangeOfferingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_reserved_node_exchange_offerings_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_get_reserved_node_exchange_offerings(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetReservedNodeExchangeOfferingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_aqua_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAquaConfigurationOutput,
    crate::error::ModifyAquaConfigurationError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyAquaConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyAquaConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyAquaConfigurationError {
            meta: generic,
            kind: crate::error::ModifyAquaConfigurationErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAquaConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ModifyAquaConfigurationError {
            meta: generic,
            kind: crate::error::ModifyAquaConfigurationErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAquaConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::ModifyAquaConfigurationError {
            meta: generic,
            kind: crate::error::ModifyAquaConfigurationErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAquaConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyAquaConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_aqua_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAquaConfigurationOutput,
    crate::error::ModifyAquaConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_aqua_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_aqua_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyAquaConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_authentication_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAuthenticationProfileOutput,
    crate::error::ModifyAuthenticationProfileError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyAuthenticationProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyAuthenticationProfileError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthenticationProfileNotFoundFault" => crate::error::ModifyAuthenticationProfileError { meta: generic, kind: crate::error::ModifyAuthenticationProfileErrorKind::AuthenticationProfileNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "AuthenticationProfileQuotaExceededFault" => crate::error::ModifyAuthenticationProfileError { meta: generic, kind: crate::error::ModifyAuthenticationProfileErrorKind::AuthenticationProfileQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authentication_profile_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authentication_profile_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthenticationProfileRequestFault" => crate::error::ModifyAuthenticationProfileError { meta: generic, kind: crate::error::ModifyAuthenticationProfileErrorKind::InvalidAuthenticationProfileRequestFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_authentication_profile_request_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authentication_profile_request_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyAuthenticationProfileError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyAuthenticationProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_authentication_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyAuthenticationProfileOutput,
    crate::error::ModifyAuthenticationProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_authentication_profile_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_authentication_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyAuthenticationProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterAlreadyExists" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::ClusterAlreadyExistsFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterNotFound" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterParameterGroupNotFound" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::ClusterParameterGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSecurityGroupNotFound" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::ClusterSecurityGroupNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DependentServiceRequestThrottlingFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::DependentServiceRequestThrottlingFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::dependent_service_request_throttling_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "HsmClientCertificateNotFoundFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::HsmClientCertificateNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hsm_client_certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "HsmConfigurationNotFoundFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::HsmConfigurationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::hsm_configuration_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientClusterCapacity" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InsufficientClusterCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSecurityGroupState" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidClusterSecurityGroupStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_cluster_security_group_state_fault::Builder::default(
                        );
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterTrack" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidClusterTrackFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_track_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_track_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidElasticIpFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidElasticIpFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_elastic_ip_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_elastic_ip_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededFault" => {
            crate::error::ModifyClusterError {
                meta: generic,
                kind: crate::error::ModifyClusterErrorKind::LimitExceededFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "NumberOfNodesPerClusterLimitExceeded" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::NumberOfNodesPerClusterLimitExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NumberOfNodesQuotaExceeded" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::NumberOfNodesQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::number_of_nodes_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TableLimitExceeded" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::TableLimitExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::table_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_table_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOptionFault" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::UnsupportedOptionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_option_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_option_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_db_revision_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterDbRevisionOutput,
    crate::error::ModifyClusterDbRevisionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterDbRevisionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyClusterDbRevisionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyClusterDbRevisionError {
            meta: generic,
            kind: crate::error::ModifyClusterDbRevisionErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterDbRevisionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterOnLatestRevision" => crate::error::ModifyClusterDbRevisionError {
            meta: generic,
            kind: crate::error::ModifyClusterDbRevisionErrorKind::ClusterOnLatestRevisionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_on_latest_revision_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_on_latest_revision_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterDbRevisionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ModifyClusterDbRevisionError {
            meta: generic,
            kind: crate::error::ModifyClusterDbRevisionErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterDbRevisionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterDbRevisionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_db_revision_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterDbRevisionOutput,
    crate::error::ModifyClusterDbRevisionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_db_revision_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_db_revision(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterDbRevisionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_iam_roles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterIamRolesOutput,
    crate::error::ModifyClusterIamRolesError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterIamRolesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyClusterIamRolesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyClusterIamRolesError {
            meta: generic,
            kind: crate::error::ModifyClusterIamRolesErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterIamRolesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ModifyClusterIamRolesError {
            meta: generic,
            kind: crate::error::ModifyClusterIamRolesErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterIamRolesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterIamRolesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_iam_roles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterIamRolesOutput,
    crate::error::ModifyClusterIamRolesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_iam_roles_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_iam_roles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterIamRolesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_maintenance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterMaintenanceOutput,
    crate::error::ModifyClusterMaintenanceError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterMaintenanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyClusterMaintenanceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyClusterMaintenanceError {
            meta: generic,
            kind: crate::error::ModifyClusterMaintenanceErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterMaintenanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ModifyClusterMaintenanceError {
            meta: generic,
            kind: crate::error::ModifyClusterMaintenanceErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterMaintenanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterMaintenanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_maintenance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterMaintenanceOutput,
    crate::error::ModifyClusterMaintenanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_maintenance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_maintenance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterMaintenanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterParameterGroupOutput,
    crate::error::ModifyClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupNotFound" => crate::error::ModifyClusterParameterGroupError { meta: generic, kind: crate::error::ModifyClusterParameterGroupErrorKind::ClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterParameterGroupState" => crate::error::ModifyClusterParameterGroupError { meta: generic, kind: crate::error::ModifyClusterParameterGroupErrorKind::InvalidClusterParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterParameterGroupOutput,
    crate::error::ModifyClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSnapshotOutput,
    crate::error::ModifyClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSnapshotNotFound" => crate::error::ModifyClusterSnapshotError {
            meta: generic,
            kind: crate::error::ModifyClusterSnapshotErrorKind::ClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSnapshotState" => crate::error::ModifyClusterSnapshotError {
            meta: generic,
            kind: crate::error::ModifyClusterSnapshotErrorKind::InvalidClusterSnapshotStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRetentionPeriodFault" => crate::error::ModifyClusterSnapshotError {
            meta: generic,
            kind: crate::error::ModifyClusterSnapshotErrorKind::InvalidRetentionPeriodFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterSnapshotError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSnapshotOutput,
    crate::error::ModifyClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_snapshot_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSnapshotScheduleOutput,
    crate::error::ModifyClusterSnapshotScheduleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterSnapshotScheduleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyClusterSnapshotScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyClusterSnapshotScheduleError { meta: generic, kind: crate::error::ModifyClusterSnapshotScheduleErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSnapshotScheduleState" => crate::error::ModifyClusterSnapshotScheduleError { meta: generic, kind: crate::error::ModifyClusterSnapshotScheduleErrorKind::InvalidClusterSnapshotScheduleStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_schedule_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_schedule_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotScheduleNotFound" => crate::error::ModifyClusterSnapshotScheduleError { meta: generic, kind: crate::error::ModifyClusterSnapshotScheduleErrorKind::SnapshotScheduleNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSnapshotScheduleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyClusterSnapshotScheduleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_snapshot_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSnapshotScheduleOutput,
    crate::error::ModifyClusterSnapshotScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_snapshot_schedule_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_subnet_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSubnetGroupOutput,
    crate::error::ModifyClusterSubnetGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyClusterSubnetGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterSubnetGroupNotFoundFault" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::ClusterSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSubnetQuotaExceededFault" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::ClusterSubnetQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DependentServiceRequestThrottlingFault" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::DependentServiceRequestThrottlingFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SubnetAlreadyInUse" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::SubnetAlreadyInUse({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::subnet_already_in_use::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subnet_already_in_use_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperation" => crate::error::ModifyClusterSubnetGroupError { meta: generic, kind: crate::error::ModifyClusterSubnetGroupErrorKind::UnauthorizedOperation({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyClusterSubnetGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_subnet_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyClusterSubnetGroupOutput,
    crate::error::ModifyClusterSubnetGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_subnet_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_cluster_subnet_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyClusterSubnetGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEndpointAccessOutput,
    crate::error::ModifyEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyEndpointAccessError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind: crate::error::ModifyEndpointAccessErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EndpointNotFound" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind: crate::error::ModifyEndpointAccessErrorKind::EndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSecurityGroupState" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind:
                crate::error::ModifyEndpointAccessErrorKind::InvalidClusterSecurityGroupStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidClusterState" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind: crate::error::ModifyEndpointAccessErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidEndpointState" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind: crate::error::ModifyEndpointAccessErrorKind::InvalidEndpointStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_endpoint_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::ModifyEndpointAccessError {
            meta: generic,
            kind: crate::error::ModifyEndpointAccessErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyEndpointAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEndpointAccessOutput,
    crate::error::ModifyEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifyEventSubscriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidSubscriptionStateFault" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::InvalidSubscriptionStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_subscription_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subscription_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSInvalidTopic" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsInvalidTopicFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_invalid_topic_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_invalid_topic_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSNoAuthorization" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsNoAuthorizationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::sns_no_authorization_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_no_authorization_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SNSTopicArnNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SnsTopicArnNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::sns_topic_arn_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_sns_topic_arn_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SourceNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_source_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionCategoryNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionCategoryNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_category_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_category_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionEventIdNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionEventIdNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_event_id_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_event_id_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "SubscriptionNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::subscription_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_subscription_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SubscriptionSeverityNotFound" => crate::error::ModifyEventSubscriptionError {
            meta: generic,
            kind: crate::error::ModifyEventSubscriptionErrorKind::SubscriptionSeverityNotFoundFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::subscription_severity_not_found_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_subscription_severity_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::ModifyEventSubscriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_event_subscription_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyEventSubscriptionOutput,
    crate::error::ModifyEventSubscriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_event_subscription_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_event_subscription(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyEventSubscriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_scheduled_action_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyScheduledActionOutput,
    crate::error::ModifyScheduledActionError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyScheduledActionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyScheduledActionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidScheduledAction" => crate::error::ModifyScheduledActionError {
            meta: generic,
            kind: crate::error::ModifyScheduledActionErrorKind::InvalidScheduledActionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_scheduled_action_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_scheduled_action_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSchedule" => crate::error::ModifyScheduledActionError {
            meta: generic,
            kind: crate::error::ModifyScheduledActionErrorKind::InvalidScheduleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_schedule_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ScheduledActionNotFound" => crate::error::ModifyScheduledActionError {
            meta: generic,
            kind: crate::error::ModifyScheduledActionErrorKind::ScheduledActionNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::scheduled_action_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_scheduled_action_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ScheduledActionTypeUnsupported" => crate::error::ModifyScheduledActionError {
            meta: generic,
            kind: crate::error::ModifyScheduledActionErrorKind::ScheduledActionTypeUnsupportedFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::scheduled_action_type_unsupported_fault::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_scheduled_action_type_unsupported_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyScheduledActionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "UnauthorizedOperation" => crate::error::ModifyScheduledActionError {
            meta: generic,
            kind: crate::error::ModifyScheduledActionErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyScheduledActionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyScheduledActionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_scheduled_action_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyScheduledActionOutput,
    crate::error::ModifyScheduledActionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_scheduled_action_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_scheduled_action(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyScheduledActionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_copy_retention_period_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotCopyRetentionPeriodOutput,
    crate::error::ModifySnapshotCopyRetentionPeriodError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ModifySnapshotCopyRetentionPeriodError { meta: generic, kind: crate::error::ModifySnapshotCopyRetentionPeriodErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterState" => crate::error::ModifySnapshotCopyRetentionPeriodError { meta: generic, kind: crate::error::ModifySnapshotCopyRetentionPeriodErrorKind::InvalidClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRetentionPeriodFault" => crate::error::ModifySnapshotCopyRetentionPeriodError { meta: generic, kind: crate::error::ModifySnapshotCopyRetentionPeriodErrorKind::InvalidRetentionPeriodFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_retention_period_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_retention_period_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotCopyDisabledFault" => crate::error::ModifySnapshotCopyRetentionPeriodError { meta: generic, kind: crate::error::ModifySnapshotCopyRetentionPeriodErrorKind::SnapshotCopyDisabledFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_copy_disabled_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_copy_disabled_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperation" => crate::error::ModifySnapshotCopyRetentionPeriodError { meta: generic, kind: crate::error::ModifySnapshotCopyRetentionPeriodErrorKind::UnauthorizedOperation({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifySnapshotCopyRetentionPeriodError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_copy_retention_period_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotCopyRetentionPeriodOutput,
    crate::error::ModifySnapshotCopyRetentionPeriodError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::modify_snapshot_copy_retention_period_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_snapshot_copy_retention_period(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotCopyRetentionPeriodError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_schedule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotScheduleOutput,
    crate::error::ModifySnapshotScheduleError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifySnapshotScheduleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ModifySnapshotScheduleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidSchedule" => crate::error::ModifySnapshotScheduleError {
            meta: generic,
            kind: crate::error::ModifySnapshotScheduleErrorKind::InvalidScheduleFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_schedule_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_schedule_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotScheduleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotScheduleNotFound" => crate::error::ModifySnapshotScheduleError {
            meta: generic,
            kind: crate::error::ModifySnapshotScheduleErrorKind::SnapshotScheduleNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::snapshot_schedule_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotScheduleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SnapshotScheduleUpdateInProgress" => crate::error::ModifySnapshotScheduleError {
            meta: generic,
            kind:
                crate::error::ModifySnapshotScheduleErrorKind::SnapshotScheduleUpdateInProgressFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_update_in_progress_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_update_in_progress_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifySnapshotScheduleError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ModifySnapshotScheduleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_snapshot_schedule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifySnapshotScheduleOutput,
    crate::error::ModifySnapshotScheduleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_snapshot_schedule_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_snapshot_schedule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifySnapshotScheduleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_usage_limit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyUsageLimitOutput, crate::error::ModifyUsageLimitError>
{
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ModifyUsageLimitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyUsageLimitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidUsageLimit" => crate::error::ModifyUsageLimitError {
            meta: generic,
            kind: crate::error::ModifyUsageLimitErrorKind::InvalidUsageLimitFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_usage_limit_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_usage_limit_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::ModifyUsageLimitError {
            meta: generic,
            kind: crate::error::ModifyUsageLimitErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UsageLimitNotFound" => crate::error::ModifyUsageLimitError {
            meta: generic,
            kind: crate::error::ModifyUsageLimitErrorKind::UsageLimitNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::usage_limit_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_usage_limit_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ModifyUsageLimitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyUsageLimitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_usage_limit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyUsageLimitOutput, crate::error::ModifyUsageLimitError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_usage_limit_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_modify_usage_limit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ModifyUsageLimitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_pause_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PauseClusterOutput, crate::error::PauseClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PauseClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PauseClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::PauseClusterError {
            meta: generic,
            kind: crate::error::PauseClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PauseClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::PauseClusterError {
            meta: generic,
            kind: crate::error::PauseClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PauseClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PauseClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_pause_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PauseClusterOutput, crate::error::PauseClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::pause_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_pause_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PauseClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_node_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedNodeOfferingOutput,
    crate::error::PurchaseReservedNodeOfferingError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PurchaseReservedNodeOfferingError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ReservedNodeAlreadyExists" => crate::error::PurchaseReservedNodeOfferingError { meta: generic, kind: crate::error::PurchaseReservedNodeOfferingErrorKind::ReservedNodeAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeOfferingNotFound" => crate::error::PurchaseReservedNodeOfferingError { meta: generic, kind: crate::error::PurchaseReservedNodeOfferingErrorKind::ReservedNodeOfferingNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_offering_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_offering_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReservedNodeQuotaExceeded" => crate::error::PurchaseReservedNodeOfferingError { meta: generic, kind: crate::error::PurchaseReservedNodeOfferingErrorKind::ReservedNodeQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reserved_node_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_reserved_node_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::PurchaseReservedNodeOfferingError { meta: generic, kind: crate::error::PurchaseReservedNodeOfferingErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PurchaseReservedNodeOfferingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_reserved_node_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PurchaseReservedNodeOfferingOutput,
    crate::error::PurchaseReservedNodeOfferingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_reserved_node_offering_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_purchase_reserved_node_offering(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PurchaseReservedNodeOfferingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootClusterOutput, crate::error::RebootClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RebootClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RebootClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::RebootClusterError {
            meta: generic,
            kind: crate::error::RebootClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::RebootClusterError {
            meta: generic,
            kind: crate::error::RebootClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RebootClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RebootClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RebootClusterOutput, crate::error::RebootClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reboot_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RebootClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_data_share_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RejectDataShareOutput, crate::error::RejectDataShareError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RejectDataShareError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RejectDataShareError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDataShareFault" => crate::error::RejectDataShareError {
            meta: generic,
            kind: crate::error::RejectDataShareErrorKind::InvalidDataShareFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_data_share_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_data_share_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RejectDataShareError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RejectDataShareError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reject_data_share_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RejectDataShareOutput, crate::error::RejectDataShareError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reject_data_share_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reject_data_share(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RejectDataShareError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_cluster_parameter_group_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetClusterParameterGroupOutput,
    crate::error::ResetClusterParameterGroupError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResetClusterParameterGroupError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ResetClusterParameterGroupError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterParameterGroupNotFound" => crate::error::ResetClusterParameterGroupError { meta: generic, kind: crate::error::ResetClusterParameterGroupErrorKind::ClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterParameterGroupState" => crate::error::ResetClusterParameterGroupError { meta: generic, kind: crate::error::ResetClusterParameterGroupErrorKind::InvalidClusterParameterGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_parameter_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_parameter_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResetClusterParameterGroupError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ResetClusterParameterGroupError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reset_cluster_parameter_group_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ResetClusterParameterGroupOutput,
    crate::error::ResetClusterParameterGroupError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reset_cluster_parameter_group_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_reset_cluster_parameter_group(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResetClusterParameterGroupError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resize_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResizeClusterOutput, crate::error::ResizeClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResizeClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResizeClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientClusterCapacity" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::InsufficientClusterCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededFault" => {
            crate::error::ResizeClusterError {
                meta: generic,
                kind: crate::error::ResizeClusterErrorKind::LimitExceededFault({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "NumberOfNodesPerClusterLimitExceeded" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::NumberOfNodesPerClusterLimitExceededFault(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder::default();
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "NumberOfNodesQuotaExceeded" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::NumberOfNodesQuotaExceededFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::number_of_nodes_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedOperation" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::UnauthorizedOperation({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOperation" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::UnsupportedOperationFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnsupportedOptionFault" => crate::error::ResizeClusterError {
            meta: generic,
            kind: crate::error::ResizeClusterErrorKind::UnsupportedOptionFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::unsupported_option_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_option_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResizeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResizeClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resize_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResizeClusterOutput, crate::error::ResizeClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resize_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_resize_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResizeClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_from_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreFromClusterSnapshotOutput,
    crate::error::RestoreFromClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RestoreFromClusterSnapshotError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessToSnapshotDenied" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::AccessToSnapshotDeniedFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::access_to_snapshot_denied_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_to_snapshot_denied_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterAlreadyExists" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterAlreadyExistsFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_already_exists_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_already_exists_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterParameterGroupNotFound" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterParameterGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_parameter_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_parameter_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterQuotaExceeded" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSecurityGroupNotFound" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSnapshotNotFound" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSubnetGroupNotFoundFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::ClusterSubnetGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_subnet_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_subnet_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DependentServiceRequestThrottlingFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::DependentServiceRequestThrottlingFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "HsmClientCertificateNotFoundFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::HsmClientCertificateNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_client_certificate_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_client_certificate_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "HsmConfigurationNotFoundFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::HsmConfigurationNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::hsm_configuration_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_hsm_configuration_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InsufficientClusterCapacity" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InsufficientClusterCapacityFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::insufficient_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSnapshotState" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSubnetGroupStateFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidClusterSubnetGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_subnet_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_subnet_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterTrack" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidClusterTrackFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_track_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_track_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidElasticIpFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidElasticIpFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_elastic_ip_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_elastic_ip_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRestore" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidRestoreFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_restore_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_restore_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSubnet" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidSubnet({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_subnet::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_subnet_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidTagFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_tag_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_tag_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidVPCNetworkStateFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::InvalidVpcNetworkStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_vpc_network_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_vpc_network_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "LimitExceededFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::LimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfNodesPerClusterLimitExceeded" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::NumberOfNodesPerClusterLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_per_cluster_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfNodesQuotaExceeded" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::NumberOfNodesQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::number_of_nodes_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_number_of_nodes_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SnapshotScheduleNotFound" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::SnapshotScheduleNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::snapshot_schedule_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_snapshot_schedule_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagLimitExceededFault" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::TagLimitExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tag_limit_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_tag_limit_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnauthorizedOperation" => crate::error::RestoreFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreFromClusterSnapshotErrorKind::UnauthorizedOperation({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unauthorized_operation::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unauthorized_operation_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreFromClusterSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_from_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreFromClusterSnapshotOutput,
    crate::error::RestoreFromClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::restore_from_cluster_snapshot_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_restore_from_cluster_snapshot(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RestoreFromClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_table_from_cluster_snapshot_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreTableFromClusterSnapshotOutput,
    crate::error::RestoreTableFromClusterSnapshotError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RestoreTableFromClusterSnapshotError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::ClusterNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSnapshotNotFound" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::ClusterSnapshotNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InProgressTableRestoreQuotaExceededFault" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::InProgressTableRestoreQuotaExceededFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::in_progress_table_restore_quota_exceeded_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_in_progress_table_restore_quota_exceeded_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSnapshotState" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::InvalidClusterSnapshotStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_snapshot_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_snapshot_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterState" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::InvalidClusterStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTableRestoreArgument" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::InvalidTableRestoreArgumentFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_table_restore_argument_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_table_restore_argument_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "UnsupportedOperation" => crate::error::RestoreTableFromClusterSnapshotError { meta: generic, kind: crate::error::RestoreTableFromClusterSnapshotErrorKind::UnsupportedOperationFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::unsupported_operation_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_unsupported_operation_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RestoreTableFromClusterSnapshotError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_restore_table_from_cluster_snapshot_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RestoreTableFromClusterSnapshotOutput,
    crate::error::RestoreTableFromClusterSnapshotError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::restore_table_from_cluster_snapshot_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_restore_table_from_cluster_snapshot(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::RestoreTableFromClusterSnapshotError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeClusterOutput, crate::error::ResumeClusterError> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::ResumeClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ResumeClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::ResumeClusterError {
            meta: generic,
            kind: crate::error::ResumeClusterErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResumeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InsufficientClusterCapacity" => crate::error::ResumeClusterError {
            meta: generic,
            kind: crate::error::ResumeClusterErrorKind::InsufficientClusterCapacityFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_cluster_capacity_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_cluster_capacity_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResumeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterState" => crate::error::ResumeClusterError {
            meta: generic,
            kind: crate::error::ResumeClusterErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::ResumeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ResumeClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_resume_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ResumeClusterOutput, crate::error::ResumeClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::resume_cluster_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_resume_cluster(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ResumeClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_cluster_security_group_ingress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeClusterSecurityGroupIngressOutput,
    crate::error::RevokeClusterSecurityGroupIngressError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorizationNotFound" => crate::error::RevokeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeClusterSecurityGroupIngressErrorKind::AuthorizationNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClusterSecurityGroupNotFound" => crate::error::RevokeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeClusterSecurityGroupIngressErrorKind::ClusterSecurityGroupNotFoundFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cluster_security_group_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_security_group_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClusterSecurityGroupState" => crate::error::RevokeClusterSecurityGroupIngressError { meta: generic, kind: crate::error::RevokeClusterSecurityGroupIngressErrorKind::InvalidClusterSecurityGroupStateFault({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RevokeClusterSecurityGroupIngressError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_cluster_security_group_ingress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeClusterSecurityGroupIngressOutput,
    crate::error::RevokeClusterSecurityGroupIngressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::revoke_cluster_security_group_ingress_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_cluster_security_group_ingress(response.body().as_ref(), output).map_err(crate::error::RevokeClusterSecurityGroupIngressError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_endpoint_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeEndpointAccessOutput,
    crate::error::RevokeEndpointAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RevokeEndpointAccessError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind: crate::error::RevokeEndpointAccessErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EndpointAuthorizationNotFound" => {
            crate::error::RevokeEndpointAccessError {
                meta: generic,
                kind:
                    crate::error::RevokeEndpointAccessErrorKind::EndpointAuthorizationNotFoundFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::endpoint_authorization_not_found_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_endpoint_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        "EndpointNotFound" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind: crate::error::RevokeEndpointAccessErrorKind::EndpointNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::endpoint_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_endpoint_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAuthorizationState" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind: crate::error::RevokeEndpointAccessErrorKind::InvalidAuthorizationStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_authorization_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_authorization_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClusterSecurityGroupState" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind:
                crate::error::RevokeEndpointAccessErrorKind::InvalidClusterSecurityGroupStateFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_cluster_security_group_state_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_security_group_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidClusterState" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind: crate::error::RevokeEndpointAccessErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidEndpointState" => crate::error::RevokeEndpointAccessError {
            meta: generic,
            kind: crate::error::RevokeEndpointAccessErrorKind::InvalidEndpointStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_endpoint_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_endpoint_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RevokeEndpointAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_endpoint_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeEndpointAccessOutput,
    crate::error::RevokeEndpointAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_endpoint_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_endpoint_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeEndpointAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_snapshot_access_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSnapshotAccessOutput,
    crate::error::RevokeSnapshotAccessError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RevokeSnapshotAccessError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RevokeSnapshotAccessError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AccessToSnapshotDenied" => crate::error::RevokeSnapshotAccessError {
            meta: generic,
            kind: crate::error::RevokeSnapshotAccessErrorKind::AccessToSnapshotDeniedFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::access_to_snapshot_denied_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_access_to_snapshot_denied_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeSnapshotAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "AuthorizationNotFound" => crate::error::RevokeSnapshotAccessError {
            meta: generic,
            kind: crate::error::RevokeSnapshotAccessErrorKind::AuthorizationNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::authorization_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_authorization_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeSnapshotAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ClusterSnapshotNotFound" => crate::error::RevokeSnapshotAccessError {
            meta: generic,
            kind: crate::error::RevokeSnapshotAccessErrorKind::ClusterSnapshotNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::cluster_snapshot_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_snapshot_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RevokeSnapshotAccessError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RevokeSnapshotAccessError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_revoke_snapshot_access_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RevokeSnapshotAccessOutput,
    crate::error::RevokeSnapshotAccessError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::revoke_snapshot_access_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_revoke_snapshot_access(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RevokeSnapshotAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_rotate_encryption_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RotateEncryptionKeyOutput,
    crate::error::RotateEncryptionKeyError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::RotateEncryptionKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RotateEncryptionKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::RotateEncryptionKeyError {
            meta: generic,
            kind: crate::error::RotateEncryptionKeyErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RotateEncryptionKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DependentServiceRequestThrottlingFault" => crate::error::RotateEncryptionKeyError {
            meta: generic,
            kind:
                crate::error::RotateEncryptionKeyErrorKind::DependentServiceRequestThrottlingFault(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::dependent_service_request_throttling_fault::Builder::default();
                            let _ = response;
                            output = crate::xml_deser::deser_structure_crate_error_dependent_service_request_throttling_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RotateEncryptionKeyError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidClusterState" => crate::error::RotateEncryptionKeyError {
            meta: generic,
            kind: crate::error::RotateEncryptionKeyErrorKind::InvalidClusterStateFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_cluster_state_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_cluster_state_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::RotateEncryptionKeyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RotateEncryptionKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_rotate_encryption_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RotateEncryptionKeyOutput,
    crate::error::RotateEncryptionKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::rotate_encryption_key_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_rotate_encryption_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RotateEncryptionKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_partner_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePartnerStatusOutput,
    crate::error::UpdatePartnerStatusError,
> {
    let generic = crate::xml_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePartnerStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePartnerStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClusterNotFound" => crate::error::UpdatePartnerStatusError {
            meta: generic,
            kind: crate::error::UpdatePartnerStatusErrorKind::ClusterNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cluster_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cluster_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdatePartnerStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PartnerNotFound" => crate::error::UpdatePartnerStatusError {
            meta: generic,
            kind: crate::error::UpdatePartnerStatusErrorKind::PartnerNotFoundFault({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::partner_not_found_fault::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_partner_not_found_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdatePartnerStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "UnauthorizedPartnerIntegration" => {
            crate::error::UpdatePartnerStatusError {
                meta: generic,
                kind:
                    crate::error::UpdatePartnerStatusErrorKind::UnauthorizedPartnerIntegrationFault(
                        {
                            #[allow(unused_mut)]
                            let mut tmp = {
                                #[allow(unused_mut)]let mut output = crate::error::unauthorized_partner_integration_fault::Builder::default();
                                let _ = response;
                                output = crate::xml_deser::deser_structure_crate_error_unauthorized_partner_integration_fault_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdatePartnerStatusError::unhandled)?;
                                output.build()
                            };
                            if (&tmp.message).is_none() {
                                tmp.message = _error_message;
                            }
                            tmp
                        },
                    ),
            }
        }
        _ => crate::error::UpdatePartnerStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_partner_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePartnerStatusOutput,
    crate::error::UpdatePartnerStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_partner_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_partner_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePartnerStatusError::unhandled)?;
        output.build()
    })
}
