// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a cluster.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Cluster {
    /// <p>The unique identifier of the cluster.</p>
    pub cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The node type for the nodes in the cluster.</p>
    pub node_type: ::std::option::Option<::std::string::String>,
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>available</code> </p> </li>
    /// <li> <p> <code>available, prep-for-resize</code> </p> </li>
    /// <li> <p> <code>available, resize-cleanup</code> </p> </li>
    /// <li> <p> <code>cancelling-resize</code> </p> </li>
    /// <li> <p> <code>creating</code> </p> </li>
    /// <li> <p> <code>deleting</code> </p> </li>
    /// <li> <p> <code>final-snapshot</code> </p> </li>
    /// <li> <p> <code>hardware-failure</code> </p> </li>
    /// <li> <p> <code>incompatible-hsm</code> </p> </li>
    /// <li> <p> <code>incompatible-network</code> </p> </li>
    /// <li> <p> <code>incompatible-parameters</code> </p> </li>
    /// <li> <p> <code>incompatible-restore</code> </p> </li>
    /// <li> <p> <code>modifying</code> </p> </li>
    /// <li> <p> <code>paused</code> </p> </li>
    /// <li> <p> <code>rebooting</code> </p> </li>
    /// <li> <p> <code>renaming</code> </p> </li>
    /// <li> <p> <code>resizing</code> </p> </li>
    /// <li> <p> <code>rotating-keys</code> </p> </li>
    /// <li> <p> <code>storage-full</code> </p> </li>
    /// <li> <p> <code>updating-hsm</code> </p> </li>
    /// </ul>
    pub cluster_status: ::std::option::Option<::std::string::String>,
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>Available - The cluster is available for queries. </p> </li>
    /// <li> <p>Unavailable - The cluster is not available for queries.</p> </li>
    /// <li> <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p>Failed - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub cluster_availability_status: ::std::option::Option<::std::string::String>,
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub modify_status: ::std::option::Option<::std::string::String>,
    /// <p>The admin user name for the cluster. This name is used to connect to the database that is specified in the <b>DBName</b> parameter. </p>
    pub master_username: ::std::option::Option<::std::string::String>,
    /// <p>The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named <code>dev</code>dev was created by default. </p>
    pub db_name: ::std::option::Option<::std::string::String>,
    /// <p>The connection endpoint.</p>
    pub endpoint: ::std::option::Option<crate::types::Endpoint>,
    /// <p>The date and time that the cluster was created.</p>
    pub cluster_create_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub automated_snapshot_retention_period: ::std::option::Option<i32>,
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub manual_snapshot_retention_period: ::std::option::Option<i32>,
    /// <p>A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code> subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the <b>VpcSecurityGroups</b> parameter. </p>
    pub cluster_security_groups: ::std::option::Option<::std::vec::Vec<crate::types::ClusterSecurityGroupMembership>>,
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.</p>
    pub vpc_security_groups: ::std::option::Option<::std::vec::Vec<crate::types::VpcSecurityGroupMembership>>,
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.</p>
    pub cluster_parameter_groups: ::std::option::Option<::std::vec::Vec<crate::types::ClusterParameterGroupStatus>>,
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub cluster_subnet_group_name: ::std::option::Option<::std::string::String>,
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub vpc_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub availability_zone: ::std::option::Option<::std::string::String>,
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    pub preferred_maintenance_window: ::std::option::Option<::std::string::String>,
    /// <p>A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.</p>
    pub pending_modified_values: ::std::option::Option<crate::types::PendingModifiedValues>,
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub cluster_version: ::std::option::Option<::std::string::String>,
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window. </p>
    pub allow_version_upgrade: ::std::option::Option<bool>,
    /// <p>The number of compute nodes in the cluster.</p>
    pub number_of_nodes: ::std::option::Option<i32>,
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be accessed from a public network.</p>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is encrypted at rest.</p>
    pub encrypted: ::std::option::Option<bool>,
    /// <p>A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.</p>
    pub restore_status: ::std::option::Option<crate::types::RestoreStatus>,
    /// <p></p>
    pub data_transfer_progress: ::std::option::Option<crate::types::DataTransferProgress>,
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub hsm_status: ::std::option::Option<crate::types::HsmStatus>,
    /// <p>A value that returns the destination region and retention period that are configured for cross-region snapshot copy.</p>
    pub cluster_snapshot_copy_status: ::std::option::Option<crate::types::ClusterSnapshotCopyStatus>,
    /// <p>The public key for the cluster.</p>
    pub cluster_public_key: ::std::option::Option<::std::string::String>,
    /// <p>The nodes in the cluster.</p>
    pub cluster_nodes: ::std::option::Option<::std::vec::Vec<crate::types::ClusterNode>>,
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub elastic_ip_status: ::std::option::Option<crate::types::ElasticIpStatus>,
    /// <p>The specific revision number of the database in the cluster.</p>
    pub cluster_revision_number: ::std::option::Option<::std::string::String>,
    /// <p>The list of tags for the cluster.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to encrypt data in the cluster.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub enhanced_vpc_routing: ::std::option::Option<bool>,
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.</p>
    pub iam_roles: ::std::option::Option<::std::vec::Vec<crate::types::ClusterIamRole>>,
    /// <p>Cluster operations that are waiting to be started.</p>
    pub pending_actions: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The name of the maintenance track for the cluster.</p>
    pub maintenance_track_name: ::std::option::Option<::std::string::String>,
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method. </p>
    pub elastic_resize_number_of_node_options: ::std::option::Option<::std::string::String>,
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    pub deferred_maintenance_windows: ::std::option::Option<::std::vec::Vec<crate::types::DeferredMaintenanceWindow>>,
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub snapshot_schedule_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub snapshot_schedule_state: ::std::option::Option<crate::types::ScheduleState>,
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub expected_next_snapshot_schedule_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>OnTrack - The next snapshot is expected to be taken on time. </p> </li>
    /// <li> <p>Pending - The next snapshot is pending to be taken. </p> </li>
    /// </ul>
    pub expected_next_snapshot_schedule_time_status: ::std::option::Option<::std::string::String>,
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub next_maintenance_window_start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li> <p>AllowCancelResize: a boolean value indicating if the resize operation can be cancelled.</p> </li>
    /// <li> <p>ResizeType: Returns ClassicResize</p> </li>
    /// </ul>
    pub resize_info: ::std::option::Option<crate::types::ResizeInfo>,
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub availability_zone_relocation_status: ::std::option::Option<::std::string::String>,
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub cluster_namespace_arn: ::std::option::Option<::std::string::String>,
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub total_storage_capacity_in_mega_bytes: ::std::option::Option<i64>,
    /// <p>This field is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator).</p>
    pub aqua_configuration: ::std::option::Option<crate::types::AquaConfiguration>,
    /// <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
    pub default_iam_role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
    pub reserved_node_exchange_status: ::std::option::Option<crate::types::ReservedNodeExchangeStatus>,
    /// <p>The custom domain name associated with the cluster.</p>
    pub custom_domain_name: ::std::option::Option<::std::string::String>,
    /// <p>The certificate Amazon Resource Name (ARN) for the custom domain name.</p>
    pub custom_domain_certificate_arn: ::std::option::Option<::std::string::String>,
    /// <p>The expiration date for the certificate associated with the custom domain name.</p>
    pub custom_domain_certificate_expiry_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.</p>
    pub master_password_secret_arn: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin credentials secret.</p>
    pub master_password_secret_kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>The IP address type for the cluster. Possible values are <code>ipv4</code> and <code>dualstack</code>.</p>
    pub ip_address_type: ::std::option::Option<::std::string::String>,
}
impl Cluster {
    /// <p>The unique identifier of the cluster.</p>
    pub fn cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.cluster_identifier.as_deref()
    }
    /// <p>The node type for the nodes in the cluster.</p>
    pub fn node_type(&self) -> ::std::option::Option<&str> {
        self.node_type.as_deref()
    }
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>available</code> </p> </li>
    /// <li> <p> <code>available, prep-for-resize</code> </p> </li>
    /// <li> <p> <code>available, resize-cleanup</code> </p> </li>
    /// <li> <p> <code>cancelling-resize</code> </p> </li>
    /// <li> <p> <code>creating</code> </p> </li>
    /// <li> <p> <code>deleting</code> </p> </li>
    /// <li> <p> <code>final-snapshot</code> </p> </li>
    /// <li> <p> <code>hardware-failure</code> </p> </li>
    /// <li> <p> <code>incompatible-hsm</code> </p> </li>
    /// <li> <p> <code>incompatible-network</code> </p> </li>
    /// <li> <p> <code>incompatible-parameters</code> </p> </li>
    /// <li> <p> <code>incompatible-restore</code> </p> </li>
    /// <li> <p> <code>modifying</code> </p> </li>
    /// <li> <p> <code>paused</code> </p> </li>
    /// <li> <p> <code>rebooting</code> </p> </li>
    /// <li> <p> <code>renaming</code> </p> </li>
    /// <li> <p> <code>resizing</code> </p> </li>
    /// <li> <p> <code>rotating-keys</code> </p> </li>
    /// <li> <p> <code>storage-full</code> </p> </li>
    /// <li> <p> <code>updating-hsm</code> </p> </li>
    /// </ul>
    pub fn cluster_status(&self) -> ::std::option::Option<&str> {
        self.cluster_status.as_deref()
    }
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>Available - The cluster is available for queries. </p> </li>
    /// <li> <p>Unavailable - The cluster is not available for queries.</p> </li>
    /// <li> <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p>Failed - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub fn cluster_availability_status(&self) -> ::std::option::Option<&str> {
        self.cluster_availability_status.as_deref()
    }
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub fn modify_status(&self) -> ::std::option::Option<&str> {
        self.modify_status.as_deref()
    }
    /// <p>The admin user name for the cluster. This name is used to connect to the database that is specified in the <b>DBName</b> parameter. </p>
    pub fn master_username(&self) -> ::std::option::Option<&str> {
        self.master_username.as_deref()
    }
    /// <p>The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named <code>dev</code>dev was created by default. </p>
    pub fn db_name(&self) -> ::std::option::Option<&str> {
        self.db_name.as_deref()
    }
    /// <p>The connection endpoint.</p>
    pub fn endpoint(&self) -> ::std::option::Option<&crate::types::Endpoint> {
        self.endpoint.as_ref()
    }
    /// <p>The date and time that the cluster was created.</p>
    pub fn cluster_create_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.cluster_create_time.as_ref()
    }
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub fn automated_snapshot_retention_period(&self) -> ::std::option::Option<i32> {
        self.automated_snapshot_retention_period
    }
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub fn manual_snapshot_retention_period(&self) -> ::std::option::Option<i32> {
        self.manual_snapshot_retention_period
    }
    /// <p>A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code> subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the <b>VpcSecurityGroups</b> parameter. </p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cluster_security_groups.is_none()`.
    pub fn cluster_security_groups(&self) -> &[crate::types::ClusterSecurityGroupMembership] {
        self.cluster_security_groups.as_deref().unwrap_or_default()
    }
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.vpc_security_groups.is_none()`.
    pub fn vpc_security_groups(&self) -> &[crate::types::VpcSecurityGroupMembership] {
        self.vpc_security_groups.as_deref().unwrap_or_default()
    }
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cluster_parameter_groups.is_none()`.
    pub fn cluster_parameter_groups(&self) -> &[crate::types::ClusterParameterGroupStatus] {
        self.cluster_parameter_groups.as_deref().unwrap_or_default()
    }
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub fn cluster_subnet_group_name(&self) -> ::std::option::Option<&str> {
        self.cluster_subnet_group_name.as_deref()
    }
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub fn vpc_id(&self) -> ::std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub fn availability_zone(&self) -> ::std::option::Option<&str> {
        self.availability_zone.as_deref()
    }
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    pub fn preferred_maintenance_window(&self) -> ::std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.</p>
    pub fn pending_modified_values(&self) -> ::std::option::Option<&crate::types::PendingModifiedValues> {
        self.pending_modified_values.as_ref()
    }
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub fn cluster_version(&self) -> ::std::option::Option<&str> {
        self.cluster_version.as_deref()
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window. </p>
    pub fn allow_version_upgrade(&self) -> ::std::option::Option<bool> {
        self.allow_version_upgrade
    }
    /// <p>The number of compute nodes in the cluster.</p>
    pub fn number_of_nodes(&self) -> ::std::option::Option<i32> {
        self.number_of_nodes
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be accessed from a public network.</p>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is encrypted at rest.</p>
    pub fn encrypted(&self) -> ::std::option::Option<bool> {
        self.encrypted
    }
    /// <p>A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.</p>
    pub fn restore_status(&self) -> ::std::option::Option<&crate::types::RestoreStatus> {
        self.restore_status.as_ref()
    }
    /// <p></p>
    pub fn data_transfer_progress(&self) -> ::std::option::Option<&crate::types::DataTransferProgress> {
        self.data_transfer_progress.as_ref()
    }
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub fn hsm_status(&self) -> ::std::option::Option<&crate::types::HsmStatus> {
        self.hsm_status.as_ref()
    }
    /// <p>A value that returns the destination region and retention period that are configured for cross-region snapshot copy.</p>
    pub fn cluster_snapshot_copy_status(&self) -> ::std::option::Option<&crate::types::ClusterSnapshotCopyStatus> {
        self.cluster_snapshot_copy_status.as_ref()
    }
    /// <p>The public key for the cluster.</p>
    pub fn cluster_public_key(&self) -> ::std::option::Option<&str> {
        self.cluster_public_key.as_deref()
    }
    /// <p>The nodes in the cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cluster_nodes.is_none()`.
    pub fn cluster_nodes(&self) -> &[crate::types::ClusterNode] {
        self.cluster_nodes.as_deref().unwrap_or_default()
    }
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub fn elastic_ip_status(&self) -> ::std::option::Option<&crate::types::ElasticIpStatus> {
        self.elastic_ip_status.as_ref()
    }
    /// <p>The specific revision number of the database in the cluster.</p>
    pub fn cluster_revision_number(&self) -> ::std::option::Option<&str> {
        self.cluster_revision_number.as_deref()
    }
    /// <p>The list of tags for the cluster.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to encrypt data in the cluster.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub fn enhanced_vpc_routing(&self) -> ::std::option::Option<bool> {
        self.enhanced_vpc_routing
    }
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.iam_roles.is_none()`.
    pub fn iam_roles(&self) -> &[crate::types::ClusterIamRole] {
        self.iam_roles.as_deref().unwrap_or_default()
    }
    /// <p>Cluster operations that are waiting to be started.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.pending_actions.is_none()`.
    pub fn pending_actions(&self) -> &[::std::string::String] {
        self.pending_actions.as_deref().unwrap_or_default()
    }
    /// <p>The name of the maintenance track for the cluster.</p>
    pub fn maintenance_track_name(&self) -> ::std::option::Option<&str> {
        self.maintenance_track_name.as_deref()
    }
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method. </p>
    pub fn elastic_resize_number_of_node_options(&self) -> ::std::option::Option<&str> {
        self.elastic_resize_number_of_node_options.as_deref()
    }
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.deferred_maintenance_windows.is_none()`.
    pub fn deferred_maintenance_windows(&self) -> &[crate::types::DeferredMaintenanceWindow] {
        self.deferred_maintenance_windows.as_deref().unwrap_or_default()
    }
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub fn snapshot_schedule_identifier(&self) -> ::std::option::Option<&str> {
        self.snapshot_schedule_identifier.as_deref()
    }
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub fn snapshot_schedule_state(&self) -> ::std::option::Option<&crate::types::ScheduleState> {
        self.snapshot_schedule_state.as_ref()
    }
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub fn expected_next_snapshot_schedule_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.expected_next_snapshot_schedule_time.as_ref()
    }
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>OnTrack - The next snapshot is expected to be taken on time. </p> </li>
    /// <li> <p>Pending - The next snapshot is pending to be taken. </p> </li>
    /// </ul>
    pub fn expected_next_snapshot_schedule_time_status(&self) -> ::std::option::Option<&str> {
        self.expected_next_snapshot_schedule_time_status.as_deref()
    }
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub fn next_maintenance_window_start_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.next_maintenance_window_start_time.as_ref()
    }
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li> <p>AllowCancelResize: a boolean value indicating if the resize operation can be cancelled.</p> </li>
    /// <li> <p>ResizeType: Returns ClassicResize</p> </li>
    /// </ul>
    pub fn resize_info(&self) -> ::std::option::Option<&crate::types::ResizeInfo> {
        self.resize_info.as_ref()
    }
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub fn availability_zone_relocation_status(&self) -> ::std::option::Option<&str> {
        self.availability_zone_relocation_status.as_deref()
    }
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub fn cluster_namespace_arn(&self) -> ::std::option::Option<&str> {
        self.cluster_namespace_arn.as_deref()
    }
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub fn total_storage_capacity_in_mega_bytes(&self) -> ::std::option::Option<i64> {
        self.total_storage_capacity_in_mega_bytes
    }
    /// <p>This field is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator).</p>
    pub fn aqua_configuration(&self) -> ::std::option::Option<&crate::types::AquaConfiguration> {
        self.aqua_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
    pub fn default_iam_role_arn(&self) -> ::std::option::Option<&str> {
        self.default_iam_role_arn.as_deref()
    }
    /// <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
    pub fn reserved_node_exchange_status(&self) -> ::std::option::Option<&crate::types::ReservedNodeExchangeStatus> {
        self.reserved_node_exchange_status.as_ref()
    }
    /// <p>The custom domain name associated with the cluster.</p>
    pub fn custom_domain_name(&self) -> ::std::option::Option<&str> {
        self.custom_domain_name.as_deref()
    }
    /// <p>The certificate Amazon Resource Name (ARN) for the custom domain name.</p>
    pub fn custom_domain_certificate_arn(&self) -> ::std::option::Option<&str> {
        self.custom_domain_certificate_arn.as_deref()
    }
    /// <p>The expiration date for the certificate associated with the custom domain name.</p>
    pub fn custom_domain_certificate_expiry_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.custom_domain_certificate_expiry_date.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.</p>
    pub fn master_password_secret_arn(&self) -> ::std::option::Option<&str> {
        self.master_password_secret_arn.as_deref()
    }
    /// <p>The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin credentials secret.</p>
    pub fn master_password_secret_kms_key_id(&self) -> ::std::option::Option<&str> {
        self.master_password_secret_kms_key_id.as_deref()
    }
    /// <p>The IP address type for the cluster. Possible values are <code>ipv4</code> and <code>dualstack</code>.</p>
    pub fn ip_address_type(&self) -> ::std::option::Option<&str> {
        self.ip_address_type.as_deref()
    }
}
impl Cluster {
    /// Creates a new builder-style object to manufacture [`Cluster`](crate::types::Cluster).
    pub fn builder() -> crate::types::builders::ClusterBuilder {
        crate::types::builders::ClusterBuilder::default()
    }
}

/// A builder for [`Cluster`](crate::types::Cluster).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ClusterBuilder {
    pub(crate) cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) node_type: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_status: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_availability_status: ::std::option::Option<::std::string::String>,
    pub(crate) modify_status: ::std::option::Option<::std::string::String>,
    pub(crate) master_username: ::std::option::Option<::std::string::String>,
    pub(crate) db_name: ::std::option::Option<::std::string::String>,
    pub(crate) endpoint: ::std::option::Option<crate::types::Endpoint>,
    pub(crate) cluster_create_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) automated_snapshot_retention_period: ::std::option::Option<i32>,
    pub(crate) manual_snapshot_retention_period: ::std::option::Option<i32>,
    pub(crate) cluster_security_groups: ::std::option::Option<::std::vec::Vec<crate::types::ClusterSecurityGroupMembership>>,
    pub(crate) vpc_security_groups: ::std::option::Option<::std::vec::Vec<crate::types::VpcSecurityGroupMembership>>,
    pub(crate) cluster_parameter_groups: ::std::option::Option<::std::vec::Vec<crate::types::ClusterParameterGroupStatus>>,
    pub(crate) cluster_subnet_group_name: ::std::option::Option<::std::string::String>,
    pub(crate) vpc_id: ::std::option::Option<::std::string::String>,
    pub(crate) availability_zone: ::std::option::Option<::std::string::String>,
    pub(crate) preferred_maintenance_window: ::std::option::Option<::std::string::String>,
    pub(crate) pending_modified_values: ::std::option::Option<crate::types::PendingModifiedValues>,
    pub(crate) cluster_version: ::std::option::Option<::std::string::String>,
    pub(crate) allow_version_upgrade: ::std::option::Option<bool>,
    pub(crate) number_of_nodes: ::std::option::Option<i32>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) encrypted: ::std::option::Option<bool>,
    pub(crate) restore_status: ::std::option::Option<crate::types::RestoreStatus>,
    pub(crate) data_transfer_progress: ::std::option::Option<crate::types::DataTransferProgress>,
    pub(crate) hsm_status: ::std::option::Option<crate::types::HsmStatus>,
    pub(crate) cluster_snapshot_copy_status: ::std::option::Option<crate::types::ClusterSnapshotCopyStatus>,
    pub(crate) cluster_public_key: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_nodes: ::std::option::Option<::std::vec::Vec<crate::types::ClusterNode>>,
    pub(crate) elastic_ip_status: ::std::option::Option<crate::types::ElasticIpStatus>,
    pub(crate) cluster_revision_number: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) enhanced_vpc_routing: ::std::option::Option<bool>,
    pub(crate) iam_roles: ::std::option::Option<::std::vec::Vec<crate::types::ClusterIamRole>>,
    pub(crate) pending_actions: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) maintenance_track_name: ::std::option::Option<::std::string::String>,
    pub(crate) elastic_resize_number_of_node_options: ::std::option::Option<::std::string::String>,
    pub(crate) deferred_maintenance_windows: ::std::option::Option<::std::vec::Vec<crate::types::DeferredMaintenanceWindow>>,
    pub(crate) snapshot_schedule_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) snapshot_schedule_state: ::std::option::Option<crate::types::ScheduleState>,
    pub(crate) expected_next_snapshot_schedule_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) expected_next_snapshot_schedule_time_status: ::std::option::Option<::std::string::String>,
    pub(crate) next_maintenance_window_start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) resize_info: ::std::option::Option<crate::types::ResizeInfo>,
    pub(crate) availability_zone_relocation_status: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_namespace_arn: ::std::option::Option<::std::string::String>,
    pub(crate) total_storage_capacity_in_mega_bytes: ::std::option::Option<i64>,
    pub(crate) aqua_configuration: ::std::option::Option<crate::types::AquaConfiguration>,
    pub(crate) default_iam_role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) reserved_node_exchange_status: ::std::option::Option<crate::types::ReservedNodeExchangeStatus>,
    pub(crate) custom_domain_name: ::std::option::Option<::std::string::String>,
    pub(crate) custom_domain_certificate_arn: ::std::option::Option<::std::string::String>,
    pub(crate) custom_domain_certificate_expiry_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) master_password_secret_arn: ::std::option::Option<::std::string::String>,
    pub(crate) master_password_secret_kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) ip_address_type: ::std::option::Option<::std::string::String>,
}
impl ClusterBuilder {
    /// <p>The unique identifier of the cluster.</p>
    pub fn cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the cluster.</p>
    pub fn set_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_identifier = input;
        self
    }
    /// <p>The unique identifier of the cluster.</p>
    pub fn get_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_identifier
    }
    /// <p>The node type for the nodes in the cluster.</p>
    pub fn node_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.node_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The node type for the nodes in the cluster.</p>
    pub fn set_node_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.node_type = input;
        self
    }
    /// <p>The node type for the nodes in the cluster.</p>
    pub fn get_node_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.node_type
    }
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>available</code> </p> </li>
    /// <li> <p> <code>available, prep-for-resize</code> </p> </li>
    /// <li> <p> <code>available, resize-cleanup</code> </p> </li>
    /// <li> <p> <code>cancelling-resize</code> </p> </li>
    /// <li> <p> <code>creating</code> </p> </li>
    /// <li> <p> <code>deleting</code> </p> </li>
    /// <li> <p> <code>final-snapshot</code> </p> </li>
    /// <li> <p> <code>hardware-failure</code> </p> </li>
    /// <li> <p> <code>incompatible-hsm</code> </p> </li>
    /// <li> <p> <code>incompatible-network</code> </p> </li>
    /// <li> <p> <code>incompatible-parameters</code> </p> </li>
    /// <li> <p> <code>incompatible-restore</code> </p> </li>
    /// <li> <p> <code>modifying</code> </p> </li>
    /// <li> <p> <code>paused</code> </p> </li>
    /// <li> <p> <code>rebooting</code> </p> </li>
    /// <li> <p> <code>renaming</code> </p> </li>
    /// <li> <p> <code>resizing</code> </p> </li>
    /// <li> <p> <code>rotating-keys</code> </p> </li>
    /// <li> <p> <code>storage-full</code> </p> </li>
    /// <li> <p> <code>updating-hsm</code> </p> </li>
    /// </ul>
    pub fn cluster_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>available</code> </p> </li>
    /// <li> <p> <code>available, prep-for-resize</code> </p> </li>
    /// <li> <p> <code>available, resize-cleanup</code> </p> </li>
    /// <li> <p> <code>cancelling-resize</code> </p> </li>
    /// <li> <p> <code>creating</code> </p> </li>
    /// <li> <p> <code>deleting</code> </p> </li>
    /// <li> <p> <code>final-snapshot</code> </p> </li>
    /// <li> <p> <code>hardware-failure</code> </p> </li>
    /// <li> <p> <code>incompatible-hsm</code> </p> </li>
    /// <li> <p> <code>incompatible-network</code> </p> </li>
    /// <li> <p> <code>incompatible-parameters</code> </p> </li>
    /// <li> <p> <code>incompatible-restore</code> </p> </li>
    /// <li> <p> <code>modifying</code> </p> </li>
    /// <li> <p> <code>paused</code> </p> </li>
    /// <li> <p> <code>rebooting</code> </p> </li>
    /// <li> <p> <code>renaming</code> </p> </li>
    /// <li> <p> <code>resizing</code> </p> </li>
    /// <li> <p> <code>rotating-keys</code> </p> </li>
    /// <li> <p> <code>storage-full</code> </p> </li>
    /// <li> <p> <code>updating-hsm</code> </p> </li>
    /// </ul>
    pub fn set_cluster_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_status = input;
        self
    }
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li> <p> <code>available</code> </p> </li>
    /// <li> <p> <code>available, prep-for-resize</code> </p> </li>
    /// <li> <p> <code>available, resize-cleanup</code> </p> </li>
    /// <li> <p> <code>cancelling-resize</code> </p> </li>
    /// <li> <p> <code>creating</code> </p> </li>
    /// <li> <p> <code>deleting</code> </p> </li>
    /// <li> <p> <code>final-snapshot</code> </p> </li>
    /// <li> <p> <code>hardware-failure</code> </p> </li>
    /// <li> <p> <code>incompatible-hsm</code> </p> </li>
    /// <li> <p> <code>incompatible-network</code> </p> </li>
    /// <li> <p> <code>incompatible-parameters</code> </p> </li>
    /// <li> <p> <code>incompatible-restore</code> </p> </li>
    /// <li> <p> <code>modifying</code> </p> </li>
    /// <li> <p> <code>paused</code> </p> </li>
    /// <li> <p> <code>rebooting</code> </p> </li>
    /// <li> <p> <code>renaming</code> </p> </li>
    /// <li> <p> <code>resizing</code> </p> </li>
    /// <li> <p> <code>rotating-keys</code> </p> </li>
    /// <li> <p> <code>storage-full</code> </p> </li>
    /// <li> <p> <code>updating-hsm</code> </p> </li>
    /// </ul>
    pub fn get_cluster_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_status
    }
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>Available - The cluster is available for queries. </p> </li>
    /// <li> <p>Unavailable - The cluster is not available for queries.</p> </li>
    /// <li> <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p>Failed - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub fn cluster_availability_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_availability_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>Available - The cluster is available for queries. </p> </li>
    /// <li> <p>Unavailable - The cluster is not available for queries.</p> </li>
    /// <li> <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p>Failed - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub fn set_cluster_availability_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_availability_status = input;
        self
    }
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>Available - The cluster is available for queries. </p> </li>
    /// <li> <p>Unavailable - The cluster is not available for queries.</p> </li>
    /// <li> <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p> </li>
    /// <li> <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p> </li>
    /// <li> <p>Failed - The cluster failed and is not available for queries.</p> </li>
    /// </ul>
    pub fn get_cluster_availability_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_availability_status
    }
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub fn modify_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.modify_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub fn set_modify_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.modify_status = input;
        self
    }
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub fn get_modify_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.modify_status
    }
    /// <p>The admin user name for the cluster. This name is used to connect to the database that is specified in the <b>DBName</b> parameter. </p>
    pub fn master_username(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.master_username = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The admin user name for the cluster. This name is used to connect to the database that is specified in the <b>DBName</b> parameter. </p>
    pub fn set_master_username(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.master_username = input;
        self
    }
    /// <p>The admin user name for the cluster. This name is used to connect to the database that is specified in the <b>DBName</b> parameter. </p>
    pub fn get_master_username(&self) -> &::std::option::Option<::std::string::String> {
        &self.master_username
    }
    /// <p>The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named <code>dev</code>dev was created by default. </p>
    pub fn db_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named <code>dev</code>dev was created by default. </p>
    pub fn set_db_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_name = input;
        self
    }
    /// <p>The name of the initial database that was created when the cluster was created. This same name is returned for the life of the cluster. If an initial database was not specified, a database named <code>dev</code>dev was created by default. </p>
    pub fn get_db_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_name
    }
    /// <p>The connection endpoint.</p>
    pub fn endpoint(mut self, input: crate::types::Endpoint) -> Self {
        self.endpoint = ::std::option::Option::Some(input);
        self
    }
    /// <p>The connection endpoint.</p>
    pub fn set_endpoint(mut self, input: ::std::option::Option<crate::types::Endpoint>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The connection endpoint.</p>
    pub fn get_endpoint(&self) -> &::std::option::Option<crate::types::Endpoint> {
        &self.endpoint
    }
    /// <p>The date and time that the cluster was created.</p>
    pub fn cluster_create_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.cluster_create_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time that the cluster was created.</p>
    pub fn set_cluster_create_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.cluster_create_time = input;
        self
    }
    /// <p>The date and time that the cluster was created.</p>
    pub fn get_cluster_create_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.cluster_create_time
    }
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub fn automated_snapshot_retention_period(mut self, input: i32) -> Self {
        self.automated_snapshot_retention_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub fn set_automated_snapshot_retention_period(mut self, input: ::std::option::Option<i32>) -> Self {
        self.automated_snapshot_retention_period = input;
        self
    }
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub fn get_automated_snapshot_retention_period(&self) -> &::std::option::Option<i32> {
        &self.automated_snapshot_retention_period
    }
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
        self.manual_snapshot_retention_period = ::std::option::Option::Some(input);
        self
    }
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub fn set_manual_snapshot_retention_period(mut self, input: ::std::option::Option<i32>) -> Self {
        self.manual_snapshot_retention_period = input;
        self
    }
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub fn get_manual_snapshot_retention_period(&self) -> &::std::option::Option<i32> {
        &self.manual_snapshot_retention_period
    }
    /// Appends an item to `cluster_security_groups`.
    ///
    /// To override the contents of this collection use [`set_cluster_security_groups`](Self::set_cluster_security_groups).
    ///
    /// <p>A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code> subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the <b>VpcSecurityGroups</b> parameter. </p>
    pub fn cluster_security_groups(mut self, input: crate::types::ClusterSecurityGroupMembership) -> Self {
        let mut v = self.cluster_security_groups.unwrap_or_default();
        v.push(input);
        self.cluster_security_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code> subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the <b>VpcSecurityGroups</b> parameter. </p>
    pub fn set_cluster_security_groups(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::ClusterSecurityGroupMembership>>,
    ) -> Self {
        self.cluster_security_groups = input;
        self
    }
    /// <p>A list of cluster security group that are associated with the cluster. Each security group is represented by an element that contains <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code> subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups, which are listed by the <b>VpcSecurityGroups</b> parameter. </p>
    pub fn get_cluster_security_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ClusterSecurityGroupMembership>> {
        &self.cluster_security_groups
    }
    /// Appends an item to `vpc_security_groups`.
    ///
    /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
    ///
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.</p>
    pub fn vpc_security_groups(mut self, input: crate::types::VpcSecurityGroupMembership) -> Self {
        let mut v = self.vpc_security_groups.unwrap_or_default();
        v.push(input);
        self.vpc_security_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.</p>
    pub fn set_vpc_security_groups(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::VpcSecurityGroupMembership>>) -> Self {
        self.vpc_security_groups = input;
        self
    }
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are associated with the cluster. This parameter is returned only if the cluster is in a VPC.</p>
    pub fn get_vpc_security_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::VpcSecurityGroupMembership>> {
        &self.vpc_security_groups
    }
    /// Appends an item to `cluster_parameter_groups`.
    ///
    /// To override the contents of this collection use [`set_cluster_parameter_groups`](Self::set_cluster_parameter_groups).
    ///
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.</p>
    pub fn cluster_parameter_groups(mut self, input: crate::types::ClusterParameterGroupStatus) -> Self {
        let mut v = self.cluster_parameter_groups.unwrap_or_default();
        v.push(input);
        self.cluster_parameter_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.</p>
    pub fn set_cluster_parameter_groups(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ClusterParameterGroupStatus>>) -> Self {
        self.cluster_parameter_groups = input;
        self
    }
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each parameter group in the list is returned with its status.</p>
    pub fn get_cluster_parameter_groups(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ClusterParameterGroupStatus>> {
        &self.cluster_parameter_groups
    }
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub fn cluster_subnet_group_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_subnet_group_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub fn set_cluster_subnet_group_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_subnet_group_name = input;
        self
    }
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.</p>
    pub fn get_cluster_subnet_group_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_subnet_group_name
    }
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub fn vpc_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vpc_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub fn set_vpc_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vpc_id = input;
        self
    }
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub fn get_vpc_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.vpc_id
    }
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub fn availability_zone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub fn set_availability_zone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone = input;
        self
    }
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub fn get_availability_zone(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone
    }
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    pub fn preferred_maintenance_window(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.preferred_maintenance_window = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    pub fn set_preferred_maintenance_window(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.preferred_maintenance_window = input;
        self
    }
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur.</p>
    pub fn get_preferred_maintenance_window(&self) -> &::std::option::Option<::std::string::String> {
        &self.preferred_maintenance_window
    }
    /// <p>A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.</p>
    pub fn pending_modified_values(mut self, input: crate::types::PendingModifiedValues) -> Self {
        self.pending_modified_values = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.</p>
    pub fn set_pending_modified_values(mut self, input: ::std::option::Option<crate::types::PendingModifiedValues>) -> Self {
        self.pending_modified_values = input;
        self
    }
    /// <p>A value that, if present, indicates that changes to the cluster are pending. Specific pending changes are identified by subelements.</p>
    pub fn get_pending_modified_values(&self) -> &::std::option::Option<crate::types::PendingModifiedValues> {
        &self.pending_modified_values
    }
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub fn cluster_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub fn set_cluster_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_version = input;
        self
    }
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub fn get_cluster_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_version
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window. </p>
    pub fn allow_version_upgrade(mut self, input: bool) -> Self {
        self.allow_version_upgrade = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window. </p>
    pub fn set_allow_version_upgrade(mut self, input: ::std::option::Option<bool>) -> Self {
        self.allow_version_upgrade = input;
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades will be applied automatically to the cluster during the maintenance window. </p>
    pub fn get_allow_version_upgrade(&self) -> &::std::option::Option<bool> {
        &self.allow_version_upgrade
    }
    /// <p>The number of compute nodes in the cluster.</p>
    pub fn number_of_nodes(mut self, input: i32) -> Self {
        self.number_of_nodes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of compute nodes in the cluster.</p>
    pub fn set_number_of_nodes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.number_of_nodes = input;
        self
    }
    /// <p>The number of compute nodes in the cluster.</p>
    pub fn get_number_of_nodes(&self) -> &::std::option::Option<i32> {
        &self.number_of_nodes
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be accessed from a public network.</p>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be accessed from a public network.</p>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be accessed from a public network.</p>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is encrypted at rest.</p>
    pub fn encrypted(mut self, input: bool) -> Self {
        self.encrypted = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is encrypted at rest.</p>
    pub fn set_encrypted(mut self, input: ::std::option::Option<bool>) -> Self {
        self.encrypted = input;
        self
    }
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is encrypted at rest.</p>
    pub fn get_encrypted(&self) -> &::std::option::Option<bool> {
        &self.encrypted
    }
    /// <p>A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.</p>
    pub fn restore_status(mut self, input: crate::types::RestoreStatus) -> Self {
        self.restore_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.</p>
    pub fn set_restore_status(mut self, input: ::std::option::Option<crate::types::RestoreStatus>) -> Self {
        self.restore_status = input;
        self
    }
    /// <p>A value that describes the status of a cluster restore action. This parameter returns null if the cluster was not created by restoring a snapshot.</p>
    pub fn get_restore_status(&self) -> &::std::option::Option<crate::types::RestoreStatus> {
        &self.restore_status
    }
    /// <p></p>
    pub fn data_transfer_progress(mut self, input: crate::types::DataTransferProgress) -> Self {
        self.data_transfer_progress = ::std::option::Option::Some(input);
        self
    }
    /// <p></p>
    pub fn set_data_transfer_progress(mut self, input: ::std::option::Option<crate::types::DataTransferProgress>) -> Self {
        self.data_transfer_progress = input;
        self
    }
    /// <p></p>
    pub fn get_data_transfer_progress(&self) -> &::std::option::Option<crate::types::DataTransferProgress> {
        &self.data_transfer_progress
    }
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub fn hsm_status(mut self, input: crate::types::HsmStatus) -> Self {
        self.hsm_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub fn set_hsm_status(mut self, input: ::std::option::Option<crate::types::HsmStatus>) -> Self {
        self.hsm_status = input;
        self
    }
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any hardware security module (HSM) settings changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub fn get_hsm_status(&self) -> &::std::option::Option<crate::types::HsmStatus> {
        &self.hsm_status
    }
    /// <p>A value that returns the destination region and retention period that are configured for cross-region snapshot copy.</p>
    pub fn cluster_snapshot_copy_status(mut self, input: crate::types::ClusterSnapshotCopyStatus) -> Self {
        self.cluster_snapshot_copy_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>A value that returns the destination region and retention period that are configured for cross-region snapshot copy.</p>
    pub fn set_cluster_snapshot_copy_status(mut self, input: ::std::option::Option<crate::types::ClusterSnapshotCopyStatus>) -> Self {
        self.cluster_snapshot_copy_status = input;
        self
    }
    /// <p>A value that returns the destination region and retention period that are configured for cross-region snapshot copy.</p>
    pub fn get_cluster_snapshot_copy_status(&self) -> &::std::option::Option<crate::types::ClusterSnapshotCopyStatus> {
        &self.cluster_snapshot_copy_status
    }
    /// <p>The public key for the cluster.</p>
    pub fn cluster_public_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_public_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The public key for the cluster.</p>
    pub fn set_cluster_public_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_public_key = input;
        self
    }
    /// <p>The public key for the cluster.</p>
    pub fn get_cluster_public_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_public_key
    }
    /// Appends an item to `cluster_nodes`.
    ///
    /// To override the contents of this collection use [`set_cluster_nodes`](Self::set_cluster_nodes).
    ///
    /// <p>The nodes in the cluster.</p>
    pub fn cluster_nodes(mut self, input: crate::types::ClusterNode) -> Self {
        let mut v = self.cluster_nodes.unwrap_or_default();
        v.push(input);
        self.cluster_nodes = ::std::option::Option::Some(v);
        self
    }
    /// <p>The nodes in the cluster.</p>
    pub fn set_cluster_nodes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ClusterNode>>) -> Self {
        self.cluster_nodes = input;
        self
    }
    /// <p>The nodes in the cluster.</p>
    pub fn get_cluster_nodes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ClusterNode>> {
        &self.cluster_nodes
    }
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub fn elastic_ip_status(mut self, input: crate::types::ElasticIpStatus) -> Self {
        self.elastic_ip_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub fn set_elastic_ip_status(mut self, input: ::std::option::Option<crate::types::ElasticIpStatus>) -> Self {
        self.elastic_ip_status = input;
        self
    }
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub fn get_elastic_ip_status(&self) -> &::std::option::Option<crate::types::ElasticIpStatus> {
        &self.elastic_ip_status
    }
    /// <p>The specific revision number of the database in the cluster.</p>
    pub fn cluster_revision_number(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_revision_number = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The specific revision number of the database in the cluster.</p>
    pub fn set_cluster_revision_number(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_revision_number = input;
        self
    }
    /// <p>The specific revision number of the database in the cluster.</p>
    pub fn get_cluster_revision_number(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_revision_number
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The list of tags for the cluster.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of tags for the cluster.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The list of tags for the cluster.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to encrypt data in the cluster.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to encrypt data in the cluster.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to encrypt data in the cluster.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
        self.enhanced_vpc_routing = ::std::option::Option::Some(input);
        self
    }
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub fn set_enhanced_vpc_routing(mut self, input: ::std::option::Option<bool>) -> Self {
        self.enhanced_vpc_routing = input;
        self
    }
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub fn get_enhanced_vpc_routing(&self) -> &::std::option::Option<bool> {
        &self.enhanced_vpc_routing
    }
    /// Appends an item to `iam_roles`.
    ///
    /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
    ///
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.</p>
    pub fn iam_roles(mut self, input: crate::types::ClusterIamRole) -> Self {
        let mut v = self.iam_roles.unwrap_or_default();
        v.push(input);
        self.iam_roles = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.</p>
    pub fn set_iam_roles(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ClusterIamRole>>) -> Self {
        self.iam_roles = input;
        self
    }
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the cluster to access other Amazon Web Services services.</p>
    pub fn get_iam_roles(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ClusterIamRole>> {
        &self.iam_roles
    }
    /// Appends an item to `pending_actions`.
    ///
    /// To override the contents of this collection use [`set_pending_actions`](Self::set_pending_actions).
    ///
    /// <p>Cluster operations that are waiting to be started.</p>
    pub fn pending_actions(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.pending_actions.unwrap_or_default();
        v.push(input.into());
        self.pending_actions = ::std::option::Option::Some(v);
        self
    }
    /// <p>Cluster operations that are waiting to be started.</p>
    pub fn set_pending_actions(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.pending_actions = input;
        self
    }
    /// <p>Cluster operations that are waiting to be started.</p>
    pub fn get_pending_actions(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.pending_actions
    }
    /// <p>The name of the maintenance track for the cluster.</p>
    pub fn maintenance_track_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.maintenance_track_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the maintenance track for the cluster.</p>
    pub fn set_maintenance_track_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.maintenance_track_name = input;
        self
    }
    /// <p>The name of the maintenance track for the cluster.</p>
    pub fn get_maintenance_track_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.maintenance_track_name
    }
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method. </p>
    pub fn elastic_resize_number_of_node_options(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.elastic_resize_number_of_node_options = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method. </p>
    pub fn set_elastic_resize_number_of_node_options(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.elastic_resize_number_of_node_options = input;
        self
    }
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method. </p>
    pub fn get_elastic_resize_number_of_node_options(&self) -> &::std::option::Option<::std::string::String> {
        &self.elastic_resize_number_of_node_options
    }
    /// Appends an item to `deferred_maintenance_windows`.
    ///
    /// To override the contents of this collection use [`set_deferred_maintenance_windows`](Self::set_deferred_maintenance_windows).
    ///
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    pub fn deferred_maintenance_windows(mut self, input: crate::types::DeferredMaintenanceWindow) -> Self {
        let mut v = self.deferred_maintenance_windows.unwrap_or_default();
        v.push(input);
        self.deferred_maintenance_windows = ::std::option::Option::Some(v);
        self
    }
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    pub fn set_deferred_maintenance_windows(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::DeferredMaintenanceWindow>>,
    ) -> Self {
        self.deferred_maintenance_windows = input;
        self
    }
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    pub fn get_deferred_maintenance_windows(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeferredMaintenanceWindow>> {
        &self.deferred_maintenance_windows
    }
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub fn snapshot_schedule_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.snapshot_schedule_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub fn set_snapshot_schedule_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.snapshot_schedule_identifier = input;
        self
    }
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub fn get_snapshot_schedule_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.snapshot_schedule_identifier
    }
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub fn snapshot_schedule_state(mut self, input: crate::types::ScheduleState) -> Self {
        self.snapshot_schedule_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub fn set_snapshot_schedule_state(mut self, input: ::std::option::Option<crate::types::ScheduleState>) -> Self {
        self.snapshot_schedule_state = input;
        self
    }
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub fn get_snapshot_schedule_state(&self) -> &::std::option::Option<crate::types::ScheduleState> {
        &self.snapshot_schedule_state
    }
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub fn expected_next_snapshot_schedule_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.expected_next_snapshot_schedule_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub fn set_expected_next_snapshot_schedule_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.expected_next_snapshot_schedule_time = input;
        self
    }
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub fn get_expected_next_snapshot_schedule_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.expected_next_snapshot_schedule_time
    }
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>OnTrack - The next snapshot is expected to be taken on time. </p> </li>
    /// <li> <p>Pending - The next snapshot is pending to be taken. </p> </li>
    /// </ul>
    pub fn expected_next_snapshot_schedule_time_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.expected_next_snapshot_schedule_time_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>OnTrack - The next snapshot is expected to be taken on time. </p> </li>
    /// <li> <p>Pending - The next snapshot is pending to be taken. </p> </li>
    /// </ul>
    pub fn set_expected_next_snapshot_schedule_time_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.expected_next_snapshot_schedule_time_status = input;
        self
    }
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled. Possible values are the following:</p>
    /// <ul>
    /// <li> <p>OnTrack - The next snapshot is expected to be taken on time. </p> </li>
    /// <li> <p>Pending - The next snapshot is pending to be taken. </p> </li>
    /// </ul>
    pub fn get_expected_next_snapshot_schedule_time_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.expected_next_snapshot_schedule_time_status
    }
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub fn next_maintenance_window_start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.next_maintenance_window_start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub fn set_next_maintenance_window_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.next_maintenance_window_start_time = input;
        self
    }
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub fn get_next_maintenance_window_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.next_maintenance_window_start_time
    }
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li> <p>AllowCancelResize: a boolean value indicating if the resize operation can be cancelled.</p> </li>
    /// <li> <p>ResizeType: Returns ClassicResize</p> </li>
    /// </ul>
    pub fn resize_info(mut self, input: crate::types::ResizeInfo) -> Self {
        self.resize_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li> <p>AllowCancelResize: a boolean value indicating if the resize operation can be cancelled.</p> </li>
    /// <li> <p>ResizeType: Returns ClassicResize</p> </li>
    /// </ul>
    pub fn set_resize_info(mut self, input: ::std::option::Option<crate::types::ResizeInfo>) -> Self {
        self.resize_info = input;
        self
    }
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li> <p>AllowCancelResize: a boolean value indicating if the resize operation can be cancelled.</p> </li>
    /// <li> <p>ResizeType: Returns ClassicResize</p> </li>
    /// </ul>
    pub fn get_resize_info(&self) -> &::std::option::Option<crate::types::ResizeInfo> {
        &self.resize_info
    }
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub fn availability_zone_relocation_status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone_relocation_status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub fn set_availability_zone_relocation_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone_relocation_status = input;
        self
    }
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub fn get_availability_zone_relocation_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone_relocation_status
    }
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub fn cluster_namespace_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_namespace_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub fn set_cluster_namespace_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_namespace_arn = input;
        self
    }
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub fn get_cluster_namespace_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_namespace_arn
    }
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub fn total_storage_capacity_in_mega_bytes(mut self, input: i64) -> Self {
        self.total_storage_capacity_in_mega_bytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub fn set_total_storage_capacity_in_mega_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
        self.total_storage_capacity_in_mega_bytes = input;
        self
    }
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub fn get_total_storage_capacity_in_mega_bytes(&self) -> &::std::option::Option<i64> {
        &self.total_storage_capacity_in_mega_bytes
    }
    /// <p>This field is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator).</p>
    pub fn aqua_configuration(mut self, input: crate::types::AquaConfiguration) -> Self {
        self.aqua_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>This field is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator).</p>
    pub fn set_aqua_configuration(mut self, input: ::std::option::Option<crate::types::AquaConfiguration>) -> Self {
        self.aqua_configuration = input;
        self
    }
    /// <p>This field is retired. Amazon Redshift automatically determines whether to use AQUA (Advanced Query Accelerator).</p>
    pub fn get_aqua_configuration(&self) -> &::std::option::Option<crate::types::AquaConfiguration> {
        &self.aqua_configuration
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
    pub fn default_iam_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.default_iam_role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
    pub fn set_default_iam_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.default_iam_role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the IAM role set as default for the cluster.</p>
    pub fn get_default_iam_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.default_iam_role_arn
    }
    /// <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
    pub fn reserved_node_exchange_status(mut self, input: crate::types::ReservedNodeExchangeStatus) -> Self {
        self.reserved_node_exchange_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
    pub fn set_reserved_node_exchange_status(mut self, input: ::std::option::Option<crate::types::ReservedNodeExchangeStatus>) -> Self {
        self.reserved_node_exchange_status = input;
        self
    }
    /// <p>The status of the reserved-node exchange request. Statuses include in-progress and requested.</p>
    pub fn get_reserved_node_exchange_status(&self) -> &::std::option::Option<crate::types::ReservedNodeExchangeStatus> {
        &self.reserved_node_exchange_status
    }
    /// <p>The custom domain name associated with the cluster.</p>
    pub fn custom_domain_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.custom_domain_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The custom domain name associated with the cluster.</p>
    pub fn set_custom_domain_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.custom_domain_name = input;
        self
    }
    /// <p>The custom domain name associated with the cluster.</p>
    pub fn get_custom_domain_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.custom_domain_name
    }
    /// <p>The certificate Amazon Resource Name (ARN) for the custom domain name.</p>
    pub fn custom_domain_certificate_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.custom_domain_certificate_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The certificate Amazon Resource Name (ARN) for the custom domain name.</p>
    pub fn set_custom_domain_certificate_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.custom_domain_certificate_arn = input;
        self
    }
    /// <p>The certificate Amazon Resource Name (ARN) for the custom domain name.</p>
    pub fn get_custom_domain_certificate_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.custom_domain_certificate_arn
    }
    /// <p>The expiration date for the certificate associated with the custom domain name.</p>
    pub fn custom_domain_certificate_expiry_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.custom_domain_certificate_expiry_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expiration date for the certificate associated with the custom domain name.</p>
    pub fn set_custom_domain_certificate_expiry_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.custom_domain_certificate_expiry_date = input;
        self
    }
    /// <p>The expiration date for the certificate associated with the custom domain name.</p>
    pub fn get_custom_domain_certificate_expiry_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.custom_domain_certificate_expiry_date
    }
    /// <p>The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.</p>
    pub fn master_password_secret_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.master_password_secret_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.</p>
    pub fn set_master_password_secret_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.master_password_secret_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.</p>
    pub fn get_master_password_secret_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.master_password_secret_arn
    }
    /// <p>The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin credentials secret.</p>
    pub fn master_password_secret_kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.master_password_secret_kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin credentials secret.</p>
    pub fn set_master_password_secret_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.master_password_secret_kms_key_id = input;
        self
    }
    /// <p>The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin credentials secret.</p>
    pub fn get_master_password_secret_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.master_password_secret_kms_key_id
    }
    /// <p>The IP address type for the cluster. Possible values are <code>ipv4</code> and <code>dualstack</code>.</p>
    pub fn ip_address_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.ip_address_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The IP address type for the cluster. Possible values are <code>ipv4</code> and <code>dualstack</code>.</p>
    pub fn set_ip_address_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.ip_address_type = input;
        self
    }
    /// <p>The IP address type for the cluster. Possible values are <code>ipv4</code> and <code>dualstack</code>.</p>
    pub fn get_ip_address_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.ip_address_type
    }
    /// Consumes the builder and constructs a [`Cluster`](crate::types::Cluster).
    pub fn build(self) -> crate::types::Cluster {
        crate::types::Cluster {
            cluster_identifier: self.cluster_identifier,
            node_type: self.node_type,
            cluster_status: self.cluster_status,
            cluster_availability_status: self.cluster_availability_status,
            modify_status: self.modify_status,
            master_username: self.master_username,
            db_name: self.db_name,
            endpoint: self.endpoint,
            cluster_create_time: self.cluster_create_time,
            automated_snapshot_retention_period: self.automated_snapshot_retention_period,
            manual_snapshot_retention_period: self.manual_snapshot_retention_period,
            cluster_security_groups: self.cluster_security_groups,
            vpc_security_groups: self.vpc_security_groups,
            cluster_parameter_groups: self.cluster_parameter_groups,
            cluster_subnet_group_name: self.cluster_subnet_group_name,
            vpc_id: self.vpc_id,
            availability_zone: self.availability_zone,
            preferred_maintenance_window: self.preferred_maintenance_window,
            pending_modified_values: self.pending_modified_values,
            cluster_version: self.cluster_version,
            allow_version_upgrade: self.allow_version_upgrade,
            number_of_nodes: self.number_of_nodes,
            publicly_accessible: self.publicly_accessible,
            encrypted: self.encrypted,
            restore_status: self.restore_status,
            data_transfer_progress: self.data_transfer_progress,
            hsm_status: self.hsm_status,
            cluster_snapshot_copy_status: self.cluster_snapshot_copy_status,
            cluster_public_key: self.cluster_public_key,
            cluster_nodes: self.cluster_nodes,
            elastic_ip_status: self.elastic_ip_status,
            cluster_revision_number: self.cluster_revision_number,
            tags: self.tags,
            kms_key_id: self.kms_key_id,
            enhanced_vpc_routing: self.enhanced_vpc_routing,
            iam_roles: self.iam_roles,
            pending_actions: self.pending_actions,
            maintenance_track_name: self.maintenance_track_name,
            elastic_resize_number_of_node_options: self.elastic_resize_number_of_node_options,
            deferred_maintenance_windows: self.deferred_maintenance_windows,
            snapshot_schedule_identifier: self.snapshot_schedule_identifier,
            snapshot_schedule_state: self.snapshot_schedule_state,
            expected_next_snapshot_schedule_time: self.expected_next_snapshot_schedule_time,
            expected_next_snapshot_schedule_time_status: self.expected_next_snapshot_schedule_time_status,
            next_maintenance_window_start_time: self.next_maintenance_window_start_time,
            resize_info: self.resize_info,
            availability_zone_relocation_status: self.availability_zone_relocation_status,
            cluster_namespace_arn: self.cluster_namespace_arn,
            total_storage_capacity_in_mega_bytes: self.total_storage_capacity_in_mega_bytes,
            aqua_configuration: self.aqua_configuration,
            default_iam_role_arn: self.default_iam_role_arn,
            reserved_node_exchange_status: self.reserved_node_exchange_status,
            custom_domain_name: self.custom_domain_name,
            custom_domain_certificate_arn: self.custom_domain_certificate_arn,
            custom_domain_certificate_expiry_date: self.custom_domain_certificate_expiry_date,
            master_password_secret_arn: self.master_password_secret_arn,
            master_password_secret_kms_key_id: self.master_password_secret_kms_key_id,
            ip_address_type: self.ip_address_type,
        }
    }
}
