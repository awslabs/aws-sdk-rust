// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePartnerStatusErrorKind = UpdatePartnerStatusError;
/// Error type for the `UpdatePartnerStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePartnerStatusError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The name of the partner was not found.</p>
    PartnerNotFoundFault(crate::error::PartnerNotFoundFault),
    /// <p>The partner integration is not authorized.</p>
    UnauthorizedPartnerIntegrationFault(crate::error::UnauthorizedPartnerIntegrationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePartnerStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePartnerStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::PartnerNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePartnerStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PartnerNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedPartnerIntegrationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePartnerStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePartnerStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePartnerStatusError {
    /// Creates the `UpdatePartnerStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePartnerStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::PartnerNotFoundFault(e) => e.meta(),
            Self::UnauthorizedPartnerIntegrationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePartnerStatusError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdatePartnerStatusError::PartnerNotFoundFault`.
    pub fn is_partner_not_found_fault(&self) -> bool {
        matches!(self, Self::PartnerNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `UpdatePartnerStatusError::UnauthorizedPartnerIntegrationFault`.
    pub fn is_unauthorized_partner_integration_fault(&self) -> bool {
        matches!(self, Self::UnauthorizedPartnerIntegrationFault(_))
    }
}
impl std::error::Error for UpdatePartnerStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::PartnerNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The partner integration is not authorized.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedPartnerIntegrationFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnauthorizedPartnerIntegrationFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedPartnerIntegrationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedPartnerIntegrationFault")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedPartnerIntegrationFault {}
impl aws_http::request_id::RequestId for crate::error::UnauthorizedPartnerIntegrationFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UnauthorizedPartnerIntegrationFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnauthorizedPartnerIntegrationFault {
    /// Creates a new builder-style object to manufacture [`UnauthorizedPartnerIntegrationFault`](crate::error::UnauthorizedPartnerIntegrationFault).
    pub fn builder() -> crate::error::unauthorized_partner_integration_fault::Builder {
        crate::error::unauthorized_partner_integration_fault::Builder::default()
    }
}

/// See [`UnauthorizedPartnerIntegrationFault`](crate::error::UnauthorizedPartnerIntegrationFault).
pub mod unauthorized_partner_integration_fault {

    /// A builder for [`UnauthorizedPartnerIntegrationFault`](crate::error::UnauthorizedPartnerIntegrationFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedPartnerIntegrationFault`](crate::error::UnauthorizedPartnerIntegrationFault).
        pub fn build(self) -> crate::error::UnauthorizedPartnerIntegrationFault {
            crate::error::UnauthorizedPartnerIntegrationFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The name of the partner was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PartnerNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PartnerNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PartnerNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PartnerNotFoundFault")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PartnerNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::PartnerNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PartnerNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl PartnerNotFoundFault {
    /// Creates a new builder-style object to manufacture [`PartnerNotFoundFault`](crate::error::PartnerNotFoundFault).
    pub fn builder() -> crate::error::partner_not_found_fault::Builder {
        crate::error::partner_not_found_fault::Builder::default()
    }
}

/// See [`PartnerNotFoundFault`](crate::error::PartnerNotFoundFault).
pub mod partner_not_found_fault {

    /// A builder for [`PartnerNotFoundFault`](crate::error::PartnerNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PartnerNotFoundFault`](crate::error::PartnerNotFoundFault).
        pub fn build(self) -> crate::error::PartnerNotFoundFault {
            crate::error::PartnerNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterNotFoundFault")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
    pub fn builder() -> crate::error::cluster_not_found_fault::Builder {
        crate::error::cluster_not_found_fault::Builder::default()
    }
}

/// See [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
pub mod cluster_not_found_fault {

    /// A builder for [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterNotFoundFault`](crate::error::ClusterNotFoundFault).
        pub fn build(self) -> crate::error::ClusterNotFoundFault {
            crate::error::ClusterNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RotateEncryptionKeyErrorKind = RotateEncryptionKeyError;
/// Error type for the `RotateEncryptionKeyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RotateEncryptionKeyError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RotateEncryptionKeyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RotateEncryptionKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RotateEncryptionKeyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RotateEncryptionKeyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RotateEncryptionKeyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RotateEncryptionKeyError {
    /// Creates the `RotateEncryptionKeyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RotateEncryptionKeyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RotateEncryptionKeyError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RotateEncryptionKeyError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `RotateEncryptionKeyError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for RotateEncryptionKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified cluster is not in the <code>available</code> state. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterStateFault")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClusterStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
    pub fn builder() -> crate::error::invalid_cluster_state_fault::Builder {
        crate::error::invalid_cluster_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
pub mod invalid_cluster_state_fault {

    /// A builder for [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterStateFault`](crate::error::InvalidClusterStateFault).
        pub fn build(self) -> crate::error::InvalidClusterStateFault {
            crate::error::InvalidClusterStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DependentServiceRequestThrottlingFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DependentServiceRequestThrottlingFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DependentServiceRequestThrottlingFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependentServiceRequestThrottlingFault")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DependentServiceRequestThrottlingFault {}
impl aws_http::request_id::RequestId for crate::error::DependentServiceRequestThrottlingFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DependentServiceRequestThrottlingFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DependentServiceRequestThrottlingFault {
    /// Creates a new builder-style object to manufacture [`DependentServiceRequestThrottlingFault`](crate::error::DependentServiceRequestThrottlingFault).
    pub fn builder() -> crate::error::dependent_service_request_throttling_fault::Builder {
        crate::error::dependent_service_request_throttling_fault::Builder::default()
    }
}

/// See [`DependentServiceRequestThrottlingFault`](crate::error::DependentServiceRequestThrottlingFault).
pub mod dependent_service_request_throttling_fault {

    /// A builder for [`DependentServiceRequestThrottlingFault`](crate::error::DependentServiceRequestThrottlingFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DependentServiceRequestThrottlingFault`](crate::error::DependentServiceRequestThrottlingFault).
        pub fn build(self) -> crate::error::DependentServiceRequestThrottlingFault {
            crate::error::DependentServiceRequestThrottlingFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RevokeSnapshotAccessErrorKind = RevokeSnapshotAccessError;
/// Error type for the `RevokeSnapshotAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeSnapshotAccessError {
    /// <p>The owner of the specified snapshot has not authorized your account to access the snapshot.</p>
    AccessToSnapshotDeniedFault(crate::error::AccessToSnapshotDeniedFault),
    /// <p>The specified CIDR IP range or EC2 security group is not authorized for the specified cluster security group.</p>
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RevokeSnapshotAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RevokeSnapshotAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => _inner.fmt(f),
            Self::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevokeSnapshotAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AuthorizationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RevokeSnapshotAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RevokeSnapshotAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeSnapshotAccessError {
    /// Creates the `RevokeSnapshotAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RevokeSnapshotAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessToSnapshotDeniedFault(e) => e.meta(),
            Self::AuthorizationNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RevokeSnapshotAccessError::AccessToSnapshotDeniedFault`.
    pub fn is_access_to_snapshot_denied_fault(&self) -> bool {
        matches!(self, Self::AccessToSnapshotDeniedFault(_))
    }
    /// Returns `true` if the error kind is `RevokeSnapshotAccessError::AuthorizationNotFoundFault`.
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthorizationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeSnapshotAccessError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeSnapshotAccessError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for RevokeSnapshotAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => Some(_inner),
            Self::AuthorizationNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested operation isn't supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedOperationFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedOperationFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationFault")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationFault {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedOperationFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedOperationFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnsupportedOperationFault {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationFault`](crate::error::UnsupportedOperationFault).
    pub fn builder() -> crate::error::unsupported_operation_fault::Builder {
        crate::error::unsupported_operation_fault::Builder::default()
    }
}

/// See [`UnsupportedOperationFault`](crate::error::UnsupportedOperationFault).
pub mod unsupported_operation_fault {

    /// A builder for [`UnsupportedOperationFault`](crate::error::UnsupportedOperationFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationFault`](crate::error::UnsupportedOperationFault).
        pub fn build(self) -> crate::error::UnsupportedOperationFault {
            crate::error::UnsupportedOperationFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSnapshotNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSnapshotNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSnapshotNotFoundFault")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSnapshotNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSnapshotNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSnapshotNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterSnapshotNotFoundFault`](crate::error::ClusterSnapshotNotFoundFault).
    pub fn builder() -> crate::error::cluster_snapshot_not_found_fault::Builder {
        crate::error::cluster_snapshot_not_found_fault::Builder::default()
    }
}

/// See [`ClusterSnapshotNotFoundFault`](crate::error::ClusterSnapshotNotFoundFault).
pub mod cluster_snapshot_not_found_fault {

    /// A builder for [`ClusterSnapshotNotFoundFault`](crate::error::ClusterSnapshotNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSnapshotNotFoundFault`](crate::error::ClusterSnapshotNotFoundFault).
        pub fn build(self) -> crate::error::ClusterSnapshotNotFoundFault {
            crate::error::ClusterSnapshotNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified CIDR IP range or EC2 security group is not authorized for the specified cluster security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorizationNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthorizationNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationNotFoundFault")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::AuthorizationNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizationNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
    pub fn builder() -> crate::error::authorization_not_found_fault::Builder {
        crate::error::authorization_not_found_fault::Builder::default()
    }
}

/// See [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
pub mod authorization_not_found_fault {

    /// A builder for [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
        pub fn build(self) -> crate::error::AuthorizationNotFoundFault {
            crate::error::AuthorizationNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The owner of the specified snapshot has not authorized your account to access the snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessToSnapshotDeniedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessToSnapshotDeniedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessToSnapshotDeniedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessToSnapshotDeniedFault")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessToSnapshotDeniedFault {}
impl aws_http::request_id::RequestId for crate::error::AccessToSnapshotDeniedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessToSnapshotDeniedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AccessToSnapshotDeniedFault {
    /// Creates a new builder-style object to manufacture [`AccessToSnapshotDeniedFault`](crate::error::AccessToSnapshotDeniedFault).
    pub fn builder() -> crate::error::access_to_snapshot_denied_fault::Builder {
        crate::error::access_to_snapshot_denied_fault::Builder::default()
    }
}

/// See [`AccessToSnapshotDeniedFault`](crate::error::AccessToSnapshotDeniedFault).
pub mod access_to_snapshot_denied_fault {

    /// A builder for [`AccessToSnapshotDeniedFault`](crate::error::AccessToSnapshotDeniedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AccessToSnapshotDeniedFault`](crate::error::AccessToSnapshotDeniedFault).
        pub fn build(self) -> crate::error::AccessToSnapshotDeniedFault {
            crate::error::AccessToSnapshotDeniedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RevokeEndpointAccessErrorKind = RevokeEndpointAccessError;
/// Error type for the `RevokeEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeEndpointAccessError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The authorization for this endpoint can't be found.</p>
    EndpointAuthorizationNotFoundFault(crate::error::EndpointAuthorizationNotFoundFault),
    /// <p>The endpoint name doesn't refer to an existing endpoint.</p>
    EndpointNotFoundFault(crate::error::EndpointNotFoundFault),
    /// <p>The status of the authorization is not valid.</p>
    InvalidAuthorizationStateFault(crate::error::InvalidAuthorizationStateFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The status of the endpoint is not valid.</p>
    InvalidEndpointStateFault(crate::error::InvalidEndpointStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RevokeEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RevokeEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointAuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthorizationStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidEndpointStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevokeEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointAuthorizationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthorizationStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEndpointStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RevokeEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RevokeEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeEndpointAccessError {
    /// Creates the `RevokeEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RevokeEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::EndpointAuthorizationNotFoundFault(e) => e.meta(),
            Self::EndpointNotFoundFault(e) => e.meta(),
            Self::InvalidAuthorizationStateFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidEndpointStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::EndpointAuthorizationNotFoundFault`.
    pub fn is_endpoint_authorization_not_found_fault(&self) -> bool {
        matches!(self, Self::EndpointAuthorizationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::EndpointNotFoundFault`.
    pub fn is_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::EndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::InvalidAuthorizationStateFault`.
    pub fn is_invalid_authorization_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthorizationStateFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `RevokeEndpointAccessError::InvalidEndpointStateFault`.
    pub fn is_invalid_endpoint_state_fault(&self) -> bool {
        matches!(self, Self::InvalidEndpointStateFault(_))
    }
}
impl std::error::Error for RevokeEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::EndpointAuthorizationNotFoundFault(_inner) => Some(_inner),
            Self::EndpointNotFoundFault(_inner) => Some(_inner),
            Self::InvalidAuthorizationStateFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidEndpointStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The status of the endpoint is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEndpointStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEndpointStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEndpointStateFault")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEndpointStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidEndpointStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEndpointStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidEndpointStateFault`](crate::error::InvalidEndpointStateFault).
    pub fn builder() -> crate::error::invalid_endpoint_state_fault::Builder {
        crate::error::invalid_endpoint_state_fault::Builder::default()
    }
}

/// See [`InvalidEndpointStateFault`](crate::error::InvalidEndpointStateFault).
pub mod invalid_endpoint_state_fault {

    /// A builder for [`InvalidEndpointStateFault`](crate::error::InvalidEndpointStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEndpointStateFault`](crate::error::InvalidEndpointStateFault).
        pub fn build(self) -> crate::error::InvalidEndpointStateFault {
            crate::error::InvalidEndpointStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The state of the cluster security group is not <code>available</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterSecurityGroupStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterSecurityGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterSecurityGroupStateFault")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterSecurityGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterSecurityGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidClusterSecurityGroupStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterSecurityGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterSecurityGroupStateFault`](crate::error::InvalidClusterSecurityGroupStateFault).
    pub fn builder() -> crate::error::invalid_cluster_security_group_state_fault::Builder {
        crate::error::invalid_cluster_security_group_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterSecurityGroupStateFault`](crate::error::InvalidClusterSecurityGroupStateFault).
pub mod invalid_cluster_security_group_state_fault {

    /// A builder for [`InvalidClusterSecurityGroupStateFault`](crate::error::InvalidClusterSecurityGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterSecurityGroupStateFault`](crate::error::InvalidClusterSecurityGroupStateFault).
        pub fn build(self) -> crate::error::InvalidClusterSecurityGroupStateFault {
            crate::error::InvalidClusterSecurityGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The status of the authorization is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAuthorizationStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAuthorizationStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthorizationStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthorizationStateFault")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthorizationStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidAuthorizationStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidAuthorizationStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAuthorizationStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidAuthorizationStateFault`](crate::error::InvalidAuthorizationStateFault).
    pub fn builder() -> crate::error::invalid_authorization_state_fault::Builder {
        crate::error::invalid_authorization_state_fault::Builder::default()
    }
}

/// See [`InvalidAuthorizationStateFault`](crate::error::InvalidAuthorizationStateFault).
pub mod invalid_authorization_state_fault {

    /// A builder for [`InvalidAuthorizationStateFault`](crate::error::InvalidAuthorizationStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthorizationStateFault`](crate::error::InvalidAuthorizationStateFault).
        pub fn build(self) -> crate::error::InvalidAuthorizationStateFault {
            crate::error::InvalidAuthorizationStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The endpoint name doesn't refer to an existing endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointNotFoundFault")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EndpointNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`EndpointNotFoundFault`](crate::error::EndpointNotFoundFault).
    pub fn builder() -> crate::error::endpoint_not_found_fault::Builder {
        crate::error::endpoint_not_found_fault::Builder::default()
    }
}

/// See [`EndpointNotFoundFault`](crate::error::EndpointNotFoundFault).
pub mod endpoint_not_found_fault {

    /// A builder for [`EndpointNotFoundFault`](crate::error::EndpointNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointNotFoundFault`](crate::error::EndpointNotFoundFault).
        pub fn build(self) -> crate::error::EndpointNotFoundFault {
            crate::error::EndpointNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The authorization for this endpoint can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointAuthorizationNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointAuthorizationNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointAuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointAuthorizationNotFoundFault")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointAuthorizationNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointAuthorizationNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EndpointAuthorizationNotFoundFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointAuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`EndpointAuthorizationNotFoundFault`](crate::error::EndpointAuthorizationNotFoundFault).
    pub fn builder() -> crate::error::endpoint_authorization_not_found_fault::Builder {
        crate::error::endpoint_authorization_not_found_fault::Builder::default()
    }
}

/// See [`EndpointAuthorizationNotFoundFault`](crate::error::EndpointAuthorizationNotFoundFault).
pub mod endpoint_authorization_not_found_fault {

    /// A builder for [`EndpointAuthorizationNotFoundFault`](crate::error::EndpointAuthorizationNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAuthorizationNotFoundFault`](crate::error::EndpointAuthorizationNotFoundFault).
        pub fn build(self) -> crate::error::EndpointAuthorizationNotFoundFault {
            crate::error::EndpointAuthorizationNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RevokeClusterSecurityGroupIngressErrorKind = RevokeClusterSecurityGroupIngressError;
/// Error type for the `RevokeClusterSecurityGroupIngressError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeClusterSecurityGroupIngressError {
    /// <p>The specified CIDR IP range or EC2 security group is not authorized for the specified cluster security group.</p>
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RevokeClusterSecurityGroupIngressError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RevokeClusterSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RevokeClusterSecurityGroupIngressError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RevokeClusterSecurityGroupIngressError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RevokeClusterSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeClusterSecurityGroupIngressError {
    /// Creates the `RevokeClusterSecurityGroupIngressError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RevokeClusterSecurityGroupIngressError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorizationNotFoundFault(e) => e.meta(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RevokeClusterSecurityGroupIngressError::AuthorizationNotFoundFault`.
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthorizationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeClusterSecurityGroupIngressError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RevokeClusterSecurityGroupIngressError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
}
impl std::error::Error for RevokeClusterSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The cluster security group name does not refer to an existing cluster security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSecurityGroupNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSecurityGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSecurityGroupNotFoundFault")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSecurityGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSecurityGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSecurityGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSecurityGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterSecurityGroupNotFoundFault`](crate::error::ClusterSecurityGroupNotFoundFault).
    pub fn builder() -> crate::error::cluster_security_group_not_found_fault::Builder {
        crate::error::cluster_security_group_not_found_fault::Builder::default()
    }
}

/// See [`ClusterSecurityGroupNotFoundFault`](crate::error::ClusterSecurityGroupNotFoundFault).
pub mod cluster_security_group_not_found_fault {

    /// A builder for [`ClusterSecurityGroupNotFoundFault`](crate::error::ClusterSecurityGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSecurityGroupNotFoundFault`](crate::error::ClusterSecurityGroupNotFoundFault).
        pub fn build(self) -> crate::error::ClusterSecurityGroupNotFoundFault {
            crate::error::ClusterSecurityGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResumeClusterErrorKind = ResumeClusterError;
/// Error type for the `ResumeClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResumeClusterError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResumeClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResumeClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResumeClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResumeClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResumeClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResumeClusterError {
    /// Creates the `ResumeClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResumeClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResumeClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResumeClusterError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `ResumeClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for ResumeClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientClusterCapacityFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientClusterCapacityFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientClusterCapacityFault")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientClusterCapacityFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientClusterCapacityFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InsufficientClusterCapacityFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InsufficientClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
    pub fn builder() -> crate::error::insufficient_cluster_capacity_fault::Builder {
        crate::error::insufficient_cluster_capacity_fault::Builder::default()
    }
}

/// See [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
pub mod insufficient_cluster_capacity_fault {

    /// A builder for [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientClusterCapacityFault`](crate::error::InsufficientClusterCapacityFault).
        pub fn build(self) -> crate::error::InsufficientClusterCapacityFault {
            crate::error::InsufficientClusterCapacityFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreTableFromClusterSnapshotErrorKind = RestoreTableFromClusterSnapshotError;
/// Error type for the `RestoreTableFromClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreTableFromClusterSnapshotError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>You have exceeded the allowed number of table restore requests. Wait for your current table restore requests to complete before making a new request.</p>
    InProgressTableRestoreQuotaExceededFault(
        crate::error::InProgressTableRestoreQuotaExceededFault,
    ),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The value specified for the <code>sourceDatabaseName</code>, <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a combination of these, doesn't exist in the snapshot.</p>
    InvalidTableRestoreArgumentFault(crate::error::InvalidTableRestoreArgumentFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreTableFromClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreTableFromClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InProgressTableRestoreQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidTableRestoreArgumentFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RestoreTableFromClusterSnapshotError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InProgressTableRestoreQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTableRestoreArgumentFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreTableFromClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreTableFromClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreTableFromClusterSnapshotError {
    /// Creates the `RestoreTableFromClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreTableFromClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InProgressTableRestoreQuotaExceededFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidTableRestoreArgumentFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::InProgressTableRestoreQuotaExceededFault`.
    pub fn is_in_progress_table_restore_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::InProgressTableRestoreQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::InvalidTableRestoreArgumentFault`.
    pub fn is_invalid_table_restore_argument_fault(&self) -> bool {
        matches!(self, Self::InvalidTableRestoreArgumentFault(_))
    }
    /// Returns `true` if the error kind is `RestoreTableFromClusterSnapshotError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for RestoreTableFromClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InProgressTableRestoreQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidTableRestoreArgumentFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The value specified for the <code>sourceDatabaseName</code>, <code>sourceSchemaName</code>, or <code>sourceTableName</code> parameter, or a combination of these, doesn't exist in the snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTableRestoreArgumentFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTableRestoreArgumentFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTableRestoreArgumentFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTableRestoreArgumentFault")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTableRestoreArgumentFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidTableRestoreArgumentFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTableRestoreArgumentFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTableRestoreArgumentFault {
    /// Creates a new builder-style object to manufacture [`InvalidTableRestoreArgumentFault`](crate::error::InvalidTableRestoreArgumentFault).
    pub fn builder() -> crate::error::invalid_table_restore_argument_fault::Builder {
        crate::error::invalid_table_restore_argument_fault::Builder::default()
    }
}

/// See [`InvalidTableRestoreArgumentFault`](crate::error::InvalidTableRestoreArgumentFault).
pub mod invalid_table_restore_argument_fault {

    /// A builder for [`InvalidTableRestoreArgumentFault`](crate::error::InvalidTableRestoreArgumentFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTableRestoreArgumentFault`](crate::error::InvalidTableRestoreArgumentFault).
        pub fn build(self) -> crate::error::InvalidTableRestoreArgumentFault {
            crate::error::InvalidTableRestoreArgumentFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterSnapshotStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterSnapshotStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterSnapshotStateFault")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterSnapshotStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterSnapshotStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClusterSnapshotStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterSnapshotStateFault`](crate::error::InvalidClusterSnapshotStateFault).
    pub fn builder() -> crate::error::invalid_cluster_snapshot_state_fault::Builder {
        crate::error::invalid_cluster_snapshot_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterSnapshotStateFault`](crate::error::InvalidClusterSnapshotStateFault).
pub mod invalid_cluster_snapshot_state_fault {

    /// A builder for [`InvalidClusterSnapshotStateFault`](crate::error::InvalidClusterSnapshotStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterSnapshotStateFault`](crate::error::InvalidClusterSnapshotStateFault).
        pub fn build(self) -> crate::error::InvalidClusterSnapshotStateFault {
            crate::error::InvalidClusterSnapshotStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You have exceeded the allowed number of table restore requests. Wait for your current table restore requests to complete before making a new request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InProgressTableRestoreQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InProgressTableRestoreQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InProgressTableRestoreQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InProgressTableRestoreQuotaExceededFault")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InProgressTableRestoreQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::InProgressTableRestoreQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InProgressTableRestoreQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InProgressTableRestoreQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`InProgressTableRestoreQuotaExceededFault`](crate::error::InProgressTableRestoreQuotaExceededFault).
    pub fn builder() -> crate::error::in_progress_table_restore_quota_exceeded_fault::Builder {
        crate::error::in_progress_table_restore_quota_exceeded_fault::Builder::default()
    }
}

/// See [`InProgressTableRestoreQuotaExceededFault`](crate::error::InProgressTableRestoreQuotaExceededFault).
pub mod in_progress_table_restore_quota_exceeded_fault {

    /// A builder for [`InProgressTableRestoreQuotaExceededFault`](crate::error::InProgressTableRestoreQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InProgressTableRestoreQuotaExceededFault`](crate::error::InProgressTableRestoreQuotaExceededFault).
        pub fn build(self) -> crate::error::InProgressTableRestoreQuotaExceededFault {
            crate::error::InProgressTableRestoreQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreFromClusterSnapshotErrorKind = RestoreFromClusterSnapshotError;
/// Error type for the `RestoreFromClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreFromClusterSnapshotError {
    /// <p>The owner of the specified snapshot has not authorized your account to access the snapshot.</p>
    AccessToSnapshotDeniedFault(crate::error::AccessToSnapshotDeniedFault),
    /// <p>The account already has a cluster with the given identifier.</p>
    ClusterAlreadyExistsFault(crate::error::ClusterAlreadyExistsFault),
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The request would exceed the allowed number of cluster instances for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterQuotaExceededFault(crate::error::ClusterQuotaExceededFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The cluster subnet group cannot be deleted because it is in use.</p>
    InvalidClusterSubnetGroupStateFault(crate::error::InvalidClusterSubnetGroupStateFault),
    /// <p>The provided cluster track name is not valid.</p>
    InvalidClusterTrackFault(crate::error::InvalidClusterTrackFault),
    /// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
    InvalidElasticIpFault(crate::error::InvalidElasticIpFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>The restore is invalid.</p>
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    /// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The cluster subnet group does not cover all Availability Zones.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
    NumberOfNodesPerClusterLimitExceededFault(
        crate::error::NumberOfNodesPerClusterLimitExceededFault,
    ),
    /// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    NumberOfNodesQuotaExceededFault(crate::error::NumberOfNodesQuotaExceededFault),
    /// <p>User already has a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreFromClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreFromClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => _inner.fmt(f),
            Self::ClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::HsmClientCertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::HsmConfigurationNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterTrackFault(_inner) => _inner.fmt(f),
            Self::InvalidElasticIpFault(_inner) => _inner.fmt(f),
            Self::InvalidReservedNodeStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRestoreFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreFromClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmClientCertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmConfigurationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterTrackFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidElasticIpFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReservedNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRestoreFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyMigratedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreFromClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreFromClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreFromClusterSnapshotError {
    /// Creates the `RestoreFromClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreFromClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessToSnapshotDeniedFault(e) => e.meta(),
            Self::ClusterAlreadyExistsFault(e) => e.meta(),
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::ClusterQuotaExceededFault(e) => e.meta(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::HsmClientCertificateNotFoundFault(e) => e.meta(),
            Self::HsmConfigurationNotFoundFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidClusterSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidClusterTrackFault(e) => e.meta(),
            Self::InvalidElasticIpFault(e) => e.meta(),
            Self::InvalidReservedNodeStateFault(e) => e.meta(),
            Self::InvalidRestoreFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesPerClusterLimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesQuotaExceededFault(e) => e.meta(),
            Self::ReservedNodeAlreadyExistsFault(e) => e.meta(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::SnapshotScheduleNotFoundFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::AccessToSnapshotDeniedFault`.
    pub fn is_access_to_snapshot_denied_fault(&self) -> bool {
        matches!(self, Self::AccessToSnapshotDeniedFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterAlreadyExistsFault`.
    pub fn is_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterQuotaExceededFault`.
    pub fn is_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::HsmClientCertificateNotFoundFault`.
    pub fn is_hsm_client_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::HsmConfigurationNotFoundFault`.
    pub fn is_hsm_configuration_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidClusterSubnetGroupStateFault`.
    pub fn is_invalid_cluster_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidClusterTrackFault`.
    pub fn is_invalid_cluster_track_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterTrackFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidElasticIpFault`.
    pub fn is_invalid_elastic_ip_fault(&self) -> bool {
        matches!(self, Self::InvalidElasticIpFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidReservedNodeStateFault`.
    pub fn is_invalid_reserved_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidReservedNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidRestoreFault`.
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(self, Self::InvalidRestoreFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::NumberOfNodesPerClusterLimitExceededFault`.
    pub fn is_number_of_nodes_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesPerClusterLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::NumberOfNodesQuotaExceededFault`.
    pub fn is_number_of_nodes_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ReservedNodeAlreadyExistsFault`.
    pub fn is_reserved_node_already_exists_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ReservedNodeAlreadyMigratedFault`.
    pub fn is_reserved_node_already_migrated_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyMigratedFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::SnapshotScheduleNotFoundFault`.
    pub fn is_snapshot_schedule_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
    /// Returns `true` if the error kind is `RestoreFromClusterSnapshotError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for RestoreFromClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => Some(_inner),
            Self::ClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::HsmClientCertificateNotFoundFault(_inner) => Some(_inner),
            Self::HsmConfigurationNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterTrackFault(_inner) => Some(_inner),
            Self::InvalidElasticIpFault(_inner) => Some(_inner),
            Self::InvalidReservedNodeStateFault(_inner) => Some(_inner),
            Self::InvalidRestoreFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesQuotaExceededFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyExistsFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotScheduleNotFoundFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Your account is not authorized to perform the requested operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnauthorizedOperation {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnauthorizedOperation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedOperation")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedOperation {}
impl aws_http::request_id::RequestId for crate::error::UnauthorizedOperation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnauthorizedOperation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnauthorizedOperation {
    /// Creates a new builder-style object to manufacture [`UnauthorizedOperation`](crate::error::UnauthorizedOperation).
    pub fn builder() -> crate::error::unauthorized_operation::Builder {
        crate::error::unauthorized_operation::Builder::default()
    }
}

/// See [`UnauthorizedOperation`](crate::error::UnauthorizedOperation).
pub mod unauthorized_operation {

    /// A builder for [`UnauthorizedOperation`](crate::error::UnauthorizedOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedOperation`](crate::error::UnauthorizedOperation).
        pub fn build(self) -> crate::error::UnauthorizedOperation {
            crate::error::UnauthorizedOperation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You have exceeded the number of tags allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagLimitExceededFault")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagLimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::TagLimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagLimitExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`TagLimitExceededFault`](crate::error::TagLimitExceededFault).
    pub fn builder() -> crate::error::tag_limit_exceeded_fault::Builder {
        crate::error::tag_limit_exceeded_fault::Builder::default()
    }
}

/// See [`TagLimitExceededFault`](crate::error::TagLimitExceededFault).
pub mod tag_limit_exceeded_fault {

    /// A builder for [`TagLimitExceededFault`](crate::error::TagLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagLimitExceededFault`](crate::error::TagLimitExceededFault).
        pub fn build(self) -> crate::error::TagLimitExceededFault {
            crate::error::TagLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>We could not find the specified snapshot schedule. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotScheduleNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotScheduleNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotScheduleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotScheduleNotFoundFault")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotScheduleNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotScheduleNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotScheduleNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotScheduleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnapshotScheduleNotFoundFault`](crate::error::SnapshotScheduleNotFoundFault).
    pub fn builder() -> crate::error::snapshot_schedule_not_found_fault::Builder {
        crate::error::snapshot_schedule_not_found_fault::Builder::default()
    }
}

/// See [`SnapshotScheduleNotFoundFault`](crate::error::SnapshotScheduleNotFoundFault).
pub mod snapshot_schedule_not_found_fault {

    /// A builder for [`SnapshotScheduleNotFoundFault`](crate::error::SnapshotScheduleNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotScheduleNotFoundFault`](crate::error::SnapshotScheduleNotFoundFault).
        pub fn build(self) -> crate::error::SnapshotScheduleNotFoundFault {
            crate::error::SnapshotScheduleNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Specified offering does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeOfferingNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeOfferingNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeOfferingNotFoundFault")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeOfferingNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeOfferingNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeOfferingNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeOfferingNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeOfferingNotFoundFault`](crate::error::ReservedNodeOfferingNotFoundFault).
    pub fn builder() -> crate::error::reserved_node_offering_not_found_fault::Builder {
        crate::error::reserved_node_offering_not_found_fault::Builder::default()
    }
}

/// See [`ReservedNodeOfferingNotFoundFault`](crate::error::ReservedNodeOfferingNotFoundFault).
pub mod reserved_node_offering_not_found_fault {

    /// A builder for [`ReservedNodeOfferingNotFoundFault`](crate::error::ReservedNodeOfferingNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeOfferingNotFoundFault`](crate::error::ReservedNodeOfferingNotFoundFault).
        pub fn build(self) -> crate::error::ReservedNodeOfferingNotFoundFault {
            crate::error::ReservedNodeOfferingNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified reserved compute node not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeNotFoundFault")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
    pub fn builder() -> crate::error::reserved_node_not_found_fault::Builder {
        crate::error::reserved_node_not_found_fault::Builder::default()
    }
}

/// See [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
pub mod reserved_node_not_found_fault {

    /// A builder for [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeNotFoundFault`](crate::error::ReservedNodeNotFoundFault).
        pub fn build(self) -> crate::error::ReservedNodeNotFoundFault {
            crate::error::ReservedNodeNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Indicates that the reserved node has already been exchanged.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeAlreadyMigratedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeAlreadyMigratedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeAlreadyMigratedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeAlreadyMigratedFault")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeAlreadyMigratedFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeAlreadyMigratedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeAlreadyMigratedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeAlreadyMigratedFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeAlreadyMigratedFault`](crate::error::ReservedNodeAlreadyMigratedFault).
    pub fn builder() -> crate::error::reserved_node_already_migrated_fault::Builder {
        crate::error::reserved_node_already_migrated_fault::Builder::default()
    }
}

/// See [`ReservedNodeAlreadyMigratedFault`](crate::error::ReservedNodeAlreadyMigratedFault).
pub mod reserved_node_already_migrated_fault {

    /// A builder for [`ReservedNodeAlreadyMigratedFault`](crate::error::ReservedNodeAlreadyMigratedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeAlreadyMigratedFault`](crate::error::ReservedNodeAlreadyMigratedFault).
        pub fn build(self) -> crate::error::ReservedNodeAlreadyMigratedFault {
            crate::error::ReservedNodeAlreadyMigratedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>User already has a reservation with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeAlreadyExistsFault")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
    pub fn builder() -> crate::error::reserved_node_already_exists_fault::Builder {
        crate::error::reserved_node_already_exists_fault::Builder::default()
    }
}

/// See [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
pub mod reserved_node_already_exists_fault {

    /// A builder for [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeAlreadyExistsFault`](crate::error::ReservedNodeAlreadyExistsFault).
        pub fn build(self) -> crate::error::ReservedNodeAlreadyExistsFault {
            crate::error::ReservedNodeAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberOfNodesQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NumberOfNodesQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfNodesQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfNodesQuotaExceededFault")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfNodesQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::NumberOfNodesQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NumberOfNodesQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NumberOfNodesQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`NumberOfNodesQuotaExceededFault`](crate::error::NumberOfNodesQuotaExceededFault).
    pub fn builder() -> crate::error::number_of_nodes_quota_exceeded_fault::Builder {
        crate::error::number_of_nodes_quota_exceeded_fault::Builder::default()
    }
}

/// See [`NumberOfNodesQuotaExceededFault`](crate::error::NumberOfNodesQuotaExceededFault).
pub mod number_of_nodes_quota_exceeded_fault {

    /// A builder for [`NumberOfNodesQuotaExceededFault`](crate::error::NumberOfNodesQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfNodesQuotaExceededFault`](crate::error::NumberOfNodesQuotaExceededFault).
        pub fn build(self) -> crate::error::NumberOfNodesQuotaExceededFault {
            crate::error::NumberOfNodesQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberOfNodesPerClusterLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NumberOfNodesPerClusterLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfNodesPerClusterLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfNodesPerClusterLimitExceededFault")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfNodesPerClusterLimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::NumberOfNodesPerClusterLimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for NumberOfNodesPerClusterLimitExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NumberOfNodesPerClusterLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`NumberOfNodesPerClusterLimitExceededFault`](crate::error::NumberOfNodesPerClusterLimitExceededFault).
    pub fn builder() -> crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder {
        crate::error::number_of_nodes_per_cluster_limit_exceeded_fault::Builder::default()
    }
}

/// See [`NumberOfNodesPerClusterLimitExceededFault`](crate::error::NumberOfNodesPerClusterLimitExceededFault).
pub mod number_of_nodes_per_cluster_limit_exceeded_fault {

    /// A builder for [`NumberOfNodesPerClusterLimitExceededFault`](crate::error::NumberOfNodesPerClusterLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfNodesPerClusterLimitExceededFault`](crate::error::NumberOfNodesPerClusterLimitExceededFault).
        pub fn build(self) -> crate::error::NumberOfNodesPerClusterLimitExceededFault {
            crate::error::NumberOfNodesPerClusterLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededFault")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::LimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for LimitExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl LimitExceededFault {
    /// Creates a new builder-style object to manufacture [`LimitExceededFault`](crate::error::LimitExceededFault).
    pub fn builder() -> crate::error::limit_exceeded_fault::Builder {
        crate::error::limit_exceeded_fault::Builder::default()
    }
}

/// See [`LimitExceededFault`](crate::error::LimitExceededFault).
pub mod limit_exceeded_fault {

    /// A builder for [`LimitExceededFault`](crate::error::LimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededFault`](crate::error::LimitExceededFault).
        pub fn build(self) -> crate::error::LimitExceededFault {
            crate::error::LimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The cluster subnet group does not cover all Availability Zones.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidVpcNetworkStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidVpcNetworkStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidVpcNetworkStateFault [InvalidVPCNetworkStateFault]"
        )?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVpcNetworkStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidVpcNetworkStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidVpcNetworkStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidVpcNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}

/// See [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
pub mod invalid_vpc_network_state_fault {

    /// A builder for [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
        pub fn build(self) -> crate::error::InvalidVpcNetworkStateFault {
            crate::error::InvalidVpcNetworkStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The tag is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagFault")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTagFault {
    /// Creates a new builder-style object to manufacture [`InvalidTagFault`](crate::error::InvalidTagFault).
    pub fn builder() -> crate::error::invalid_tag_fault::Builder {
        crate::error::invalid_tag_fault::Builder::default()
    }
}

/// See [`InvalidTagFault`](crate::error::InvalidTagFault).
pub mod invalid_tag_fault {

    /// A builder for [`InvalidTagFault`](crate::error::InvalidTagFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagFault`](crate::error::InvalidTagFault).
        pub fn build(self) -> crate::error::InvalidTagFault {
            crate::error::InvalidTagFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSubnet {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSubnet {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
impl aws_http::request_id::RequestId for crate::error::InvalidSubnet {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSubnet {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet).
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}

/// See [`InvalidSubnet`](crate::error::InvalidSubnet).
pub mod invalid_subnet {

    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet).
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The restore is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRestoreFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRestoreFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreFault")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRestoreFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidRestoreFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRestoreFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRestoreFault {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
    pub fn builder() -> crate::error::invalid_restore_fault::Builder {
        crate::error::invalid_restore_fault::Builder::default()
    }
}

/// See [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
pub mod invalid_restore_fault {

    /// A builder for [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
        pub fn build(self) -> crate::error::InvalidRestoreFault {
            crate::error::InvalidRestoreFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReservedNodeStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReservedNodeStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReservedNodeStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReservedNodeStateFault")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReservedNodeStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidReservedNodeStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidReservedNodeStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidReservedNodeStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidReservedNodeStateFault`](crate::error::InvalidReservedNodeStateFault).
    pub fn builder() -> crate::error::invalid_reserved_node_state_fault::Builder {
        crate::error::invalid_reserved_node_state_fault::Builder::default()
    }
}

/// See [`InvalidReservedNodeStateFault`](crate::error::InvalidReservedNodeStateFault).
pub mod invalid_reserved_node_state_fault {

    /// A builder for [`InvalidReservedNodeStateFault`](crate::error::InvalidReservedNodeStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReservedNodeStateFault`](crate::error::InvalidReservedNodeStateFault).
        pub fn build(self) -> crate::error::InvalidReservedNodeStateFault {
            crate::error::InvalidReservedNodeStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidElasticIpFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidElasticIpFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidElasticIpFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidElasticIpFault")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidElasticIpFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidElasticIpFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidElasticIpFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidElasticIpFault {
    /// Creates a new builder-style object to manufacture [`InvalidElasticIpFault`](crate::error::InvalidElasticIpFault).
    pub fn builder() -> crate::error::invalid_elastic_ip_fault::Builder {
        crate::error::invalid_elastic_ip_fault::Builder::default()
    }
}

/// See [`InvalidElasticIpFault`](crate::error::InvalidElasticIpFault).
pub mod invalid_elastic_ip_fault {

    /// A builder for [`InvalidElasticIpFault`](crate::error::InvalidElasticIpFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidElasticIpFault`](crate::error::InvalidElasticIpFault).
        pub fn build(self) -> crate::error::InvalidElasticIpFault {
            crate::error::InvalidElasticIpFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The provided cluster track name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterTrackFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterTrackFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterTrackFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterTrackFault")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterTrackFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterTrackFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClusterTrackFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterTrackFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterTrackFault`](crate::error::InvalidClusterTrackFault).
    pub fn builder() -> crate::error::invalid_cluster_track_fault::Builder {
        crate::error::invalid_cluster_track_fault::Builder::default()
    }
}

/// See [`InvalidClusterTrackFault`](crate::error::InvalidClusterTrackFault).
pub mod invalid_cluster_track_fault {

    /// A builder for [`InvalidClusterTrackFault`](crate::error::InvalidClusterTrackFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterTrackFault`](crate::error::InvalidClusterTrackFault).
        pub fn build(self) -> crate::error::InvalidClusterTrackFault {
            crate::error::InvalidClusterTrackFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The cluster subnet group cannot be deleted because it is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterSubnetGroupStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterSubnetGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterSubnetGroupStateFault")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterSubnetGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterSubnetGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidClusterSubnetGroupStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterSubnetGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterSubnetGroupStateFault`](crate::error::InvalidClusterSubnetGroupStateFault).
    pub fn builder() -> crate::error::invalid_cluster_subnet_group_state_fault::Builder {
        crate::error::invalid_cluster_subnet_group_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterSubnetGroupStateFault`](crate::error::InvalidClusterSubnetGroupStateFault).
pub mod invalid_cluster_subnet_group_state_fault {

    /// A builder for [`InvalidClusterSubnetGroupStateFault`](crate::error::InvalidClusterSubnetGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterSubnetGroupStateFault`](crate::error::InvalidClusterSubnetGroupStateFault).
        pub fn build(self) -> crate::error::InvalidClusterSubnetGroupStateFault {
            crate::error::InvalidClusterSubnetGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmConfigurationNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmConfigurationNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmConfigurationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmConfigurationNotFoundFault")?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmConfigurationNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::HsmConfigurationNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for HsmConfigurationNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmConfigurationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`HsmConfigurationNotFoundFault`](crate::error::HsmConfigurationNotFoundFault).
    pub fn builder() -> crate::error::hsm_configuration_not_found_fault::Builder {
        crate::error::hsm_configuration_not_found_fault::Builder::default()
    }
}

/// See [`HsmConfigurationNotFoundFault`](crate::error::HsmConfigurationNotFoundFault).
pub mod hsm_configuration_not_found_fault {

    /// A builder for [`HsmConfigurationNotFoundFault`](crate::error::HsmConfigurationNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmConfigurationNotFoundFault`](crate::error::HsmConfigurationNotFoundFault).
        pub fn build(self) -> crate::error::HsmConfigurationNotFoundFault {
            crate::error::HsmConfigurationNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmClientCertificateNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmClientCertificateNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmClientCertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmClientCertificateNotFoundFault")?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmClientCertificateNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::HsmClientCertificateNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for HsmClientCertificateNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmClientCertificateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`HsmClientCertificateNotFoundFault`](crate::error::HsmClientCertificateNotFoundFault).
    pub fn builder() -> crate::error::hsm_client_certificate_not_found_fault::Builder {
        crate::error::hsm_client_certificate_not_found_fault::Builder::default()
    }
}

/// See [`HsmClientCertificateNotFoundFault`](crate::error::HsmClientCertificateNotFoundFault).
pub mod hsm_client_certificate_not_found_fault {

    /// A builder for [`HsmClientCertificateNotFoundFault`](crate::error::HsmClientCertificateNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmClientCertificateNotFoundFault`](crate::error::HsmClientCertificateNotFoundFault).
        pub fn build(self) -> crate::error::HsmClientCertificateNotFoundFault {
            crate::error::HsmClientCertificateNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DependentServiceUnavailableFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DependentServiceUnavailableFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DependentServiceUnavailableFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependentServiceUnavailableFault")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DependentServiceUnavailableFault {}
impl aws_http::request_id::RequestId for crate::error::DependentServiceUnavailableFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DependentServiceUnavailableFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DependentServiceUnavailableFault {
    /// Creates a new builder-style object to manufacture [`DependentServiceUnavailableFault`](crate::error::DependentServiceUnavailableFault).
    pub fn builder() -> crate::error::dependent_service_unavailable_fault::Builder {
        crate::error::dependent_service_unavailable_fault::Builder::default()
    }
}

/// See [`DependentServiceUnavailableFault`](crate::error::DependentServiceUnavailableFault).
pub mod dependent_service_unavailable_fault {

    /// A builder for [`DependentServiceUnavailableFault`](crate::error::DependentServiceUnavailableFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DependentServiceUnavailableFault`](crate::error::DependentServiceUnavailableFault).
        pub fn build(self) -> crate::error::DependentServiceUnavailableFault {
            crate::error::DependentServiceUnavailableFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSubnetGroupNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSubnetGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSubnetGroupNotFoundFault")?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSubnetGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSubnetGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSubnetGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterSubnetGroupNotFoundFault`](crate::error::ClusterSubnetGroupNotFoundFault).
    pub fn builder() -> crate::error::cluster_subnet_group_not_found_fault::Builder {
        crate::error::cluster_subnet_group_not_found_fault::Builder::default()
    }
}

/// See [`ClusterSubnetGroupNotFoundFault`](crate::error::ClusterSubnetGroupNotFoundFault).
pub mod cluster_subnet_group_not_found_fault {

    /// A builder for [`ClusterSubnetGroupNotFoundFault`](crate::error::ClusterSubnetGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSubnetGroupNotFoundFault`](crate::error::ClusterSubnetGroupNotFoundFault).
        pub fn build(self) -> crate::error::ClusterSubnetGroupNotFoundFault {
            crate::error::ClusterSubnetGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request would exceed the allowed number of cluster instances for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterQuotaExceededFault")?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterQuotaExceededFault`](crate::error::ClusterQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_quota_exceeded_fault::Builder {
        crate::error::cluster_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterQuotaExceededFault`](crate::error::ClusterQuotaExceededFault).
pub mod cluster_quota_exceeded_fault {

    /// A builder for [`ClusterQuotaExceededFault`](crate::error::ClusterQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterQuotaExceededFault`](crate::error::ClusterQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterQuotaExceededFault {
            crate::error::ClusterQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The parameter group name does not refer to an existing parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterParameterGroupNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterParameterGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterParameterGroupNotFoundFault")?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterParameterGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterParameterGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterParameterGroupNotFoundFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ClusterParameterGroupNotFoundFault`](crate::error::ClusterParameterGroupNotFoundFault).
    pub fn builder() -> crate::error::cluster_parameter_group_not_found_fault::Builder {
        crate::error::cluster_parameter_group_not_found_fault::Builder::default()
    }
}

/// See [`ClusterParameterGroupNotFoundFault`](crate::error::ClusterParameterGroupNotFoundFault).
pub mod cluster_parameter_group_not_found_fault {

    /// A builder for [`ClusterParameterGroupNotFoundFault`](crate::error::ClusterParameterGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterGroupNotFoundFault`](crate::error::ClusterParameterGroupNotFoundFault).
        pub fn build(self) -> crate::error::ClusterParameterGroupNotFoundFault {
            crate::error::ClusterParameterGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The account already has a cluster with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterAlreadyExistsFault")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_already_exists_fault::Builder {
        crate::error::cluster_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
pub mod cluster_already_exists_fault {

    /// A builder for [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterAlreadyExistsFault`](crate::error::ClusterAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterAlreadyExistsFault {
            crate::error::ClusterAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResizeClusterErrorKind = ResizeClusterError;
/// Error type for the `ResizeClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResizeClusterError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
    NumberOfNodesPerClusterLimitExceededFault(
        crate::error::NumberOfNodesPerClusterLimitExceededFault,
    ),
    /// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    NumberOfNodesQuotaExceededFault(crate::error::NumberOfNodesQuotaExceededFault),
    /// <p>User already has a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// <p>A request option was specified that is not supported.</p>
    UnsupportedOptionFault(crate::error::UnsupportedOptionFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResizeClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResizeClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidReservedNodeStateFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOptionFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResizeClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReservedNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyMigratedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOptionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResizeClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResizeClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResizeClusterError {
    /// Creates the `ResizeClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResizeClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidReservedNodeStateFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesPerClusterLimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesQuotaExceededFault(e) => e.meta(),
            Self::ReservedNodeAlreadyExistsFault(e) => e.meta(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::UnsupportedOptionFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResizeClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::InvalidReservedNodeStateFault`.
    pub fn is_invalid_reserved_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidReservedNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::NumberOfNodesPerClusterLimitExceededFault`.
    pub fn is_number_of_nodes_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesPerClusterLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::NumberOfNodesQuotaExceededFault`.
    pub fn is_number_of_nodes_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::ReservedNodeAlreadyExistsFault`.
    pub fn is_reserved_node_already_exists_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::ReservedNodeAlreadyMigratedFault`.
    pub fn is_reserved_node_already_migrated_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyMigratedFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
    /// Returns `true` if the error kind is `ResizeClusterError::UnsupportedOptionFault`.
    pub fn is_unsupported_option_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOptionFault(_))
    }
}
impl std::error::Error for ResizeClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidReservedNodeStateFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesQuotaExceededFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyExistsFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::UnsupportedOptionFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A request option was specified that is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedOptionFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedOptionFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOptionFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOptionFault")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOptionFault {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedOptionFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedOptionFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnsupportedOptionFault {
    /// Creates a new builder-style object to manufacture [`UnsupportedOptionFault`](crate::error::UnsupportedOptionFault).
    pub fn builder() -> crate::error::unsupported_option_fault::Builder {
        crate::error::unsupported_option_fault::Builder::default()
    }
}

/// See [`UnsupportedOptionFault`](crate::error::UnsupportedOptionFault).
pub mod unsupported_option_fault {

    /// A builder for [`UnsupportedOptionFault`](crate::error::UnsupportedOptionFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOptionFault`](crate::error::UnsupportedOptionFault).
        pub fn build(self) -> crate::error::UnsupportedOptionFault {
            crate::error::UnsupportedOptionFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResetClusterParameterGroupErrorKind = ResetClusterParameterGroupError;
/// Error type for the `ResetClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetClusterParameterGroupError {
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The cluster parameter group action can not be completed because another task is in progress that involves the parameter group. Wait a few moments and try the operation again.</p>
    InvalidClusterParameterGroupStateFault(crate::error::InvalidClusterParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResetClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResetClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResetClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResetClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResetClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetClusterParameterGroupError {
    /// Creates the `ResetClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResetClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResetClusterParameterGroupError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResetClusterParameterGroupError::InvalidClusterParameterGroupStateFault`.
    pub fn is_invalid_cluster_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterParameterGroupStateFault(_))
    }
}
impl std::error::Error for ResetClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The cluster parameter group action can not be completed because another task is in progress that involves the parameter group. Wait a few moments and try the operation again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterParameterGroupStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterParameterGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterParameterGroupStateFault")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterParameterGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterParameterGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidClusterParameterGroupStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterParameterGroupStateFault`](crate::error::InvalidClusterParameterGroupStateFault).
    pub fn builder() -> crate::error::invalid_cluster_parameter_group_state_fault::Builder {
        crate::error::invalid_cluster_parameter_group_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterParameterGroupStateFault`](crate::error::InvalidClusterParameterGroupStateFault).
pub mod invalid_cluster_parameter_group_state_fault {

    /// A builder for [`InvalidClusterParameterGroupStateFault`](crate::error::InvalidClusterParameterGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterParameterGroupStateFault`](crate::error::InvalidClusterParameterGroupStateFault).
        pub fn build(self) -> crate::error::InvalidClusterParameterGroupStateFault {
            crate::error::InvalidClusterParameterGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RejectDataShareErrorKind = RejectDataShareError;
/// Error type for the `RejectDataShareError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectDataShareError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RejectDataShareError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RejectDataShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RejectDataShareError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RejectDataShareError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RejectDataShareError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectDataShareError {
    /// Creates the `RejectDataShareError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RejectDataShareError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RejectDataShareError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
}
impl std::error::Error for RejectDataShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>There is an error with the datashare.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDataShareFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDataShareFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDataShareFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDataShareFault")?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDataShareFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDataShareFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDataShareFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDataShareFault {
    /// Creates a new builder-style object to manufacture [`InvalidDataShareFault`](crate::error::InvalidDataShareFault).
    pub fn builder() -> crate::error::invalid_data_share_fault::Builder {
        crate::error::invalid_data_share_fault::Builder::default()
    }
}

/// See [`InvalidDataShareFault`](crate::error::InvalidDataShareFault).
pub mod invalid_data_share_fault {

    /// A builder for [`InvalidDataShareFault`](crate::error::InvalidDataShareFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDataShareFault`](crate::error::InvalidDataShareFault).
        pub fn build(self) -> crate::error::InvalidDataShareFault {
            crate::error::InvalidDataShareFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RebootClusterErrorKind = RebootClusterError;
/// Error type for the `RebootClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootClusterError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RebootClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RebootClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RebootClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RebootClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RebootClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootClusterError {
    /// Creates the `RebootClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RebootClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RebootClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RebootClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for RebootClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PurchaseReservedNodeOfferingErrorKind = PurchaseReservedNodeOfferingError;
/// Error type for the `PurchaseReservedNodeOfferingError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedNodeOfferingError {
    /// <p>User already has a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>Request would exceed the user's compute node quota. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ReservedNodeQuotaExceededFault(crate::error::ReservedNodeQuotaExceededFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PurchaseReservedNodeOfferingError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PurchaseReservedNodeOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ReservedNodeAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PurchaseReservedNodeOfferingError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ReservedNodeAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PurchaseReservedNodeOfferingError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PurchaseReservedNodeOfferingError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedNodeOfferingError {
    /// Creates the `PurchaseReservedNodeOfferingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PurchaseReservedNodeOfferingError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ReservedNodeAlreadyExistsFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::ReservedNodeQuotaExceededFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodeOfferingError::ReservedNodeAlreadyExistsFault`.
    pub fn is_reserved_node_already_exists_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodeOfferingError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodeOfferingError::ReservedNodeQuotaExceededFault`.
    pub fn is_reserved_node_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedNodeOfferingError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for PurchaseReservedNodeOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ReservedNodeAlreadyExistsFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeQuotaExceededFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would exceed the user's compute node quota. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeQuotaExceededFault")?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
    pub fn builder() -> crate::error::reserved_node_quota_exceeded_fault::Builder {
        crate::error::reserved_node_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
pub mod reserved_node_quota_exceeded_fault {

    /// A builder for [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeQuotaExceededFault`](crate::error::ReservedNodeQuotaExceededFault).
        pub fn build(self) -> crate::error::ReservedNodeQuotaExceededFault {
            crate::error::ReservedNodeQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PauseClusterErrorKind = PauseClusterError;
/// Error type for the `PauseClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PauseClusterError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PauseClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PauseClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PauseClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PauseClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PauseClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PauseClusterError {
    /// Creates the `PauseClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PauseClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PauseClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `PauseClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for PauseClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyUsageLimitErrorKind = ModifyUsageLimitError;
/// Error type for the `ModifyUsageLimitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyUsageLimitError {
    /// <p>The usage limit is not valid.</p>
    InvalidUsageLimitFault(crate::error::InvalidUsageLimitFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// <p>The usage limit identifier can't be found.</p>
    UsageLimitNotFoundFault(crate::error::UsageLimitNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyUsageLimitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyUsageLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidUsageLimitFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::UsageLimitNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyUsageLimitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidUsageLimitFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UsageLimitNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyUsageLimitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyUsageLimitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyUsageLimitError {
    /// Creates the `ModifyUsageLimitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyUsageLimitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidUsageLimitFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::UsageLimitNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyUsageLimitError::InvalidUsageLimitFault`.
    pub fn is_invalid_usage_limit_fault(&self) -> bool {
        matches!(self, Self::InvalidUsageLimitFault(_))
    }
    /// Returns `true` if the error kind is `ModifyUsageLimitError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
    /// Returns `true` if the error kind is `ModifyUsageLimitError::UsageLimitNotFoundFault`.
    pub fn is_usage_limit_not_found_fault(&self) -> bool {
        matches!(self, Self::UsageLimitNotFoundFault(_))
    }
}
impl std::error::Error for ModifyUsageLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidUsageLimitFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::UsageLimitNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The usage limit identifier can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UsageLimitNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UsageLimitNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UsageLimitNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UsageLimitNotFoundFault")?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UsageLimitNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::UsageLimitNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UsageLimitNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UsageLimitNotFoundFault {
    /// Creates a new builder-style object to manufacture [`UsageLimitNotFoundFault`](crate::error::UsageLimitNotFoundFault).
    pub fn builder() -> crate::error::usage_limit_not_found_fault::Builder {
        crate::error::usage_limit_not_found_fault::Builder::default()
    }
}

/// See [`UsageLimitNotFoundFault`](crate::error::UsageLimitNotFoundFault).
pub mod usage_limit_not_found_fault {

    /// A builder for [`UsageLimitNotFoundFault`](crate::error::UsageLimitNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UsageLimitNotFoundFault`](crate::error::UsageLimitNotFoundFault).
        pub fn build(self) -> crate::error::UsageLimitNotFoundFault {
            crate::error::UsageLimitNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The usage limit is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidUsageLimitFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidUsageLimitFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUsageLimitFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUsageLimitFault")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUsageLimitFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidUsageLimitFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidUsageLimitFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidUsageLimitFault {
    /// Creates a new builder-style object to manufacture [`InvalidUsageLimitFault`](crate::error::InvalidUsageLimitFault).
    pub fn builder() -> crate::error::invalid_usage_limit_fault::Builder {
        crate::error::invalid_usage_limit_fault::Builder::default()
    }
}

/// See [`InvalidUsageLimitFault`](crate::error::InvalidUsageLimitFault).
pub mod invalid_usage_limit_fault {

    /// A builder for [`InvalidUsageLimitFault`](crate::error::InvalidUsageLimitFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUsageLimitFault`](crate::error::InvalidUsageLimitFault).
        pub fn build(self) -> crate::error::InvalidUsageLimitFault {
            crate::error::InvalidUsageLimitFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifySnapshotScheduleErrorKind = ModifySnapshotScheduleError;
/// Error type for the `ModifySnapshotScheduleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifySnapshotScheduleError {
    /// <p>The schedule you submitted isn't valid.</p>
    InvalidScheduleFault(crate::error::InvalidScheduleFault),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// <p>The specified snapshot schedule is already being updated.</p>
    SnapshotScheduleUpdateInProgressFault(crate::error::SnapshotScheduleUpdateInProgressFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifySnapshotScheduleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifySnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidScheduleFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleNotFoundFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleUpdateInProgressFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifySnapshotScheduleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidScheduleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleUpdateInProgressFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifySnapshotScheduleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifySnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifySnapshotScheduleError {
    /// Creates the `ModifySnapshotScheduleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifySnapshotScheduleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidScheduleFault(e) => e.meta(),
            Self::SnapshotScheduleNotFoundFault(e) => e.meta(),
            Self::SnapshotScheduleUpdateInProgressFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifySnapshotScheduleError::InvalidScheduleFault`.
    pub fn is_invalid_schedule_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduleFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotScheduleError::SnapshotScheduleNotFoundFault`.
    pub fn is_snapshot_schedule_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotScheduleError::SnapshotScheduleUpdateInProgressFault`.
    pub fn is_snapshot_schedule_update_in_progress_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleUpdateInProgressFault(_))
    }
}
impl std::error::Error for ModifySnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidScheduleFault(_inner) => Some(_inner),
            Self::SnapshotScheduleNotFoundFault(_inner) => Some(_inner),
            Self::SnapshotScheduleUpdateInProgressFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified snapshot schedule is already being updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotScheduleUpdateInProgressFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotScheduleUpdateInProgressFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotScheduleUpdateInProgressFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotScheduleUpdateInProgressFault")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotScheduleUpdateInProgressFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotScheduleUpdateInProgressFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SnapshotScheduleUpdateInProgressFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotScheduleUpdateInProgressFault {
    /// Creates a new builder-style object to manufacture [`SnapshotScheduleUpdateInProgressFault`](crate::error::SnapshotScheduleUpdateInProgressFault).
    pub fn builder() -> crate::error::snapshot_schedule_update_in_progress_fault::Builder {
        crate::error::snapshot_schedule_update_in_progress_fault::Builder::default()
    }
}

/// See [`SnapshotScheduleUpdateInProgressFault`](crate::error::SnapshotScheduleUpdateInProgressFault).
pub mod snapshot_schedule_update_in_progress_fault {

    /// A builder for [`SnapshotScheduleUpdateInProgressFault`](crate::error::SnapshotScheduleUpdateInProgressFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotScheduleUpdateInProgressFault`](crate::error::SnapshotScheduleUpdateInProgressFault).
        pub fn build(self) -> crate::error::SnapshotScheduleUpdateInProgressFault {
            crate::error::SnapshotScheduleUpdateInProgressFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The schedule you submitted isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidScheduleFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidScheduleFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidScheduleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidScheduleFault")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidScheduleFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidScheduleFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidScheduleFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidScheduleFault {
    /// Creates a new builder-style object to manufacture [`InvalidScheduleFault`](crate::error::InvalidScheduleFault).
    pub fn builder() -> crate::error::invalid_schedule_fault::Builder {
        crate::error::invalid_schedule_fault::Builder::default()
    }
}

/// See [`InvalidScheduleFault`](crate::error::InvalidScheduleFault).
pub mod invalid_schedule_fault {

    /// A builder for [`InvalidScheduleFault`](crate::error::InvalidScheduleFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidScheduleFault`](crate::error::InvalidScheduleFault).
        pub fn build(self) -> crate::error::InvalidScheduleFault {
            crate::error::InvalidScheduleFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifySnapshotCopyRetentionPeriodErrorKind = ModifySnapshotCopyRetentionPeriodError;
/// Error type for the `ModifySnapshotCopyRetentionPeriodError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifySnapshotCopyRetentionPeriodError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
    SnapshotCopyDisabledFault(crate::error::SnapshotCopyDisabledFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifySnapshotCopyRetentionPeriodError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifySnapshotCopyRetentionPeriodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyDisabledFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ModifySnapshotCopyRetentionPeriodError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyDisabledFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifySnapshotCopyRetentionPeriodError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifySnapshotCopyRetentionPeriodError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifySnapshotCopyRetentionPeriodError {
    /// Creates the `ModifySnapshotCopyRetentionPeriodError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifySnapshotCopyRetentionPeriodError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::SnapshotCopyDisabledFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifySnapshotCopyRetentionPeriodError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotCopyRetentionPeriodError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotCopyRetentionPeriodError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotCopyRetentionPeriodError::SnapshotCopyDisabledFault`.
    pub fn is_snapshot_copy_disabled_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyDisabledFault(_))
    }
    /// Returns `true` if the error kind is `ModifySnapshotCopyRetentionPeriodError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for ModifySnapshotCopyRetentionPeriodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::SnapshotCopyDisabledFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyDisabledFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyDisabledFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyDisabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyDisabledFault")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyDisabledFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyDisabledFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotCopyDisabledFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyDisabledFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyDisabledFault`](crate::error::SnapshotCopyDisabledFault).
    pub fn builder() -> crate::error::snapshot_copy_disabled_fault::Builder {
        crate::error::snapshot_copy_disabled_fault::Builder::default()
    }
}

/// See [`SnapshotCopyDisabledFault`](crate::error::SnapshotCopyDisabledFault).
pub mod snapshot_copy_disabled_fault {

    /// A builder for [`SnapshotCopyDisabledFault`](crate::error::SnapshotCopyDisabledFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyDisabledFault`](crate::error::SnapshotCopyDisabledFault).
        pub fn build(self) -> crate::error::SnapshotCopyDisabledFault {
            crate::error::SnapshotCopyDisabledFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The retention period specified is either in the past or is not a valid value.</p>
/// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRetentionPeriodFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRetentionPeriodFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRetentionPeriodFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRetentionPeriodFault")?;
        if let Some(inner_54) = &self.message {
            {
                write!(f, ": {}", inner_54)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRetentionPeriodFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidRetentionPeriodFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRetentionPeriodFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRetentionPeriodFault {
    /// Creates a new builder-style object to manufacture [`InvalidRetentionPeriodFault`](crate::error::InvalidRetentionPeriodFault).
    pub fn builder() -> crate::error::invalid_retention_period_fault::Builder {
        crate::error::invalid_retention_period_fault::Builder::default()
    }
}

/// See [`InvalidRetentionPeriodFault`](crate::error::InvalidRetentionPeriodFault).
pub mod invalid_retention_period_fault {

    /// A builder for [`InvalidRetentionPeriodFault`](crate::error::InvalidRetentionPeriodFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRetentionPeriodFault`](crate::error::InvalidRetentionPeriodFault).
        pub fn build(self) -> crate::error::InvalidRetentionPeriodFault {
            crate::error::InvalidRetentionPeriodFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyScheduledActionErrorKind = ModifyScheduledActionError;
/// Error type for the `ModifyScheduledActionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyScheduledActionError {
    /// <p>The scheduled action is not valid. </p>
    InvalidScheduledActionFault(crate::error::InvalidScheduledActionFault),
    /// <p>The schedule you submitted isn't valid.</p>
    InvalidScheduleFault(crate::error::InvalidScheduleFault),
    /// <p>The scheduled action cannot be found. </p>
    ScheduledActionNotFoundFault(crate::error::ScheduledActionNotFoundFault),
    /// <p>The action type specified for a scheduled action is not supported. </p>
    ScheduledActionTypeUnsupportedFault(crate::error::ScheduledActionTypeUnsupportedFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyScheduledActionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyScheduledActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidScheduledActionFault(_inner) => _inner.fmt(f),
            Self::InvalidScheduleFault(_inner) => _inner.fmt(f),
            Self::ScheduledActionNotFoundFault(_inner) => _inner.fmt(f),
            Self::ScheduledActionTypeUnsupportedFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyScheduledActionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidScheduledActionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidScheduleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduledActionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduledActionTypeUnsupportedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyScheduledActionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyScheduledActionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyScheduledActionError {
    /// Creates the `ModifyScheduledActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyScheduledActionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidScheduledActionFault(e) => e.meta(),
            Self::InvalidScheduleFault(e) => e.meta(),
            Self::ScheduledActionNotFoundFault(e) => e.meta(),
            Self::ScheduledActionTypeUnsupportedFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyScheduledActionError::InvalidScheduledActionFault`.
    pub fn is_invalid_scheduled_action_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduledActionFault(_))
    }
    /// Returns `true` if the error kind is `ModifyScheduledActionError::InvalidScheduleFault`.
    pub fn is_invalid_schedule_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduleFault(_))
    }
    /// Returns `true` if the error kind is `ModifyScheduledActionError::ScheduledActionNotFoundFault`.
    pub fn is_scheduled_action_not_found_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyScheduledActionError::ScheduledActionTypeUnsupportedFault`.
    pub fn is_scheduled_action_type_unsupported_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionTypeUnsupportedFault(_))
    }
    /// Returns `true` if the error kind is `ModifyScheduledActionError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for ModifyScheduledActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidScheduledActionFault(_inner) => Some(_inner),
            Self::InvalidScheduleFault(_inner) => Some(_inner),
            Self::ScheduledActionNotFoundFault(_inner) => Some(_inner),
            Self::ScheduledActionTypeUnsupportedFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The action type specified for a scheduled action is not supported. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduledActionTypeUnsupportedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ScheduledActionTypeUnsupportedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScheduledActionTypeUnsupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScheduledActionTypeUnsupportedFault")?;
        if let Some(inner_55) = &self.message {
            {
                write!(f, ": {}", inner_55)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ScheduledActionTypeUnsupportedFault {}
impl aws_http::request_id::RequestId for crate::error::ScheduledActionTypeUnsupportedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ScheduledActionTypeUnsupportedFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ScheduledActionTypeUnsupportedFault {
    /// Creates a new builder-style object to manufacture [`ScheduledActionTypeUnsupportedFault`](crate::error::ScheduledActionTypeUnsupportedFault).
    pub fn builder() -> crate::error::scheduled_action_type_unsupported_fault::Builder {
        crate::error::scheduled_action_type_unsupported_fault::Builder::default()
    }
}

/// See [`ScheduledActionTypeUnsupportedFault`](crate::error::ScheduledActionTypeUnsupportedFault).
pub mod scheduled_action_type_unsupported_fault {

    /// A builder for [`ScheduledActionTypeUnsupportedFault`](crate::error::ScheduledActionTypeUnsupportedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionTypeUnsupportedFault`](crate::error::ScheduledActionTypeUnsupportedFault).
        pub fn build(self) -> crate::error::ScheduledActionTypeUnsupportedFault {
            crate::error::ScheduledActionTypeUnsupportedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The scheduled action cannot be found. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduledActionNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ScheduledActionNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScheduledActionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScheduledActionNotFoundFault")?;
        if let Some(inner_56) = &self.message {
            {
                write!(f, ": {}", inner_56)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ScheduledActionNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ScheduledActionNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ScheduledActionNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ScheduledActionNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ScheduledActionNotFoundFault`](crate::error::ScheduledActionNotFoundFault).
    pub fn builder() -> crate::error::scheduled_action_not_found_fault::Builder {
        crate::error::scheduled_action_not_found_fault::Builder::default()
    }
}

/// See [`ScheduledActionNotFoundFault`](crate::error::ScheduledActionNotFoundFault).
pub mod scheduled_action_not_found_fault {

    /// A builder for [`ScheduledActionNotFoundFault`](crate::error::ScheduledActionNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionNotFoundFault`](crate::error::ScheduledActionNotFoundFault).
        pub fn build(self) -> crate::error::ScheduledActionNotFoundFault {
            crate::error::ScheduledActionNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The scheduled action is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidScheduledActionFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidScheduledActionFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidScheduledActionFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidScheduledActionFault")?;
        if let Some(inner_57) = &self.message {
            {
                write!(f, ": {}", inner_57)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidScheduledActionFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidScheduledActionFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidScheduledActionFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidScheduledActionFault {
    /// Creates a new builder-style object to manufacture [`InvalidScheduledActionFault`](crate::error::InvalidScheduledActionFault).
    pub fn builder() -> crate::error::invalid_scheduled_action_fault::Builder {
        crate::error::invalid_scheduled_action_fault::Builder::default()
    }
}

/// See [`InvalidScheduledActionFault`](crate::error::InvalidScheduledActionFault).
pub mod invalid_scheduled_action_fault {

    /// A builder for [`InvalidScheduledActionFault`](crate::error::InvalidScheduledActionFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidScheduledActionFault`](crate::error::InvalidScheduledActionFault).
        pub fn build(self) -> crate::error::InvalidScheduledActionFault {
            crate::error::InvalidScheduledActionFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyEventSubscriptionErrorKind = ModifyEventSubscriptionError;
/// Error type for the `ModifyEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyEventSubscriptionError {
    /// <p>The subscription request is invalid because it is a duplicate request. This subscription request is already in progress.</p>
    InvalidSubscriptionStateFault(crate::error::InvalidSubscriptionStateFault),
    /// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS topic.</p>
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    /// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    /// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not exist.</p>
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    /// <p>The specified Amazon Redshift event source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>The value specified for the event category was not one of the allowed values, or it specified a category that does not apply to the specified source type. The allowed values are Configuration, Management, Monitoring, and Security.</p>
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
    SubscriptionEventIdNotFoundFault(crate::error::SubscriptionEventIdNotFoundFault),
    /// <p>An Amazon Redshift event notification subscription with the specified name does not exist.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// <p>The value specified for the event severity was not one of the allowed values, or it specified a severity that does not apply to the specified source type. The allowed values are ERROR and INFO.</p>
    SubscriptionSeverityNotFoundFault(crate::error::SubscriptionSeverityNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => _inner.fmt(f),
            Self::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            Self::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            Self::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            Self::SourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionCategoryNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionEventIdNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionSeverityNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsInvalidTopicFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsNoAuthorizationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsTopicArnNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionCategoryNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionEventIdNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionSeverityNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyEventSubscriptionError {
    /// Creates the `ModifyEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidSubscriptionStateFault(e) => e.meta(),
            Self::SnsInvalidTopicFault(e) => e.meta(),
            Self::SnsNoAuthorizationFault(e) => e.meta(),
            Self::SnsTopicArnNotFoundFault(e) => e.meta(),
            Self::SourceNotFoundFault(e) => e.meta(),
            Self::SubscriptionCategoryNotFoundFault(e) => e.meta(),
            Self::SubscriptionEventIdNotFoundFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::SubscriptionSeverityNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::InvalidSubscriptionStateFault`.
    pub fn is_invalid_subscription_state_fault(&self) -> bool {
        matches!(self, Self::InvalidSubscriptionStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsInvalidTopicFault`.
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(self, Self::SnsInvalidTopicFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsNoAuthorizationFault`.
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(self, Self::SnsNoAuthorizationFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsTopicArnNotFoundFault`.
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(self, Self::SnsTopicArnNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SourceNotFoundFault`.
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(self, Self::SourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionCategoryNotFoundFault`.
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionCategoryNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionEventIdNotFoundFault`.
    pub fn is_subscription_event_id_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionEventIdNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionSeverityNotFoundFault`.
    pub fn is_subscription_severity_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionSeverityNotFoundFault(_))
    }
}
impl std::error::Error for ModifyEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => Some(_inner),
            Self::SnsInvalidTopicFault(_inner) => Some(_inner),
            Self::SnsNoAuthorizationFault(_inner) => Some(_inner),
            Self::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            Self::SourceNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionCategoryNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionEventIdNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionSeverityNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The value specified for the event severity was not one of the allowed values, or it specified a severity that does not apply to the specified source type. The allowed values are ERROR and INFO.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionSeverityNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionSeverityNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionSeverityNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionSeverityNotFoundFault")?;
        if let Some(inner_58) = &self.message {
            {
                write!(f, ": {}", inner_58)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionSeverityNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionSeverityNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionSeverityNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubscriptionSeverityNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionSeverityNotFoundFault`](crate::error::SubscriptionSeverityNotFoundFault).
    pub fn builder() -> crate::error::subscription_severity_not_found_fault::Builder {
        crate::error::subscription_severity_not_found_fault::Builder::default()
    }
}

/// See [`SubscriptionSeverityNotFoundFault`](crate::error::SubscriptionSeverityNotFoundFault).
pub mod subscription_severity_not_found_fault {

    /// A builder for [`SubscriptionSeverityNotFoundFault`](crate::error::SubscriptionSeverityNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionSeverityNotFoundFault`](crate::error::SubscriptionSeverityNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionSeverityNotFoundFault {
            crate::error::SubscriptionSeverityNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An Amazon Redshift event notification subscription with the specified name does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionNotFoundFault")?;
        if let Some(inner_59) = &self.message {
            {
                write!(f, ": {}", inner_59)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubscriptionNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
    pub fn builder() -> crate::error::subscription_not_found_fault::Builder {
        crate::error::subscription_not_found_fault::Builder::default()
    }
}

/// See [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
pub mod subscription_not_found_fault {

    /// A builder for [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionNotFoundFault {
            crate::error::SubscriptionNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionEventIdNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionEventIdNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionEventIdNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionEventIdNotFoundFault")?;
        if let Some(inner_60) = &self.message {
            {
                write!(f, ": {}", inner_60)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionEventIdNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionEventIdNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionEventIdNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubscriptionEventIdNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionEventIdNotFoundFault`](crate::error::SubscriptionEventIdNotFoundFault).
    pub fn builder() -> crate::error::subscription_event_id_not_found_fault::Builder {
        crate::error::subscription_event_id_not_found_fault::Builder::default()
    }
}

/// See [`SubscriptionEventIdNotFoundFault`](crate::error::SubscriptionEventIdNotFoundFault).
pub mod subscription_event_id_not_found_fault {

    /// A builder for [`SubscriptionEventIdNotFoundFault`](crate::error::SubscriptionEventIdNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionEventIdNotFoundFault`](crate::error::SubscriptionEventIdNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionEventIdNotFoundFault {
            crate::error::SubscriptionEventIdNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The value specified for the event category was not one of the allowed values, or it specified a category that does not apply to the specified source type. The allowed values are Configuration, Management, Monitoring, and Security.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionCategoryNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionCategoryNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionCategoryNotFoundFault")?;
        if let Some(inner_61) = &self.message {
            {
                write!(f, ": {}", inner_61)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionCategoryNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionCategoryNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionCategoryNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubscriptionCategoryNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
    pub fn builder() -> crate::error::subscription_category_not_found_fault::Builder {
        crate::error::subscription_category_not_found_fault::Builder::default()
    }
}

/// See [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
pub mod subscription_category_not_found_fault {

    /// A builder for [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionCategoryNotFoundFault {
            crate::error::SubscriptionCategoryNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified Amazon Redshift event source could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SourceNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceNotFoundFault")?;
        if let Some(inner_62) = &self.message {
            {
                write!(f, ": {}", inner_62)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SourceNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SourceNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SourceNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
    pub fn builder() -> crate::error::source_not_found_fault::Builder {
        crate::error::source_not_found_fault::Builder::default()
    }
}

/// See [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
pub mod source_not_found_fault {

    /// A builder for [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
        pub fn build(self) -> crate::error::SourceNotFoundFault {
            crate::error::SourceNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsTopicArnNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsTopicArnNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsTopicArnNotFoundFault [SNSTopicArnNotFoundFault]")?;
        if let Some(inner_63) = &self.message {
            {
                write!(f, ": {}", inner_63)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsTopicArnNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SnsTopicArnNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsTopicArnNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnsTopicArnNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
    pub fn builder() -> crate::error::sns_topic_arn_not_found_fault::Builder {
        crate::error::sns_topic_arn_not_found_fault::Builder::default()
    }
}

/// See [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
pub mod sns_topic_arn_not_found_fault {

    /// A builder for [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
        pub fn build(self) -> crate::error::SnsTopicArnNotFoundFault {
            crate::error::SnsTopicArnNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsNoAuthorizationFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsNoAuthorizationFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsNoAuthorizationFault [SNSNoAuthorizationFault]")?;
        if let Some(inner_64) = &self.message {
            {
                write!(f, ": {}", inner_64)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsNoAuthorizationFault {}
impl aws_http::request_id::RequestId for crate::error::SnsNoAuthorizationFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsNoAuthorizationFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnsNoAuthorizationFault {
    /// Creates a new builder-style object to manufacture [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
    pub fn builder() -> crate::error::sns_no_authorization_fault::Builder {
        crate::error::sns_no_authorization_fault::Builder::default()
    }
}

/// See [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
pub mod sns_no_authorization_fault {

    /// A builder for [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
        pub fn build(self) -> crate::error::SnsNoAuthorizationFault {
            crate::error::SnsNoAuthorizationFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsInvalidTopicFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsInvalidTopicFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsInvalidTopicFault [SNSInvalidTopicFault]")?;
        if let Some(inner_65) = &self.message {
            {
                write!(f, ": {}", inner_65)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsInvalidTopicFault {}
impl aws_http::request_id::RequestId for crate::error::SnsInvalidTopicFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsInvalidTopicFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnsInvalidTopicFault {
    /// Creates a new builder-style object to manufacture [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
    pub fn builder() -> crate::error::sns_invalid_topic_fault::Builder {
        crate::error::sns_invalid_topic_fault::Builder::default()
    }
}

/// See [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
pub mod sns_invalid_topic_fault {

    /// A builder for [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
        pub fn build(self) -> crate::error::SnsInvalidTopicFault {
            crate::error::SnsInvalidTopicFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The subscription request is invalid because it is a duplicate request. This subscription request is already in progress.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSubscriptionStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSubscriptionStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubscriptionStateFault")?;
        if let Some(inner_66) = &self.message {
            {
                write!(f, ": {}", inner_66)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubscriptionStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidSubscriptionStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSubscriptionStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSubscriptionStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidSubscriptionStateFault`](crate::error::InvalidSubscriptionStateFault).
    pub fn builder() -> crate::error::invalid_subscription_state_fault::Builder {
        crate::error::invalid_subscription_state_fault::Builder::default()
    }
}

/// See [`InvalidSubscriptionStateFault`](crate::error::InvalidSubscriptionStateFault).
pub mod invalid_subscription_state_fault {

    /// A builder for [`InvalidSubscriptionStateFault`](crate::error::InvalidSubscriptionStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubscriptionStateFault`](crate::error::InvalidSubscriptionStateFault).
        pub fn build(self) -> crate::error::InvalidSubscriptionStateFault {
            crate::error::InvalidSubscriptionStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyEndpointAccessErrorKind = ModifyEndpointAccessError;
/// Error type for the `ModifyEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyEndpointAccessError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The endpoint name doesn't refer to an existing endpoint.</p>
    EndpointNotFoundFault(crate::error::EndpointNotFoundFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The status of the endpoint is not valid.</p>
    InvalidEndpointStateFault(crate::error::InvalidEndpointStateFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidEndpointStateFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEndpointStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyEndpointAccessError {
    /// Creates the `ModifyEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::EndpointNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidEndpointStateFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::EndpointNotFoundFault`.
    pub fn is_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::EndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::InvalidEndpointStateFault`.
    pub fn is_invalid_endpoint_state_fault(&self) -> bool {
        matches!(self, Self::InvalidEndpointStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEndpointAccessError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for ModifyEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::EndpointNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidEndpointStateFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterSubnetGroupErrorKind = ModifyClusterSubnetGroupError;
/// Error type for the `ModifyClusterSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterSubnetGroupError {
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The request would result in user exceeding the allowed number of subnets in a cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSubnetQuotaExceededFault(crate::error::ClusterSubnetQuotaExceededFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>A specified subnet is already in use by another cluster.</p>
    SubnetAlreadyInUse(crate::error::SubnetAlreadyInUse),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::SubnetAlreadyInUse(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetAlreadyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterSubnetGroupError {
    /// Creates the `ModifyClusterSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::ClusterSubnetQuotaExceededFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::SubnetAlreadyInUse(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::ClusterSubnetQuotaExceededFault`.
    pub fn is_cluster_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::SubnetAlreadyInUse`.
    pub fn is_subnet_already_in_use(&self) -> bool {
        matches!(self, Self::SubnetAlreadyInUse(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSubnetGroupError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for ModifyClusterSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::SubnetAlreadyInUse(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A specified subnet is already in use by another cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetAlreadyInUse {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetAlreadyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetAlreadyInUse")?;
        if let Some(inner_67) = &self.message {
            {
                write!(f, ": {}", inner_67)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetAlreadyInUse {}
impl aws_http::request_id::RequestId for crate::error::SubnetAlreadyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetAlreadyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubnetAlreadyInUse {
    /// Creates a new builder-style object to manufacture [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
    pub fn builder() -> crate::error::subnet_already_in_use::Builder {
        crate::error::subnet_already_in_use::Builder::default()
    }
}

/// See [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
pub mod subnet_already_in_use {

    /// A builder for [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
        pub fn build(self) -> crate::error::SubnetAlreadyInUse {
            crate::error::SubnetAlreadyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request would result in user exceeding the allowed number of subnets in a cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSubnetQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSubnetQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSubnetQuotaExceededFault")?;
        if let Some(inner_68) = &self.message {
            {
                write!(f, ": {}", inner_68)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSubnetQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSubnetQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSubnetQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterSubnetQuotaExceededFault`](crate::error::ClusterSubnetQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_subnet_quota_exceeded_fault::Builder {
        crate::error::cluster_subnet_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterSubnetQuotaExceededFault`](crate::error::ClusterSubnetQuotaExceededFault).
pub mod cluster_subnet_quota_exceeded_fault {

    /// A builder for [`ClusterSubnetQuotaExceededFault`](crate::error::ClusterSubnetQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSubnetQuotaExceededFault`](crate::error::ClusterSubnetQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterSubnetQuotaExceededFault {
            crate::error::ClusterSubnetQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterSnapshotScheduleErrorKind = ModifyClusterSnapshotScheduleError;
/// Error type for the `ModifyClusterSnapshotScheduleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterSnapshotScheduleError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The cluster snapshot schedule state is not valid.</p>
    InvalidClusterSnapshotScheduleStateFault(
        crate::error::InvalidClusterSnapshotScheduleStateFault,
    ),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterSnapshotScheduleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ModifyClusterSnapshotScheduleError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterSnapshotScheduleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterSnapshotScheduleError {
    /// Creates the `ModifyClusterSnapshotScheduleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterSnapshotScheduleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSnapshotScheduleStateFault(e) => e.meta(),
            Self::SnapshotScheduleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotScheduleError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotScheduleError::InvalidClusterSnapshotScheduleStateFault`.
    pub fn is_invalid_cluster_snapshot_schedule_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotScheduleStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotScheduleError::SnapshotScheduleNotFoundFault`.
    pub fn is_snapshot_schedule_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleNotFoundFault(_))
    }
}
impl std::error::Error for ModifyClusterSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => Some(_inner),
            Self::SnapshotScheduleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The cluster snapshot schedule state is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterSnapshotScheduleStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterSnapshotScheduleStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterSnapshotScheduleStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterSnapshotScheduleStateFault")?;
        if let Some(inner_69) = &self.message {
            {
                write!(f, ": {}", inner_69)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterSnapshotScheduleStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterSnapshotScheduleStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidClusterSnapshotScheduleStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterSnapshotScheduleStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterSnapshotScheduleStateFault`](crate::error::InvalidClusterSnapshotScheduleStateFault).
    pub fn builder() -> crate::error::invalid_cluster_snapshot_schedule_state_fault::Builder {
        crate::error::invalid_cluster_snapshot_schedule_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterSnapshotScheduleStateFault`](crate::error::InvalidClusterSnapshotScheduleStateFault).
pub mod invalid_cluster_snapshot_schedule_state_fault {

    /// A builder for [`InvalidClusterSnapshotScheduleStateFault`](crate::error::InvalidClusterSnapshotScheduleStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterSnapshotScheduleStateFault`](crate::error::InvalidClusterSnapshotScheduleStateFault).
        pub fn build(self) -> crate::error::InvalidClusterSnapshotScheduleStateFault {
            crate::error::InvalidClusterSnapshotScheduleStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterSnapshotErrorKind = ModifyClusterSnapshotError;
/// Error type for the `ModifyClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterSnapshotError {
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterSnapshotError {
    /// Creates the `ModifyClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterSnapshotError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
}
impl std::error::Error for ModifyClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterParameterGroupErrorKind = ModifyClusterParameterGroupError;
/// Error type for the `ModifyClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterParameterGroupError {
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The cluster parameter group action can not be completed because another task is in progress that involves the parameter group. Wait a few moments and try the operation again.</p>
    InvalidClusterParameterGroupStateFault(crate::error::InvalidClusterParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterParameterGroupError {
    /// Creates the `ModifyClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterParameterGroupError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterParameterGroupError::InvalidClusterParameterGroupStateFault`.
    pub fn is_invalid_cluster_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterParameterGroupStateFault(_))
    }
}
impl std::error::Error for ModifyClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterMaintenanceErrorKind = ModifyClusterMaintenanceError;
/// Error type for the `ModifyClusterMaintenanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterMaintenanceError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterMaintenanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterMaintenanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterMaintenanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterMaintenanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterMaintenanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterMaintenanceError {
    /// Creates the `ModifyClusterMaintenanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterMaintenanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterMaintenanceError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterMaintenanceError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for ModifyClusterMaintenanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterIamRolesErrorKind = ModifyClusterIamRolesError;
/// Error type for the `ModifyClusterIamRolesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterIamRolesError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterIamRolesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterIamRolesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterIamRolesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterIamRolesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterIamRolesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterIamRolesError {
    /// Creates the `ModifyClusterIamRolesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterIamRolesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterIamRolesError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterIamRolesError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for ModifyClusterIamRolesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterDbRevisionErrorKind = ModifyClusterDbRevisionError;
/// Error type for the `ModifyClusterDbRevisionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterDbRevisionError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>Cluster is already on the latest database revision.</p>
    ClusterOnLatestRevisionFault(crate::error::ClusterOnLatestRevisionFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterDbRevisionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterDbRevisionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterOnLatestRevisionFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterDbRevisionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterOnLatestRevisionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterDbRevisionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterDbRevisionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterDbRevisionError {
    /// Creates the `ModifyClusterDbRevisionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterDbRevisionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterOnLatestRevisionFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterDbRevisionError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterDbRevisionError::ClusterOnLatestRevisionFault`.
    pub fn is_cluster_on_latest_revision_fault(&self) -> bool {
        matches!(self, Self::ClusterOnLatestRevisionFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterDbRevisionError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for ModifyClusterDbRevisionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterOnLatestRevisionFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cluster is already on the latest database revision.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterOnLatestRevisionFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterOnLatestRevisionFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterOnLatestRevisionFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterOnLatestRevisionFault")?;
        if let Some(inner_70) = &self.message {
            {
                write!(f, ": {}", inner_70)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterOnLatestRevisionFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterOnLatestRevisionFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterOnLatestRevisionFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterOnLatestRevisionFault {
    /// Creates a new builder-style object to manufacture [`ClusterOnLatestRevisionFault`](crate::error::ClusterOnLatestRevisionFault).
    pub fn builder() -> crate::error::cluster_on_latest_revision_fault::Builder {
        crate::error::cluster_on_latest_revision_fault::Builder::default()
    }
}

/// See [`ClusterOnLatestRevisionFault`](crate::error::ClusterOnLatestRevisionFault).
pub mod cluster_on_latest_revision_fault {

    /// A builder for [`ClusterOnLatestRevisionFault`](crate::error::ClusterOnLatestRevisionFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterOnLatestRevisionFault`](crate::error::ClusterOnLatestRevisionFault).
        pub fn build(self) -> crate::error::ClusterOnLatestRevisionFault {
            crate::error::ClusterOnLatestRevisionFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyClusterErrorKind = ModifyClusterError;
/// Error type for the `ModifyClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyClusterError {
    /// <p>The account already has a cluster with the given identifier.</p>
    ClusterAlreadyExistsFault(crate::error::ClusterAlreadyExistsFault),
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The provided cluster track name is not valid.</p>
    InvalidClusterTrackFault(crate::error::InvalidClusterTrackFault),
    /// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
    InvalidElasticIpFault(crate::error::InvalidElasticIpFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
    NumberOfNodesPerClusterLimitExceededFault(
        crate::error::NumberOfNodesPerClusterLimitExceededFault,
    ),
    /// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    NumberOfNodesQuotaExceededFault(crate::error::NumberOfNodesQuotaExceededFault),
    /// <p>The number of tables in the cluster exceeds the limit for the requested new cluster node type. </p>
    TableLimitExceededFault(crate::error::TableLimitExceededFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>A request option was specified that is not supported.</p>
    UnsupportedOptionFault(crate::error::UnsupportedOptionFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::HsmClientCertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::HsmConfigurationNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterTrackFault(_inner) => _inner.fmt(f),
            Self::InvalidElasticIpFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TableLimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::UnsupportedOptionFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmClientCertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmConfigurationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterTrackFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidElasticIpFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TableLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOptionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyClusterError {
    /// Creates the `ModifyClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterAlreadyExistsFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::HsmClientCertificateNotFoundFault(e) => e.meta(),
            Self::HsmConfigurationNotFoundFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidClusterTrackFault(e) => e.meta(),
            Self::InvalidElasticIpFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesPerClusterLimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesQuotaExceededFault(e) => e.meta(),
            Self::TableLimitExceededFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::UnsupportedOptionFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyClusterError::ClusterAlreadyExistsFault`.
    pub fn is_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::HsmClientCertificateNotFoundFault`.
    pub fn is_hsm_client_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::HsmConfigurationNotFoundFault`.
    pub fn is_hsm_configuration_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InvalidClusterTrackFault`.
    pub fn is_invalid_cluster_track_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterTrackFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InvalidElasticIpFault`.
    pub fn is_invalid_elastic_ip_fault(&self) -> bool {
        matches!(self, Self::InvalidElasticIpFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::NumberOfNodesPerClusterLimitExceededFault`.
    pub fn is_number_of_nodes_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesPerClusterLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::NumberOfNodesQuotaExceededFault`.
    pub fn is_number_of_nodes_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::TableLimitExceededFault`.
    pub fn is_table_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TableLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
    /// Returns `true` if the error kind is `ModifyClusterError::UnsupportedOptionFault`.
    pub fn is_unsupported_option_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOptionFault(_))
    }
}
impl std::error::Error for ModifyClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::HsmClientCertificateNotFoundFault(_inner) => Some(_inner),
            Self::HsmConfigurationNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidClusterTrackFault(_inner) => Some(_inner),
            Self::InvalidElasticIpFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesQuotaExceededFault(_inner) => Some(_inner),
            Self::TableLimitExceededFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::UnsupportedOptionFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of tables in the cluster exceeds the limit for the requested new cluster node type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TableLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TableLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableLimitExceededFault")?;
        if let Some(inner_71) = &self.message {
            {
                write!(f, ": {}", inner_71)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TableLimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::TableLimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TableLimitExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TableLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`TableLimitExceededFault`](crate::error::TableLimitExceededFault).
    pub fn builder() -> crate::error::table_limit_exceeded_fault::Builder {
        crate::error::table_limit_exceeded_fault::Builder::default()
    }
}

/// See [`TableLimitExceededFault`](crate::error::TableLimitExceededFault).
pub mod table_limit_exceeded_fault {

    /// A builder for [`TableLimitExceededFault`](crate::error::TableLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TableLimitExceededFault`](crate::error::TableLimitExceededFault).
        pub fn build(self) -> crate::error::TableLimitExceededFault {
            crate::error::TableLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyAuthenticationProfileErrorKind = ModifyAuthenticationProfileError;
/// Error type for the `ModifyAuthenticationProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyAuthenticationProfileError {
    /// <p>The authentication profile can't be found.</p>
    AuthenticationProfileNotFoundFault(crate::error::AuthenticationProfileNotFoundFault),
    /// <p>The size or number of authentication profiles has exceeded the quota. The maximum length of the JSON string and maximum number of authentication profiles is determined by a quota for your account.</p>
    AuthenticationProfileQuotaExceededFault(crate::error::AuthenticationProfileQuotaExceededFault),
    /// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
    InvalidAuthenticationProfileRequestFault(
        crate::error::InvalidAuthenticationProfileRequestFault,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyAuthenticationProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyAuthenticationProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => _inner.fmt(f),
            Self::AuthenticationProfileQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyAuthenticationProfileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AuthenticationProfileQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthenticationProfileRequestFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyAuthenticationProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyAuthenticationProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyAuthenticationProfileError {
    /// Creates the `ModifyAuthenticationProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyAuthenticationProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationProfileNotFoundFault(e) => e.meta(),
            Self::AuthenticationProfileQuotaExceededFault(e) => e.meta(),
            Self::InvalidAuthenticationProfileRequestFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyAuthenticationProfileError::AuthenticationProfileNotFoundFault`.
    pub fn is_authentication_profile_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyAuthenticationProfileError::AuthenticationProfileQuotaExceededFault`.
    pub fn is_authentication_profile_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyAuthenticationProfileError::InvalidAuthenticationProfileRequestFault`.
    pub fn is_invalid_authentication_profile_request_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthenticationProfileRequestFault(_))
    }
}
impl std::error::Error for ModifyAuthenticationProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => Some(_inner),
            Self::AuthenticationProfileQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAuthenticationProfileRequestFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAuthenticationProfileRequestFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthenticationProfileRequestFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthenticationProfileRequestFault")?;
        if let Some(inner_72) = &self.message {
            {
                write!(f, ": {}", inner_72)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthenticationProfileRequestFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidAuthenticationProfileRequestFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidAuthenticationProfileRequestFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAuthenticationProfileRequestFault {
    /// Creates a new builder-style object to manufacture [`InvalidAuthenticationProfileRequestFault`](crate::error::InvalidAuthenticationProfileRequestFault).
    pub fn builder() -> crate::error::invalid_authentication_profile_request_fault::Builder {
        crate::error::invalid_authentication_profile_request_fault::Builder::default()
    }
}

/// See [`InvalidAuthenticationProfileRequestFault`](crate::error::InvalidAuthenticationProfileRequestFault).
pub mod invalid_authentication_profile_request_fault {

    /// A builder for [`InvalidAuthenticationProfileRequestFault`](crate::error::InvalidAuthenticationProfileRequestFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthenticationProfileRequestFault`](crate::error::InvalidAuthenticationProfileRequestFault).
        pub fn build(self) -> crate::error::InvalidAuthenticationProfileRequestFault {
            crate::error::InvalidAuthenticationProfileRequestFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The size or number of authentication profiles has exceeded the quota. The maximum length of the JSON string and maximum number of authentication profiles is determined by a quota for your account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationProfileQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthenticationProfileQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthenticationProfileQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthenticationProfileQuotaExceededFault")?;
        if let Some(inner_73) = &self.message {
            {
                write!(f, ": {}", inner_73)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthenticationProfileQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::AuthenticationProfileQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AuthenticationProfileQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthenticationProfileQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`AuthenticationProfileQuotaExceededFault`](crate::error::AuthenticationProfileQuotaExceededFault).
    pub fn builder() -> crate::error::authentication_profile_quota_exceeded_fault::Builder {
        crate::error::authentication_profile_quota_exceeded_fault::Builder::default()
    }
}

/// See [`AuthenticationProfileQuotaExceededFault`](crate::error::AuthenticationProfileQuotaExceededFault).
pub mod authentication_profile_quota_exceeded_fault {

    /// A builder for [`AuthenticationProfileQuotaExceededFault`](crate::error::AuthenticationProfileQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationProfileQuotaExceededFault`](crate::error::AuthenticationProfileQuotaExceededFault).
        pub fn build(self) -> crate::error::AuthenticationProfileQuotaExceededFault {
            crate::error::AuthenticationProfileQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The authentication profile can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationProfileNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthenticationProfileNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthenticationProfileNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthenticationProfileNotFoundFault")?;
        if let Some(inner_74) = &self.message {
            {
                write!(f, ": {}", inner_74)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthenticationProfileNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::AuthenticationProfileNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AuthenticationProfileNotFoundFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthenticationProfileNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthenticationProfileNotFoundFault`](crate::error::AuthenticationProfileNotFoundFault).
    pub fn builder() -> crate::error::authentication_profile_not_found_fault::Builder {
        crate::error::authentication_profile_not_found_fault::Builder::default()
    }
}

/// See [`AuthenticationProfileNotFoundFault`](crate::error::AuthenticationProfileNotFoundFault).
pub mod authentication_profile_not_found_fault {

    /// A builder for [`AuthenticationProfileNotFoundFault`](crate::error::AuthenticationProfileNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationProfileNotFoundFault`](crate::error::AuthenticationProfileNotFoundFault).
        pub fn build(self) -> crate::error::AuthenticationProfileNotFoundFault {
            crate::error::AuthenticationProfileNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyAquaConfigurationErrorKind = ModifyAquaConfigurationError;
/// Error type for the `ModifyAquaConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyAquaConfigurationError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyAquaConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyAquaConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyAquaConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyAquaConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyAquaConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyAquaConfigurationError {
    /// Creates the `ModifyAquaConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyAquaConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyAquaConfigurationError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyAquaConfigurationError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyAquaConfigurationError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for ModifyAquaConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetReservedNodeExchangeOfferingsErrorKind = GetReservedNodeExchangeOfferingsError;
/// Error type for the `GetReservedNodeExchangeOfferingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetReservedNodeExchangeOfferingsError {
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetReservedNodeExchangeOfferingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetReservedNodeExchangeOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::InvalidReservedNodeStateFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetReservedNodeExchangeOfferingsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReservedNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyMigratedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetReservedNodeExchangeOfferingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetReservedNodeExchangeOfferingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetReservedNodeExchangeOfferingsError {
    /// Creates the `GetReservedNodeExchangeOfferingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetReservedNodeExchangeOfferingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::InvalidReservedNodeStateFault(e) => e.meta(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::InvalidReservedNodeStateFault`.
    pub fn is_invalid_reserved_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidReservedNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::ReservedNodeAlreadyMigratedFault`.
    pub fn is_reserved_node_already_migrated_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyMigratedFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeOfferingsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for GetReservedNodeExchangeOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::InvalidReservedNodeStateFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetReservedNodeExchangeConfigurationOptionsErrorKind =
    GetReservedNodeExchangeConfigurationOptionsError;
/// Error type for the `GetReservedNodeExchangeConfigurationOptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetReservedNodeExchangeConfigurationOptionsError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for GetReservedNodeExchangeConfigurationOptionsError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetReservedNodeExchangeConfigurationOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::InvalidReservedNodeStateFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GetReservedNodeExchangeConfigurationOptionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReservedNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyMigratedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::GetReservedNodeExchangeConfigurationOptionsError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for GetReservedNodeExchangeConfigurationOptionsError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetReservedNodeExchangeConfigurationOptionsError {
    /// Creates the `GetReservedNodeExchangeConfigurationOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetReservedNodeExchangeConfigurationOptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::InvalidReservedNodeStateFault(e) => e.meta(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::InvalidReservedNodeStateFault`.
    pub fn is_invalid_reserved_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidReservedNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeAlreadyMigratedFault`.
    pub fn is_reserved_node_already_migrated_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyMigratedFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetReservedNodeExchangeConfigurationOptionsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for GetReservedNodeExchangeConfigurationOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::InvalidReservedNodeStateFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetClusterCredentialsWithIAMErrorKind = GetClusterCredentialsWithIAMError;
/// Error type for the `GetClusterCredentialsWithIAMError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClusterCredentialsWithIAMError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetClusterCredentialsWithIAMError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetClusterCredentialsWithIAMError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetClusterCredentialsWithIAMError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetClusterCredentialsWithIAMError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetClusterCredentialsWithIAMError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClusterCredentialsWithIAMError {
    /// Creates the `GetClusterCredentialsWithIAMError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetClusterCredentialsWithIAMError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetClusterCredentialsWithIAMError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetClusterCredentialsWithIAMError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for GetClusterCredentialsWithIAMError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetClusterCredentialsErrorKind = GetClusterCredentialsError;
/// Error type for the `GetClusterCredentialsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClusterCredentialsError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetClusterCredentialsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetClusterCredentialsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetClusterCredentialsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetClusterCredentialsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetClusterCredentialsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClusterCredentialsError {
    /// Creates the `GetClusterCredentialsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetClusterCredentialsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetClusterCredentialsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `GetClusterCredentialsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for GetClusterCredentialsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableSnapshotCopyErrorKind = EnableSnapshotCopyError;
/// Error type for the `EnableSnapshotCopyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableSnapshotCopyError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
    CopyToRegionDisabledFault(crate::error::CopyToRegionDisabledFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The specified options are incompatible.</p>
    IncompatibleOrderableOptions(crate::error::IncompatibleOrderableOptions),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The cluster already has cross-region snapshot copy enabled.</p>
    SnapshotCopyAlreadyEnabledFault(crate::error::SnapshotCopyAlreadyEnabledFault),
    /// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed correctly and that the grant exists in the destination region.</p>
    SnapshotCopyGrantNotFoundFault(crate::error::SnapshotCopyGrantNotFoundFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>The specified region is incorrect or does not exist.</p>
    UnknownSnapshotCopyRegionFault(crate::error::UnknownSnapshotCopyRegionFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableSnapshotCopyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableSnapshotCopyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::CopyToRegionDisabledFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::IncompatibleOrderableOptions(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyAlreadyEnabledFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::UnknownSnapshotCopyRegionFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableSnapshotCopyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CopyToRegionDisabledFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleOrderableOptions(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyAlreadyEnabledFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyGrantNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnknownSnapshotCopyRegionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableSnapshotCopyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableSnapshotCopyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableSnapshotCopyError {
    /// Creates the `EnableSnapshotCopyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableSnapshotCopyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::CopyToRegionDisabledFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::IncompatibleOrderableOptions(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::SnapshotCopyAlreadyEnabledFault(e) => e.meta(),
            Self::SnapshotCopyGrantNotFoundFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::UnknownSnapshotCopyRegionFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::CopyToRegionDisabledFault`.
    pub fn is_copy_to_region_disabled_fault(&self) -> bool {
        matches!(self, Self::CopyToRegionDisabledFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::IncompatibleOrderableOptions`.
    pub fn is_incompatible_orderable_options(&self) -> bool {
        matches!(self, Self::IncompatibleOrderableOptions(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::SnapshotCopyAlreadyEnabledFault`.
    pub fn is_snapshot_copy_already_enabled_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyAlreadyEnabledFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::SnapshotCopyGrantNotFoundFault`.
    pub fn is_snapshot_copy_grant_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyGrantNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
    /// Returns `true` if the error kind is `EnableSnapshotCopyError::UnknownSnapshotCopyRegionFault`.
    pub fn is_unknown_snapshot_copy_region_fault(&self) -> bool {
        matches!(self, Self::UnknownSnapshotCopyRegionFault(_))
    }
}
impl std::error::Error for EnableSnapshotCopyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::CopyToRegionDisabledFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::IncompatibleOrderableOptions(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::SnapshotCopyAlreadyEnabledFault(_inner) => Some(_inner),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::UnknownSnapshotCopyRegionFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified region is incorrect or does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnknownSnapshotCopyRegionFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnknownSnapshotCopyRegionFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnknownSnapshotCopyRegionFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnknownSnapshotCopyRegionFault")?;
        if let Some(inner_75) = &self.message {
            {
                write!(f, ": {}", inner_75)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnknownSnapshotCopyRegionFault {}
impl aws_http::request_id::RequestId for crate::error::UnknownSnapshotCopyRegionFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnknownSnapshotCopyRegionFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnknownSnapshotCopyRegionFault {
    /// Creates a new builder-style object to manufacture [`UnknownSnapshotCopyRegionFault`](crate::error::UnknownSnapshotCopyRegionFault).
    pub fn builder() -> crate::error::unknown_snapshot_copy_region_fault::Builder {
        crate::error::unknown_snapshot_copy_region_fault::Builder::default()
    }
}

/// See [`UnknownSnapshotCopyRegionFault`](crate::error::UnknownSnapshotCopyRegionFault).
pub mod unknown_snapshot_copy_region_fault {

    /// A builder for [`UnknownSnapshotCopyRegionFault`](crate::error::UnknownSnapshotCopyRegionFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnknownSnapshotCopyRegionFault`](crate::error::UnknownSnapshotCopyRegionFault).
        pub fn build(self) -> crate::error::UnknownSnapshotCopyRegionFault {
            crate::error::UnknownSnapshotCopyRegionFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed correctly and that the grant exists in the destination region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyGrantNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyGrantNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyGrantNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyGrantNotFoundFault")?;
        if let Some(inner_76) = &self.message {
            {
                write!(f, ": {}", inner_76)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyGrantNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyGrantNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotCopyGrantNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyGrantNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyGrantNotFoundFault`](crate::error::SnapshotCopyGrantNotFoundFault).
    pub fn builder() -> crate::error::snapshot_copy_grant_not_found_fault::Builder {
        crate::error::snapshot_copy_grant_not_found_fault::Builder::default()
    }
}

/// See [`SnapshotCopyGrantNotFoundFault`](crate::error::SnapshotCopyGrantNotFoundFault).
pub mod snapshot_copy_grant_not_found_fault {

    /// A builder for [`SnapshotCopyGrantNotFoundFault`](crate::error::SnapshotCopyGrantNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyGrantNotFoundFault`](crate::error::SnapshotCopyGrantNotFoundFault).
        pub fn build(self) -> crate::error::SnapshotCopyGrantNotFoundFault {
            crate::error::SnapshotCopyGrantNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The cluster already has cross-region snapshot copy enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyAlreadyEnabledFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyAlreadyEnabledFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyAlreadyEnabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyAlreadyEnabledFault")?;
        if let Some(inner_77) = &self.message {
            {
                write!(f, ": {}", inner_77)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyAlreadyEnabledFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyAlreadyEnabledFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotCopyAlreadyEnabledFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyAlreadyEnabledFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyAlreadyEnabledFault`](crate::error::SnapshotCopyAlreadyEnabledFault).
    pub fn builder() -> crate::error::snapshot_copy_already_enabled_fault::Builder {
        crate::error::snapshot_copy_already_enabled_fault::Builder::default()
    }
}

/// See [`SnapshotCopyAlreadyEnabledFault`](crate::error::SnapshotCopyAlreadyEnabledFault).
pub mod snapshot_copy_already_enabled_fault {

    /// A builder for [`SnapshotCopyAlreadyEnabledFault`](crate::error::SnapshotCopyAlreadyEnabledFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyAlreadyEnabledFault`](crate::error::SnapshotCopyAlreadyEnabledFault).
        pub fn build(self) -> crate::error::SnapshotCopyAlreadyEnabledFault {
            crate::error::SnapshotCopyAlreadyEnabledFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified options are incompatible.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncompatibleOrderableOptions {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IncompatibleOrderableOptions {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleOrderableOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncompatibleOrderableOptions")?;
        if let Some(inner_78) = &self.message {
            {
                write!(f, ": {}", inner_78)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleOrderableOptions {}
impl aws_http::request_id::RequestId for crate::error::IncompatibleOrderableOptions {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IncompatibleOrderableOptions {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IncompatibleOrderableOptions {
    /// Creates a new builder-style object to manufacture [`IncompatibleOrderableOptions`](crate::error::IncompatibleOrderableOptions).
    pub fn builder() -> crate::error::incompatible_orderable_options::Builder {
        crate::error::incompatible_orderable_options::Builder::default()
    }
}

/// See [`IncompatibleOrderableOptions`](crate::error::IncompatibleOrderableOptions).
pub mod incompatible_orderable_options {

    /// A builder for [`IncompatibleOrderableOptions`](crate::error::IncompatibleOrderableOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleOrderableOptions`](crate::error::IncompatibleOrderableOptions).
        pub fn build(self) -> crate::error::IncompatibleOrderableOptions {
            crate::error::IncompatibleOrderableOptions {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Cross-region snapshot copy was temporarily disabled. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CopyToRegionDisabledFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CopyToRegionDisabledFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CopyToRegionDisabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CopyToRegionDisabledFault")?;
        if let Some(inner_79) = &self.message {
            {
                write!(f, ": {}", inner_79)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CopyToRegionDisabledFault {}
impl aws_http::request_id::RequestId for crate::error::CopyToRegionDisabledFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyToRegionDisabledFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl CopyToRegionDisabledFault {
    /// Creates a new builder-style object to manufacture [`CopyToRegionDisabledFault`](crate::error::CopyToRegionDisabledFault).
    pub fn builder() -> crate::error::copy_to_region_disabled_fault::Builder {
        crate::error::copy_to_region_disabled_fault::Builder::default()
    }
}

/// See [`CopyToRegionDisabledFault`](crate::error::CopyToRegionDisabledFault).
pub mod copy_to_region_disabled_fault {

    /// A builder for [`CopyToRegionDisabledFault`](crate::error::CopyToRegionDisabledFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CopyToRegionDisabledFault`](crate::error::CopyToRegionDisabledFault).
        pub fn build(self) -> crate::error::CopyToRegionDisabledFault {
            crate::error::CopyToRegionDisabledFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EnableLoggingErrorKind = EnableLoggingError;
/// Error type for the `EnableLoggingError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableLoggingError {
    /// <p>Could not find the specified S3 bucket.</p>
    BucketNotFoundFault(crate::error::BucketNotFoundFault),
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The cluster does not have read bucket or put object permissions on the S3 bucket specified when enabling logging.</p>
    InsufficientS3BucketPolicyFault(crate::error::InsufficientS3BucketPolicyFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The S3 bucket name is invalid. For more information about naming rules, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3) Developer Guide.</p>
    InvalidS3BucketNameFault(crate::error::InvalidS3BucketNameFault),
    /// <p>The string specified for the logging S3 key prefix does not comply with the documented constraints.</p>
    InvalidS3KeyPrefixFault(crate::error::InvalidS3KeyPrefixFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EnableLoggingError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EnableLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BucketNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientS3BucketPolicyFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidS3BucketNameFault(_inner) => _inner.fmt(f),
            Self::InvalidS3KeyPrefixFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EnableLoggingError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BucketNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientS3BucketPolicyFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidS3BucketNameFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidS3KeyPrefixFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EnableLoggingError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EnableLoggingError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableLoggingError {
    /// Creates the `EnableLoggingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EnableLoggingError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BucketNotFoundFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InsufficientS3BucketPolicyFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidS3BucketNameFault(e) => e.meta(),
            Self::InvalidS3KeyPrefixFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EnableLoggingError::BucketNotFoundFault`.
    pub fn is_bucket_not_found_fault(&self) -> bool {
        matches!(self, Self::BucketNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `EnableLoggingError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `EnableLoggingError::InsufficientS3BucketPolicyFault`.
    pub fn is_insufficient_s3_bucket_policy_fault(&self) -> bool {
        matches!(self, Self::InsufficientS3BucketPolicyFault(_))
    }
    /// Returns `true` if the error kind is `EnableLoggingError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `EnableLoggingError::InvalidS3BucketNameFault`.
    pub fn is_invalid_s3_bucket_name_fault(&self) -> bool {
        matches!(self, Self::InvalidS3BucketNameFault(_))
    }
    /// Returns `true` if the error kind is `EnableLoggingError::InvalidS3KeyPrefixFault`.
    pub fn is_invalid_s3_key_prefix_fault(&self) -> bool {
        matches!(self, Self::InvalidS3KeyPrefixFault(_))
    }
}
impl std::error::Error for EnableLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BucketNotFoundFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientS3BucketPolicyFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidS3BucketNameFault(_inner) => Some(_inner),
            Self::InvalidS3KeyPrefixFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The string specified for the logging S3 key prefix does not comply with the documented constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidS3KeyPrefixFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidS3KeyPrefixFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3KeyPrefixFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3KeyPrefixFault")?;
        if let Some(inner_80) = &self.message {
            {
                write!(f, ": {}", inner_80)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3KeyPrefixFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidS3KeyPrefixFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidS3KeyPrefixFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidS3KeyPrefixFault {
    /// Creates a new builder-style object to manufacture [`InvalidS3KeyPrefixFault`](crate::error::InvalidS3KeyPrefixFault).
    pub fn builder() -> crate::error::invalid_s3_key_prefix_fault::Builder {
        crate::error::invalid_s3_key_prefix_fault::Builder::default()
    }
}

/// See [`InvalidS3KeyPrefixFault`](crate::error::InvalidS3KeyPrefixFault).
pub mod invalid_s3_key_prefix_fault {

    /// A builder for [`InvalidS3KeyPrefixFault`](crate::error::InvalidS3KeyPrefixFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3KeyPrefixFault`](crate::error::InvalidS3KeyPrefixFault).
        pub fn build(self) -> crate::error::InvalidS3KeyPrefixFault {
            crate::error::InvalidS3KeyPrefixFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The S3 bucket name is invalid. For more information about naming rules, go to <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html">Bucket Restrictions and Limitations</a> in the Amazon Simple Storage Service (S3) Developer Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidS3BucketNameFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidS3BucketNameFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidS3BucketNameFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidS3BucketNameFault")?;
        if let Some(inner_81) = &self.message {
            {
                write!(f, ": {}", inner_81)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidS3BucketNameFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidS3BucketNameFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidS3BucketNameFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidS3BucketNameFault {
    /// Creates a new builder-style object to manufacture [`InvalidS3BucketNameFault`](crate::error::InvalidS3BucketNameFault).
    pub fn builder() -> crate::error::invalid_s3_bucket_name_fault::Builder {
        crate::error::invalid_s3_bucket_name_fault::Builder::default()
    }
}

/// See [`InvalidS3BucketNameFault`](crate::error::InvalidS3BucketNameFault).
pub mod invalid_s3_bucket_name_fault {

    /// A builder for [`InvalidS3BucketNameFault`](crate::error::InvalidS3BucketNameFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidS3BucketNameFault`](crate::error::InvalidS3BucketNameFault).
        pub fn build(self) -> crate::error::InvalidS3BucketNameFault {
            crate::error::InvalidS3BucketNameFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The cluster does not have read bucket or put object permissions on the S3 bucket specified when enabling logging.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientS3BucketPolicyFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientS3BucketPolicyFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientS3BucketPolicyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientS3BucketPolicyFault")?;
        if let Some(inner_82) = &self.message {
            {
                write!(f, ": {}", inner_82)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientS3BucketPolicyFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientS3BucketPolicyFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InsufficientS3BucketPolicyFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InsufficientS3BucketPolicyFault {
    /// Creates a new builder-style object to manufacture [`InsufficientS3BucketPolicyFault`](crate::error::InsufficientS3BucketPolicyFault).
    pub fn builder() -> crate::error::insufficient_s3_bucket_policy_fault::Builder {
        crate::error::insufficient_s3_bucket_policy_fault::Builder::default()
    }
}

/// See [`InsufficientS3BucketPolicyFault`](crate::error::InsufficientS3BucketPolicyFault).
pub mod insufficient_s3_bucket_policy_fault {

    /// A builder for [`InsufficientS3BucketPolicyFault`](crate::error::InsufficientS3BucketPolicyFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientS3BucketPolicyFault`](crate::error::InsufficientS3BucketPolicyFault).
        pub fn build(self) -> crate::error::InsufficientS3BucketPolicyFault {
            crate::error::InsufficientS3BucketPolicyFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Could not find the specified S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BucketNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BucketNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BucketNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BucketNotFoundFault")?;
        if let Some(inner_83) = &self.message {
            {
                write!(f, ": {}", inner_83)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BucketNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::BucketNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BucketNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BucketNotFoundFault {
    /// Creates a new builder-style object to manufacture [`BucketNotFoundFault`](crate::error::BucketNotFoundFault).
    pub fn builder() -> crate::error::bucket_not_found_fault::Builder {
        crate::error::bucket_not_found_fault::Builder::default()
    }
}

/// See [`BucketNotFoundFault`](crate::error::BucketNotFoundFault).
pub mod bucket_not_found_fault {

    /// A builder for [`BucketNotFoundFault`](crate::error::BucketNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BucketNotFoundFault`](crate::error::BucketNotFoundFault).
        pub fn build(self) -> crate::error::BucketNotFoundFault {
            crate::error::BucketNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisassociateDataShareConsumerErrorKind = DisassociateDataShareConsumerError;
/// Error type for the `DisassociateDataShareConsumerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateDataShareConsumerError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
    InvalidNamespaceFault(crate::error::InvalidNamespaceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateDataShareConsumerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisassociateDataShareConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::InvalidNamespaceFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DisassociateDataShareConsumerError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNamespaceFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisassociateDataShareConsumerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateDataShareConsumerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateDataShareConsumerError {
    /// Creates the `DisassociateDataShareConsumerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisassociateDataShareConsumerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::InvalidNamespaceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisassociateDataShareConsumerError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
    /// Returns `true` if the error kind is `DisassociateDataShareConsumerError::InvalidNamespaceFault`.
    pub fn is_invalid_namespace_fault(&self) -> bool {
        matches!(self, Self::InvalidNamespaceFault(_))
    }
}
impl std::error::Error for DisassociateDataShareConsumerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::InvalidNamespaceFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNamespaceFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidNamespaceFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNamespaceFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNamespaceFault")?;
        if let Some(inner_84) = &self.message {
            {
                write!(f, ": {}", inner_84)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNamespaceFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidNamespaceFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidNamespaceFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidNamespaceFault {
    /// Creates a new builder-style object to manufacture [`InvalidNamespaceFault`](crate::error::InvalidNamespaceFault).
    pub fn builder() -> crate::error::invalid_namespace_fault::Builder {
        crate::error::invalid_namespace_fault::Builder::default()
    }
}

/// See [`InvalidNamespaceFault`](crate::error::InvalidNamespaceFault).
pub mod invalid_namespace_fault {

    /// A builder for [`InvalidNamespaceFault`](crate::error::InvalidNamespaceFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNamespaceFault`](crate::error::InvalidNamespaceFault).
        pub fn build(self) -> crate::error::InvalidNamespaceFault {
            crate::error::InvalidNamespaceFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableSnapshotCopyErrorKind = DisableSnapshotCopyError;
/// Error type for the `DisableSnapshotCopyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableSnapshotCopyError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The cluster already has cross-region snapshot copy disabled.</p>
    SnapshotCopyAlreadyDisabledFault(crate::error::SnapshotCopyAlreadyDisabledFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableSnapshotCopyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableSnapshotCopyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyAlreadyDisabledFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableSnapshotCopyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyAlreadyDisabledFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableSnapshotCopyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableSnapshotCopyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableSnapshotCopyError {
    /// Creates the `DisableSnapshotCopyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableSnapshotCopyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::SnapshotCopyAlreadyDisabledFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableSnapshotCopyError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DisableSnapshotCopyError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DisableSnapshotCopyError::SnapshotCopyAlreadyDisabledFault`.
    pub fn is_snapshot_copy_already_disabled_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyAlreadyDisabledFault(_))
    }
    /// Returns `true` if the error kind is `DisableSnapshotCopyError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for DisableSnapshotCopyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::SnapshotCopyAlreadyDisabledFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The cluster already has cross-region snapshot copy disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyAlreadyDisabledFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyAlreadyDisabledFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyAlreadyDisabledFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyAlreadyDisabledFault")?;
        if let Some(inner_85) = &self.message {
            {
                write!(f, ": {}", inner_85)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyAlreadyDisabledFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyAlreadyDisabledFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotCopyAlreadyDisabledFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyAlreadyDisabledFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyAlreadyDisabledFault`](crate::error::SnapshotCopyAlreadyDisabledFault).
    pub fn builder() -> crate::error::snapshot_copy_already_disabled_fault::Builder {
        crate::error::snapshot_copy_already_disabled_fault::Builder::default()
    }
}

/// See [`SnapshotCopyAlreadyDisabledFault`](crate::error::SnapshotCopyAlreadyDisabledFault).
pub mod snapshot_copy_already_disabled_fault {

    /// A builder for [`SnapshotCopyAlreadyDisabledFault`](crate::error::SnapshotCopyAlreadyDisabledFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyAlreadyDisabledFault`](crate::error::SnapshotCopyAlreadyDisabledFault).
        pub fn build(self) -> crate::error::SnapshotCopyAlreadyDisabledFault {
            crate::error::SnapshotCopyAlreadyDisabledFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisableLoggingErrorKind = DisableLoggingError;
/// Error type for the `DisableLoggingError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableLoggingError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisableLoggingError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisableLoggingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisableLoggingError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisableLoggingError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisableLoggingError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableLoggingError {
    /// Creates the `DisableLoggingError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisableLoggingError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisableLoggingError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DisableLoggingError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for DisableLoggingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeUsageLimitsErrorKind = DescribeUsageLimitsError;
/// Error type for the `DescribeUsageLimitsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUsageLimitsError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeUsageLimitsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeUsageLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeUsageLimitsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeUsageLimitsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeUsageLimitsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUsageLimitsError {
    /// Creates the `DescribeUsageLimitsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeUsageLimitsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeUsageLimitsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeUsageLimitsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeUsageLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeTagsErrorKind = DescribeTagsError;
/// Error type for the `DescribeTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTagsError {
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The resource could not be found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTagsError {
    /// Creates the `DescribeTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidTagFault(e) => e.meta(),
            Self::ResourceNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeTagsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `DescribeTagsError::ResourceNotFoundFault`.
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(self, Self::ResourceNotFoundFault(_))
    }
}
impl std::error::Error for DescribeTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::ResourceNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The resource could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundFault")?;
        if let Some(inner_86) = &self.message {
            {
                write!(f, ": {}", inner_86)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ResourceNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
    pub fn builder() -> crate::error::resource_not_found_fault::Builder {
        crate::error::resource_not_found_fault::Builder::default()
    }
}

/// See [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
pub mod resource_not_found_fault {

    /// A builder for [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
        pub fn build(self) -> crate::error::ResourceNotFoundFault {
            crate::error::ResourceNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeTableRestoreStatusErrorKind = DescribeTableRestoreStatusError;
/// Error type for the `DescribeTableRestoreStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTableRestoreStatusError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
    TableRestoreNotFoundFault(crate::error::TableRestoreNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeTableRestoreStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeTableRestoreStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::TableRestoreNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeTableRestoreStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TableRestoreNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeTableRestoreStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeTableRestoreStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTableRestoreStatusError {
    /// Creates the `DescribeTableRestoreStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeTableRestoreStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::TableRestoreNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeTableRestoreStatusError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeTableRestoreStatusError::TableRestoreNotFoundFault`.
    pub fn is_table_restore_not_found_fault(&self) -> bool {
        matches!(self, Self::TableRestoreNotFoundFault(_))
    }
}
impl std::error::Error for DescribeTableRestoreStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::TableRestoreNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified <code>TableRestoreRequestId</code> value was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TableRestoreNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TableRestoreNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TableRestoreNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableRestoreNotFoundFault")?;
        if let Some(inner_87) = &self.message {
            {
                write!(f, ": {}", inner_87)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TableRestoreNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::TableRestoreNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TableRestoreNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TableRestoreNotFoundFault {
    /// Creates a new builder-style object to manufacture [`TableRestoreNotFoundFault`](crate::error::TableRestoreNotFoundFault).
    pub fn builder() -> crate::error::table_restore_not_found_fault::Builder {
        crate::error::table_restore_not_found_fault::Builder::default()
    }
}

/// See [`TableRestoreNotFoundFault`](crate::error::TableRestoreNotFoundFault).
pub mod table_restore_not_found_fault {

    /// A builder for [`TableRestoreNotFoundFault`](crate::error::TableRestoreNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TableRestoreNotFoundFault`](crate::error::TableRestoreNotFoundFault).
        pub fn build(self) -> crate::error::TableRestoreNotFoundFault {
            crate::error::TableRestoreNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeStorageErrorKind = DescribeStorageError;
/// Error type for the `DescribeStorageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStorageError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeStorageError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeStorageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeStorageError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeStorageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStorageError {
    /// Creates the `DescribeStorageError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeStorageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeStorageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSnapshotSchedulesErrorKind = DescribeSnapshotSchedulesError;
/// Error type for the `DescribeSnapshotSchedulesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotSchedulesError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSnapshotSchedulesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSnapshotSchedulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSnapshotSchedulesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSnapshotSchedulesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSnapshotSchedulesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotSchedulesError {
    /// Creates the `DescribeSnapshotSchedulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSnapshotSchedulesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeSnapshotSchedulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSnapshotCopyGrantsErrorKind = DescribeSnapshotCopyGrantsError;
/// Error type for the `DescribeSnapshotCopyGrantsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotCopyGrantsError {
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed correctly and that the grant exists in the destination region.</p>
    SnapshotCopyGrantNotFoundFault(crate::error::SnapshotCopyGrantNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSnapshotCopyGrantsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSnapshotCopyGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSnapshotCopyGrantsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyGrantNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSnapshotCopyGrantsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSnapshotCopyGrantsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotCopyGrantsError {
    /// Creates the `DescribeSnapshotCopyGrantsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSnapshotCopyGrantsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidTagFault(e) => e.meta(),
            Self::SnapshotCopyGrantNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSnapshotCopyGrantsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotCopyGrantsError::SnapshotCopyGrantNotFoundFault`.
    pub fn is_snapshot_copy_grant_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyGrantNotFoundFault(_))
    }
}
impl std::error::Error for DescribeSnapshotCopyGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeScheduledActionsErrorKind = DescribeScheduledActionsError;
/// Error type for the `DescribeScheduledActionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeScheduledActionsError {
    /// <p>The scheduled action cannot be found. </p>
    ScheduledActionNotFoundFault(crate::error::ScheduledActionNotFoundFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeScheduledActionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeScheduledActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeScheduledActionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeScheduledActionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeScheduledActionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeScheduledActionsError {
    /// Creates the `DescribeScheduledActionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeScheduledActionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ScheduledActionNotFoundFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeScheduledActionsError::ScheduledActionNotFoundFault`.
    pub fn is_scheduled_action_not_found_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeScheduledActionsError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for DescribeScheduledActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeResizeErrorKind = DescribeResizeError;
/// Error type for the `DescribeResizeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResizeError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>A resize operation for the specified cluster is not found.</p>
    ResizeNotFoundFault(crate::error::ResizeNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeResizeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeResizeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ResizeNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeResizeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResizeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeResizeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeResizeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResizeError {
    /// Creates the `DescribeResizeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeResizeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ResizeNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeResizeError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeResizeError::ResizeNotFoundFault`.
    pub fn is_resize_not_found_fault(&self) -> bool {
        matches!(self, Self::ResizeNotFoundFault(_))
    }
}
impl std::error::Error for DescribeResizeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ResizeNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A resize operation for the specified cluster is not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResizeNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResizeNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResizeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResizeNotFoundFault")?;
        if let Some(inner_88) = &self.message {
            {
                write!(f, ": {}", inner_88)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResizeNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ResizeNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResizeNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResizeNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ResizeNotFoundFault`](crate::error::ResizeNotFoundFault).
    pub fn builder() -> crate::error::resize_not_found_fault::Builder {
        crate::error::resize_not_found_fault::Builder::default()
    }
}

/// See [`ResizeNotFoundFault`](crate::error::ResizeNotFoundFault).
pub mod resize_not_found_fault {

    /// A builder for [`ResizeNotFoundFault`](crate::error::ResizeNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResizeNotFoundFault`](crate::error::ResizeNotFoundFault).
        pub fn build(self) -> crate::error::ResizeNotFoundFault {
            crate::error::ResizeNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeReservedNodesErrorKind = DescribeReservedNodesError;
/// Error type for the `DescribeReservedNodesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedNodesError {
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedNodesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeReservedNodesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeReservedNodesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedNodesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedNodesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedNodesError {
    /// Creates the `DescribeReservedNodesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeReservedNodesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodesError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
}
impl std::error::Error for DescribeReservedNodesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeReservedNodeOfferingsErrorKind = DescribeReservedNodeOfferingsError;
/// Error type for the `DescribeReservedNodeOfferingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedNodeOfferingsError {
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedNodeOfferingsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeReservedNodeOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeReservedNodeOfferingsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedNodeOfferingsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedNodeOfferingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedNodeOfferingsError {
    /// Creates the `DescribeReservedNodeOfferingsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeReservedNodeOfferingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeOfferingsError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeOfferingsError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeOfferingsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeReservedNodeOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeReservedNodeExchangeStatusErrorKind = DescribeReservedNodeExchangeStatusError;
/// Error type for the `DescribeReservedNodeExchangeStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedNodeExchangeStatusError {
    /// <p>The reserved-node exchange status wasn't found.</p>
    ReservedNodeExchangeNotFoundFault(crate::error::ReservedNodeExchangeNotFoundFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedNodeExchangeStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeReservedNodeExchangeStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ReservedNodeExchangeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeReservedNodeExchangeStatusError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ReservedNodeExchangeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedNodeExchangeStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedNodeExchangeStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedNodeExchangeStatusError {
    /// Creates the `DescribeReservedNodeExchangeStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeReservedNodeExchangeStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ReservedNodeExchangeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeExchangeStatusError::ReservedNodeExchangeNotFoundFault`.
    pub fn is_reserved_node_exchange_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeExchangeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeExchangeStatusError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedNodeExchangeStatusError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeReservedNodeExchangeStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ReservedNodeExchangeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The reserved-node exchange status wasn't found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReservedNodeExchangeNotFoundFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReservedNodeExchangeNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedNodeExchangeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedNodeExchangeNotFoundFault")?;
        if let Some(inner_89) = &self.message {
            {
                write!(f, ": {}", inner_89)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReservedNodeExchangeNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ReservedNodeExchangeNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReservedNodeExchangeNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ReservedNodeExchangeNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedNodeExchangeNotFoundFault`](crate::error::ReservedNodeExchangeNotFoundFault).
    pub fn builder() -> crate::error::reserved_node_exchange_not_found_fault::Builder {
        crate::error::reserved_node_exchange_not_found_fault::Builder::default()
    }
}

/// See [`ReservedNodeExchangeNotFoundFault`](crate::error::ReservedNodeExchangeNotFoundFault).
pub mod reserved_node_exchange_not_found_fault {

    /// A builder for [`ReservedNodeExchangeNotFoundFault`](crate::error::ReservedNodeExchangeNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeExchangeNotFoundFault`](crate::error::ReservedNodeExchangeNotFoundFault).
        pub fn build(self) -> crate::error::ReservedNodeExchangeNotFoundFault {
            crate::error::ReservedNodeExchangeNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribePartnersErrorKind = DescribePartnersError;
/// Error type for the `DescribePartnersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePartnersError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The partner integration is not authorized.</p>
    UnauthorizedPartnerIntegrationFault(crate::error::UnauthorizedPartnerIntegrationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePartnersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribePartnersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribePartnersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedPartnerIntegrationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribePartnersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePartnersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePartnersError {
    /// Creates the `DescribePartnersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribePartnersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::UnauthorizedPartnerIntegrationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribePartnersError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribePartnersError::UnauthorizedPartnerIntegrationFault`.
    pub fn is_unauthorized_partner_integration_fault(&self) -> bool {
        matches!(self, Self::UnauthorizedPartnerIntegrationFault(_))
    }
}
impl std::error::Error for DescribePartnersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeOrderableClusterOptionsErrorKind = DescribeOrderableClusterOptionsError;
/// Error type for the `DescribeOrderableClusterOptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrderableClusterOptionsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeOrderableClusterOptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeOrderableClusterOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeOrderableClusterOptionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeOrderableClusterOptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeOrderableClusterOptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrderableClusterOptionsError {
    /// Creates the `DescribeOrderableClusterOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeOrderableClusterOptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeOrderableClusterOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeNodeConfigurationOptionsErrorKind = DescribeNodeConfigurationOptionsError;
/// Error type for the `DescribeNodeConfigurationOptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeNodeConfigurationOptionsError {
    /// <p>The owner of the specified snapshot has not authorized your account to access the snapshot.</p>
    AccessToSnapshotDeniedFault(crate::error::AccessToSnapshotDeniedFault),
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeNodeConfigurationOptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeNodeConfigurationOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeNodeConfigurationOptionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeNodeConfigurationOptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeNodeConfigurationOptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeNodeConfigurationOptionsError {
    /// Creates the `DescribeNodeConfigurationOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeNodeConfigurationOptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessToSnapshotDeniedFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeNodeConfigurationOptionsError::AccessToSnapshotDeniedFault`.
    pub fn is_access_to_snapshot_denied_fault(&self) -> bool {
        matches!(self, Self::AccessToSnapshotDeniedFault(_))
    }
    /// Returns `true` if the error kind is `DescribeNodeConfigurationOptionsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeNodeConfigurationOptionsError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeNodeConfigurationOptionsError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `DescribeNodeConfigurationOptionsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeNodeConfigurationOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessToSnapshotDeniedFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeLoggingStatusErrorKind = DescribeLoggingStatusError;
/// Error type for the `DescribeLoggingStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLoggingStatusError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeLoggingStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeLoggingStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeLoggingStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeLoggingStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeLoggingStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLoggingStatusError {
    /// Creates the `DescribeLoggingStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeLoggingStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeLoggingStatusError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
}
impl std::error::Error for DescribeLoggingStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeHsmConfigurationsErrorKind = DescribeHsmConfigurationsError;
/// Error type for the `DescribeHsmConfigurationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHsmConfigurationsError {
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeHsmConfigurationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeHsmConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeHsmConfigurationsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeHsmConfigurationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeHsmConfigurationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHsmConfigurationsError {
    /// Creates the `DescribeHsmConfigurationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeHsmConfigurationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmConfigurationNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeHsmConfigurationsError::HsmConfigurationNotFoundFault`.
    pub fn is_hsm_configuration_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeHsmConfigurationsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeHsmConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeHsmClientCertificatesErrorKind = DescribeHsmClientCertificatesError;
/// Error type for the `DescribeHsmClientCertificatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHsmClientCertificatesError {
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeHsmClientCertificatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeHsmClientCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeHsmClientCertificatesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeHsmClientCertificatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeHsmClientCertificatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHsmClientCertificatesError {
    /// Creates the `DescribeHsmClientCertificatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeHsmClientCertificatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmClientCertificateNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeHsmClientCertificatesError::HsmClientCertificateNotFoundFault`.
    pub fn is_hsm_client_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeHsmClientCertificatesError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeHsmClientCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventSubscriptionsErrorKind = DescribeEventSubscriptionsError;
/// Error type for the `DescribeEventSubscriptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventSubscriptionsError {
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>An Amazon Redshift event notification subscription with the specified name does not exist.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventSubscriptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventSubscriptionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventSubscriptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventSubscriptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventSubscriptionsError {
    /// Creates the `DescribeEventSubscriptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventSubscriptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidTagFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEventSubscriptionsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `DescribeEventSubscriptionsError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for DescribeEventSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventsErrorKind = DescribeEventsError;
/// Error type for the `DescribeEventsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    /// Creates the `DescribeEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventCategoriesErrorKind = DescribeEventCategoriesError;
/// Error type for the `DescribeEventCategoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventCategoriesError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventCategoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventCategoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventCategoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventCategoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventCategoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventCategoriesError {
    /// Creates the `DescribeEventCategoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventCategoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEventCategoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEndpointAuthorizationErrorKind = DescribeEndpointAuthorizationError;
/// Error type for the `DescribeEndpointAuthorizationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEndpointAuthorizationError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEndpointAuthorizationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEndpointAuthorizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeEndpointAuthorizationError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEndpointAuthorizationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEndpointAuthorizationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEndpointAuthorizationError {
    /// Creates the `DescribeEndpointAuthorizationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEndpointAuthorizationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEndpointAuthorizationError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeEndpointAuthorizationError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeEndpointAuthorizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEndpointAccessErrorKind = DescribeEndpointAccessError;
/// Error type for the `DescribeEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEndpointAccessError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The endpoint name doesn't refer to an existing endpoint.</p>
    EndpointNotFoundFault(crate::error::EndpointNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEndpointAccessError {
    /// Creates the `DescribeEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::EndpointNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeEndpointAccessError::EndpointNotFoundFault`.
    pub fn is_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::EndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for DescribeEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::EndpointNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDefaultClusterParametersErrorKind = DescribeDefaultClusterParametersError;
/// Error type for the `DescribeDefaultClusterParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDefaultClusterParametersError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDefaultClusterParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDefaultClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDefaultClusterParametersError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDefaultClusterParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDefaultClusterParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDefaultClusterParametersError {
    /// Creates the `DescribeDefaultClusterParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDefaultClusterParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeDefaultClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDataSharesForProducerErrorKind = DescribeDataSharesForProducerError;
/// Error type for the `DescribeDataSharesForProducerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSharesForProducerError {
    /// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
    InvalidNamespaceFault(crate::error::InvalidNamespaceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDataSharesForProducerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDataSharesForProducerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNamespaceFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDataSharesForProducerError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNamespaceFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDataSharesForProducerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDataSharesForProducerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSharesForProducerError {
    /// Creates the `DescribeDataSharesForProducerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDataSharesForProducerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNamespaceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDataSharesForProducerError::InvalidNamespaceFault`.
    pub fn is_invalid_namespace_fault(&self) -> bool {
        matches!(self, Self::InvalidNamespaceFault(_))
    }
}
impl std::error::Error for DescribeDataSharesForProducerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNamespaceFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDataSharesForConsumerErrorKind = DescribeDataSharesForConsumerError;
/// Error type for the `DescribeDataSharesForConsumerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSharesForConsumerError {
    /// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
    InvalidNamespaceFault(crate::error::InvalidNamespaceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDataSharesForConsumerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDataSharesForConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNamespaceFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDataSharesForConsumerError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNamespaceFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDataSharesForConsumerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDataSharesForConsumerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSharesForConsumerError {
    /// Creates the `DescribeDataSharesForConsumerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDataSharesForConsumerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNamespaceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDataSharesForConsumerError::InvalidNamespaceFault`.
    pub fn is_invalid_namespace_fault(&self) -> bool {
        matches!(self, Self::InvalidNamespaceFault(_))
    }
}
impl std::error::Error for DescribeDataSharesForConsumerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNamespaceFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDataSharesErrorKind = DescribeDataSharesError;
/// Error type for the `DescribeDataSharesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataSharesError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDataSharesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDataSharesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDataSharesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDataSharesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDataSharesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataSharesError {
    /// Creates the `DescribeDataSharesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDataSharesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDataSharesError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
}
impl std::error::Error for DescribeDataSharesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterVersionsErrorKind = DescribeClusterVersionsError;
/// Error type for the `DescribeClusterVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterVersionsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterVersionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterVersionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterVersionsError {
    /// Creates the `DescribeClusterVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeClusterVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterTracksErrorKind = DescribeClusterTracksError;
/// Error type for the `DescribeClusterTracksError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterTracksError {
    /// <p>The provided cluster track name is not valid.</p>
    InvalidClusterTrackFault(crate::error::InvalidClusterTrackFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterTracksError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterTracksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidClusterTrackFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterTracksError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidClusterTrackFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterTracksError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterTracksError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterTracksError {
    /// Creates the `DescribeClusterTracksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterTracksError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidClusterTrackFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterTracksError::InvalidClusterTrackFault`.
    pub fn is_invalid_cluster_track_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterTrackFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterTracksError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for DescribeClusterTracksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidClusterTrackFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterSubnetGroupsErrorKind = DescribeClusterSubnetGroupsError;
/// Error type for the `DescribeClusterSubnetGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterSubnetGroupsError {
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterSubnetGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterSubnetGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterSubnetGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterSubnetGroupsError {
    /// Creates the `DescribeClusterSubnetGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterSubnetGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterSubnetGroupsError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterSubnetGroupsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeClusterSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterSnapshotsErrorKind = DescribeClusterSnapshotsError;
/// Error type for the `DescribeClusterSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterSnapshotsError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterSnapshotsError {
    /// Creates the `DescribeClusterSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterSnapshotsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterSnapshotsError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterSnapshotsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterSnapshotsError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for DescribeClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterSecurityGroupsErrorKind = DescribeClusterSecurityGroupsError;
/// Error type for the `DescribeClusterSecurityGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterSecurityGroupsError {
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterSecurityGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeClusterSecurityGroupsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterSecurityGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterSecurityGroupsError {
    /// Creates the `DescribeClusterSecurityGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterSecurityGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterSecurityGroupsError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterSecurityGroupsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeClusterSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClustersErrorKind = DescribeClustersError;
/// Error type for the `DescribeClustersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClustersError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClustersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClustersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClustersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClustersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClustersError {
    /// Creates the `DescribeClustersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClustersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClustersError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClustersError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterParametersErrorKind = DescribeClusterParametersError;
/// Error type for the `DescribeClusterParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterParametersError {
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterParametersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterParametersError {
    /// Creates the `DescribeClusterParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterParametersError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterParameterGroupsErrorKind = DescribeClusterParameterGroupsError;
/// Error type for the `DescribeClusterParameterGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterParameterGroupsError {
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterParameterGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeClusterParameterGroupsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterParameterGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterParameterGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterParameterGroupsError {
    /// Creates the `DescribeClusterParameterGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterParameterGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterParameterGroupsError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterParameterGroupsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
}
impl std::error::Error for DescribeClusterParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeClusterDbRevisionsErrorKind = DescribeClusterDbRevisionsError;
/// Error type for the `DescribeClusterDbRevisionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeClusterDbRevisionsError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeClusterDbRevisionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeClusterDbRevisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeClusterDbRevisionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeClusterDbRevisionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeClusterDbRevisionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeClusterDbRevisionsError {
    /// Creates the `DescribeClusterDbRevisionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeClusterDbRevisionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeClusterDbRevisionsError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeClusterDbRevisionsError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
}
impl std::error::Error for DescribeClusterDbRevisionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeAuthenticationProfilesErrorKind = DescribeAuthenticationProfilesError;
/// Error type for the `DescribeAuthenticationProfilesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAuthenticationProfilesError {
    /// <p>The authentication profile can't be found.</p>
    AuthenticationProfileNotFoundFault(crate::error::AuthenticationProfileNotFoundFault),
    /// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
    InvalidAuthenticationProfileRequestFault(
        crate::error::InvalidAuthenticationProfileRequestFault,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeAuthenticationProfilesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeAuthenticationProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeAuthenticationProfilesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthenticationProfileRequestFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeAuthenticationProfilesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAuthenticationProfilesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAuthenticationProfilesError {
    /// Creates the `DescribeAuthenticationProfilesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeAuthenticationProfilesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationProfileNotFoundFault(e) => e.meta(),
            Self::InvalidAuthenticationProfileRequestFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeAuthenticationProfilesError::AuthenticationProfileNotFoundFault`.
    pub fn is_authentication_profile_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeAuthenticationProfilesError::InvalidAuthenticationProfileRequestFault`.
    pub fn is_invalid_authentication_profile_request_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthenticationProfileRequestFault(_))
    }
}
impl std::error::Error for DescribeAuthenticationProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => Some(_inner),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeAccountAttributesErrorKind = DescribeAccountAttributesError;
/// Error type for the `DescribeAccountAttributesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountAttributesError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeAccountAttributesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeAccountAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeAccountAttributesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeAccountAttributesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeAccountAttributesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountAttributesError {
    /// Creates the `DescribeAccountAttributesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeAccountAttributesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeAccountAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteUsageLimitErrorKind = DeleteUsageLimitError;
/// Error type for the `DeleteUsageLimitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUsageLimitError {
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// <p>The usage limit identifier can't be found.</p>
    UsageLimitNotFoundFault(crate::error::UsageLimitNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteUsageLimitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteUsageLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::UsageLimitNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteUsageLimitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UsageLimitNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteUsageLimitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteUsageLimitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUsageLimitError {
    /// Creates the `DeleteUsageLimitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteUsageLimitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::UsageLimitNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteUsageLimitError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
    /// Returns `true` if the error kind is `DeleteUsageLimitError::UsageLimitNotFoundFault`.
    pub fn is_usage_limit_not_found_fault(&self) -> bool {
        matches!(self, Self::UsageLimitNotFoundFault(_))
    }
}
impl std::error::Error for DeleteUsageLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::UsageLimitNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteTagsErrorKind = DeleteTagsError;
/// Error type for the `DeleteTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTagsError {
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The resource could not be found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTagsError {
    /// Creates the `DeleteTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidTagFault(e) => e.meta(),
            Self::ResourceNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteTagsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `DeleteTagsError::ResourceNotFoundFault`.
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(self, Self::ResourceNotFoundFault(_))
    }
}
impl std::error::Error for DeleteTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::ResourceNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSnapshotScheduleErrorKind = DeleteSnapshotScheduleError;
/// Error type for the `DeleteSnapshotScheduleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotScheduleError {
    /// <p>The cluster snapshot schedule state is not valid.</p>
    InvalidClusterSnapshotScheduleStateFault(
        crate::error::InvalidClusterSnapshotScheduleStateFault,
    ),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSnapshotScheduleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSnapshotScheduleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSnapshotScheduleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotScheduleError {
    /// Creates the `DeleteSnapshotScheduleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSnapshotScheduleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidClusterSnapshotScheduleStateFault(e) => e.meta(),
            Self::SnapshotScheduleNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSnapshotScheduleError::InvalidClusterSnapshotScheduleStateFault`.
    pub fn is_invalid_cluster_snapshot_schedule_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotScheduleStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotScheduleError::SnapshotScheduleNotFoundFault`.
    pub fn is_snapshot_schedule_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleNotFoundFault(_))
    }
}
impl std::error::Error for DeleteSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidClusterSnapshotScheduleStateFault(_inner) => Some(_inner),
            Self::SnapshotScheduleNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSnapshotCopyGrantErrorKind = DeleteSnapshotCopyGrantError;
/// Error type for the `DeleteSnapshotCopyGrantError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotCopyGrantError {
    /// <p>The snapshot copy grant can't be deleted because it is used by one or more clusters.</p>
    InvalidSnapshotCopyGrantStateFault(crate::error::InvalidSnapshotCopyGrantStateFault),
    /// <p>The specified snapshot copy grant can't be found. Make sure that the name is typed correctly and that the grant exists in the destination region.</p>
    SnapshotCopyGrantNotFoundFault(crate::error::SnapshotCopyGrantNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSnapshotCopyGrantError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSnapshotCopyGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidSnapshotCopyGrantStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSnapshotCopyGrantError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidSnapshotCopyGrantStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyGrantNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSnapshotCopyGrantError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSnapshotCopyGrantError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotCopyGrantError {
    /// Creates the `DeleteSnapshotCopyGrantError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSnapshotCopyGrantError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidSnapshotCopyGrantStateFault(e) => e.meta(),
            Self::SnapshotCopyGrantNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSnapshotCopyGrantError::InvalidSnapshotCopyGrantStateFault`.
    pub fn is_invalid_snapshot_copy_grant_state_fault(&self) -> bool {
        matches!(self, Self::InvalidSnapshotCopyGrantStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotCopyGrantError::SnapshotCopyGrantNotFoundFault`.
    pub fn is_snapshot_copy_grant_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyGrantNotFoundFault(_))
    }
}
impl std::error::Error for DeleteSnapshotCopyGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidSnapshotCopyGrantStateFault(_inner) => Some(_inner),
            Self::SnapshotCopyGrantNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The snapshot copy grant can't be deleted because it is used by one or more clusters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSnapshotCopyGrantStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSnapshotCopyGrantStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnapshotCopyGrantStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSnapshotCopyGrantStateFault")?;
        if let Some(inner_90) = &self.message {
            {
                write!(f, ": {}", inner_90)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnapshotCopyGrantStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidSnapshotCopyGrantStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidSnapshotCopyGrantStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSnapshotCopyGrantStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidSnapshotCopyGrantStateFault`](crate::error::InvalidSnapshotCopyGrantStateFault).
    pub fn builder() -> crate::error::invalid_snapshot_copy_grant_state_fault::Builder {
        crate::error::invalid_snapshot_copy_grant_state_fault::Builder::default()
    }
}

/// See [`InvalidSnapshotCopyGrantStateFault`](crate::error::InvalidSnapshotCopyGrantStateFault).
pub mod invalid_snapshot_copy_grant_state_fault {

    /// A builder for [`InvalidSnapshotCopyGrantStateFault`](crate::error::InvalidSnapshotCopyGrantStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnapshotCopyGrantStateFault`](crate::error::InvalidSnapshotCopyGrantStateFault).
        pub fn build(self) -> crate::error::InvalidSnapshotCopyGrantStateFault {
            crate::error::InvalidSnapshotCopyGrantStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteScheduledActionErrorKind = DeleteScheduledActionError;
/// Error type for the `DeleteScheduledActionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteScheduledActionError {
    /// <p>The scheduled action cannot be found. </p>
    ScheduledActionNotFoundFault(crate::error::ScheduledActionNotFoundFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteScheduledActionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteScheduledActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteScheduledActionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteScheduledActionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteScheduledActionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteScheduledActionError {
    /// Creates the `DeleteScheduledActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteScheduledActionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ScheduledActionNotFoundFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteScheduledActionError::ScheduledActionNotFoundFault`.
    pub fn is_scheduled_action_not_found_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteScheduledActionError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for DeleteScheduledActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ScheduledActionNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeletePartnerErrorKind = DeletePartnerError;
/// Error type for the `DeletePartnerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePartnerError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The name of the partner was not found.</p>
    PartnerNotFoundFault(crate::error::PartnerNotFoundFault),
    /// <p>The partner integration is not authorized.</p>
    UnauthorizedPartnerIntegrationFault(crate::error::UnauthorizedPartnerIntegrationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePartnerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeletePartnerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::PartnerNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeletePartnerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PartnerNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedPartnerIntegrationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeletePartnerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePartnerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePartnerError {
    /// Creates the `DeletePartnerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeletePartnerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::PartnerNotFoundFault(e) => e.meta(),
            Self::UnauthorizedPartnerIntegrationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeletePartnerError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeletePartnerError::PartnerNotFoundFault`.
    pub fn is_partner_not_found_fault(&self) -> bool {
        matches!(self, Self::PartnerNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeletePartnerError::UnauthorizedPartnerIntegrationFault`.
    pub fn is_unauthorized_partner_integration_fault(&self) -> bool {
        matches!(self, Self::UnauthorizedPartnerIntegrationFault(_))
    }
}
impl std::error::Error for DeletePartnerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::PartnerNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteHsmConfigurationErrorKind = DeleteHsmConfigurationError;
/// Error type for the `DeleteHsmConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteHsmConfigurationError {
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The specified HSM configuration is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
    InvalidHsmConfigurationStateFault(crate::error::InvalidHsmConfigurationStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteHsmConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteHsmConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidHsmConfigurationStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteHsmConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHsmConfigurationStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteHsmConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteHsmConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteHsmConfigurationError {
    /// Creates the `DeleteHsmConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteHsmConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmConfigurationNotFoundFault(e) => e.meta(),
            Self::InvalidHsmConfigurationStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteHsmConfigurationError::HsmConfigurationNotFoundFault`.
    pub fn is_hsm_configuration_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteHsmConfigurationError::InvalidHsmConfigurationStateFault`.
    pub fn is_invalid_hsm_configuration_state_fault(&self) -> bool {
        matches!(self, Self::InvalidHsmConfigurationStateFault(_))
    }
}
impl std::error::Error for DeleteHsmConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmConfigurationNotFoundFault(_inner) => Some(_inner),
            Self::InvalidHsmConfigurationStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified HSM configuration is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidHsmConfigurationStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidHsmConfigurationStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidHsmConfigurationStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidHsmConfigurationStateFault")?;
        if let Some(inner_91) = &self.message {
            {
                write!(f, ": {}", inner_91)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidHsmConfigurationStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidHsmConfigurationStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidHsmConfigurationStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidHsmConfigurationStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidHsmConfigurationStateFault`](crate::error::InvalidHsmConfigurationStateFault).
    pub fn builder() -> crate::error::invalid_hsm_configuration_state_fault::Builder {
        crate::error::invalid_hsm_configuration_state_fault::Builder::default()
    }
}

/// See [`InvalidHsmConfigurationStateFault`](crate::error::InvalidHsmConfigurationStateFault).
pub mod invalid_hsm_configuration_state_fault {

    /// A builder for [`InvalidHsmConfigurationStateFault`](crate::error::InvalidHsmConfigurationStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidHsmConfigurationStateFault`](crate::error::InvalidHsmConfigurationStateFault).
        pub fn build(self) -> crate::error::InvalidHsmConfigurationStateFault {
            crate::error::InvalidHsmConfigurationStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteHsmClientCertificateErrorKind = DeleteHsmClientCertificateError;
/// Error type for the `DeleteHsmClientCertificateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteHsmClientCertificateError {
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>The specified HSM client certificate is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
    InvalidHsmClientCertificateStateFault(crate::error::InvalidHsmClientCertificateStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteHsmClientCertificateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteHsmClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidHsmClientCertificateStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteHsmClientCertificateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidHsmClientCertificateStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteHsmClientCertificateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteHsmClientCertificateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteHsmClientCertificateError {
    /// Creates the `DeleteHsmClientCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteHsmClientCertificateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmClientCertificateNotFoundFault(e) => e.meta(),
            Self::InvalidHsmClientCertificateStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteHsmClientCertificateError::HsmClientCertificateNotFoundFault`.
    pub fn is_hsm_client_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteHsmClientCertificateError::InvalidHsmClientCertificateStateFault`.
    pub fn is_invalid_hsm_client_certificate_state_fault(&self) -> bool {
        matches!(self, Self::InvalidHsmClientCertificateStateFault(_))
    }
}
impl std::error::Error for DeleteHsmClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmClientCertificateNotFoundFault(_inner) => Some(_inner),
            Self::InvalidHsmClientCertificateStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified HSM client certificate is not in the <code>available</code> state, or it is still in use by one or more Amazon Redshift clusters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidHsmClientCertificateStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidHsmClientCertificateStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidHsmClientCertificateStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidHsmClientCertificateStateFault")?;
        if let Some(inner_92) = &self.message {
            {
                write!(f, ": {}", inner_92)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidHsmClientCertificateStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidHsmClientCertificateStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidHsmClientCertificateStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidHsmClientCertificateStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidHsmClientCertificateStateFault`](crate::error::InvalidHsmClientCertificateStateFault).
    pub fn builder() -> crate::error::invalid_hsm_client_certificate_state_fault::Builder {
        crate::error::invalid_hsm_client_certificate_state_fault::Builder::default()
    }
}

/// See [`InvalidHsmClientCertificateStateFault`](crate::error::InvalidHsmClientCertificateStateFault).
pub mod invalid_hsm_client_certificate_state_fault {

    /// A builder for [`InvalidHsmClientCertificateStateFault`](crate::error::InvalidHsmClientCertificateStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidHsmClientCertificateStateFault`](crate::error::InvalidHsmClientCertificateStateFault).
        pub fn build(self) -> crate::error::InvalidHsmClientCertificateStateFault {
            crate::error::InvalidHsmClientCertificateStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteEventSubscriptionErrorKind = DeleteEventSubscriptionError;
/// Error type for the `DeleteEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSubscriptionError {
    /// <p>The subscription request is invalid because it is a duplicate request. This subscription request is already in progress.</p>
    InvalidSubscriptionStateFault(crate::error::InvalidSubscriptionStateFault),
    /// <p>An Amazon Redshift event notification subscription with the specified name does not exist.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventSubscriptionError {
    /// Creates the `DeleteEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidSubscriptionStateFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteEventSubscriptionError::InvalidSubscriptionStateFault`.
    pub fn is_invalid_subscription_state_fault(&self) -> bool {
        matches!(self, Self::InvalidSubscriptionStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEventSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for DeleteEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidSubscriptionStateFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteEndpointAccessErrorKind = DeleteEndpointAccessError;
/// Error type for the `DeleteEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEndpointAccessError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The endpoint name doesn't refer to an existing endpoint.</p>
    EndpointNotFoundFault(crate::error::EndpointNotFoundFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The status of the endpoint is not valid.</p>
    InvalidEndpointStateFault(crate::error::InvalidEndpointStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidEndpointStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEndpointStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEndpointAccessError {
    /// Creates the `DeleteEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::EndpointNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidEndpointStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEndpointAccessError::EndpointNotFoundFault`.
    pub fn is_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::EndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEndpointAccessError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEndpointAccessError::InvalidEndpointStateFault`.
    pub fn is_invalid_endpoint_state_fault(&self) -> bool {
        matches!(self, Self::InvalidEndpointStateFault(_))
    }
}
impl std::error::Error for DeleteEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::EndpointNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidEndpointStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterSubnetGroupErrorKind = DeleteClusterSubnetGroupError;
/// Error type for the `DeleteClusterSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterSubnetGroupError {
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The cluster subnet group cannot be deleted because it is in use.</p>
    InvalidClusterSubnetGroupStateFault(crate::error::InvalidClusterSubnetGroupStateFault),
    /// <p>The state of the subnet is invalid.</p>
    InvalidClusterSubnetStateFault(crate::error::InvalidClusterSubnetStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSubnetStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSubnetStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterSubnetGroupError {
    /// Creates the `DeleteClusterSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidClusterSubnetStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterSubnetGroupError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterSubnetGroupError::InvalidClusterSubnetGroupStateFault`.
    pub fn is_invalid_cluster_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterSubnetGroupError::InvalidClusterSubnetStateFault`.
    pub fn is_invalid_cluster_subnet_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSubnetStateFault(_))
    }
}
impl std::error::Error for DeleteClusterSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterSubnetStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The state of the subnet is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClusterSubnetStateFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClusterSubnetStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClusterSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClusterSubnetStateFault")?;
        if let Some(inner_93) = &self.message {
            {
                write!(f, ": {}", inner_93)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClusterSubnetStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidClusterSubnetStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidClusterSubnetStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidClusterSubnetStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidClusterSubnetStateFault`](crate::error::InvalidClusterSubnetStateFault).
    pub fn builder() -> crate::error::invalid_cluster_subnet_state_fault::Builder {
        crate::error::invalid_cluster_subnet_state_fault::Builder::default()
    }
}

/// See [`InvalidClusterSubnetStateFault`](crate::error::InvalidClusterSubnetStateFault).
pub mod invalid_cluster_subnet_state_fault {

    /// A builder for [`InvalidClusterSubnetStateFault`](crate::error::InvalidClusterSubnetStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClusterSubnetStateFault`](crate::error::InvalidClusterSubnetStateFault).
        pub fn build(self) -> crate::error::InvalidClusterSubnetStateFault {
            crate::error::InvalidClusterSubnetStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterSnapshotErrorKind = DeleteClusterSnapshotError;
/// Error type for the `DeleteClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterSnapshotError {
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterSnapshotError {
    /// Creates the `DeleteClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterSnapshotError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterSnapshotError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
}
impl std::error::Error for DeleteClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterSecurityGroupErrorKind = DeleteClusterSecurityGroupError;
/// Error type for the `DeleteClusterSecurityGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterSecurityGroupError {
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterSecurityGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterSecurityGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterSecurityGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterSecurityGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterSecurityGroupError {
    /// Creates the `DeleteClusterSecurityGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterSecurityGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterSecurityGroupError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterSecurityGroupError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
}
impl std::error::Error for DeleteClusterSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterParameterGroupErrorKind = DeleteClusterParameterGroupError;
/// Error type for the `DeleteClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterParameterGroupError {
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The cluster parameter group action can not be completed because another task is in progress that involves the parameter group. Wait a few moments and try the operation again.</p>
    InvalidClusterParameterGroupStateFault(crate::error::InvalidClusterParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterParameterGroupError {
    /// Creates the `DeleteClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterParameterGroupError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterParameterGroupError::InvalidClusterParameterGroupStateFault`.
    pub fn is_invalid_cluster_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterParameterGroupStateFault(_))
    }
}
impl std::error::Error for DeleteClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteClusterErrorKind = DeleteClusterError;
/// Error type for the `DeleteClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClusterError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The value specified as a snapshot identifier is already used by an existing snapshot.</p>
    ClusterSnapshotAlreadyExistsFault(crate::error::ClusterSnapshotAlreadyExistsFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster snapshots.</p>
    ClusterSnapshotQuotaExceededFault(crate::error::ClusterSnapshotQuotaExceededFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClusterError {
    /// Creates the `DeleteClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::ClusterSnapshotQuotaExceededFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteClusterError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::ClusterSnapshotAlreadyExistsFault`.
    pub fn is_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::ClusterSnapshotQuotaExceededFault`.
    pub fn is_cluster_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteClusterError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
}
impl std::error::Error for DeleteClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSnapshotQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSnapshotQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSnapshotQuotaExceededFault")?;
        if let Some(inner_94) = &self.message {
            {
                write!(f, ": {}", inner_94)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSnapshotQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSnapshotQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSnapshotQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterSnapshotQuotaExceededFault`](crate::error::ClusterSnapshotQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_snapshot_quota_exceeded_fault::Builder {
        crate::error::cluster_snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterSnapshotQuotaExceededFault`](crate::error::ClusterSnapshotQuotaExceededFault).
pub mod cluster_snapshot_quota_exceeded_fault {

    /// A builder for [`ClusterSnapshotQuotaExceededFault`](crate::error::ClusterSnapshotQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSnapshotQuotaExceededFault`](crate::error::ClusterSnapshotQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterSnapshotQuotaExceededFault {
            crate::error::ClusterSnapshotQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The value specified as a snapshot identifier is already used by an existing snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSnapshotAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSnapshotAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSnapshotAlreadyExistsFault")?;
        if let Some(inner_95) = &self.message {
            {
                write!(f, ": {}", inner_95)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSnapshotAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSnapshotAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ClusterSnapshotAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterSnapshotAlreadyExistsFault`](crate::error::ClusterSnapshotAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_snapshot_already_exists_fault::Builder {
        crate::error::cluster_snapshot_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterSnapshotAlreadyExistsFault`](crate::error::ClusterSnapshotAlreadyExistsFault).
pub mod cluster_snapshot_already_exists_fault {

    /// A builder for [`ClusterSnapshotAlreadyExistsFault`](crate::error::ClusterSnapshotAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSnapshotAlreadyExistsFault`](crate::error::ClusterSnapshotAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterSnapshotAlreadyExistsFault {
            crate::error::ClusterSnapshotAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteAuthenticationProfileErrorKind = DeleteAuthenticationProfileError;
/// Error type for the `DeleteAuthenticationProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuthenticationProfileError {
    /// <p>The authentication profile can't be found.</p>
    AuthenticationProfileNotFoundFault(crate::error::AuthenticationProfileNotFoundFault),
    /// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
    InvalidAuthenticationProfileRequestFault(
        crate::error::InvalidAuthenticationProfileRequestFault,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteAuthenticationProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteAuthenticationProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteAuthenticationProfileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthenticationProfileRequestFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteAuthenticationProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteAuthenticationProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuthenticationProfileError {
    /// Creates the `DeleteAuthenticationProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteAuthenticationProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationProfileNotFoundFault(e) => e.meta(),
            Self::InvalidAuthenticationProfileRequestFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteAuthenticationProfileError::AuthenticationProfileNotFoundFault`.
    pub fn is_authentication_profile_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteAuthenticationProfileError::InvalidAuthenticationProfileRequestFault`.
    pub fn is_invalid_authentication_profile_request_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthenticationProfileRequestFault(_))
    }
}
impl std::error::Error for DeleteAuthenticationProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationProfileNotFoundFault(_inner) => Some(_inner),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeauthorizeDataShareErrorKind = DeauthorizeDataShareError;
/// Error type for the `DeauthorizeDataShareError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeauthorizeDataShareError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeauthorizeDataShareError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeauthorizeDataShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeauthorizeDataShareError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeauthorizeDataShareError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeauthorizeDataShareError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeauthorizeDataShareError {
    /// Creates the `DeauthorizeDataShareError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeauthorizeDataShareError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeauthorizeDataShareError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
}
impl std::error::Error for DeauthorizeDataShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateUsageLimitErrorKind = CreateUsageLimitError;
/// Error type for the `CreateUsageLimitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUsageLimitError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The usage limit is not valid.</p>
    InvalidUsageLimitFault(crate::error::InvalidUsageLimitFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// <p>The usage limit already exists. </p>
    UsageLimitAlreadyExistsFault(crate::error::UsageLimitAlreadyExistsFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateUsageLimitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateUsageLimitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidUsageLimitFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::UsageLimitAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateUsageLimitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUsageLimitFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UsageLimitAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateUsageLimitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateUsageLimitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUsageLimitError {
    /// Creates the `CreateUsageLimitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateUsageLimitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidUsageLimitFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::UsageLimitAlreadyExistsFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::InvalidUsageLimitFault`.
    pub fn is_invalid_usage_limit_fault(&self) -> bool {
        matches!(self, Self::InvalidUsageLimitFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
    /// Returns `true` if the error kind is `CreateUsageLimitError::UsageLimitAlreadyExistsFault`.
    pub fn is_usage_limit_already_exists_fault(&self) -> bool {
        matches!(self, Self::UsageLimitAlreadyExistsFault(_))
    }
}
impl std::error::Error for CreateUsageLimitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidUsageLimitFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::UsageLimitAlreadyExistsFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The usage limit already exists. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UsageLimitAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UsageLimitAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UsageLimitAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UsageLimitAlreadyExistsFault")?;
        if let Some(inner_96) = &self.message {
            {
                write!(f, ": {}", inner_96)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UsageLimitAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::UsageLimitAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UsageLimitAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UsageLimitAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`UsageLimitAlreadyExistsFault`](crate::error::UsageLimitAlreadyExistsFault).
    pub fn builder() -> crate::error::usage_limit_already_exists_fault::Builder {
        crate::error::usage_limit_already_exists_fault::Builder::default()
    }
}

/// See [`UsageLimitAlreadyExistsFault`](crate::error::UsageLimitAlreadyExistsFault).
pub mod usage_limit_already_exists_fault {

    /// A builder for [`UsageLimitAlreadyExistsFault`](crate::error::UsageLimitAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UsageLimitAlreadyExistsFault`](crate::error::UsageLimitAlreadyExistsFault).
        pub fn build(self) -> crate::error::UsageLimitAlreadyExistsFault {
            crate::error::UsageLimitAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateTagsErrorKind = CreateTagsError;
/// Error type for the `CreateTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTagsError {
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The resource could not be found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateTagsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateTagsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTagsError {
    /// Creates the `CreateTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::ResourceNotFoundFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateTagsError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateTagsError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateTagsError::ResourceNotFoundFault`.
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(self, Self::ResourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateTagsError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::ResourceNotFoundFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSnapshotScheduleErrorKind = CreateSnapshotScheduleError;
/// Error type for the `CreateSnapshotScheduleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotScheduleError {
    /// <p>The schedule you submitted isn't valid.</p>
    InvalidScheduleFault(crate::error::InvalidScheduleFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The definition you submitted is not supported.</p>
    ScheduleDefinitionTypeUnsupportedFault(crate::error::ScheduleDefinitionTypeUnsupportedFault),
    /// <p>The specified snapshot schedule already exists. </p>
    SnapshotScheduleAlreadyExistsFault(crate::error::SnapshotScheduleAlreadyExistsFault),
    /// <p>You have exceeded the quota of snapshot schedules. </p>
    SnapshotScheduleQuotaExceededFault(crate::error::SnapshotScheduleQuotaExceededFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSnapshotScheduleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSnapshotScheduleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidScheduleFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::ScheduleDefinitionTypeUnsupportedFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSnapshotScheduleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidScheduleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduleDefinitionTypeUnsupportedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSnapshotScheduleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSnapshotScheduleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotScheduleError {
    /// Creates the `CreateSnapshotScheduleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSnapshotScheduleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidScheduleFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::ScheduleDefinitionTypeUnsupportedFault(e) => e.meta(),
            Self::SnapshotScheduleAlreadyExistsFault(e) => e.meta(),
            Self::SnapshotScheduleQuotaExceededFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::InvalidScheduleFault`.
    pub fn is_invalid_schedule_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduleFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::ScheduleDefinitionTypeUnsupportedFault`.
    pub fn is_schedule_definition_type_unsupported_fault(&self) -> bool {
        matches!(self, Self::ScheduleDefinitionTypeUnsupportedFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::SnapshotScheduleAlreadyExistsFault`.
    pub fn is_snapshot_schedule_already_exists_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::SnapshotScheduleQuotaExceededFault`.
    pub fn is_snapshot_schedule_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotScheduleError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateSnapshotScheduleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidScheduleFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::ScheduleDefinitionTypeUnsupportedFault(_inner) => Some(_inner),
            Self::SnapshotScheduleAlreadyExistsFault(_inner) => Some(_inner),
            Self::SnapshotScheduleQuotaExceededFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have exceeded the quota of snapshot schedules. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotScheduleQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotScheduleQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotScheduleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotScheduleQuotaExceededFault")?;
        if let Some(inner_97) = &self.message {
            {
                write!(f, ": {}", inner_97)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotScheduleQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotScheduleQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SnapshotScheduleQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotScheduleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotScheduleQuotaExceededFault`](crate::error::SnapshotScheduleQuotaExceededFault).
    pub fn builder() -> crate::error::snapshot_schedule_quota_exceeded_fault::Builder {
        crate::error::snapshot_schedule_quota_exceeded_fault::Builder::default()
    }
}

/// See [`SnapshotScheduleQuotaExceededFault`](crate::error::SnapshotScheduleQuotaExceededFault).
pub mod snapshot_schedule_quota_exceeded_fault {

    /// A builder for [`SnapshotScheduleQuotaExceededFault`](crate::error::SnapshotScheduleQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotScheduleQuotaExceededFault`](crate::error::SnapshotScheduleQuotaExceededFault).
        pub fn build(self) -> crate::error::SnapshotScheduleQuotaExceededFault {
            crate::error::SnapshotScheduleQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified snapshot schedule already exists. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotScheduleAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotScheduleAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotScheduleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotScheduleAlreadyExistsFault")?;
        if let Some(inner_98) = &self.message {
            {
                write!(f, ": {}", inner_98)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotScheduleAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotScheduleAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SnapshotScheduleAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotScheduleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`SnapshotScheduleAlreadyExistsFault`](crate::error::SnapshotScheduleAlreadyExistsFault).
    pub fn builder() -> crate::error::snapshot_schedule_already_exists_fault::Builder {
        crate::error::snapshot_schedule_already_exists_fault::Builder::default()
    }
}

/// See [`SnapshotScheduleAlreadyExistsFault`](crate::error::SnapshotScheduleAlreadyExistsFault).
pub mod snapshot_schedule_already_exists_fault {

    /// A builder for [`SnapshotScheduleAlreadyExistsFault`](crate::error::SnapshotScheduleAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotScheduleAlreadyExistsFault`](crate::error::SnapshotScheduleAlreadyExistsFault).
        pub fn build(self) -> crate::error::SnapshotScheduleAlreadyExistsFault {
            crate::error::SnapshotScheduleAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The definition you submitted is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleDefinitionTypeUnsupportedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ScheduleDefinitionTypeUnsupportedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScheduleDefinitionTypeUnsupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScheduleDefinitionTypeUnsupportedFault")?;
        if let Some(inner_99) = &self.message {
            {
                write!(f, ": {}", inner_99)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ScheduleDefinitionTypeUnsupportedFault {}
impl aws_http::request_id::RequestId for crate::error::ScheduleDefinitionTypeUnsupportedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ScheduleDefinitionTypeUnsupportedFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ScheduleDefinitionTypeUnsupportedFault {
    /// Creates a new builder-style object to manufacture [`ScheduleDefinitionTypeUnsupportedFault`](crate::error::ScheduleDefinitionTypeUnsupportedFault).
    pub fn builder() -> crate::error::schedule_definition_type_unsupported_fault::Builder {
        crate::error::schedule_definition_type_unsupported_fault::Builder::default()
    }
}

/// See [`ScheduleDefinitionTypeUnsupportedFault`](crate::error::ScheduleDefinitionTypeUnsupportedFault).
pub mod schedule_definition_type_unsupported_fault {

    /// A builder for [`ScheduleDefinitionTypeUnsupportedFault`](crate::error::ScheduleDefinitionTypeUnsupportedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleDefinitionTypeUnsupportedFault`](crate::error::ScheduleDefinitionTypeUnsupportedFault).
        pub fn build(self) -> crate::error::ScheduleDefinitionTypeUnsupportedFault {
            crate::error::ScheduleDefinitionTypeUnsupportedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSnapshotCopyGrantErrorKind = CreateSnapshotCopyGrantError;
/// Error type for the `CreateSnapshotCopyGrantError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotCopyGrantError {
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The snapshot copy grant can't be created because a grant with the same name already exists.</p>
    SnapshotCopyGrantAlreadyExistsFault(crate::error::SnapshotCopyGrantAlreadyExistsFault),
    /// <p>The Amazon Web Services account has exceeded the maximum number of snapshot copy grants in this region.</p>
    SnapshotCopyGrantQuotaExceededFault(crate::error::SnapshotCopyGrantQuotaExceededFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSnapshotCopyGrantError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSnapshotCopyGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyGrantAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::SnapshotCopyGrantQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSnapshotCopyGrantError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyGrantAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotCopyGrantQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSnapshotCopyGrantError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSnapshotCopyGrantError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotCopyGrantError {
    /// Creates the `CreateSnapshotCopyGrantError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSnapshotCopyGrantError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::SnapshotCopyGrantAlreadyExistsFault(e) => e.meta(),
            Self::SnapshotCopyGrantQuotaExceededFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::SnapshotCopyGrantAlreadyExistsFault`.
    pub fn is_snapshot_copy_grant_already_exists_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyGrantAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::SnapshotCopyGrantQuotaExceededFault`.
    pub fn is_snapshot_copy_grant_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotCopyGrantQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotCopyGrantError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateSnapshotCopyGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::SnapshotCopyGrantAlreadyExistsFault(_inner) => Some(_inner),
            Self::SnapshotCopyGrantQuotaExceededFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The Amazon Web Services account has exceeded the maximum number of snapshot copy grants in this region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyGrantQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyGrantQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyGrantQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyGrantQuotaExceededFault")?;
        if let Some(inner_100) = &self.message {
            {
                write!(f, ": {}", inner_100)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyGrantQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyGrantQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SnapshotCopyGrantQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyGrantQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyGrantQuotaExceededFault`](crate::error::SnapshotCopyGrantQuotaExceededFault).
    pub fn builder() -> crate::error::snapshot_copy_grant_quota_exceeded_fault::Builder {
        crate::error::snapshot_copy_grant_quota_exceeded_fault::Builder::default()
    }
}

/// See [`SnapshotCopyGrantQuotaExceededFault`](crate::error::SnapshotCopyGrantQuotaExceededFault).
pub mod snapshot_copy_grant_quota_exceeded_fault {

    /// A builder for [`SnapshotCopyGrantQuotaExceededFault`](crate::error::SnapshotCopyGrantQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyGrantQuotaExceededFault`](crate::error::SnapshotCopyGrantQuotaExceededFault).
        pub fn build(self) -> crate::error::SnapshotCopyGrantQuotaExceededFault {
            crate::error::SnapshotCopyGrantQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The snapshot copy grant can't be created because a grant with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotCopyGrantAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotCopyGrantAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotCopyGrantAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotCopyGrantAlreadyExistsFault")?;
        if let Some(inner_101) = &self.message {
            {
                write!(f, ": {}", inner_101)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotCopyGrantAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotCopyGrantAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SnapshotCopyGrantAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotCopyGrantAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyGrantAlreadyExistsFault`](crate::error::SnapshotCopyGrantAlreadyExistsFault).
    pub fn builder() -> crate::error::snapshot_copy_grant_already_exists_fault::Builder {
        crate::error::snapshot_copy_grant_already_exists_fault::Builder::default()
    }
}

/// See [`SnapshotCopyGrantAlreadyExistsFault`](crate::error::SnapshotCopyGrantAlreadyExistsFault).
pub mod snapshot_copy_grant_already_exists_fault {

    /// A builder for [`SnapshotCopyGrantAlreadyExistsFault`](crate::error::SnapshotCopyGrantAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyGrantAlreadyExistsFault`](crate::error::SnapshotCopyGrantAlreadyExistsFault).
        pub fn build(self) -> crate::error::SnapshotCopyGrantAlreadyExistsFault {
            crate::error::SnapshotCopyGrantAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateScheduledActionErrorKind = CreateScheduledActionError;
/// Error type for the `CreateScheduledActionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateScheduledActionError {
    /// <p>The scheduled action is not valid. </p>
    InvalidScheduledActionFault(crate::error::InvalidScheduledActionFault),
    /// <p>The schedule you submitted isn't valid.</p>
    InvalidScheduleFault(crate::error::InvalidScheduleFault),
    /// <p>The scheduled action already exists. </p>
    ScheduledActionAlreadyExistsFault(crate::error::ScheduledActionAlreadyExistsFault),
    /// <p>The quota for scheduled actions exceeded. </p>
    ScheduledActionQuotaExceededFault(crate::error::ScheduledActionQuotaExceededFault),
    /// <p>The action type specified for a scheduled action is not supported. </p>
    ScheduledActionTypeUnsupportedFault(crate::error::ScheduledActionTypeUnsupportedFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateScheduledActionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateScheduledActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidScheduledActionFault(_inner) => _inner.fmt(f),
            Self::InvalidScheduleFault(_inner) => _inner.fmt(f),
            Self::ScheduledActionAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ScheduledActionQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ScheduledActionTypeUnsupportedFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateScheduledActionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidScheduledActionFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidScheduleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduledActionAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduledActionQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ScheduledActionTypeUnsupportedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateScheduledActionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateScheduledActionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateScheduledActionError {
    /// Creates the `CreateScheduledActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateScheduledActionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidScheduledActionFault(e) => e.meta(),
            Self::InvalidScheduleFault(e) => e.meta(),
            Self::ScheduledActionAlreadyExistsFault(e) => e.meta(),
            Self::ScheduledActionQuotaExceededFault(e) => e.meta(),
            Self::ScheduledActionTypeUnsupportedFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::InvalidScheduledActionFault`.
    pub fn is_invalid_scheduled_action_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduledActionFault(_))
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::InvalidScheduleFault`.
    pub fn is_invalid_schedule_fault(&self) -> bool {
        matches!(self, Self::InvalidScheduleFault(_))
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::ScheduledActionAlreadyExistsFault`.
    pub fn is_scheduled_action_already_exists_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::ScheduledActionQuotaExceededFault`.
    pub fn is_scheduled_action_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::ScheduledActionTypeUnsupportedFault`.
    pub fn is_scheduled_action_type_unsupported_fault(&self) -> bool {
        matches!(self, Self::ScheduledActionTypeUnsupportedFault(_))
    }
    /// Returns `true` if the error kind is `CreateScheduledActionError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for CreateScheduledActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidScheduledActionFault(_inner) => Some(_inner),
            Self::InvalidScheduleFault(_inner) => Some(_inner),
            Self::ScheduledActionAlreadyExistsFault(_inner) => Some(_inner),
            Self::ScheduledActionQuotaExceededFault(_inner) => Some(_inner),
            Self::ScheduledActionTypeUnsupportedFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The quota for scheduled actions exceeded. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduledActionQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ScheduledActionQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScheduledActionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScheduledActionQuotaExceededFault")?;
        if let Some(inner_102) = &self.message {
            {
                write!(f, ": {}", inner_102)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ScheduledActionQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ScheduledActionQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ScheduledActionQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ScheduledActionQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ScheduledActionQuotaExceededFault`](crate::error::ScheduledActionQuotaExceededFault).
    pub fn builder() -> crate::error::scheduled_action_quota_exceeded_fault::Builder {
        crate::error::scheduled_action_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ScheduledActionQuotaExceededFault`](crate::error::ScheduledActionQuotaExceededFault).
pub mod scheduled_action_quota_exceeded_fault {

    /// A builder for [`ScheduledActionQuotaExceededFault`](crate::error::ScheduledActionQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionQuotaExceededFault`](crate::error::ScheduledActionQuotaExceededFault).
        pub fn build(self) -> crate::error::ScheduledActionQuotaExceededFault {
            crate::error::ScheduledActionQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The scheduled action already exists. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduledActionAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ScheduledActionAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScheduledActionAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScheduledActionAlreadyExistsFault")?;
        if let Some(inner_103) = &self.message {
            {
                write!(f, ": {}", inner_103)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ScheduledActionAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ScheduledActionAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ScheduledActionAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ScheduledActionAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ScheduledActionAlreadyExistsFault`](crate::error::ScheduledActionAlreadyExistsFault).
    pub fn builder() -> crate::error::scheduled_action_already_exists_fault::Builder {
        crate::error::scheduled_action_already_exists_fault::Builder::default()
    }
}

/// See [`ScheduledActionAlreadyExistsFault`](crate::error::ScheduledActionAlreadyExistsFault).
pub mod scheduled_action_already_exists_fault {

    /// A builder for [`ScheduledActionAlreadyExistsFault`](crate::error::ScheduledActionAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionAlreadyExistsFault`](crate::error::ScheduledActionAlreadyExistsFault).
        pub fn build(self) -> crate::error::ScheduledActionAlreadyExistsFault {
            crate::error::ScheduledActionAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateHsmConfigurationErrorKind = CreateHsmConfigurationError;
/// Error type for the `CreateHsmConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHsmConfigurationError {
    /// <p>There is already an existing Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationAlreadyExistsFault(crate::error::HsmConfigurationAlreadyExistsFault),
    /// <p>The quota for HSM configurations has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    HsmConfigurationQuotaExceededFault(crate::error::HsmConfigurationQuotaExceededFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateHsmConfigurationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateHsmConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmConfigurationAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::HsmConfigurationQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateHsmConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmConfigurationAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmConfigurationQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateHsmConfigurationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateHsmConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHsmConfigurationError {
    /// Creates the `CreateHsmConfigurationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateHsmConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmConfigurationAlreadyExistsFault(e) => e.meta(),
            Self::HsmConfigurationQuotaExceededFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateHsmConfigurationError::HsmConfigurationAlreadyExistsFault`.
    pub fn is_hsm_configuration_already_exists_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmConfigurationError::HsmConfigurationQuotaExceededFault`.
    pub fn is_hsm_configuration_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmConfigurationError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmConfigurationError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateHsmConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmConfigurationAlreadyExistsFault(_inner) => Some(_inner),
            Self::HsmConfigurationQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The quota for HSM configurations has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmConfigurationQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmConfigurationQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmConfigurationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmConfigurationQuotaExceededFault")?;
        if let Some(inner_104) = &self.message {
            {
                write!(f, ": {}", inner_104)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmConfigurationQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::HsmConfigurationQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for HsmConfigurationQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmConfigurationQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`HsmConfigurationQuotaExceededFault`](crate::error::HsmConfigurationQuotaExceededFault).
    pub fn builder() -> crate::error::hsm_configuration_quota_exceeded_fault::Builder {
        crate::error::hsm_configuration_quota_exceeded_fault::Builder::default()
    }
}

/// See [`HsmConfigurationQuotaExceededFault`](crate::error::HsmConfigurationQuotaExceededFault).
pub mod hsm_configuration_quota_exceeded_fault {

    /// A builder for [`HsmConfigurationQuotaExceededFault`](crate::error::HsmConfigurationQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmConfigurationQuotaExceededFault`](crate::error::HsmConfigurationQuotaExceededFault).
        pub fn build(self) -> crate::error::HsmConfigurationQuotaExceededFault {
            crate::error::HsmConfigurationQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>There is already an existing Amazon Redshift HSM configuration with the specified identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmConfigurationAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmConfigurationAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmConfigurationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmConfigurationAlreadyExistsFault")?;
        if let Some(inner_105) = &self.message {
            {
                write!(f, ": {}", inner_105)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmConfigurationAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::HsmConfigurationAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for HsmConfigurationAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmConfigurationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`HsmConfigurationAlreadyExistsFault`](crate::error::HsmConfigurationAlreadyExistsFault).
    pub fn builder() -> crate::error::hsm_configuration_already_exists_fault::Builder {
        crate::error::hsm_configuration_already_exists_fault::Builder::default()
    }
}

/// See [`HsmConfigurationAlreadyExistsFault`](crate::error::HsmConfigurationAlreadyExistsFault).
pub mod hsm_configuration_already_exists_fault {

    /// A builder for [`HsmConfigurationAlreadyExistsFault`](crate::error::HsmConfigurationAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmConfigurationAlreadyExistsFault`](crate::error::HsmConfigurationAlreadyExistsFault).
        pub fn build(self) -> crate::error::HsmConfigurationAlreadyExistsFault {
            crate::error::HsmConfigurationAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateHsmClientCertificateErrorKind = CreateHsmClientCertificateError;
/// Error type for the `CreateHsmClientCertificateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateHsmClientCertificateError {
    /// <p>There is already an existing Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateAlreadyExistsFault(crate::error::HsmClientCertificateAlreadyExistsFault),
    /// <p>The quota for HSM client certificates has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    HsmClientCertificateQuotaExceededFault(crate::error::HsmClientCertificateQuotaExceededFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateHsmClientCertificateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateHsmClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::HsmClientCertificateAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::HsmClientCertificateQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateHsmClientCertificateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::HsmClientCertificateAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmClientCertificateQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateHsmClientCertificateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateHsmClientCertificateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateHsmClientCertificateError {
    /// Creates the `CreateHsmClientCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateHsmClientCertificateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::HsmClientCertificateAlreadyExistsFault(e) => e.meta(),
            Self::HsmClientCertificateQuotaExceededFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateHsmClientCertificateError::HsmClientCertificateAlreadyExistsFault`.
    pub fn is_hsm_client_certificate_already_exists_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmClientCertificateError::HsmClientCertificateQuotaExceededFault`.
    pub fn is_hsm_client_certificate_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmClientCertificateError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateHsmClientCertificateError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateHsmClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::HsmClientCertificateAlreadyExistsFault(_inner) => Some(_inner),
            Self::HsmClientCertificateQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The quota for HSM client certificates has been reached. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmClientCertificateQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmClientCertificateQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmClientCertificateQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmClientCertificateQuotaExceededFault")?;
        if let Some(inner_106) = &self.message {
            {
                write!(f, ": {}", inner_106)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmClientCertificateQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::HsmClientCertificateQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for HsmClientCertificateQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmClientCertificateQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`HsmClientCertificateQuotaExceededFault`](crate::error::HsmClientCertificateQuotaExceededFault).
    pub fn builder() -> crate::error::hsm_client_certificate_quota_exceeded_fault::Builder {
        crate::error::hsm_client_certificate_quota_exceeded_fault::Builder::default()
    }
}

/// See [`HsmClientCertificateQuotaExceededFault`](crate::error::HsmClientCertificateQuotaExceededFault).
pub mod hsm_client_certificate_quota_exceeded_fault {

    /// A builder for [`HsmClientCertificateQuotaExceededFault`](crate::error::HsmClientCertificateQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmClientCertificateQuotaExceededFault`](crate::error::HsmClientCertificateQuotaExceededFault).
        pub fn build(self) -> crate::error::HsmClientCertificateQuotaExceededFault {
            crate::error::HsmClientCertificateQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>There is already an existing Amazon Redshift HSM client certificate with the specified identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct HsmClientCertificateAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl HsmClientCertificateAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for HsmClientCertificateAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HsmClientCertificateAlreadyExistsFault")?;
        if let Some(inner_107) = &self.message {
            {
                write!(f, ": {}", inner_107)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for HsmClientCertificateAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::HsmClientCertificateAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for HsmClientCertificateAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl HsmClientCertificateAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`HsmClientCertificateAlreadyExistsFault`](crate::error::HsmClientCertificateAlreadyExistsFault).
    pub fn builder() -> crate::error::hsm_client_certificate_already_exists_fault::Builder {
        crate::error::hsm_client_certificate_already_exists_fault::Builder::default()
    }
}

/// See [`HsmClientCertificateAlreadyExistsFault`](crate::error::HsmClientCertificateAlreadyExistsFault).
pub mod hsm_client_certificate_already_exists_fault {

    /// A builder for [`HsmClientCertificateAlreadyExistsFault`](crate::error::HsmClientCertificateAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`HsmClientCertificateAlreadyExistsFault`](crate::error::HsmClientCertificateAlreadyExistsFault).
        pub fn build(self) -> crate::error::HsmClientCertificateAlreadyExistsFault {
            crate::error::HsmClientCertificateAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateEventSubscriptionErrorKind = CreateEventSubscriptionError;
/// Error type for the `CreateEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSubscriptionError {
    /// <p>The request would exceed the allowed number of event subscriptions for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>Amazon SNS has responded that there is a problem with the specified Amazon SNS topic.</p>
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    /// <p>You do not have permission to publish to the specified Amazon SNS topic.</p>
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    /// <p>An Amazon SNS topic with the specified Amazon Resource Name (ARN) does not exist.</p>
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    /// <p>The specified Amazon Redshift event source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>There is already an existing event notification subscription with the specified name.</p>
    SubscriptionAlreadyExistFault(crate::error::SubscriptionAlreadyExistFault),
    /// <p>The value specified for the event category was not one of the allowed values, or it specified a category that does not apply to the specified source type. The allowed values are Configuration, Management, Monitoring, and Security.</p>
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// <p>An Amazon Redshift event with the specified event ID does not exist.</p>
    SubscriptionEventIdNotFoundFault(crate::error::SubscriptionEventIdNotFoundFault),
    /// <p>The value specified for the event severity was not one of the allowed values, or it specified a severity that does not apply to the specified source type. The allowed values are ERROR and INFO.</p>
    SubscriptionSeverityNotFoundFault(crate::error::SubscriptionSeverityNotFoundFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            Self::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            Self::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            Self::SourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionAlreadyExistFault(_inner) => _inner.fmt(f),
            Self::SubscriptionCategoryNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionEventIdNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionSeverityNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsInvalidTopicFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsNoAuthorizationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsTopicArnNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionAlreadyExistFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionCategoryNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionEventIdNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionSeverityNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventSubscriptionError {
    /// Creates the `CreateEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EventSubscriptionQuotaExceededFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::SnsInvalidTopicFault(e) => e.meta(),
            Self::SnsNoAuthorizationFault(e) => e.meta(),
            Self::SnsTopicArnNotFoundFault(e) => e.meta(),
            Self::SourceNotFoundFault(e) => e.meta(),
            Self::SubscriptionAlreadyExistFault(e) => e.meta(),
            Self::SubscriptionCategoryNotFoundFault(e) => e.meta(),
            Self::SubscriptionEventIdNotFoundFault(e) => e.meta(),
            Self::SubscriptionSeverityNotFoundFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::EventSubscriptionQuotaExceededFault`.
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::EventSubscriptionQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsInvalidTopicFault`.
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(self, Self::SnsInvalidTopicFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsNoAuthorizationFault`.
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(self, Self::SnsNoAuthorizationFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsTopicArnNotFoundFault`.
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(self, Self::SnsTopicArnNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SourceNotFoundFault`.
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(self, Self::SourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionAlreadyExistFault`.
    pub fn is_subscription_already_exist_fault(&self) -> bool {
        matches!(self, Self::SubscriptionAlreadyExistFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionCategoryNotFoundFault`.
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionCategoryNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionEventIdNotFoundFault`.
    pub fn is_subscription_event_id_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionEventIdNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionSeverityNotFoundFault`.
    pub fn is_subscription_severity_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionSeverityNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::SnsInvalidTopicFault(_inner) => Some(_inner),
            Self::SnsNoAuthorizationFault(_inner) => Some(_inner),
            Self::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            Self::SourceNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionAlreadyExistFault(_inner) => Some(_inner),
            Self::SubscriptionCategoryNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionEventIdNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionSeverityNotFoundFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>There is already an existing event notification subscription with the specified name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionAlreadyExistFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionAlreadyExistFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionAlreadyExistFault")?;
        if let Some(inner_108) = &self.message {
            {
                write!(f, ": {}", inner_108)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionAlreadyExistFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionAlreadyExistFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionAlreadyExistFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SubscriptionAlreadyExistFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
    pub fn builder() -> crate::error::subscription_already_exist_fault::Builder {
        crate::error::subscription_already_exist_fault::Builder::default()
    }
}

/// See [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
pub mod subscription_already_exist_fault {

    /// A builder for [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
        pub fn build(self) -> crate::error::SubscriptionAlreadyExistFault {
            crate::error::SubscriptionAlreadyExistFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request would exceed the allowed number of event subscriptions for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventSubscriptionQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EventSubscriptionQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EventSubscriptionQuotaExceededFault")?;
        if let Some(inner_109) = &self.message {
            {
                write!(f, ": {}", inner_109)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EventSubscriptionQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::EventSubscriptionQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EventSubscriptionQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EventSubscriptionQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
    pub fn builder() -> crate::error::event_subscription_quota_exceeded_fault::Builder {
        crate::error::event_subscription_quota_exceeded_fault::Builder::default()
    }
}

/// See [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
pub mod event_subscription_quota_exceeded_fault {

    /// A builder for [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
        pub fn build(self) -> crate::error::EventSubscriptionQuotaExceededFault {
            crate::error::EventSubscriptionQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateEndpointAccessErrorKind = CreateEndpointAccessError;
/// Error type for the `CreateEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEndpointAccessError {
    /// <p>You are not authorized to access the cluster.</p>
    AccessToClusterDeniedFault(crate::error::AccessToClusterDeniedFault),
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
    EndpointAlreadyExistsFault(crate::error::EndpointAlreadyExistsFault),
    /// <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
    EndpointsPerAuthorizationLimitExceededFault(
        crate::error::EndpointsPerAuthorizationLimitExceededFault,
    ),
    /// <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
    EndpointsPerClusterLimitExceededFault(crate::error::EndpointsPerClusterLimitExceededFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessToClusterDeniedFault(_inner) => _inner.fmt(f),
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::EndpointsPerAuthorizationLimitExceededFault(_inner) => _inner.fmt(f),
            Self::EndpointsPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessToClusterDeniedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointsPerAuthorizationLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointsPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEndpointAccessError {
    /// Creates the `CreateEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessToClusterDeniedFault(e) => e.meta(),
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::EndpointAlreadyExistsFault(e) => e.meta(),
            Self::EndpointsPerAuthorizationLimitExceededFault(e) => e.meta(),
            Self::EndpointsPerClusterLimitExceededFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::AccessToClusterDeniedFault`.
    pub fn is_access_to_cluster_denied_fault(&self) -> bool {
        matches!(self, Self::AccessToClusterDeniedFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::EndpointAlreadyExistsFault`.
    pub fn is_endpoint_already_exists_fault(&self) -> bool {
        matches!(self, Self::EndpointAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::EndpointsPerAuthorizationLimitExceededFault`.
    pub fn is_endpoints_per_authorization_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::EndpointsPerAuthorizationLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::EndpointsPerClusterLimitExceededFault`.
    pub fn is_endpoints_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::EndpointsPerClusterLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
    /// Returns `true` if the error kind is `CreateEndpointAccessError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for CreateEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessToClusterDeniedFault(_inner) => Some(_inner),
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::EndpointAlreadyExistsFault(_inner) => Some(_inner),
            Self::EndpointsPerAuthorizationLimitExceededFault(_inner) => Some(_inner),
            Self::EndpointsPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of Redshift-managed VPC endpoints per cluster has exceeded its limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointsPerClusterLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointsPerClusterLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointsPerClusterLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointsPerClusterLimitExceededFault")?;
        if let Some(inner_110) = &self.message {
            {
                write!(f, ": {}", inner_110)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointsPerClusterLimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointsPerClusterLimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EndpointsPerClusterLimitExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointsPerClusterLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`EndpointsPerClusterLimitExceededFault`](crate::error::EndpointsPerClusterLimitExceededFault).
    pub fn builder() -> crate::error::endpoints_per_cluster_limit_exceeded_fault::Builder {
        crate::error::endpoints_per_cluster_limit_exceeded_fault::Builder::default()
    }
}

/// See [`EndpointsPerClusterLimitExceededFault`](crate::error::EndpointsPerClusterLimitExceededFault).
pub mod endpoints_per_cluster_limit_exceeded_fault {

    /// A builder for [`EndpointsPerClusterLimitExceededFault`](crate::error::EndpointsPerClusterLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointsPerClusterLimitExceededFault`](crate::error::EndpointsPerClusterLimitExceededFault).
        pub fn build(self) -> crate::error::EndpointsPerClusterLimitExceededFault {
            crate::error::EndpointsPerClusterLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The number of Redshift-managed VPC endpoints per authorization has exceeded its limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointsPerAuthorizationLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointsPerAuthorizationLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointsPerAuthorizationLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointsPerAuthorizationLimitExceededFault")?;
        if let Some(inner_111) = &self.message {
            {
                write!(f, ": {}", inner_111)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointsPerAuthorizationLimitExceededFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointsPerAuthorizationLimitExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EndpointsPerAuthorizationLimitExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointsPerAuthorizationLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`EndpointsPerAuthorizationLimitExceededFault`](crate::error::EndpointsPerAuthorizationLimitExceededFault).
    pub fn builder() -> crate::error::endpoints_per_authorization_limit_exceeded_fault::Builder {
        crate::error::endpoints_per_authorization_limit_exceeded_fault::Builder::default()
    }
}

/// See [`EndpointsPerAuthorizationLimitExceededFault`](crate::error::EndpointsPerAuthorizationLimitExceededFault).
pub mod endpoints_per_authorization_limit_exceeded_fault {

    /// A builder for [`EndpointsPerAuthorizationLimitExceededFault`](crate::error::EndpointsPerAuthorizationLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointsPerAuthorizationLimitExceededFault`](crate::error::EndpointsPerAuthorizationLimitExceededFault).
        pub fn build(self) -> crate::error::EndpointsPerAuthorizationLimitExceededFault {
            crate::error::EndpointsPerAuthorizationLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The account already has a Redshift-managed VPC endpoint with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointAlreadyExistsFault")?;
        if let Some(inner_112) = &self.message {
            {
                write!(f, ": {}", inner_112)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EndpointAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`EndpointAlreadyExistsFault`](crate::error::EndpointAlreadyExistsFault).
    pub fn builder() -> crate::error::endpoint_already_exists_fault::Builder {
        crate::error::endpoint_already_exists_fault::Builder::default()
    }
}

/// See [`EndpointAlreadyExistsFault`](crate::error::EndpointAlreadyExistsFault).
pub mod endpoint_already_exists_fault {

    /// A builder for [`EndpointAlreadyExistsFault`](crate::error::EndpointAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAlreadyExistsFault`](crate::error::EndpointAlreadyExistsFault).
        pub fn build(self) -> crate::error::EndpointAlreadyExistsFault {
            crate::error::EndpointAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You are not authorized to access the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessToClusterDeniedFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessToClusterDeniedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessToClusterDeniedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessToClusterDeniedFault")?;
        if let Some(inner_113) = &self.message {
            {
                write!(f, ": {}", inner_113)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessToClusterDeniedFault {}
impl aws_http::request_id::RequestId for crate::error::AccessToClusterDeniedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessToClusterDeniedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AccessToClusterDeniedFault {
    /// Creates a new builder-style object to manufacture [`AccessToClusterDeniedFault`](crate::error::AccessToClusterDeniedFault).
    pub fn builder() -> crate::error::access_to_cluster_denied_fault::Builder {
        crate::error::access_to_cluster_denied_fault::Builder::default()
    }
}

/// See [`AccessToClusterDeniedFault`](crate::error::AccessToClusterDeniedFault).
pub mod access_to_cluster_denied_fault {

    /// A builder for [`AccessToClusterDeniedFault`](crate::error::AccessToClusterDeniedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AccessToClusterDeniedFault`](crate::error::AccessToClusterDeniedFault).
        pub fn build(self) -> crate::error::AccessToClusterDeniedFault {
            crate::error::AccessToClusterDeniedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterSubnetGroupErrorKind = CreateClusterSubnetGroupError;
/// Error type for the `CreateClusterSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterSubnetGroupError {
    /// <p>A <i>ClusterSubnetGroupName</i> is already used by an existing cluster subnet group. </p>
    ClusterSubnetGroupAlreadyExistsFault(crate::error::ClusterSubnetGroupAlreadyExistsFault),
    /// <p>The request would result in user exceeding the allowed number of cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSubnetGroupQuotaExceededFault(crate::error::ClusterSubnetGroupQuotaExceededFault),
    /// <p>The request would result in user exceeding the allowed number of subnets in a cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSubnetQuotaExceededFault(crate::error::ClusterSubnetQuotaExceededFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSubnetGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSubnetGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterSubnetGroupError {
    /// Creates the `CreateClusterSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSubnetGroupAlreadyExistsFault(e) => e.meta(),
            Self::ClusterSubnetGroupQuotaExceededFault(e) => e.meta(),
            Self::ClusterSubnetQuotaExceededFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::ClusterSubnetGroupAlreadyExistsFault`.
    pub fn is_cluster_subnet_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::ClusterSubnetGroupQuotaExceededFault`.
    pub fn is_cluster_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::ClusterSubnetQuotaExceededFault`.
    pub fn is_cluster_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSubnetGroupError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for CreateClusterSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSubnetGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterSubnetGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::ClusterSubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request would result in user exceeding the allowed number of cluster subnet groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSubnetGroupQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSubnetGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSubnetGroupQuotaExceededFault")?;
        if let Some(inner_114) = &self.message {
            {
                write!(f, ": {}", inner_114)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSubnetGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSubnetGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterSubnetGroupQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterSubnetGroupQuotaExceededFault`](crate::error::ClusterSubnetGroupQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_subnet_group_quota_exceeded_fault::Builder {
        crate::error::cluster_subnet_group_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterSubnetGroupQuotaExceededFault`](crate::error::ClusterSubnetGroupQuotaExceededFault).
pub mod cluster_subnet_group_quota_exceeded_fault {

    /// A builder for [`ClusterSubnetGroupQuotaExceededFault`](crate::error::ClusterSubnetGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSubnetGroupQuotaExceededFault`](crate::error::ClusterSubnetGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterSubnetGroupQuotaExceededFault {
            crate::error::ClusterSubnetGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A <i>ClusterSubnetGroupName</i> is already used by an existing cluster subnet group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSubnetGroupAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSubnetGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSubnetGroupAlreadyExistsFault")?;
        if let Some(inner_115) = &self.message {
            {
                write!(f, ": {}", inner_115)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSubnetGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSubnetGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterSubnetGroupAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterSubnetGroupAlreadyExistsFault`](crate::error::ClusterSubnetGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_subnet_group_already_exists_fault::Builder {
        crate::error::cluster_subnet_group_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterSubnetGroupAlreadyExistsFault`](crate::error::ClusterSubnetGroupAlreadyExistsFault).
pub mod cluster_subnet_group_already_exists_fault {

    /// A builder for [`ClusterSubnetGroupAlreadyExistsFault`](crate::error::ClusterSubnetGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSubnetGroupAlreadyExistsFault`](crate::error::ClusterSubnetGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterSubnetGroupAlreadyExistsFault {
            crate::error::ClusterSubnetGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterSnapshotErrorKind = CreateClusterSnapshotError;
/// Error type for the `CreateClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterSnapshotError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The value specified as a snapshot identifier is already used by an existing snapshot.</p>
    ClusterSnapshotAlreadyExistsFault(crate::error::ClusterSnapshotAlreadyExistsFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster snapshots.</p>
    ClusterSnapshotQuotaExceededFault(crate::error::ClusterSnapshotQuotaExceededFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterSnapshotError {
    /// Creates the `CreateClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::ClusterSnapshotQuotaExceededFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::ClusterSnapshotAlreadyExistsFault`.
    pub fn is_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::ClusterSnapshotQuotaExceededFault`.
    pub fn is_cluster_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSnapshotError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterSecurityGroupErrorKind = CreateClusterSecurityGroupError;
/// Error type for the `CreateClusterSecurityGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterSecurityGroupError {
    /// <p>A cluster security group with the same name already exists.</p>
    ClusterSecurityGroupAlreadyExistsFault(crate::error::ClusterSecurityGroupAlreadyExistsFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster security groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterSecurityGroupQuotaExceededFault(crate::error::ClusterSecurityGroupQuotaExceededFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterSecurityGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSecurityGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterSecurityGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSecurityGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterSecurityGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterSecurityGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterSecurityGroupError {
    /// Creates the `CreateClusterSecurityGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterSecurityGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSecurityGroupAlreadyExistsFault(e) => e.meta(),
            Self::ClusterSecurityGroupQuotaExceededFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterSecurityGroupError::ClusterSecurityGroupAlreadyExistsFault`.
    pub fn is_cluster_security_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSecurityGroupError::ClusterSecurityGroupQuotaExceededFault`.
    pub fn is_cluster_security_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSecurityGroupError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterSecurityGroupError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateClusterSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSecurityGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster security groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSecurityGroupQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSecurityGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSecurityGroupQuotaExceededFault")?;
        if let Some(inner_116) = &self.message {
            {
                write!(f, ": {}", inner_116)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSecurityGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSecurityGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterSecurityGroupQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSecurityGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterSecurityGroupQuotaExceededFault`](crate::error::ClusterSecurityGroupQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_security_group_quota_exceeded_fault::Builder {
        crate::error::cluster_security_group_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterSecurityGroupQuotaExceededFault`](crate::error::ClusterSecurityGroupQuotaExceededFault).
pub mod cluster_security_group_quota_exceeded_fault {

    /// A builder for [`ClusterSecurityGroupQuotaExceededFault`](crate::error::ClusterSecurityGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSecurityGroupQuotaExceededFault`](crate::error::ClusterSecurityGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterSecurityGroupQuotaExceededFault {
            crate::error::ClusterSecurityGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A cluster security group with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterSecurityGroupAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterSecurityGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterSecurityGroupAlreadyExistsFault")?;
        if let Some(inner_117) = &self.message {
            {
                write!(f, ": {}", inner_117)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterSecurityGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterSecurityGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterSecurityGroupAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterSecurityGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterSecurityGroupAlreadyExistsFault`](crate::error::ClusterSecurityGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_security_group_already_exists_fault::Builder {
        crate::error::cluster_security_group_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterSecurityGroupAlreadyExistsFault`](crate::error::ClusterSecurityGroupAlreadyExistsFault).
pub mod cluster_security_group_already_exists_fault {

    /// A builder for [`ClusterSecurityGroupAlreadyExistsFault`](crate::error::ClusterSecurityGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSecurityGroupAlreadyExistsFault`](crate::error::ClusterSecurityGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterSecurityGroupAlreadyExistsFault {
            crate::error::ClusterSecurityGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterParameterGroupErrorKind = CreateClusterParameterGroupError;
/// Error type for the `CreateClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterParameterGroupError {
    /// <p>A cluster parameter group with the same name already exists.</p>
    ClusterParameterGroupAlreadyExistsFault(crate::error::ClusterParameterGroupAlreadyExistsFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster parameter groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterParameterGroupQuotaExceededFault(crate::error::ClusterParameterGroupQuotaExceededFault),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterParameterGroupError {
    /// Creates the `CreateClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::ClusterParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterParameterGroupError::ClusterParameterGroupAlreadyExistsFault`.
    pub fn is_cluster_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterParameterGroupError::ClusterParameterGroupQuotaExceededFault`.
    pub fn is_cluster_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterParameterGroupError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterParameterGroupError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
}
impl std::error::Error for CreateClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request would result in the user exceeding the allowed number of cluster parameter groups. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterParameterGroupQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterParameterGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterParameterGroupQuotaExceededFault")?;
        if let Some(inner_118) = &self.message {
            {
                write!(f, ": {}", inner_118)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterParameterGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterParameterGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterParameterGroupQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterParameterGroupQuotaExceededFault`](crate::error::ClusterParameterGroupQuotaExceededFault).
    pub fn builder() -> crate::error::cluster_parameter_group_quota_exceeded_fault::Builder {
        crate::error::cluster_parameter_group_quota_exceeded_fault::Builder::default()
    }
}

/// See [`ClusterParameterGroupQuotaExceededFault`](crate::error::ClusterParameterGroupQuotaExceededFault).
pub mod cluster_parameter_group_quota_exceeded_fault {

    /// A builder for [`ClusterParameterGroupQuotaExceededFault`](crate::error::ClusterParameterGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterGroupQuotaExceededFault`](crate::error::ClusterParameterGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::ClusterParameterGroupQuotaExceededFault {
            crate::error::ClusterParameterGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A cluster parameter group with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClusterParameterGroupAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClusterParameterGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterParameterGroupAlreadyExistsFault")?;
        if let Some(inner_119) = &self.message {
            {
                write!(f, ": {}", inner_119)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClusterParameterGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::ClusterParameterGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClusterParameterGroupAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ClusterParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ClusterParameterGroupAlreadyExistsFault`](crate::error::ClusterParameterGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::cluster_parameter_group_already_exists_fault::Builder {
        crate::error::cluster_parameter_group_already_exists_fault::Builder::default()
    }
}

/// See [`ClusterParameterGroupAlreadyExistsFault`](crate::error::ClusterParameterGroupAlreadyExistsFault).
pub mod cluster_parameter_group_already_exists_fault {

    /// A builder for [`ClusterParameterGroupAlreadyExistsFault`](crate::error::ClusterParameterGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterGroupAlreadyExistsFault`](crate::error::ClusterParameterGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::ClusterParameterGroupAlreadyExistsFault {
            crate::error::ClusterParameterGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateClusterErrorKind = CreateClusterError;
/// Error type for the `CreateClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateClusterError {
    /// <p>The account already has a cluster with the given identifier.</p>
    ClusterAlreadyExistsFault(crate::error::ClusterAlreadyExistsFault),
    /// <p>The parameter group name does not refer to an existing parameter group.</p>
    ClusterParameterGroupNotFoundFault(crate::error::ClusterParameterGroupNotFoundFault),
    /// <p>The request would exceed the allowed number of cluster instances for this account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    ClusterQuotaExceededFault(crate::error::ClusterQuotaExceededFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The cluster subnet group name does not refer to an existing cluster subnet group.</p>
    ClusterSubnetGroupNotFoundFault(crate::error::ClusterSubnetGroupNotFoundFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>There is no Amazon Redshift HSM client certificate with the specified identifier.</p>
    HsmClientCertificateNotFoundFault(crate::error::HsmClientCertificateNotFoundFault),
    /// <p>There is no Amazon Redshift HSM configuration with the specified identifier.</p>
    HsmConfigurationNotFoundFault(crate::error::HsmConfigurationNotFoundFault),
    /// <p>The number of nodes specified exceeds the allotted capacity of the cluster.</p>
    InsufficientClusterCapacityFault(crate::error::InsufficientClusterCapacityFault),
    /// <p>The cluster subnet group cannot be deleted because it is in use.</p>
    InvalidClusterSubnetGroupStateFault(crate::error::InvalidClusterSubnetGroupStateFault),
    /// <p>The provided cluster track name is not valid.</p>
    InvalidClusterTrackFault(crate::error::InvalidClusterTrackFault),
    /// <p>The Elastic IP (EIP) is invalid or cannot be found.</p>
    InvalidElasticIpFault(crate::error::InvalidElasticIpFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// <p>The requested subnet is not valid, or not all of the subnets are in the same VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>The tag is invalid.</p>
    InvalidTagFault(crate::error::InvalidTagFault),
    /// <p>The cluster subnet group does not cover all Availability Zones.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The operation would exceed the number of nodes allowed for a cluster.</p>
    NumberOfNodesPerClusterLimitExceededFault(
        crate::error::NumberOfNodesPerClusterLimitExceededFault,
    ),
    /// <p>The operation would exceed the number of nodes allotted to the account. For information about increasing your quota, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/amazon-redshift-limits.html">Limits in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
    NumberOfNodesQuotaExceededFault(crate::error::NumberOfNodesQuotaExceededFault),
    /// <p>We could not find the specified snapshot schedule. </p>
    SnapshotScheduleNotFoundFault(crate::error::SnapshotScheduleNotFoundFault),
    /// <p>You have exceeded the number of tags allowed.</p>
    TagLimitExceededFault(crate::error::TagLimitExceededFault),
    /// <p>Your account is not authorized to perform the requested operation.</p>
    UnauthorizedOperation(crate::error::UnauthorizedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::HsmClientCertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::HsmConfigurationNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterTrackFault(_inner) => _inner.fmt(f),
            Self::InvalidElasticIpFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidTagFault(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::NumberOfNodesQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::SnapshotScheduleNotFoundFault(_inner) => _inner.fmt(f),
            Self::TagLimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmClientCertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::HsmConfigurationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterTrackFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidElasticIpFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfNodesQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotScheduleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateClusterError {
    /// Creates the `CreateClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterAlreadyExistsFault(e) => e.meta(),
            Self::ClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::ClusterQuotaExceededFault(e) => e.meta(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::ClusterSubnetGroupNotFoundFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::HsmClientCertificateNotFoundFault(e) => e.meta(),
            Self::HsmConfigurationNotFoundFault(e) => e.meta(),
            Self::InsufficientClusterCapacityFault(e) => e.meta(),
            Self::InvalidClusterSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidClusterTrackFault(e) => e.meta(),
            Self::InvalidElasticIpFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidTagFault(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesPerClusterLimitExceededFault(e) => e.meta(),
            Self::NumberOfNodesQuotaExceededFault(e) => e.meta(),
            Self::SnapshotScheduleNotFoundFault(e) => e.meta(),
            Self::TagLimitExceededFault(e) => e.meta(),
            Self::UnauthorizedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterAlreadyExistsFault`.
    pub fn is_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterParameterGroupNotFoundFault`.
    pub fn is_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterQuotaExceededFault`.
    pub fn is_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::ClusterSubnetGroupNotFoundFault`.
    pub fn is_cluster_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::HsmClientCertificateNotFoundFault`.
    pub fn is_hsm_client_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmClientCertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::HsmConfigurationNotFoundFault`.
    pub fn is_hsm_configuration_not_found_fault(&self) -> bool {
        matches!(self, Self::HsmConfigurationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InsufficientClusterCapacityFault`.
    pub fn is_insufficient_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidClusterSubnetGroupStateFault`.
    pub fn is_invalid_cluster_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidClusterTrackFault`.
    pub fn is_invalid_cluster_track_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterTrackFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidElasticIpFault`.
    pub fn is_invalid_elastic_ip_fault(&self) -> bool {
        matches!(self, Self::InvalidElasticIpFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidTagFault`.
    pub fn is_invalid_tag_fault(&self) -> bool {
        matches!(self, Self::InvalidTagFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::NumberOfNodesPerClusterLimitExceededFault`.
    pub fn is_number_of_nodes_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesPerClusterLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::NumberOfNodesQuotaExceededFault`.
    pub fn is_number_of_nodes_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::NumberOfNodesQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::SnapshotScheduleNotFoundFault`.
    pub fn is_snapshot_schedule_not_found_fault(&self) -> bool {
        matches!(self, Self::SnapshotScheduleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::TagLimitExceededFault`.
    pub fn is_tag_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::TagLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateClusterError::UnauthorizedOperation`.
    pub fn is_unauthorized_operation(&self) -> bool {
        matches!(self, Self::UnauthorizedOperation(_))
    }
}
impl std::error::Error for CreateClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::HsmClientCertificateNotFoundFault(_inner) => Some(_inner),
            Self::HsmConfigurationNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidClusterSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidClusterTrackFault(_inner) => Some(_inner),
            Self::InvalidElasticIpFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidTagFault(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::NumberOfNodesQuotaExceededFault(_inner) => Some(_inner),
            Self::SnapshotScheduleNotFoundFault(_inner) => Some(_inner),
            Self::TagLimitExceededFault(_inner) => Some(_inner),
            Self::UnauthorizedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateAuthenticationProfileErrorKind = CreateAuthenticationProfileError;
/// Error type for the `CreateAuthenticationProfileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuthenticationProfileError {
    /// <p>The authentication profile already exists.</p>
    AuthenticationProfileAlreadyExistsFault(crate::error::AuthenticationProfileAlreadyExistsFault),
    /// <p>The size or number of authentication profiles has exceeded the quota. The maximum length of the JSON string and maximum number of authentication profiles is determined by a quota for your account.</p>
    AuthenticationProfileQuotaExceededFault(crate::error::AuthenticationProfileQuotaExceededFault),
    /// <p>The authentication profile request is not valid. The profile name can't be null or empty. The authentication profile API operation must be available in the Amazon Web Services Region.</p>
    InvalidAuthenticationProfileRequestFault(
        crate::error::InvalidAuthenticationProfileRequestFault,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateAuthenticationProfileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateAuthenticationProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthenticationProfileAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::AuthenticationProfileQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateAuthenticationProfileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthenticationProfileAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AuthenticationProfileQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthenticationProfileRequestFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateAuthenticationProfileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateAuthenticationProfileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuthenticationProfileError {
    /// Creates the `CreateAuthenticationProfileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateAuthenticationProfileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthenticationProfileAlreadyExistsFault(e) => e.meta(),
            Self::AuthenticationProfileQuotaExceededFault(e) => e.meta(),
            Self::InvalidAuthenticationProfileRequestFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateAuthenticationProfileError::AuthenticationProfileAlreadyExistsFault`.
    pub fn is_authentication_profile_already_exists_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateAuthenticationProfileError::AuthenticationProfileQuotaExceededFault`.
    pub fn is_authentication_profile_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::AuthenticationProfileQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateAuthenticationProfileError::InvalidAuthenticationProfileRequestFault`.
    pub fn is_invalid_authentication_profile_request_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthenticationProfileRequestFault(_))
    }
}
impl std::error::Error for CreateAuthenticationProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthenticationProfileAlreadyExistsFault(_inner) => Some(_inner),
            Self::AuthenticationProfileQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidAuthenticationProfileRequestFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The authentication profile already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthenticationProfileAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthenticationProfileAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthenticationProfileAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthenticationProfileAlreadyExistsFault")?;
        if let Some(inner_120) = &self.message {
            {
                write!(f, ": {}", inner_120)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthenticationProfileAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::AuthenticationProfileAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AuthenticationProfileAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthenticationProfileAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AuthenticationProfileAlreadyExistsFault`](crate::error::AuthenticationProfileAlreadyExistsFault).
    pub fn builder() -> crate::error::authentication_profile_already_exists_fault::Builder {
        crate::error::authentication_profile_already_exists_fault::Builder::default()
    }
}

/// See [`AuthenticationProfileAlreadyExistsFault`](crate::error::AuthenticationProfileAlreadyExistsFault).
pub mod authentication_profile_already_exists_fault {

    /// A builder for [`AuthenticationProfileAlreadyExistsFault`](crate::error::AuthenticationProfileAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationProfileAlreadyExistsFault`](crate::error::AuthenticationProfileAlreadyExistsFault).
        pub fn build(self) -> crate::error::AuthenticationProfileAlreadyExistsFault {
            crate::error::AuthenticationProfileAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyClusterSnapshotErrorKind = CopyClusterSnapshotError;
/// Error type for the `CopyClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyClusterSnapshotError {
    /// <p>The value specified as a snapshot identifier is already used by an existing snapshot.</p>
    ClusterSnapshotAlreadyExistsFault(crate::error::ClusterSnapshotAlreadyExistsFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The request would result in the user exceeding the allowed number of cluster snapshots.</p>
    ClusterSnapshotQuotaExceededFault(crate::error::ClusterSnapshotQuotaExceededFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyClusterSnapshotError {
    /// Creates the `CopyClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::ClusterSnapshotQuotaExceededFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyClusterSnapshotError::ClusterSnapshotAlreadyExistsFault`.
    pub fn is_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CopyClusterSnapshotError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopyClusterSnapshotError::ClusterSnapshotQuotaExceededFault`.
    pub fn is_cluster_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CopyClusterSnapshotError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `CopyClusterSnapshotError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
}
impl std::error::Error for CopyClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::ClusterSnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CancelResizeErrorKind = CancelResizeError;
/// Error type for the `CancelResizeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelResizeError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>A resize operation for the specified cluster is not found.</p>
    ResizeNotFoundFault(crate::error::ResizeNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CancelResizeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CancelResizeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::ResizeNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CancelResizeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResizeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CancelResizeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelResizeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelResizeError {
    /// Creates the `CancelResizeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CancelResizeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::ResizeNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CancelResizeError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CancelResizeError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CancelResizeError::ResizeNotFoundFault`.
    pub fn is_resize_not_found_fault(&self) -> bool {
        matches!(self, Self::ResizeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CancelResizeError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for CancelResizeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::ResizeNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchModifyClusterSnapshotsErrorKind = BatchModifyClusterSnapshotsError;
/// Error type for the `BatchModifyClusterSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchModifyClusterSnapshotsError {
    /// <p>The maximum number for snapshot identifiers has been reached. The limit is 100. </p>
    BatchModifyClusterSnapshotsLimitExceededFault(
        crate::error::BatchModifyClusterSnapshotsLimitExceededFault,
    ),
    /// <p>The retention period specified is either in the past or is not a valid value.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    InvalidRetentionPeriodFault(crate::error::InvalidRetentionPeriodFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchModifyClusterSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchModifyClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BatchModifyClusterSnapshotsLimitExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidRetentionPeriodFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchModifyClusterSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchModifyClusterSnapshotsLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRetentionPeriodFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchModifyClusterSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchModifyClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchModifyClusterSnapshotsError {
    /// Creates the `BatchModifyClusterSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchModifyClusterSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BatchModifyClusterSnapshotsLimitExceededFault(e) => e.meta(),
            Self::InvalidRetentionPeriodFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchModifyClusterSnapshotsError::BatchModifyClusterSnapshotsLimitExceededFault`.
    pub fn is_batch_modify_cluster_snapshots_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::BatchModifyClusterSnapshotsLimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `BatchModifyClusterSnapshotsError::InvalidRetentionPeriodFault`.
    pub fn is_invalid_retention_period_fault(&self) -> bool {
        matches!(self, Self::InvalidRetentionPeriodFault(_))
    }
}
impl std::error::Error for BatchModifyClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BatchModifyClusterSnapshotsLimitExceededFault(_inner) => Some(_inner),
            Self::InvalidRetentionPeriodFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number for snapshot identifiers has been reached. The limit is 100. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchModifyClusterSnapshotsLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BatchModifyClusterSnapshotsLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BatchModifyClusterSnapshotsLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BatchModifyClusterSnapshotsLimitExceededFault")?;
        if let Some(inner_121) = &self.message {
            {
                write!(f, ": {}", inner_121)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BatchModifyClusterSnapshotsLimitExceededFault {}
impl aws_http::request_id::RequestId
    for crate::error::BatchModifyClusterSnapshotsLimitExceededFault
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for BatchModifyClusterSnapshotsLimitExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BatchModifyClusterSnapshotsLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`BatchModifyClusterSnapshotsLimitExceededFault`](crate::error::BatchModifyClusterSnapshotsLimitExceededFault).
    pub fn builder() -> crate::error::batch_modify_cluster_snapshots_limit_exceeded_fault::Builder {
        crate::error::batch_modify_cluster_snapshots_limit_exceeded_fault::Builder::default()
    }
}

/// See [`BatchModifyClusterSnapshotsLimitExceededFault`](crate::error::BatchModifyClusterSnapshotsLimitExceededFault).
pub mod batch_modify_cluster_snapshots_limit_exceeded_fault {

    /// A builder for [`BatchModifyClusterSnapshotsLimitExceededFault`](crate::error::BatchModifyClusterSnapshotsLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BatchModifyClusterSnapshotsLimitExceededFault`](crate::error::BatchModifyClusterSnapshotsLimitExceededFault).
        pub fn build(self) -> crate::error::BatchModifyClusterSnapshotsLimitExceededFault {
            crate::error::BatchModifyClusterSnapshotsLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchDeleteClusterSnapshotsErrorKind = BatchDeleteClusterSnapshotsError;
/// Error type for the `BatchDeleteClusterSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDeleteClusterSnapshotsError {
    /// <p>The maximum number for a batch delete of snapshots has been reached. The limit is 100. </p>
    BatchDeleteRequestSizeExceededFault(crate::error::BatchDeleteRequestSizeExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchDeleteClusterSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchDeleteClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BatchDeleteRequestSizeExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchDeleteClusterSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchDeleteRequestSizeExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchDeleteClusterSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDeleteClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDeleteClusterSnapshotsError {
    /// Creates the `BatchDeleteClusterSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchDeleteClusterSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BatchDeleteRequestSizeExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchDeleteClusterSnapshotsError::BatchDeleteRequestSizeExceededFault`.
    pub fn is_batch_delete_request_size_exceeded_fault(&self) -> bool {
        matches!(self, Self::BatchDeleteRequestSizeExceededFault(_))
    }
}
impl std::error::Error for BatchDeleteClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BatchDeleteRequestSizeExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number for a batch delete of snapshots has been reached. The limit is 100. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteRequestSizeExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BatchDeleteRequestSizeExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BatchDeleteRequestSizeExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BatchDeleteRequestSizeExceededFault")?;
        if let Some(inner_122) = &self.message {
            {
                write!(f, ": {}", inner_122)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BatchDeleteRequestSizeExceededFault {}
impl aws_http::request_id::RequestId for crate::error::BatchDeleteRequestSizeExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for BatchDeleteRequestSizeExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BatchDeleteRequestSizeExceededFault {
    /// Creates a new builder-style object to manufacture [`BatchDeleteRequestSizeExceededFault`](crate::error::BatchDeleteRequestSizeExceededFault).
    pub fn builder() -> crate::error::batch_delete_request_size_exceeded_fault::Builder {
        crate::error::batch_delete_request_size_exceeded_fault::Builder::default()
    }
}

/// See [`BatchDeleteRequestSizeExceededFault`](crate::error::BatchDeleteRequestSizeExceededFault).
pub mod batch_delete_request_size_exceeded_fault {

    /// A builder for [`BatchDeleteRequestSizeExceededFault`](crate::error::BatchDeleteRequestSizeExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteRequestSizeExceededFault`](crate::error::BatchDeleteRequestSizeExceededFault).
        pub fn build(self) -> crate::error::BatchDeleteRequestSizeExceededFault {
            crate::error::BatchDeleteRequestSizeExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AuthorizeSnapshotAccessErrorKind = AuthorizeSnapshotAccessError;
/// Error type for the `AuthorizeSnapshotAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeSnapshotAccessError {
    /// <p>The specified CIDR block or EC2 security group is already authorized for the specified cluster security group.</p>
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    /// <p>The authorization quota for the cluster security group has been reached.</p>
    AuthorizationQuotaExceededFault(crate::error::AuthorizationQuotaExceededFault),
    /// <p>The snapshot identifier does not refer to an existing cluster snapshot.</p>
    ClusterSnapshotNotFoundFault(crate::error::ClusterSnapshotNotFoundFault),
    /// <p>The request cannot be completed because a dependent service is throttling requests made by Amazon Redshift on your behalf. Wait and retry the request.</p>
    DependentServiceRequestThrottlingFault(crate::error::DependentServiceRequestThrottlingFault),
    /// <p>The specified cluster snapshot is not in the <code>available</code> state, or other accounts are authorized to access the snapshot. </p>
    InvalidClusterSnapshotStateFault(crate::error::InvalidClusterSnapshotStateFault),
    /// <p>The encryption key has exceeded its grant limit in Amazon Web Services KMS.</p>
    LimitExceededFault(crate::error::LimitExceededFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AuthorizeSnapshotAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AuthorizeSnapshotAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::AuthorizationQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DependentServiceRequestThrottlingFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::LimitExceededFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizeSnapshotAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AuthorizationQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DependentServiceRequestThrottlingFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AuthorizeSnapshotAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AuthorizeSnapshotAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeSnapshotAccessError {
    /// Creates the `AuthorizeSnapshotAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AuthorizeSnapshotAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorizationAlreadyExistsFault(e) => e.meta(),
            Self::AuthorizationQuotaExceededFault(e) => e.meta(),
            Self::ClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::DependentServiceRequestThrottlingFault(e) => e.meta(),
            Self::InvalidClusterSnapshotStateFault(e) => e.meta(),
            Self::LimitExceededFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::AuthorizationAlreadyExistsFault`.
    pub fn is_authorization_already_exists_fault(&self) -> bool {
        matches!(self, Self::AuthorizationAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::AuthorizationQuotaExceededFault`.
    pub fn is_authorization_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::AuthorizationQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::ClusterSnapshotNotFoundFault`.
    pub fn is_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::DependentServiceRequestThrottlingFault`.
    pub fn is_dependent_service_request_throttling_fault(&self) -> bool {
        matches!(self, Self::DependentServiceRequestThrottlingFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::InvalidClusterSnapshotStateFault`.
    pub fn is_invalid_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::LimitExceededFault`.
    pub fn is_limit_exceeded_fault(&self) -> bool {
        matches!(self, Self::LimitExceededFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeSnapshotAccessError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for AuthorizeSnapshotAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => Some(_inner),
            Self::AuthorizationQuotaExceededFault(_inner) => Some(_inner),
            Self::ClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::DependentServiceRequestThrottlingFault(_inner) => Some(_inner),
            Self::InvalidClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::LimitExceededFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The authorization quota for the cluster security group has been reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorizationQuotaExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthorizationQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationQuotaExceededFault")?;
        if let Some(inner_123) = &self.message {
            {
                write!(f, ": {}", inner_123)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::AuthorizationQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizationQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthorizationQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault).
    pub fn builder() -> crate::error::authorization_quota_exceeded_fault::Builder {
        crate::error::authorization_quota_exceeded_fault::Builder::default()
    }
}

/// See [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault).
pub mod authorization_quota_exceeded_fault {

    /// A builder for [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationQuotaExceededFault`](crate::error::AuthorizationQuotaExceededFault).
        pub fn build(self) -> crate::error::AuthorizationQuotaExceededFault {
            crate::error::AuthorizationQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified CIDR block or EC2 security group is already authorized for the specified cluster security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorizationAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthorizationAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationAlreadyExistsFault")?;
        if let Some(inner_124) = &self.message {
            {
                write!(f, ": {}", inner_124)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::AuthorizationAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizationAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AuthorizationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault).
    pub fn builder() -> crate::error::authorization_already_exists_fault::Builder {
        crate::error::authorization_already_exists_fault::Builder::default()
    }
}

/// See [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault).
pub mod authorization_already_exists_fault {

    /// A builder for [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault).
        pub fn build(self) -> crate::error::AuthorizationAlreadyExistsFault {
            crate::error::AuthorizationAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AuthorizeEndpointAccessErrorKind = AuthorizeEndpointAccessError;
/// Error type for the `AuthorizeEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeEndpointAccessError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The authorization already exists for this endpoint.</p>
    EndpointAuthorizationAlreadyExistsFault(crate::error::EndpointAuthorizationAlreadyExistsFault),
    /// <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
    EndpointAuthorizationsPerClusterLimitExceededFault(
        crate::error::EndpointAuthorizationsPerClusterLimitExceededFault,
    ),
    /// <p>The status of the authorization is not valid.</p>
    InvalidAuthorizationStateFault(crate::error::InvalidAuthorizationStateFault),
    /// <p>The specified cluster is not in the <code>available</code> state. </p>
    InvalidClusterStateFault(crate::error::InvalidClusterStateFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AuthorizeEndpointAccessError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AuthorizeEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::EndpointAuthorizationAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidAuthorizationStateFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterStateFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizeEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointAuthorizationAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthorizationStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AuthorizeEndpointAccessError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AuthorizeEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeEndpointAccessError {
    /// Creates the `AuthorizeEndpointAccessError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AuthorizeEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::EndpointAuthorizationAlreadyExistsFault(e) => e.meta(),
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(e) => e.meta(),
            Self::InvalidAuthorizationStateFault(e) => e.meta(),
            Self::InvalidClusterStateFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::EndpointAuthorizationAlreadyExistsFault`.
    pub fn is_endpoint_authorization_already_exists_fault(&self) -> bool {
        matches!(self, Self::EndpointAuthorizationAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::EndpointAuthorizationsPerClusterLimitExceededFault`.
    pub fn is_endpoint_authorizations_per_cluster_limit_exceeded_fault(&self) -> bool {
        matches!(
            self,
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(_)
        )
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::InvalidAuthorizationStateFault`.
    pub fn is_invalid_authorization_state_fault(&self) -> bool {
        matches!(self, Self::InvalidAuthorizationStateFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::InvalidClusterStateFault`.
    pub fn is_invalid_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeEndpointAccessError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for AuthorizeEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::EndpointAuthorizationAlreadyExistsFault(_inner) => Some(_inner),
            Self::EndpointAuthorizationsPerClusterLimitExceededFault(_inner) => Some(_inner),
            Self::InvalidAuthorizationStateFault(_inner) => Some(_inner),
            Self::InvalidClusterStateFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of endpoint authorizations per cluster has exceeded its limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointAuthorizationsPerClusterLimitExceededFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointAuthorizationsPerClusterLimitExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointAuthorizationsPerClusterLimitExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointAuthorizationsPerClusterLimitExceededFault")?;
        if let Some(inner_125) = &self.message {
            {
                write!(f, ": {}", inner_125)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointAuthorizationsPerClusterLimitExceededFault {}
impl aws_http::request_id::RequestId
    for crate::error::EndpointAuthorizationsPerClusterLimitExceededFault
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EndpointAuthorizationsPerClusterLimitExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointAuthorizationsPerClusterLimitExceededFault {
    /// Creates a new builder-style object to manufacture [`EndpointAuthorizationsPerClusterLimitExceededFault`](crate::error::EndpointAuthorizationsPerClusterLimitExceededFault).
    pub fn builder(
    ) -> crate::error::endpoint_authorizations_per_cluster_limit_exceeded_fault::Builder {
        crate::error::endpoint_authorizations_per_cluster_limit_exceeded_fault::Builder::default()
    }
}

/// See [`EndpointAuthorizationsPerClusterLimitExceededFault`](crate::error::EndpointAuthorizationsPerClusterLimitExceededFault).
pub mod endpoint_authorizations_per_cluster_limit_exceeded_fault {

    /// A builder for [`EndpointAuthorizationsPerClusterLimitExceededFault`](crate::error::EndpointAuthorizationsPerClusterLimitExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAuthorizationsPerClusterLimitExceededFault`](crate::error::EndpointAuthorizationsPerClusterLimitExceededFault).
        pub fn build(self) -> crate::error::EndpointAuthorizationsPerClusterLimitExceededFault {
            crate::error::EndpointAuthorizationsPerClusterLimitExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The authorization already exists for this endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EndpointAuthorizationAlreadyExistsFault {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EndpointAuthorizationAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EndpointAuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EndpointAuthorizationAlreadyExistsFault")?;
        if let Some(inner_126) = &self.message {
            {
                write!(f, ": {}", inner_126)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EndpointAuthorizationAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::EndpointAuthorizationAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EndpointAuthorizationAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EndpointAuthorizationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`EndpointAuthorizationAlreadyExistsFault`](crate::error::EndpointAuthorizationAlreadyExistsFault).
    pub fn builder() -> crate::error::endpoint_authorization_already_exists_fault::Builder {
        crate::error::endpoint_authorization_already_exists_fault::Builder::default()
    }
}

/// See [`EndpointAuthorizationAlreadyExistsFault`](crate::error::EndpointAuthorizationAlreadyExistsFault).
pub mod endpoint_authorization_already_exists_fault {

    /// A builder for [`EndpointAuthorizationAlreadyExistsFault`](crate::error::EndpointAuthorizationAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAuthorizationAlreadyExistsFault`](crate::error::EndpointAuthorizationAlreadyExistsFault).
        pub fn build(self) -> crate::error::EndpointAuthorizationAlreadyExistsFault {
            crate::error::EndpointAuthorizationAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AuthorizeDataShareErrorKind = AuthorizeDataShareError;
/// Error type for the `AuthorizeDataShareError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeDataShareError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AuthorizeDataShareError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AuthorizeDataShareError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizeDataShareError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AuthorizeDataShareError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AuthorizeDataShareError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeDataShareError {
    /// Creates the `AuthorizeDataShareError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AuthorizeDataShareError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AuthorizeDataShareError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
}
impl std::error::Error for AuthorizeDataShareError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AuthorizeClusterSecurityGroupIngressErrorKind = AuthorizeClusterSecurityGroupIngressError;
/// Error type for the `AuthorizeClusterSecurityGroupIngressError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeClusterSecurityGroupIngressError {
    /// <p>The specified CIDR block or EC2 security group is already authorized for the specified cluster security group.</p>
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    /// <p>The authorization quota for the cluster security group has been reached.</p>
    AuthorizationQuotaExceededFault(crate::error::AuthorizationQuotaExceededFault),
    /// <p>The cluster security group name does not refer to an existing cluster security group.</p>
    ClusterSecurityGroupNotFoundFault(crate::error::ClusterSecurityGroupNotFoundFault),
    /// <p>The state of the cluster security group is not <code>available</code>. </p>
    InvalidClusterSecurityGroupStateFault(crate::error::InvalidClusterSecurityGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AuthorizeClusterSecurityGroupIngressError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AuthorizeClusterSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::AuthorizationQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AuthorizeClusterSecurityGroupIngressError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::AuthorizationQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClusterSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClusterSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AuthorizeClusterSecurityGroupIngressError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AuthorizeClusterSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeClusterSecurityGroupIngressError {
    /// Creates the `AuthorizeClusterSecurityGroupIngressError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AuthorizeClusterSecurityGroupIngressError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorizationAlreadyExistsFault(e) => e.meta(),
            Self::AuthorizationQuotaExceededFault(e) => e.meta(),
            Self::ClusterSecurityGroupNotFoundFault(e) => e.meta(),
            Self::InvalidClusterSecurityGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AuthorizeClusterSecurityGroupIngressError::AuthorizationAlreadyExistsFault`.
    pub fn is_authorization_already_exists_fault(&self) -> bool {
        matches!(self, Self::AuthorizationAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeClusterSecurityGroupIngressError::AuthorizationQuotaExceededFault`.
    pub fn is_authorization_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::AuthorizationQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeClusterSecurityGroupIngressError::ClusterSecurityGroupNotFoundFault`.
    pub fn is_cluster_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AuthorizeClusterSecurityGroupIngressError::InvalidClusterSecurityGroupStateFault`.
    pub fn is_invalid_cluster_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidClusterSecurityGroupStateFault(_))
    }
}
impl std::error::Error for AuthorizeClusterSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorizationAlreadyExistsFault(_inner) => Some(_inner),
            Self::AuthorizationQuotaExceededFault(_inner) => Some(_inner),
            Self::ClusterSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidClusterSecurityGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AssociateDataShareConsumerErrorKind = AssociateDataShareConsumerError;
/// Error type for the `AssociateDataShareConsumerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateDataShareConsumerError {
    /// <p>There is an error with the datashare.</p>
    InvalidDataShareFault(crate::error::InvalidDataShareFault),
    /// <p>The namespace isn't valid because the namespace doesn't exist. Provide a valid namespace.</p>
    InvalidNamespaceFault(crate::error::InvalidNamespaceFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateDataShareConsumerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AssociateDataShareConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDataShareFault(_inner) => _inner.fmt(f),
            Self::InvalidNamespaceFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociateDataShareConsumerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDataShareFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNamespaceFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociateDataShareConsumerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateDataShareConsumerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateDataShareConsumerError {
    /// Creates the `AssociateDataShareConsumerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AssociateDataShareConsumerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDataShareFault(e) => e.meta(),
            Self::InvalidNamespaceFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateDataShareConsumerError::InvalidDataShareFault`.
    pub fn is_invalid_data_share_fault(&self) -> bool {
        matches!(self, Self::InvalidDataShareFault(_))
    }
    /// Returns `true` if the error kind is `AssociateDataShareConsumerError::InvalidNamespaceFault`.
    pub fn is_invalid_namespace_fault(&self) -> bool {
        matches!(self, Self::InvalidNamespaceFault(_))
    }
}
impl std::error::Error for AssociateDataShareConsumerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDataShareFault(_inner) => Some(_inner),
            Self::InvalidNamespaceFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddPartnerErrorKind = AddPartnerError;
/// Error type for the `AddPartnerError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddPartnerError {
    /// <p>The <code>ClusterIdentifier</code> parameter does not refer to an existing cluster. </p>
    ClusterNotFoundFault(crate::error::ClusterNotFoundFault),
    /// <p>The name of the partner was not found.</p>
    PartnerNotFoundFault(crate::error::PartnerNotFoundFault),
    /// <p>The partner integration is not authorized.</p>
    UnauthorizedPartnerIntegrationFault(crate::error::UnauthorizedPartnerIntegrationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddPartnerError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddPartnerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::PartnerNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddPartnerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PartnerNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnauthorizedPartnerIntegrationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddPartnerError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddPartnerError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddPartnerError {
    /// Creates the `AddPartnerError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddPartnerError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClusterNotFoundFault(e) => e.meta(),
            Self::PartnerNotFoundFault(e) => e.meta(),
            Self::UnauthorizedPartnerIntegrationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddPartnerError::ClusterNotFoundFault`.
    pub fn is_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::ClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddPartnerError::PartnerNotFoundFault`.
    pub fn is_partner_not_found_fault(&self) -> bool {
        matches!(self, Self::PartnerNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddPartnerError::UnauthorizedPartnerIntegrationFault`.
    pub fn is_unauthorized_partner_integration_fault(&self) -> bool {
        matches!(self, Self::UnauthorizedPartnerIntegrationFault(_))
    }
}
impl std::error::Error for AddPartnerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClusterNotFoundFault(_inner) => Some(_inner),
            Self::PartnerNotFoundFault(_inner) => Some(_inner),
            Self::UnauthorizedPartnerIntegrationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AcceptReservedNodeExchangeErrorKind = AcceptReservedNodeExchangeError;
/// Error type for the `AcceptReservedNodeExchangeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptReservedNodeExchangeError {
    /// <p>Your request cannot be completed because a dependent internal service is temporarily unavailable. Wait 30 to 60 seconds and try again.</p>
    DependentServiceUnavailableFault(crate::error::DependentServiceUnavailableFault),
    /// <p>Indicates that the Reserved Node being exchanged is not in an active state.</p>
    InvalidReservedNodeStateFault(crate::error::InvalidReservedNodeStateFault),
    /// <p>User already has a reservation with the given identifier.</p>
    ReservedNodeAlreadyExistsFault(crate::error::ReservedNodeAlreadyExistsFault),
    /// <p>Indicates that the reserved node has already been exchanged.</p>
    ReservedNodeAlreadyMigratedFault(crate::error::ReservedNodeAlreadyMigratedFault),
    /// <p>The specified reserved compute node not found.</p>
    ReservedNodeNotFoundFault(crate::error::ReservedNodeNotFoundFault),
    /// <p>Specified offering does not exist.</p>
    ReservedNodeOfferingNotFoundFault(crate::error::ReservedNodeOfferingNotFoundFault),
    /// <p>The requested operation isn't supported.</p>
    UnsupportedOperationFault(crate::error::UnsupportedOperationFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AcceptReservedNodeExchangeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AcceptReservedNodeExchangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => _inner.fmt(f),
            Self::InvalidReservedNodeStateFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeNotFoundFault(_inner) => _inner.fmt(f),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => _inner.fmt(f),
            Self::UnsupportedOperationFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AcceptReservedNodeExchangeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReservedNodeStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeAlreadyMigratedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReservedNodeOfferingNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AcceptReservedNodeExchangeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AcceptReservedNodeExchangeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptReservedNodeExchangeError {
    /// Creates the `AcceptReservedNodeExchangeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AcceptReservedNodeExchangeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DependentServiceUnavailableFault(e) => e.meta(),
            Self::InvalidReservedNodeStateFault(e) => e.meta(),
            Self::ReservedNodeAlreadyExistsFault(e) => e.meta(),
            Self::ReservedNodeAlreadyMigratedFault(e) => e.meta(),
            Self::ReservedNodeNotFoundFault(e) => e.meta(),
            Self::ReservedNodeOfferingNotFoundFault(e) => e.meta(),
            Self::UnsupportedOperationFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::DependentServiceUnavailableFault`.
    pub fn is_dependent_service_unavailable_fault(&self) -> bool {
        matches!(self, Self::DependentServiceUnavailableFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::InvalidReservedNodeStateFault`.
    pub fn is_invalid_reserved_node_state_fault(&self) -> bool {
        matches!(self, Self::InvalidReservedNodeStateFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::ReservedNodeAlreadyExistsFault`.
    pub fn is_reserved_node_already_exists_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::ReservedNodeAlreadyMigratedFault`.
    pub fn is_reserved_node_already_migrated_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeAlreadyMigratedFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::ReservedNodeNotFoundFault`.
    pub fn is_reserved_node_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::ReservedNodeOfferingNotFoundFault`.
    pub fn is_reserved_node_offering_not_found_fault(&self) -> bool {
        matches!(self, Self::ReservedNodeOfferingNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AcceptReservedNodeExchangeError::UnsupportedOperationFault`.
    pub fn is_unsupported_operation_fault(&self) -> bool {
        matches!(self, Self::UnsupportedOperationFault(_))
    }
}
impl std::error::Error for AcceptReservedNodeExchangeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DependentServiceUnavailableFault(_inner) => Some(_inner),
            Self::InvalidReservedNodeStateFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyExistsFault(_inner) => Some(_inner),
            Self::ReservedNodeAlreadyMigratedFault(_inner) => Some(_inner),
            Self::ReservedNodeNotFoundFault(_inner) => Some(_inner),
            Self::ReservedNodeOfferingNotFoundFault(_inner) => Some(_inner),
            Self::UnsupportedOperationFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
