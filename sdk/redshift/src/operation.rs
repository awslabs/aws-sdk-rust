// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the
/// configuration (term, payment type, or number of nodes) and no additional costs.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AcceptReservedNodeExchange {
    _private: (),
}
impl AcceptReservedNodeExchange {
    /// Creates a new builder-style object to manufacture [`AcceptReservedNodeExchangeInput`](crate::input::AcceptReservedNodeExchangeInput)
    pub fn builder() -> crate::input::accept_reserved_node_exchange_input::Builder {
        crate::input::accept_reserved_node_exchange_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AcceptReservedNodeExchange {
    type Output = std::result::Result<
        crate::output::AcceptReservedNodeExchangeOutput,
        crate::error::AcceptReservedNodeExchangeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_accept_reserved_node_exchange_error(response)
        } else {
            crate::operation_ser::parse_accept_reserved_node_exchange_response(response)
        }
    }
}

/// <p>Adds a partner integration to a cluster.
/// This operation authorizes a partner to push status updates for the specified database.
/// To complete the integration, you also set up the integration on the partner website.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddPartner {
    _private: (),
}
impl AddPartner {
    /// Creates a new builder-style object to manufacture [`AddPartnerInput`](crate::input::AddPartnerInput)
    pub fn builder() -> crate::input::add_partner_input::Builder {
        crate::input::add_partner_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddPartner {
    type Output =
        std::result::Result<crate::output::AddPartnerOutput, crate::error::AddPartnerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_add_partner_error(response)
        } else {
            crate::operation_ser::parse_add_partner_response(response)
        }
    }
}

/// <p>From a datashare consumer account, associates a datashare with the
/// account (AssociateEntireAccount) or the specified namespace (ConsumerArn). If you make this association, the consumer
/// can consume the datashare.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateDataShareConsumer {
    _private: (),
}
impl AssociateDataShareConsumer {
    /// Creates a new builder-style object to manufacture [`AssociateDataShareConsumerInput`](crate::input::AssociateDataShareConsumerInput)
    pub fn builder() -> crate::input::associate_data_share_consumer_input::Builder {
        crate::input::associate_data_share_consumer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateDataShareConsumer {
    type Output = std::result::Result<
        crate::output::AssociateDataShareConsumerOutput,
        crate::error::AssociateDataShareConsumerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_associate_data_share_consumer_error(response)
        } else {
            crate::operation_ser::parse_associate_data_share_consumer_response(response)
        }
    }
}

/// <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether
/// the application accessing your cluster is running on the Internet or an Amazon EC2
/// instance, you can authorize inbound access to either a Classless Interdomain Routing
/// (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as
/// many as 20 ingress rules to an Amazon Redshift security group.</p>
/// <p>If you authorize access to an Amazon EC2 security group, specify
/// <i>EC2SecurityGroupName</i> and
/// <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and
/// Amazon Redshift cluster must be in the same Amazon Web Services Region. </p>
/// <p>If you authorize access to a CIDR/IP address range, specify
/// <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia
/// article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p>
/// <p>You must also associate the security group with a cluster so that clients running
/// on these IP addresses or the EC2 instance are authorized to connect to the cluster. For
/// information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security
/// Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AuthorizeClusterSecurityGroupIngress {
    _private: (),
}
impl AuthorizeClusterSecurityGroupIngress {
    /// Creates a new builder-style object to manufacture [`AuthorizeClusterSecurityGroupIngressInput`](crate::input::AuthorizeClusterSecurityGroupIngressInput)
    pub fn builder() -> crate::input::authorize_cluster_security_group_ingress_input::Builder {
        crate::input::authorize_cluster_security_group_ingress_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AuthorizeClusterSecurityGroupIngress {
    type Output = std::result::Result<
        crate::output::AuthorizeClusterSecurityGroupIngressOutput,
        crate::error::AuthorizeClusterSecurityGroupIngressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_authorize_cluster_security_group_ingress_error(response)
        } else {
            crate::operation_ser::parse_authorize_cluster_security_group_ingress_response(response)
        }
    }
}

/// <p>From a data producer account, authorizes the sharing of a datashare with one or more
/// consumer accounts. To authorize a datashare for a data consumer, the producer account
/// must have the correct access privileges.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AuthorizeDataShare {
    _private: (),
}
impl AuthorizeDataShare {
    /// Creates a new builder-style object to manufacture [`AuthorizeDataShareInput`](crate::input::AuthorizeDataShareInput)
    pub fn builder() -> crate::input::authorize_data_share_input::Builder {
        crate::input::authorize_data_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AuthorizeDataShare {
    type Output = std::result::Result<
        crate::output::AuthorizeDataShareOutput,
        crate::error::AuthorizeDataShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_authorize_data_share_error(response)
        } else {
            crate::operation_ser::parse_authorize_data_share_response(response)
        }
    }
}

/// <p>Grants access to a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AuthorizeEndpointAccess {
    _private: (),
}
impl AuthorizeEndpointAccess {
    /// Creates a new builder-style object to manufacture [`AuthorizeEndpointAccessInput`](crate::input::AuthorizeEndpointAccessInput)
    pub fn builder() -> crate::input::authorize_endpoint_access_input::Builder {
        crate::input::authorize_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AuthorizeEndpointAccess {
    type Output = std::result::Result<
        crate::output::AuthorizeEndpointAccessOutput,
        crate::error::AuthorizeEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_authorize_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_authorize_endpoint_access_response(response)
        }
    }
}

/// <p>Authorizes the specified Amazon Web Services account to restore the specified
/// snapshot.</p>
/// <p>
/// For more information about working with snapshots, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AuthorizeSnapshotAccess {
    _private: (),
}
impl AuthorizeSnapshotAccess {
    /// Creates a new builder-style object to manufacture [`AuthorizeSnapshotAccessInput`](crate::input::AuthorizeSnapshotAccessInput)
    pub fn builder() -> crate::input::authorize_snapshot_access_input::Builder {
        crate::input::authorize_snapshot_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AuthorizeSnapshotAccess {
    type Output = std::result::Result<
        crate::output::AuthorizeSnapshotAccessOutput,
        crate::error::AuthorizeSnapshotAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_authorize_snapshot_access_error(response)
        } else {
            crate::operation_ser::parse_authorize_snapshot_access_response(response)
        }
    }
}

/// <p>Deletes a set of cluster snapshots.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteClusterSnapshots {
    _private: (),
}
impl BatchDeleteClusterSnapshots {
    /// Creates a new builder-style object to manufacture [`BatchDeleteClusterSnapshotsInput`](crate::input::BatchDeleteClusterSnapshotsInput)
    pub fn builder() -> crate::input::batch_delete_cluster_snapshots_input::Builder {
        crate::input::batch_delete_cluster_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteClusterSnapshots {
    type Output = std::result::Result<
        crate::output::BatchDeleteClusterSnapshotsOutput,
        crate::error::BatchDeleteClusterSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_delete_cluster_snapshots_error(response)
        } else {
            crate::operation_ser::parse_batch_delete_cluster_snapshots_response(response)
        }
    }
}

/// <p>Modifies the settings for a set of cluster snapshots.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchModifyClusterSnapshots {
    _private: (),
}
impl BatchModifyClusterSnapshots {
    /// Creates a new builder-style object to manufacture [`BatchModifyClusterSnapshotsInput`](crate::input::BatchModifyClusterSnapshotsInput)
    pub fn builder() -> crate::input::batch_modify_cluster_snapshots_input::Builder {
        crate::input::batch_modify_cluster_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchModifyClusterSnapshots {
    type Output = std::result::Result<
        crate::output::BatchModifyClusterSnapshotsOutput,
        crate::error::BatchModifyClusterSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_modify_cluster_snapshots_error(response)
        } else {
            crate::operation_ser::parse_batch_modify_cluster_snapshots_response(response)
        }
    }
}

/// <p>Cancels a resize operation for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelResize {
    _private: (),
}
impl CancelResize {
    /// Creates a new builder-style object to manufacture [`CancelResizeInput`](crate::input::CancelResizeInput)
    pub fn builder() -> crate::input::cancel_resize_input::Builder {
        crate::input::cancel_resize_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelResize {
    type Output =
        std::result::Result<crate::output::CancelResizeOutput, crate::error::CancelResizeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_cancel_resize_error(response)
        } else {
            crate::operation_ser::parse_cancel_resize_response(response)
        }
    }
}

/// <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot.
/// The source must be an automated snapshot and it must be in the available
/// state.</p>
/// <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the
/// cluster. Also, when the retention period of the snapshot expires, Amazon Redshift
/// automatically deletes it. If you want to keep an automated snapshot for a longer period,
/// you can make a manual copy of the snapshot. Manual snapshots are retained until you
/// delete them.</p>
/// <p>
/// For more information about working with snapshots, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CopyClusterSnapshot {
    _private: (),
}
impl CopyClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`CopyClusterSnapshotInput`](crate::input::CopyClusterSnapshotInput)
    pub fn builder() -> crate::input::copy_cluster_snapshot_input::Builder {
        crate::input::copy_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CopyClusterSnapshot {
    type Output = std::result::Result<
        crate::output::CopyClusterSnapshotOutput,
        crate::error::CopyClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_copy_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_copy_cluster_snapshot_response(response)
        }
    }
}

/// <p>Creates an authentication profile with the specified parameters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAuthenticationProfile {
    _private: (),
}
impl CreateAuthenticationProfile {
    /// Creates a new builder-style object to manufacture [`CreateAuthenticationProfileInput`](crate::input::CreateAuthenticationProfileInput)
    pub fn builder() -> crate::input::create_authentication_profile_input::Builder {
        crate::input::create_authentication_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAuthenticationProfile {
    type Output = std::result::Result<
        crate::output::CreateAuthenticationProfileOutput,
        crate::error::CreateAuthenticationProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_authentication_profile_error(response)
        } else {
            crate::operation_ser::parse_create_authentication_profile_response(response)
        }
    }
}

/// <p>Creates a new cluster with the specified parameters.</p>
/// <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster
/// subnet group name. The cluster subnet group identifies the subnets of your VPC that
/// Amazon Redshift uses when creating the cluster.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCluster {
    _private: (),
}
impl CreateCluster {
    /// Creates a new builder-style object to manufacture [`CreateClusterInput`](crate::input::CreateClusterInput)
    pub fn builder() -> crate::input::create_cluster_input::Builder {
        crate::input::create_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCluster {
    type Output =
        std::result::Result<crate::output::CreateClusterOutput, crate::error::CreateClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_response(response)
        }
    }
}

/// <p>Creates an Amazon Redshift parameter group.</p>
/// <p>Creating parameter groups is independent of creating clusters. You can associate a
/// cluster with a parameter group when you create the cluster. You can also associate an
/// existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p>
/// <p>Parameters in the parameter group define specific behavior that applies to the
/// databases you create on the cluster.
/// For more information about parameters and parameter groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateClusterParameterGroup {
    _private: (),
}
impl CreateClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`CreateClusterParameterGroupInput`](crate::input::CreateClusterParameterGroupInput)
    pub fn builder() -> crate::input::create_cluster_parameter_group_input::Builder {
        crate::input::create_cluster_parameter_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateClusterParameterGroup {
    type Output = std::result::Result<
        crate::output::CreateClusterParameterGroupOutput,
        crate::error::CreateClusterParameterGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_parameter_group_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_parameter_group_response(response)
        }
    }
}

/// <p>Creates a new Amazon Redshift security group. You use security groups to control access
/// to non-VPC clusters.</p>
/// <p>
/// For information about managing security groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
/// <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateClusterSecurityGroup {
    _private: (),
}
impl CreateClusterSecurityGroup {
    /// Creates a new builder-style object to manufacture [`CreateClusterSecurityGroupInput`](crate::input::CreateClusterSecurityGroupInput)
    pub fn builder() -> crate::input::create_cluster_security_group_input::Builder {
        crate::input::create_cluster_security_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateClusterSecurityGroup {
    type Output = std::result::Result<
        crate::output::CreateClusterSecurityGroupOutput,
        crate::error::CreateClusterSecurityGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_security_group_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_security_group_response(response)
        }
    }
}

/// <p>Creates a manual snapshot of the specified cluster. The cluster must be in the
/// <code>available</code> state. </p>
/// <p>
/// For more information about working with snapshots, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateClusterSnapshot {
    _private: (),
}
impl CreateClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`CreateClusterSnapshotInput`](crate::input::CreateClusterSnapshotInput)
    pub fn builder() -> crate::input::create_cluster_snapshot_input::Builder {
        crate::input::create_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateClusterSnapshot {
    type Output = std::result::Result<
        crate::output::CreateClusterSnapshotOutput,
        crate::error::CreateClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_snapshot_response(response)
        }
    }
}

/// <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more
/// subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating
/// Amazon Redshift subnet group.</p>
/// <p>
/// For information about subnet groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the
/// <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateClusterSubnetGroup {
    _private: (),
}
impl CreateClusterSubnetGroup {
    /// Creates a new builder-style object to manufacture [`CreateClusterSubnetGroupInput`](crate::input::CreateClusterSubnetGroupInput)
    pub fn builder() -> crate::input::create_cluster_subnet_group_input::Builder {
        crate::input::create_cluster_subnet_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateClusterSubnetGroup {
    type Output = std::result::Result<
        crate::output::CreateClusterSubnetGroupOutput,
        crate::error::CreateClusterSubnetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_cluster_subnet_group_error(response)
        } else {
            crate::operation_ser::parse_create_cluster_subnet_group_response(response)
        }
    }
}

/// <p>Creates a Redshift-managed VPC endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEndpointAccess {
    _private: (),
}
impl CreateEndpointAccess {
    /// Creates a new builder-style object to manufacture [`CreateEndpointAccessInput`](crate::input::CreateEndpointAccessInput)
    pub fn builder() -> crate::input::create_endpoint_access_input::Builder {
        crate::input::create_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEndpointAccess {
    type Output = std::result::Result<
        crate::output::CreateEndpointAccessOutput,
        crate::error::CreateEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_create_endpoint_access_response(response)
        }
    }
}

/// <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN
/// (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console,
/// the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you
/// must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in
/// the SNS console.</p>
/// <p>You can specify the source type, and lists of Amazon Redshift source IDs, event
/// categories, and event severities. Notifications will be sent for all events you want
/// that match those criteria. For example, you can specify source type = cluster, source ID
/// = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity =
/// ERROR. The subscription will only send notifications for those ERROR events in the
/// Availability and Backup categories for the specified clusters.</p>
/// <p>If you specify both the source type and source IDs, such as source type = cluster
/// and source identifier = my-cluster-1, notifications will be sent for all the cluster
/// events for my-cluster-1. If you specify a source type but do not specify a source
/// identifier, you will receive notice of the events for the objects of that type in your
/// Amazon Web Services account. If you do not specify either the SourceType nor the SourceIdentifier, you
/// will be notified of events generated from all Amazon Redshift sources belonging to your Amazon Web Services account. You must specify a source type if you specify a source ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEventSubscription {
    _private: (),
}
impl CreateEventSubscription {
    /// Creates a new builder-style object to manufacture [`CreateEventSubscriptionInput`](crate::input::CreateEventSubscriptionInput)
    pub fn builder() -> crate::input::create_event_subscription_input::Builder {
        crate::input::create_event_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEventSubscription {
    type Output = std::result::Result<
        crate::output::CreateEventSubscriptionOutput,
        crate::error::CreateEventSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_event_subscription_error(response)
        } else {
            crate::operation_ser::parse_create_event_subscription_response(response)
        }
    }
}

/// <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to
/// the client's HSM in order to store and retrieve the keys used to encrypt the cluster
/// databases.</p>
/// <p>The command returns a public key, which you must store in the HSM. In addition to
/// creating the HSM certificate, you must create an Amazon Redshift HSM configuration that
/// provides a cluster the information needed to store and use encryption keys in the HSM.
/// For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html#working-with-HSM">Hardware Security Modules</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateHsmClientCertificate {
    _private: (),
}
impl CreateHsmClientCertificate {
    /// Creates a new builder-style object to manufacture [`CreateHsmClientCertificateInput`](crate::input::CreateHsmClientCertificateInput)
    pub fn builder() -> crate::input::create_hsm_client_certificate_input::Builder {
        crate::input::create_hsm_client_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateHsmClientCertificate {
    type Output = std::result::Result<
        crate::output::CreateHsmClientCertificateOutput,
        crate::error::CreateHsmClientCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_hsm_client_certificate_error(response)
        } else {
            crate::operation_ser::parse_create_hsm_client_certificate_response(response)
        }
    }
}

/// <p>Creates an HSM configuration that contains the information required by an Amazon Redshift
/// cluster to store and use database encryption keys in a Hardware Security Module (HSM).
/// After creating the HSM configuration, you can specify it as a parameter when creating a
/// cluster. The cluster will then store its encryption keys in the HSM.</p>
/// <p>In addition to creating an HSM configuration, you must also create an HSM client
/// certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a>
/// in the Amazon Redshift Cluster Management Guide.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateHsmConfiguration {
    _private: (),
}
impl CreateHsmConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateHsmConfigurationInput`](crate::input::CreateHsmConfigurationInput)
    pub fn builder() -> crate::input::create_hsm_configuration_input::Builder {
        crate::input::create_hsm_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateHsmConfiguration {
    type Output = std::result::Result<
        crate::output::CreateHsmConfigurationOutput,
        crate::error::CreateHsmConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_hsm_configuration_error(response)
        } else {
            crate::operation_ser::parse_create_hsm_configuration_response(response)
        }
    }
}

/// <p>Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action.
/// For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateScheduledAction {
    _private: (),
}
impl CreateScheduledAction {
    /// Creates a new builder-style object to manufacture [`CreateScheduledActionInput`](crate::input::CreateScheduledActionInput)
    pub fn builder() -> crate::input::create_scheduled_action_input::Builder {
        crate::input::create_scheduled_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateScheduledAction {
    type Output = std::result::Result<
        crate::output::CreateScheduledActionOutput,
        crate::error::CreateScheduledActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_scheduled_action_error(response)
        } else {
            crate::operation_ser::parse_create_scheduled_action_response(response)
        }
    }
}

/// <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key
/// (CMK) from Key Management Service (KMS) to encrypt copied snapshots in a
/// destination region.</p>
/// <p>
/// For more information about managing snapshot copy grants, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSnapshotCopyGrant {
    _private: (),
}
impl CreateSnapshotCopyGrant {
    /// Creates a new builder-style object to manufacture [`CreateSnapshotCopyGrantInput`](crate::input::CreateSnapshotCopyGrantInput)
    pub fn builder() -> crate::input::create_snapshot_copy_grant_input::Builder {
        crate::input::create_snapshot_copy_grant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSnapshotCopyGrant {
    type Output = std::result::Result<
        crate::output::CreateSnapshotCopyGrantOutput,
        crate::error::CreateSnapshotCopyGrantError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_snapshot_copy_grant_error(response)
        } else {
            crate::operation_ser::parse_create_snapshot_copy_grant_response(response)
        }
    }
}

/// <p>Create a snapshot schedule that can be associated to a cluster and which overrides the default system backup schedule. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSnapshotSchedule {
    _private: (),
}
impl CreateSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`CreateSnapshotScheduleInput`](crate::input::CreateSnapshotScheduleInput)
    pub fn builder() -> crate::input::create_snapshot_schedule_input::Builder {
        crate::input::create_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::CreateSnapshotScheduleOutput,
        crate::error::CreateSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_snapshot_schedule_error(response)
        } else {
            crate::operation_ser::parse_create_snapshot_schedule_response(response)
        }
    }
}

/// <p>Adds tags to a cluster.</p>
/// <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a
/// resource, you will receive an error and the attempt will fail.</p>
/// <p>If you specify a key that already exists for the resource, the value for that key
/// will be updated with the new value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTags {
    _private: (),
}
impl CreateTags {
    /// Creates a new builder-style object to manufacture [`CreateTagsInput`](crate::input::CreateTagsInput)
    pub fn builder() -> crate::input::create_tags_input::Builder {
        crate::input::create_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTags {
    type Output =
        std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_tags_error(response)
        } else {
            crate::operation_ser::parse_create_tags_response(response)
        }
    }
}

/// <p>Creates a usage limit for a specified Amazon Redshift feature on a cluster.
/// The usage limit is identified by the returned usage limit identifier.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUsageLimit {
    _private: (),
}
impl CreateUsageLimit {
    /// Creates a new builder-style object to manufacture [`CreateUsageLimitInput`](crate::input::CreateUsageLimitInput)
    pub fn builder() -> crate::input::create_usage_limit_input::Builder {
        crate::input::create_usage_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUsageLimit {
    type Output = std::result::Result<
        crate::output::CreateUsageLimitOutput,
        crate::error::CreateUsageLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_usage_limit_error(response)
        } else {
            crate::operation_ser::parse_create_usage_limit_response(response)
        }
    }
}

/// <p>From the producer account, removes authorization from the specified datashare. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeauthorizeDataShare {
    _private: (),
}
impl DeauthorizeDataShare {
    /// Creates a new builder-style object to manufacture [`DeauthorizeDataShareInput`](crate::input::DeauthorizeDataShareInput)
    pub fn builder() -> crate::input::deauthorize_data_share_input::Builder {
        crate::input::deauthorize_data_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeauthorizeDataShare {
    type Output = std::result::Result<
        crate::output::DeauthorizeDataShareOutput,
        crate::error::DeauthorizeDataShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_deauthorize_data_share_error(response)
        } else {
            crate::operation_ser::parse_deauthorize_data_share_response(response)
        }
    }
}

/// <p>Deletes an authentication profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAuthenticationProfile {
    _private: (),
}
impl DeleteAuthenticationProfile {
    /// Creates a new builder-style object to manufacture [`DeleteAuthenticationProfileInput`](crate::input::DeleteAuthenticationProfileInput)
    pub fn builder() -> crate::input::delete_authentication_profile_input::Builder {
        crate::input::delete_authentication_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAuthenticationProfile {
    type Output = std::result::Result<
        crate::output::DeleteAuthenticationProfileOutput,
        crate::error::DeleteAuthenticationProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_authentication_profile_error(response)
        } else {
            crate::operation_ser::parse_delete_authentication_profile_response(response)
        }
    }
}

/// <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web
/// service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete
/// operation cannot be canceled or reverted once submitted.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
/// <p>If you want to shut down the cluster and retain it for future use, set
/// <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a
/// name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this
/// snapshot to resume using the cluster. If a final cluster snapshot is requested, the
/// status of the cluster will be "final-snapshot" while the snapshot is being taken, then
/// it's "deleting" once Amazon Redshift begins deleting the cluster. </p>
/// <p>
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCluster {
    _private: (),
}
impl DeleteCluster {
    /// Creates a new builder-style object to manufacture [`DeleteClusterInput`](crate::input::DeleteClusterInput)
    pub fn builder() -> crate::input::delete_cluster_input::Builder {
        crate::input::delete_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCluster {
    type Output =
        std::result::Result<crate::output::DeleteClusterOutput, crate::error::DeleteClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_cluster_error(response)
        } else {
            crate::operation_ser::parse_delete_cluster_response(response)
        }
    }
}

/// <p>Deletes a specified Amazon Redshift parameter group.</p>
/// <note>
/// <p>You cannot delete a parameter group if it is associated with a
/// cluster.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteClusterParameterGroup {
    _private: (),
}
impl DeleteClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`DeleteClusterParameterGroupInput`](crate::input::DeleteClusterParameterGroupInput)
    pub fn builder() -> crate::input::delete_cluster_parameter_group_input::Builder {
        crate::input::delete_cluster_parameter_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteClusterParameterGroup {
    type Output = std::result::Result<
        crate::output::DeleteClusterParameterGroupOutput,
        crate::error::DeleteClusterParameterGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_cluster_parameter_group_error(response)
        } else {
            crate::operation_ser::parse_delete_cluster_parameter_group_response(response)
        }
    }
}

/// <p>Deletes an Amazon Redshift security group.</p>
/// <note>
/// <p>You cannot delete a security group that is associated with any clusters. You
/// cannot delete the default security group.</p>
/// </note>
/// <p>
/// For information about managing security groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
/// <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteClusterSecurityGroup {
    _private: (),
}
impl DeleteClusterSecurityGroup {
    /// Creates a new builder-style object to manufacture [`DeleteClusterSecurityGroupInput`](crate::input::DeleteClusterSecurityGroupInput)
    pub fn builder() -> crate::input::delete_cluster_security_group_input::Builder {
        crate::input::delete_cluster_security_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteClusterSecurityGroup {
    type Output = std::result::Result<
        crate::output::DeleteClusterSecurityGroupOutput,
        crate::error::DeleteClusterSecurityGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_cluster_security_group_error(response)
        } else {
            crate::operation_ser::parse_delete_cluster_security_group_response(response)
        }
    }
}

/// <p>Deletes the specified manual snapshot. The snapshot must be in the
/// <code>available</code> state, with no other users authorized to access the snapshot. </p>
/// <p>Unlike automated snapshots, manual snapshots are retained even after you delete
/// your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual
/// snapshot explicitly to avoid getting charged. If other accounts are authorized to access
/// the snapshot, you must revoke all of the authorizations before you can delete the
/// snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteClusterSnapshot {
    _private: (),
}
impl DeleteClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`DeleteClusterSnapshotInput`](crate::input::DeleteClusterSnapshotInput)
    pub fn builder() -> crate::input::delete_cluster_snapshot_input::Builder {
        crate::input::delete_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteClusterSnapshot {
    type Output = std::result::Result<
        crate::output::DeleteClusterSnapshotOutput,
        crate::error::DeleteClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_delete_cluster_snapshot_response(response)
        }
    }
}

/// <p>Deletes the specified cluster subnet group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteClusterSubnetGroup {
    _private: (),
}
impl DeleteClusterSubnetGroup {
    /// Creates a new builder-style object to manufacture [`DeleteClusterSubnetGroupInput`](crate::input::DeleteClusterSubnetGroupInput)
    pub fn builder() -> crate::input::delete_cluster_subnet_group_input::Builder {
        crate::input::delete_cluster_subnet_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteClusterSubnetGroup {
    type Output = std::result::Result<
        crate::output::DeleteClusterSubnetGroupOutput,
        crate::error::DeleteClusterSubnetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_cluster_subnet_group_error(response)
        } else {
            crate::operation_ser::parse_delete_cluster_subnet_group_response(response)
        }
    }
}

/// <p>Deletes a Redshift-managed VPC endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEndpointAccess {
    _private: (),
}
impl DeleteEndpointAccess {
    /// Creates a new builder-style object to manufacture [`DeleteEndpointAccessInput`](crate::input::DeleteEndpointAccessInput)
    pub fn builder() -> crate::input::delete_endpoint_access_input::Builder {
        crate::input::delete_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEndpointAccess {
    type Output = std::result::Result<
        crate::output::DeleteEndpointAccessOutput,
        crate::error::DeleteEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_delete_endpoint_access_response(response)
        }
    }
}

/// <p>Deletes an Amazon Redshift event notification subscription.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEventSubscription {
    _private: (),
}
impl DeleteEventSubscription {
    /// Creates a new builder-style object to manufacture [`DeleteEventSubscriptionInput`](crate::input::DeleteEventSubscriptionInput)
    pub fn builder() -> crate::input::delete_event_subscription_input::Builder {
        crate::input::delete_event_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEventSubscription {
    type Output = std::result::Result<
        crate::output::DeleteEventSubscriptionOutput,
        crate::error::DeleteEventSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_event_subscription_error(response)
        } else {
            crate::operation_ser::parse_delete_event_subscription_response(response)
        }
    }
}

/// <p>Deletes the specified HSM client certificate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteHsmClientCertificate {
    _private: (),
}
impl DeleteHsmClientCertificate {
    /// Creates a new builder-style object to manufacture [`DeleteHsmClientCertificateInput`](crate::input::DeleteHsmClientCertificateInput)
    pub fn builder() -> crate::input::delete_hsm_client_certificate_input::Builder {
        crate::input::delete_hsm_client_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteHsmClientCertificate {
    type Output = std::result::Result<
        crate::output::DeleteHsmClientCertificateOutput,
        crate::error::DeleteHsmClientCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_hsm_client_certificate_error(response)
        } else {
            crate::operation_ser::parse_delete_hsm_client_certificate_response(response)
        }
    }
}

/// <p>Deletes the specified Amazon Redshift HSM configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteHsmConfiguration {
    _private: (),
}
impl DeleteHsmConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteHsmConfigurationInput`](crate::input::DeleteHsmConfigurationInput)
    pub fn builder() -> crate::input::delete_hsm_configuration_input::Builder {
        crate::input::delete_hsm_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteHsmConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteHsmConfigurationOutput,
        crate::error::DeleteHsmConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_hsm_configuration_error(response)
        } else {
            crate::operation_ser::parse_delete_hsm_configuration_response(response)
        }
    }
}

/// <p>Deletes a partner integration from a cluster. Data can still flow to the cluster until the integration is deleted at the partner's website.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePartner {
    _private: (),
}
impl DeletePartner {
    /// Creates a new builder-style object to manufacture [`DeletePartnerInput`](crate::input::DeletePartnerInput)
    pub fn builder() -> crate::input::delete_partner_input::Builder {
        crate::input::delete_partner_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePartner {
    type Output =
        std::result::Result<crate::output::DeletePartnerOutput, crate::error::DeletePartnerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_partner_error(response)
        } else {
            crate::operation_ser::parse_delete_partner_response(response)
        }
    }
}

/// <p>Deletes a scheduled action.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteScheduledAction {
    _private: (),
}
impl DeleteScheduledAction {
    /// Creates a new builder-style object to manufacture [`DeleteScheduledActionInput`](crate::input::DeleteScheduledActionInput)
    pub fn builder() -> crate::input::delete_scheduled_action_input::Builder {
        crate::input::delete_scheduled_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteScheduledAction {
    type Output = std::result::Result<
        crate::output::DeleteScheduledActionOutput,
        crate::error::DeleteScheduledActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_scheduled_action_error(response)
        } else {
            crate::operation_ser::parse_delete_scheduled_action_response(response)
        }
    }
}

/// <p>Deletes the specified snapshot copy grant.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSnapshotCopyGrant {
    _private: (),
}
impl DeleteSnapshotCopyGrant {
    /// Creates a new builder-style object to manufacture [`DeleteSnapshotCopyGrantInput`](crate::input::DeleteSnapshotCopyGrantInput)
    pub fn builder() -> crate::input::delete_snapshot_copy_grant_input::Builder {
        crate::input::delete_snapshot_copy_grant_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSnapshotCopyGrant {
    type Output = std::result::Result<
        crate::output::DeleteSnapshotCopyGrantOutput,
        crate::error::DeleteSnapshotCopyGrantError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_snapshot_copy_grant_error(response)
        } else {
            crate::operation_ser::parse_delete_snapshot_copy_grant_response(response)
        }
    }
}

/// <p>Deletes a snapshot schedule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSnapshotSchedule {
    _private: (),
}
impl DeleteSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`DeleteSnapshotScheduleInput`](crate::input::DeleteSnapshotScheduleInput)
    pub fn builder() -> crate::input::delete_snapshot_schedule_input::Builder {
        crate::input::delete_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::DeleteSnapshotScheduleOutput,
        crate::error::DeleteSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_snapshot_schedule_error(response)
        } else {
            crate::operation_ser::parse_delete_snapshot_schedule_response(response)
        }
    }
}

/// <p>Deletes tags from a resource. You must provide the ARN of the resource
/// from which you want to delete the tag or tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTags {
    _private: (),
}
impl DeleteTags {
    /// Creates a new builder-style object to manufacture [`DeleteTagsInput`](crate::input::DeleteTagsInput)
    pub fn builder() -> crate::input::delete_tags_input::Builder {
        crate::input::delete_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTags {
    type Output =
        std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_tags_error(response)
        } else {
            crate::operation_ser::parse_delete_tags_response(response)
        }
    }
}

/// <p>Deletes a usage limit from a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUsageLimit {
    _private: (),
}
impl DeleteUsageLimit {
    /// Creates a new builder-style object to manufacture [`DeleteUsageLimitInput`](crate::input::DeleteUsageLimitInput)
    pub fn builder() -> crate::input::delete_usage_limit_input::Builder {
        crate::input::delete_usage_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUsageLimit {
    type Output = std::result::Result<
        crate::output::DeleteUsageLimitOutput,
        crate::error::DeleteUsageLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_usage_limit_error(response)
        } else {
            crate::operation_ser::parse_delete_usage_limit_response(response)
        }
    }
}

/// <p>Returns a list of attributes attached to an account</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountAttributes {
    _private: (),
}
impl DescribeAccountAttributes {
    /// Creates a new builder-style object to manufacture [`DescribeAccountAttributesInput`](crate::input::DescribeAccountAttributesInput)
    pub fn builder() -> crate::input::describe_account_attributes_input::Builder {
        crate::input::describe_account_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountAttributes {
    type Output = std::result::Result<
        crate::output::DescribeAccountAttributesOutput,
        crate::error::DescribeAccountAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_account_attributes_error(response)
        } else {
            crate::operation_ser::parse_describe_account_attributes_response(response)
        }
    }
}

/// <p>Describes an authentication profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAuthenticationProfiles {
    _private: (),
}
impl DescribeAuthenticationProfiles {
    /// Creates a new builder-style object to manufacture [`DescribeAuthenticationProfilesInput`](crate::input::DescribeAuthenticationProfilesInput)
    pub fn builder() -> crate::input::describe_authentication_profiles_input::Builder {
        crate::input::describe_authentication_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAuthenticationProfiles {
    type Output = std::result::Result<
        crate::output::DescribeAuthenticationProfilesOutput,
        crate::error::DescribeAuthenticationProfilesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_authentication_profiles_error(response)
        } else {
            crate::operation_ser::parse_describe_authentication_profiles_response(response)
        }
    }
}

/// <p>Returns an array of <code>ClusterDbRevision</code> objects.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterDbRevisions {
    _private: (),
}
impl DescribeClusterDbRevisions {
    /// Creates a new builder-style object to manufacture [`DescribeClusterDbRevisionsInput`](crate::input::DescribeClusterDbRevisionsInput)
    pub fn builder() -> crate::input::describe_cluster_db_revisions_input::Builder {
        crate::input::describe_cluster_db_revisions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterDbRevisions {
    type Output = std::result::Result<
        crate::output::DescribeClusterDbRevisionsOutput,
        crate::error::DescribeClusterDbRevisionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_db_revisions_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_db_revisions_response(response)
        }
    }
}

/// <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you
/// created and the default parameter group. For each parameter group, the response includes
/// the parameter group name, description, and parameter group family name. You can
/// optionally specify a name to retrieve the description of a specific parameter
/// group.</p>
/// <p>
/// For more information about parameters and parameter groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all parameter groups that match any combination of the specified keys and values. For
/// example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all parameter groups that
/// have any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, parameter groups are
/// returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterParameterGroups {
    _private: (),
}
impl DescribeClusterParameterGroups {
    /// Creates a new builder-style object to manufacture [`DescribeClusterParameterGroupsInput`](crate::input::DescribeClusterParameterGroupsInput)
    pub fn builder() -> crate::input::describe_cluster_parameter_groups_input::Builder {
        crate::input::describe_cluster_parameter_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterParameterGroups {
    type Output = std::result::Result<
        crate::output::DescribeClusterParameterGroupsOutput,
        crate::error::DescribeClusterParameterGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_parameter_groups_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_parameter_groups_response(response)
        }
    }
}

/// <p>Returns a detailed list of parameters contained within the specified Amazon Redshift
/// parameter group. For each parameter the response includes information such as parameter
/// name, description, data type, value, whether the parameter value is modifiable, and so
/// on.</p>
/// <p>You can specify <i>source</i> filter to retrieve parameters of only
/// specific type. For example, to retrieve parameters that were modified by a user action
/// such as from <a>ModifyClusterParameterGroup</a>, you can specify
/// <i>source</i> equal to <i>user</i>.</p>
/// <p>
/// For more information about parameters and parameter groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterParameters {
    _private: (),
}
impl DescribeClusterParameters {
    /// Creates a new builder-style object to manufacture [`DescribeClusterParametersInput`](crate::input::DescribeClusterParametersInput)
    pub fn builder() -> crate::input::describe_cluster_parameters_input::Builder {
        crate::input::describe_cluster_parameters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterParameters {
    type Output = std::result::Result<
        crate::output::DescribeClusterParametersOutput,
        crate::error::DescribeClusterParametersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_parameters_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_parameters_response(response)
        }
    }
}

/// <p>Returns properties of provisioned clusters including general cluster properties,
/// cluster database properties, maintenance and backup properties, and security and access
/// properties. This operation supports pagination.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all clusters that match any combination of the specified keys and values. For example,
/// if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all clusters that have any
/// combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, clusters are returned
/// regardless of whether they have tag keys or values associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusters {
    _private: (),
}
impl DescribeClusters {
    /// Creates a new builder-style object to manufacture [`DescribeClustersInput`](crate::input::DescribeClustersInput)
    pub fn builder() -> crate::input::describe_clusters_input::Builder {
        crate::input::describe_clusters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusters {
    type Output = std::result::Result<
        crate::output::DescribeClustersOutput,
        crate::error::DescribeClustersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_clusters_error(response)
        } else {
            crate::operation_ser::parse_describe_clusters_response(response)
        }
    }
}

/// <p>Returns information about Amazon Redshift security groups. If the name of a security
/// group is specified, the response will contain only information about only that security
/// group.</p>
/// <p>
/// For information about managing security groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
/// <i>Amazon Redshift Cluster Management Guide</i>.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all security groups that match any combination of the specified keys and values. For
/// example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all security groups that
/// have any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, security groups are
/// returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterSecurityGroups {
    _private: (),
}
impl DescribeClusterSecurityGroups {
    /// Creates a new builder-style object to manufacture [`DescribeClusterSecurityGroupsInput`](crate::input::DescribeClusterSecurityGroupsInput)
    pub fn builder() -> crate::input::describe_cluster_security_groups_input::Builder {
        crate::input::describe_cluster_security_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterSecurityGroups {
    type Output = std::result::Result<
        crate::output::DescribeClusterSecurityGroupsOutput,
        crate::error::DescribeClusterSecurityGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_security_groups_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_security_groups_response(response)
        }
    }
}

/// <p>Returns one or more snapshot objects, which contain metadata about your cluster
/// snapshots. By default, this operation returns information about all snapshots of all
/// clusters that are owned by your Amazon Web Services account. No information is returned for
/// snapshots owned by inactive Amazon Web Services accounts.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all snapshots that match any combination of the specified keys and values. For example,
/// if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all snapshots that have any
/// combination of those values are returned. Only snapshots that you own are returned in
/// the response; shared snapshots are not returned with the tag key and tag value request
/// parameters.</p>
/// <p>If both tag keys and values are omitted from the request, snapshots are returned
/// regardless of whether they have tag keys or values associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterSnapshots {
    _private: (),
}
impl DescribeClusterSnapshots {
    /// Creates a new builder-style object to manufacture [`DescribeClusterSnapshotsInput`](crate::input::DescribeClusterSnapshotsInput)
    pub fn builder() -> crate::input::describe_cluster_snapshots_input::Builder {
        crate::input::describe_cluster_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterSnapshots {
    type Output = std::result::Result<
        crate::output::DescribeClusterSnapshotsOutput,
        crate::error::DescribeClusterSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_snapshots_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_snapshots_response(response)
        }
    }
}

/// <p>Returns one or more cluster subnet group objects, which contain metadata about your
/// cluster subnet groups. By default, this operation returns information about all cluster
/// subnet groups that are defined in your Amazon Web Services account.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all subnet groups that match any combination of the specified keys and values. For
/// example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all subnet groups that have
/// any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, subnet groups are
/// returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterSubnetGroups {
    _private: (),
}
impl DescribeClusterSubnetGroups {
    /// Creates a new builder-style object to manufacture [`DescribeClusterSubnetGroupsInput`](crate::input::DescribeClusterSubnetGroupsInput)
    pub fn builder() -> crate::input::describe_cluster_subnet_groups_input::Builder {
        crate::input::describe_cluster_subnet_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterSubnetGroups {
    type Output = std::result::Result<
        crate::output::DescribeClusterSubnetGroupsOutput,
        crate::error::DescribeClusterSubnetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_subnet_groups_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_subnet_groups_response(response)
        }
    }
}

/// <p>Returns a list of all the available maintenance tracks.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterTracks {
    _private: (),
}
impl DescribeClusterTracks {
    /// Creates a new builder-style object to manufacture [`DescribeClusterTracksInput`](crate::input::DescribeClusterTracksInput)
    pub fn builder() -> crate::input::describe_cluster_tracks_input::Builder {
        crate::input::describe_cluster_tracks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterTracks {
    type Output = std::result::Result<
        crate::output::DescribeClusterTracksOutput,
        crate::error::DescribeClusterTracksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_tracks_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_tracks_response(response)
        }
    }
}

/// <p>Returns descriptions of the available Amazon Redshift cluster versions. You can call this
/// operation even before creating any clusters to learn more about the Amazon Redshift versions.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClusterVersions {
    _private: (),
}
impl DescribeClusterVersions {
    /// Creates a new builder-style object to manufacture [`DescribeClusterVersionsInput`](crate::input::DescribeClusterVersionsInput)
    pub fn builder() -> crate::input::describe_cluster_versions_input::Builder {
        crate::input::describe_cluster_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClusterVersions {
    type Output = std::result::Result<
        crate::output::DescribeClusterVersionsOutput,
        crate::error::DescribeClusterVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_cluster_versions_error(response)
        } else {
            crate::operation_ser::parse_describe_cluster_versions_response(response)
        }
    }
}

/// <p>Shows the status of any inbound or outbound datashares available in the specified
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataShares {
    _private: (),
}
impl DescribeDataShares {
    /// Creates a new builder-style object to manufacture [`DescribeDataSharesInput`](crate::input::DescribeDataSharesInput)
    pub fn builder() -> crate::input::describe_data_shares_input::Builder {
        crate::input::describe_data_shares_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataShares {
    type Output = std::result::Result<
        crate::output::DescribeDataSharesOutput,
        crate::error::DescribeDataSharesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_data_shares_error(response)
        } else {
            crate::operation_ser::parse_describe_data_shares_response(response)
        }
    }
}

/// <p>Returns a list of datashares where the account identifier being called is a consumer account identifier.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSharesForConsumer {
    _private: (),
}
impl DescribeDataSharesForConsumer {
    /// Creates a new builder-style object to manufacture [`DescribeDataSharesForConsumerInput`](crate::input::DescribeDataSharesForConsumerInput)
    pub fn builder() -> crate::input::describe_data_shares_for_consumer_input::Builder {
        crate::input::describe_data_shares_for_consumer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSharesForConsumer {
    type Output = std::result::Result<
        crate::output::DescribeDataSharesForConsumerOutput,
        crate::error::DescribeDataSharesForConsumerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_data_shares_for_consumer_error(response)
        } else {
            crate::operation_ser::parse_describe_data_shares_for_consumer_response(response)
        }
    }
}

/// <p>Returns a list of datashares when the account identifier being called is a producer account identifier.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataSharesForProducer {
    _private: (),
}
impl DescribeDataSharesForProducer {
    /// Creates a new builder-style object to manufacture [`DescribeDataSharesForProducerInput`](crate::input::DescribeDataSharesForProducerInput)
    pub fn builder() -> crate::input::describe_data_shares_for_producer_input::Builder {
        crate::input::describe_data_shares_for_producer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataSharesForProducer {
    type Output = std::result::Result<
        crate::output::DescribeDataSharesForProducerOutput,
        crate::error::DescribeDataSharesForProducerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_data_shares_for_producer_error(response)
        } else {
            crate::operation_ser::parse_describe_data_shares_for_producer_response(response)
        }
    }
}

/// <p>Returns a list of parameter settings for the specified parameter group
/// family.</p>
/// <p>
/// For more information about parameters and parameter groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDefaultClusterParameters {
    _private: (),
}
impl DescribeDefaultClusterParameters {
    /// Creates a new builder-style object to manufacture [`DescribeDefaultClusterParametersInput`](crate::input::DescribeDefaultClusterParametersInput)
    pub fn builder() -> crate::input::describe_default_cluster_parameters_input::Builder {
        crate::input::describe_default_cluster_parameters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDefaultClusterParameters {
    type Output = std::result::Result<
        crate::output::DescribeDefaultClusterParametersOutput,
        crate::error::DescribeDefaultClusterParametersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_default_cluster_parameters_error(response)
        } else {
            crate::operation_ser::parse_describe_default_cluster_parameters_response(response)
        }
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEndpointAccess {
    _private: (),
}
impl DescribeEndpointAccess {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointAccessInput`](crate::input::DescribeEndpointAccessInput)
    pub fn builder() -> crate::input::describe_endpoint_access_input::Builder {
        crate::input::describe_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEndpointAccess {
    type Output = std::result::Result<
        crate::output::DescribeEndpointAccessOutput,
        crate::error::DescribeEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_describe_endpoint_access_response(response)
        }
    }
}

/// <p>Describes an endpoint authorization.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEndpointAuthorization {
    _private: (),
}
impl DescribeEndpointAuthorization {
    /// Creates a new builder-style object to manufacture [`DescribeEndpointAuthorizationInput`](crate::input::DescribeEndpointAuthorizationInput)
    pub fn builder() -> crate::input::describe_endpoint_authorization_input::Builder {
        crate::input::describe_endpoint_authorization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEndpointAuthorization {
    type Output = std::result::Result<
        crate::output::DescribeEndpointAuthorizationOutput,
        crate::error::DescribeEndpointAuthorizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_endpoint_authorization_error(response)
        } else {
            crate::operation_ser::parse_describe_endpoint_authorization_response(response)
        }
    }
}

/// <p>Displays a list of event categories for all event source types, or for a specified
/// source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event
/// Notifications</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventCategories {
    _private: (),
}
impl DescribeEventCategories {
    /// Creates a new builder-style object to manufacture [`DescribeEventCategoriesInput`](crate::input::DescribeEventCategoriesInput)
    pub fn builder() -> crate::input::describe_event_categories_input::Builder {
        crate::input::describe_event_categories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventCategories {
    type Output = std::result::Result<
        crate::output::DescribeEventCategoriesOutput,
        crate::error::DescribeEventCategoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_event_categories_error(response)
        } else {
            crate::operation_ser::parse_describe_event_categories_response(response)
        }
    }
}

/// <p>Returns events related to clusters, security groups, snapshots, and parameter
/// groups for the past 14 days. Events specific to a particular cluster, security group,
/// snapshot or parameter group can be obtained by providing the name as a parameter. By
/// default, the past hour of events are returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEvents {
    _private: (),
}
impl DescribeEvents {
    /// Creates a new builder-style object to manufacture [`DescribeEventsInput`](crate::input::DescribeEventsInput)
    pub fn builder() -> crate::input::describe_events_input::Builder {
        crate::input::describe_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEvents {
    type Output =
        std::result::Result<crate::output::DescribeEventsOutput, crate::error::DescribeEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_events_error(response)
        } else {
            crate::operation_ser::parse_describe_events_response(response)
        }
    }
}

/// <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a
/// customer account. If you specify a subscription name, lists the description for that
/// subscription.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all event notification subscriptions that match any combination of the specified keys
/// and values. For example, if you have <code>owner</code> and <code>environment</code> for
/// tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions
/// that have any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, subscriptions are
/// returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeEventSubscriptions {
    _private: (),
}
impl DescribeEventSubscriptions {
    /// Creates a new builder-style object to manufacture [`DescribeEventSubscriptionsInput`](crate::input::DescribeEventSubscriptionsInput)
    pub fn builder() -> crate::input::describe_event_subscriptions_input::Builder {
        crate::input::describe_event_subscriptions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeEventSubscriptions {
    type Output = std::result::Result<
        crate::output::DescribeEventSubscriptionsOutput,
        crate::error::DescribeEventSubscriptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_event_subscriptions_error(response)
        } else {
            crate::operation_ser::parse_describe_event_subscriptions_response(response)
        }
    }
}

/// <p>Returns information about the specified HSM client certificate. If no certificate
/// ID is specified, returns information about all the HSM certificates owned by your Amazon Web Services account.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all HSM client certificates that match any combination of the specified keys and values.
/// For example, if you have <code>owner</code> and <code>environment</code> for tag keys,
/// and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates
/// that have any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, HSM client certificates
/// are returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeHsmClientCertificates {
    _private: (),
}
impl DescribeHsmClientCertificates {
    /// Creates a new builder-style object to manufacture [`DescribeHsmClientCertificatesInput`](crate::input::DescribeHsmClientCertificatesInput)
    pub fn builder() -> crate::input::describe_hsm_client_certificates_input::Builder {
        crate::input::describe_hsm_client_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeHsmClientCertificates {
    type Output = std::result::Result<
        crate::output::DescribeHsmClientCertificatesOutput,
        crate::error::DescribeHsmClientCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_hsm_client_certificates_error(response)
        } else {
            crate::operation_ser::parse_describe_hsm_client_certificates_response(response)
        }
    }
}

/// <p>Returns information about the specified Amazon Redshift HSM configuration. If no
/// configuration ID is specified, returns information about all the HSM configurations
/// owned by your Amazon Web Services account.</p>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all HSM connections that match any combination of the specified keys and values. For
/// example, if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all HSM connections that
/// have any combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, HSM connections are
/// returned regardless of whether they have tag keys or values associated with
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeHsmConfigurations {
    _private: (),
}
impl DescribeHsmConfigurations {
    /// Creates a new builder-style object to manufacture [`DescribeHsmConfigurationsInput`](crate::input::DescribeHsmConfigurationsInput)
    pub fn builder() -> crate::input::describe_hsm_configurations_input::Builder {
        crate::input::describe_hsm_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeHsmConfigurations {
    type Output = std::result::Result<
        crate::output::DescribeHsmConfigurationsOutput,
        crate::error::DescribeHsmConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_hsm_configurations_error(response)
        } else {
            crate::operation_ser::parse_describe_hsm_configurations_response(response)
        }
    }
}

/// <p>Describes whether information, such as queries and connection attempts, is being
/// logged for the specified Amazon Redshift cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLoggingStatus {
    _private: (),
}
impl DescribeLoggingStatus {
    /// Creates a new builder-style object to manufacture [`DescribeLoggingStatusInput`](crate::input::DescribeLoggingStatusInput)
    pub fn builder() -> crate::input::describe_logging_status_input::Builder {
        crate::input::describe_logging_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLoggingStatus {
    type Output = std::result::Result<
        crate::output::DescribeLoggingStatusOutput,
        crate::error::DescribeLoggingStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_logging_status_error(response)
        } else {
            crate::operation_ser::parse_describe_logging_status_response(response)
        }
    }
}

/// <p>Returns properties of possible node configurations such as node type, number of nodes, and
/// disk usage for the specified action type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeNodeConfigurationOptions {
    _private: (),
}
impl DescribeNodeConfigurationOptions {
    /// Creates a new builder-style object to manufacture [`DescribeNodeConfigurationOptionsInput`](crate::input::DescribeNodeConfigurationOptionsInput)
    pub fn builder() -> crate::input::describe_node_configuration_options_input::Builder {
        crate::input::describe_node_configuration_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeNodeConfigurationOptions {
    type Output = std::result::Result<
        crate::output::DescribeNodeConfigurationOptionsOutput,
        crate::error::DescribeNodeConfigurationOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_node_configuration_options_error(response)
        } else {
            crate::operation_ser::parse_describe_node_configuration_options_response(response)
        }
    }
}

/// <p>Returns a list of orderable cluster options. Before you create a new cluster you
/// can use this operation to find what options are available, such as the EC2 Availability
/// Zones (AZ) in the specific Amazon Web Services Region that you can specify, and the node types you can
/// request. The node types differ by available storage, memory, CPU and price. With the
/// cost involved you might want to obtain a list of cluster options in the specific region
/// and specify values when creating a cluster.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOrderableClusterOptions {
    _private: (),
}
impl DescribeOrderableClusterOptions {
    /// Creates a new builder-style object to manufacture [`DescribeOrderableClusterOptionsInput`](crate::input::DescribeOrderableClusterOptionsInput)
    pub fn builder() -> crate::input::describe_orderable_cluster_options_input::Builder {
        crate::input::describe_orderable_cluster_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOrderableClusterOptions {
    type Output = std::result::Result<
        crate::output::DescribeOrderableClusterOptionsOutput,
        crate::error::DescribeOrderableClusterOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_orderable_cluster_options_error(response)
        } else {
            crate::operation_ser::parse_describe_orderable_cluster_options_response(response)
        }
    }
}

/// <p>Returns information about the partner integrations defined for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePartners {
    _private: (),
}
impl DescribePartners {
    /// Creates a new builder-style object to manufacture [`DescribePartnersInput`](crate::input::DescribePartnersInput)
    pub fn builder() -> crate::input::describe_partners_input::Builder {
        crate::input::describe_partners_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePartners {
    type Output = std::result::Result<
        crate::output::DescribePartnersOutput,
        crate::error::DescribePartnersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_partners_error(response)
        } else {
            crate::operation_ser::parse_describe_partners_response(response)
        }
    }
}

/// <p>Returns a list of the available reserved node offerings by Amazon Redshift with their
/// descriptions including the node type, the fixed and recurring costs of reserving the
/// node and duration the node will be reserved for you. These descriptions help you
/// determine which reserve node offering you want to purchase. You then use the unique
/// offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one
/// or more nodes for your Amazon Redshift cluster. </p>
/// <p>
/// For more information about reserved node offerings, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedNodeOfferings {
    _private: (),
}
impl DescribeReservedNodeOfferings {
    /// Creates a new builder-style object to manufacture [`DescribeReservedNodeOfferingsInput`](crate::input::DescribeReservedNodeOfferingsInput)
    pub fn builder() -> crate::input::describe_reserved_node_offerings_input::Builder {
        crate::input::describe_reserved_node_offerings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedNodeOfferings {
    type Output = std::result::Result<
        crate::output::DescribeReservedNodeOfferingsOutput,
        crate::error::DescribeReservedNodeOfferingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_reserved_node_offerings_error(response)
        } else {
            crate::operation_ser::parse_describe_reserved_node_offerings_response(response)
        }
    }
}

/// <p>Returns the descriptions of the reserved nodes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedNodes {
    _private: (),
}
impl DescribeReservedNodes {
    /// Creates a new builder-style object to manufacture [`DescribeReservedNodesInput`](crate::input::DescribeReservedNodesInput)
    pub fn builder() -> crate::input::describe_reserved_nodes_input::Builder {
        crate::input::describe_reserved_nodes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedNodes {
    type Output = std::result::Result<
        crate::output::DescribeReservedNodesOutput,
        crate::error::DescribeReservedNodesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_reserved_nodes_error(response)
        } else {
            crate::operation_ser::parse_describe_reserved_nodes_response(response)
        }
    }
}

/// <p>Returns information about the last resize operation for the specified cluster. If
/// no resize operation has ever been initiated for the specified cluster, a <code>HTTP
/// 404</code> error is returned. If a resize operation was initiated and completed, the
/// status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p>
/// <p>A resize operation can be requested using <a>ModifyCluster</a> and
/// specifying a different number or type of nodes for the cluster. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeResize {
    _private: (),
}
impl DescribeResize {
    /// Creates a new builder-style object to manufacture [`DescribeResizeInput`](crate::input::DescribeResizeInput)
    pub fn builder() -> crate::input::describe_resize_input::Builder {
        crate::input::describe_resize_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeResize {
    type Output =
        std::result::Result<crate::output::DescribeResizeOutput, crate::error::DescribeResizeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_resize_error(response)
        } else {
            crate::operation_ser::parse_describe_resize_response(response)
        }
    }
}

/// <p>Describes properties of scheduled actions.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeScheduledActions {
    _private: (),
}
impl DescribeScheduledActions {
    /// Creates a new builder-style object to manufacture [`DescribeScheduledActionsInput`](crate::input::DescribeScheduledActionsInput)
    pub fn builder() -> crate::input::describe_scheduled_actions_input::Builder {
        crate::input::describe_scheduled_actions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeScheduledActions {
    type Output = std::result::Result<
        crate::output::DescribeScheduledActionsOutput,
        crate::error::DescribeScheduledActionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_scheduled_actions_error(response)
        } else {
            crate::operation_ser::parse_describe_scheduled_actions_response(response)
        }
    }
}

/// <p>Returns a list of snapshot copy grants owned by the Amazon Web Services account in the destination
/// region.</p>
/// <p>
/// For more information about managing snapshot copy grants, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSnapshotCopyGrants {
    _private: (),
}
impl DescribeSnapshotCopyGrants {
    /// Creates a new builder-style object to manufacture [`DescribeSnapshotCopyGrantsInput`](crate::input::DescribeSnapshotCopyGrantsInput)
    pub fn builder() -> crate::input::describe_snapshot_copy_grants_input::Builder {
        crate::input::describe_snapshot_copy_grants_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSnapshotCopyGrants {
    type Output = std::result::Result<
        crate::output::DescribeSnapshotCopyGrantsOutput,
        crate::error::DescribeSnapshotCopyGrantsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_snapshot_copy_grants_error(response)
        } else {
            crate::operation_ser::parse_describe_snapshot_copy_grants_response(response)
        }
    }
}

/// <p>Returns a list of snapshot schedules. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSnapshotSchedules {
    _private: (),
}
impl DescribeSnapshotSchedules {
    /// Creates a new builder-style object to manufacture [`DescribeSnapshotSchedulesInput`](crate::input::DescribeSnapshotSchedulesInput)
    pub fn builder() -> crate::input::describe_snapshot_schedules_input::Builder {
        crate::input::describe_snapshot_schedules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSnapshotSchedules {
    type Output = std::result::Result<
        crate::output::DescribeSnapshotSchedulesOutput,
        crate::error::DescribeSnapshotSchedulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_snapshot_schedules_error(response)
        } else {
            crate::operation_ser::parse_describe_snapshot_schedules_response(response)
        }
    }
}

/// <p>Returns account level backups storage size and provisional storage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStorage {
    _private: (),
}
impl DescribeStorage {
    /// Creates a new builder-style object to manufacture [`DescribeStorageInput`](crate::input::DescribeStorageInput)
    pub fn builder() -> crate::input::describe_storage_input::Builder {
        crate::input::describe_storage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStorage {
    type Output = std::result::Result<
        crate::output::DescribeStorageOutput,
        crate::error::DescribeStorageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_storage_error(response)
        } else {
            crate::operation_ser::parse_describe_storage_response(response)
        }
    }
}

/// <p>Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value
/// for the <code>TableRestoreRequestId</code> parameter, then
/// <code>DescribeTableRestoreStatus</code> returns the status of all table restore
/// requests ordered by the date and time of the request in ascending order. Otherwise
/// <code>DescribeTableRestoreStatus</code> returns the status of the table specified by
/// <code>TableRestoreRequestId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTableRestoreStatus {
    _private: (),
}
impl DescribeTableRestoreStatus {
    /// Creates a new builder-style object to manufacture [`DescribeTableRestoreStatusInput`](crate::input::DescribeTableRestoreStatusInput)
    pub fn builder() -> crate::input::describe_table_restore_status_input::Builder {
        crate::input::describe_table_restore_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTableRestoreStatus {
    type Output = std::result::Result<
        crate::output::DescribeTableRestoreStatusOutput,
        crate::error::DescribeTableRestoreStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_table_restore_status_error(response)
        } else {
            crate::operation_ser::parse_describe_table_restore_status_response(response)
        }
    }
}

/// <p>Returns a list of tags. You can return tags from a specific resource by specifying
/// an ARN, or you can return all tags for a given type of resource, such as clusters,
/// snapshots, and so on.</p>
/// <p>The following are limitations for <code>DescribeTags</code>: </p>
/// <ul>
/// <li>
/// <p>You cannot specify an ARN and a resource-type value together in the same
/// request.</p>
/// </li>
/// <li>
/// <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code>
/// parameters together with the ARN parameter.</p>
/// </li>
/// <li>
/// <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results
/// to return in a request.</p>
/// </li>
/// </ul>
/// <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns
/// all resources that match any combination of the specified keys and values. For example,
/// if you have <code>owner</code> and <code>environment</code> for tag keys, and
/// <code>admin</code> and <code>test</code> for tag values, all resources that have any
/// combination of those values are returned.</p>
/// <p>If both tag keys and values are omitted from the request, resources are returned
/// regardless of whether they have tag keys or values associated with them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTags {
    _private: (),
}
impl DescribeTags {
    /// Creates a new builder-style object to manufacture [`DescribeTagsInput`](crate::input::DescribeTagsInput)
    pub fn builder() -> crate::input::describe_tags_input::Builder {
        crate::input::describe_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTags {
    type Output =
        std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_tags_error(response)
        } else {
            crate::operation_ser::parse_describe_tags_response(response)
        }
    }
}

/// <p>Shows usage limits on a cluster.
/// Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:</p>
/// <ul>
/// <li>
/// <p>If usage limit identifier, cluster identifier, and feature type are not provided,
/// then all usage limit objects for the current account in the current region are returned.</p>
/// </li>
/// <li>
/// <p>If usage limit identifier is provided,
/// then the corresponding usage limit object is returned.</p>
/// </li>
/// <li>
/// <p>If cluster identifier is provided,
/// then all usage limit objects for the specified cluster are returned.</p>
/// </li>
/// <li>
/// <p>If cluster identifier and feature type are provided,
/// then all usage limit objects for the combination of cluster and feature are returned.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUsageLimits {
    _private: (),
}
impl DescribeUsageLimits {
    /// Creates a new builder-style object to manufacture [`DescribeUsageLimitsInput`](crate::input::DescribeUsageLimitsInput)
    pub fn builder() -> crate::input::describe_usage_limits_input::Builder {
        crate::input::describe_usage_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUsageLimits {
    type Output = std::result::Result<
        crate::output::DescribeUsageLimitsOutput,
        crate::error::DescribeUsageLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_usage_limits_error(response)
        } else {
            crate::operation_ser::parse_describe_usage_limits_response(response)
        }
    }
}

/// <p>Stops logging information, such as queries and connection attempts, for the
/// specified Amazon Redshift cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableLogging {
    _private: (),
}
impl DisableLogging {
    /// Creates a new builder-style object to manufacture [`DisableLoggingInput`](crate::input::DisableLoggingInput)
    pub fn builder() -> crate::input::disable_logging_input::Builder {
        crate::input::disable_logging_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableLogging {
    type Output =
        std::result::Result<crate::output::DisableLoggingOutput, crate::error::DisableLoggingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_disable_logging_error(response)
        } else {
            crate::operation_ser::parse_disable_logging_response(response)
        }
    }
}

/// <p>Disables the automatic copying of snapshots from one region to another region for a
/// specified cluster.</p>
/// <p>If your cluster and its snapshots are encrypted using a customer master key (CMK)
/// from Key Management Service, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that
/// grants Amazon Redshift permission to the CMK in the destination region. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableSnapshotCopy {
    _private: (),
}
impl DisableSnapshotCopy {
    /// Creates a new builder-style object to manufacture [`DisableSnapshotCopyInput`](crate::input::DisableSnapshotCopyInput)
    pub fn builder() -> crate::input::disable_snapshot_copy_input::Builder {
        crate::input::disable_snapshot_copy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableSnapshotCopy {
    type Output = std::result::Result<
        crate::output::DisableSnapshotCopyOutput,
        crate::error::DisableSnapshotCopyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_disable_snapshot_copy_error(response)
        } else {
            crate::operation_ser::parse_disable_snapshot_copy_response(response)
        }
    }
}

/// <p>From a consumer account, remove association for the specified datashare.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateDataShareConsumer {
    _private: (),
}
impl DisassociateDataShareConsumer {
    /// Creates a new builder-style object to manufacture [`DisassociateDataShareConsumerInput`](crate::input::DisassociateDataShareConsumerInput)
    pub fn builder() -> crate::input::disassociate_data_share_consumer_input::Builder {
        crate::input::disassociate_data_share_consumer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateDataShareConsumer {
    type Output = std::result::Result<
        crate::output::DisassociateDataShareConsumerOutput,
        crate::error::DisassociateDataShareConsumerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_disassociate_data_share_consumer_error(response)
        } else {
            crate::operation_ser::parse_disassociate_data_share_consumer_response(response)
        }
    }
}

/// <p>Starts logging information, such as queries and connection attempts, for the
/// specified Amazon Redshift cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableLogging {
    _private: (),
}
impl EnableLogging {
    /// Creates a new builder-style object to manufacture [`EnableLoggingInput`](crate::input::EnableLoggingInput)
    pub fn builder() -> crate::input::enable_logging_input::Builder {
        crate::input::enable_logging_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableLogging {
    type Output =
        std::result::Result<crate::output::EnableLoggingOutput, crate::error::EnableLoggingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_enable_logging_error(response)
        } else {
            crate::operation_ser::parse_enable_logging_response(response)
        }
    }
}

/// <p>Enables the automatic copy of snapshots from one region to another region for a
/// specified cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableSnapshotCopy {
    _private: (),
}
impl EnableSnapshotCopy {
    /// Creates a new builder-style object to manufacture [`EnableSnapshotCopyInput`](crate::input::EnableSnapshotCopyInput)
    pub fn builder() -> crate::input::enable_snapshot_copy_input::Builder {
        crate::input::enable_snapshot_copy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableSnapshotCopy {
    type Output = std::result::Result<
        crate::output::EnableSnapshotCopyOutput,
        crate::error::EnableSnapshotCopyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_enable_snapshot_copy_error(response)
        } else {
            crate::operation_ser::parse_enable_snapshot_copy_response(response)
        }
    }
}

/// <p>Returns a database user name and temporary password with temporary authorization to
/// log on to an Amazon Redshift database. The action returns the database user name
/// prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or
/// <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can
/// optionally specify one or more database user groups that the user will join at log on.
/// By default, the temporary credentials expire in 900 seconds. You can optionally specify
/// a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more
/// information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication
/// to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p>
/// <p>The Identity and Access Management (IAM) user or role that runs
/// GetClusterCredentials must have an IAM policy attached that allows access to all
/// necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the
/// Amazon Redshift Cluster Management Guide.</p>
/// <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the
/// <code>redshift:JoinGroup</code> action with access to the listed
/// <code>dbgroups</code>. </p>
/// <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>,
/// then the policy must include the <code>redshift:CreateClusterUser</code>
/// privilege.</p>
/// <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access
/// to the resource <code>dbname</code> for the specified database name. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetClusterCredentials {
    _private: (),
}
impl GetClusterCredentials {
    /// Creates a new builder-style object to manufacture [`GetClusterCredentialsInput`](crate::input::GetClusterCredentialsInput)
    pub fn builder() -> crate::input::get_cluster_credentials_input::Builder {
        crate::input::get_cluster_credentials_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetClusterCredentials {
    type Output = std::result::Result<
        crate::output::GetClusterCredentialsOutput,
        crate::error::GetClusterCredentialsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_cluster_credentials_error(response)
        } else {
            crate::operation_ser::parse_get_cluster_credentials_response(response)
        }
    }
}

/// <p>Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term,
/// and usage price of the given DC1 reserved node.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetReservedNodeExchangeOfferings {
    _private: (),
}
impl GetReservedNodeExchangeOfferings {
    /// Creates a new builder-style object to manufacture [`GetReservedNodeExchangeOfferingsInput`](crate::input::GetReservedNodeExchangeOfferingsInput)
    pub fn builder() -> crate::input::get_reserved_node_exchange_offerings_input::Builder {
        crate::input::get_reserved_node_exchange_offerings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetReservedNodeExchangeOfferings {
    type Output = std::result::Result<
        crate::output::GetReservedNodeExchangeOfferingsOutput,
        crate::error::GetReservedNodeExchangeOfferingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_reserved_node_exchange_offerings_error(response)
        } else {
            crate::operation_ser::parse_get_reserved_node_exchange_offerings_response(response)
        }
    }
}

/// <p>Modifies whether a cluster can use AQUA (Advanced Query Accelerator). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyAquaConfiguration {
    _private: (),
}
impl ModifyAquaConfiguration {
    /// Creates a new builder-style object to manufacture [`ModifyAquaConfigurationInput`](crate::input::ModifyAquaConfigurationInput)
    pub fn builder() -> crate::input::modify_aqua_configuration_input::Builder {
        crate::input::modify_aqua_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyAquaConfiguration {
    type Output = std::result::Result<
        crate::output::ModifyAquaConfigurationOutput,
        crate::error::ModifyAquaConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_aqua_configuration_error(response)
        } else {
            crate::operation_ser::parse_modify_aqua_configuration_response(response)
        }
    }
}

/// <p>Modifies an authentication profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyAuthenticationProfile {
    _private: (),
}
impl ModifyAuthenticationProfile {
    /// Creates a new builder-style object to manufacture [`ModifyAuthenticationProfileInput`](crate::input::ModifyAuthenticationProfileInput)
    pub fn builder() -> crate::input::modify_authentication_profile_input::Builder {
        crate::input::modify_authentication_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyAuthenticationProfile {
    type Output = std::result::Result<
        crate::output::ModifyAuthenticationProfileOutput,
        crate::error::ModifyAuthenticationProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_authentication_profile_error(response)
        } else {
            crate::operation_ser::parse_modify_authentication_profile_response(response)
        }
    }
}

/// <p>Modifies the settings for a cluster.</p>       
/// <p>You can also change node type and the number of nodes to scale up or down the
/// cluster. When resizing a cluster, you must specify both the number of nodes and the node
/// type even if one of the parameters does not change.</p>
/// <p>You can add another security or
/// parameter group, or change the admin user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyCluster {
    _private: (),
}
impl ModifyCluster {
    /// Creates a new builder-style object to manufacture [`ModifyClusterInput`](crate::input::ModifyClusterInput)
    pub fn builder() -> crate::input::modify_cluster_input::Builder {
        crate::input::modify_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyCluster {
    type Output =
        std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_response(response)
        }
    }
}

/// <p>Modifies the database revision of a cluster. The database revision is a unique
/// revision of the database running in a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterDbRevision {
    _private: (),
}
impl ModifyClusterDbRevision {
    /// Creates a new builder-style object to manufacture [`ModifyClusterDbRevisionInput`](crate::input::ModifyClusterDbRevisionInput)
    pub fn builder() -> crate::input::modify_cluster_db_revision_input::Builder {
        crate::input::modify_cluster_db_revision_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterDbRevision {
    type Output = std::result::Result<
        crate::output::ModifyClusterDbRevisionOutput,
        crate::error::ModifyClusterDbRevisionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_db_revision_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_db_revision_response(response)
        }
    }
}

/// <p>Modifies the list of Identity and Access Management (IAM) roles that can be
/// used by the cluster to access other Amazon Web Services services.</p>
/// <p>A cluster can have up to 10 IAM roles associated at any time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterIamRoles {
    _private: (),
}
impl ModifyClusterIamRoles {
    /// Creates a new builder-style object to manufacture [`ModifyClusterIamRolesInput`](crate::input::ModifyClusterIamRolesInput)
    pub fn builder() -> crate::input::modify_cluster_iam_roles_input::Builder {
        crate::input::modify_cluster_iam_roles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterIamRoles {
    type Output = std::result::Result<
        crate::output::ModifyClusterIamRolesOutput,
        crate::error::ModifyClusterIamRolesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_iam_roles_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_iam_roles_response(response)
        }
    }
}

/// <p>Modifies the maintenance settings of a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterMaintenance {
    _private: (),
}
impl ModifyClusterMaintenance {
    /// Creates a new builder-style object to manufacture [`ModifyClusterMaintenanceInput`](crate::input::ModifyClusterMaintenanceInput)
    pub fn builder() -> crate::input::modify_cluster_maintenance_input::Builder {
        crate::input::modify_cluster_maintenance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterMaintenance {
    type Output = std::result::Result<
        crate::output::ModifyClusterMaintenanceOutput,
        crate::error::ModifyClusterMaintenanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_maintenance_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_maintenance_response(response)
        }
    }
}

/// <p>Modifies the parameters of a parameter group. For the parameters parameter, it can't contain ASCII characters.</p>
/// <p>
/// For more information about parameters and parameter groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterParameterGroup {
    _private: (),
}
impl ModifyClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`ModifyClusterParameterGroupInput`](crate::input::ModifyClusterParameterGroupInput)
    pub fn builder() -> crate::input::modify_cluster_parameter_group_input::Builder {
        crate::input::modify_cluster_parameter_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterParameterGroup {
    type Output = std::result::Result<
        crate::output::ModifyClusterParameterGroupOutput,
        crate::error::ModifyClusterParameterGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_parameter_group_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_parameter_group_response(response)
        }
    }
}

/// <p>Modifies the settings for a snapshot.</p>
/// <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterSnapshot {
    _private: (),
}
impl ModifyClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`ModifyClusterSnapshotInput`](crate::input::ModifyClusterSnapshotInput)
    pub fn builder() -> crate::input::modify_cluster_snapshot_input::Builder {
        crate::input::modify_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterSnapshot {
    type Output = std::result::Result<
        crate::output::ModifyClusterSnapshotOutput,
        crate::error::ModifyClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_snapshot_response(response)
        }
    }
}

/// <p>Modifies a snapshot schedule for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterSnapshotSchedule {
    _private: (),
}
impl ModifyClusterSnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`ModifyClusterSnapshotScheduleInput`](crate::input::ModifyClusterSnapshotScheduleInput)
    pub fn builder() -> crate::input::modify_cluster_snapshot_schedule_input::Builder {
        crate::input::modify_cluster_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterSnapshotSchedule {
    type Output = std::result::Result<
        crate::output::ModifyClusterSnapshotScheduleOutput,
        crate::error::ModifyClusterSnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_snapshot_schedule_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_snapshot_schedule_response(response)
        }
    }
}

/// <p>Modifies a cluster subnet group to include the specified list of VPC subnets. The
/// operation replaces the existing list of subnets with the new list of subnets.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClusterSubnetGroup {
    _private: (),
}
impl ModifyClusterSubnetGroup {
    /// Creates a new builder-style object to manufacture [`ModifyClusterSubnetGroupInput`](crate::input::ModifyClusterSubnetGroupInput)
    pub fn builder() -> crate::input::modify_cluster_subnet_group_input::Builder {
        crate::input::modify_cluster_subnet_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClusterSubnetGroup {
    type Output = std::result::Result<
        crate::output::ModifyClusterSubnetGroupOutput,
        crate::error::ModifyClusterSubnetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_cluster_subnet_group_error(response)
        } else {
            crate::operation_ser::parse_modify_cluster_subnet_group_response(response)
        }
    }
}

/// <p>Modifies a Redshift-managed VPC endpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyEndpointAccess {
    _private: (),
}
impl ModifyEndpointAccess {
    /// Creates a new builder-style object to manufacture [`ModifyEndpointAccessInput`](crate::input::ModifyEndpointAccessInput)
    pub fn builder() -> crate::input::modify_endpoint_access_input::Builder {
        crate::input::modify_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyEndpointAccess {
    type Output = std::result::Result<
        crate::output::ModifyEndpointAccessOutput,
        crate::error::ModifyEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_modify_endpoint_access_response(response)
        }
    }
}

/// <p>Modifies an existing Amazon Redshift event notification subscription.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyEventSubscription {
    _private: (),
}
impl ModifyEventSubscription {
    /// Creates a new builder-style object to manufacture [`ModifyEventSubscriptionInput`](crate::input::ModifyEventSubscriptionInput)
    pub fn builder() -> crate::input::modify_event_subscription_input::Builder {
        crate::input::modify_event_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyEventSubscription {
    type Output = std::result::Result<
        crate::output::ModifyEventSubscriptionOutput,
        crate::error::ModifyEventSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_event_subscription_error(response)
        } else {
            crate::operation_ser::parse_modify_event_subscription_response(response)
        }
    }
}

/// <p>Modifies a scheduled action.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyScheduledAction {
    _private: (),
}
impl ModifyScheduledAction {
    /// Creates a new builder-style object to manufacture [`ModifyScheduledActionInput`](crate::input::ModifyScheduledActionInput)
    pub fn builder() -> crate::input::modify_scheduled_action_input::Builder {
        crate::input::modify_scheduled_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyScheduledAction {
    type Output = std::result::Result<
        crate::output::ModifyScheduledActionOutput,
        crate::error::ModifyScheduledActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_scheduled_action_error(response)
        } else {
            crate::operation_ser::parse_modify_scheduled_action_response(response)
        }
    }
}

/// <p>Modifies the number of days to retain snapshots in the destination Amazon Web Services Region after
/// they are copied from the source Amazon Web Services Region. By default, this operation only changes the
/// retention period of copied automated snapshots. The retention periods for both new and
/// existing copied automated snapshots are updated with the new retention period. You can
/// set the manual option to change only the retention periods of copied manual snapshots.
/// If you set this option, only newly copied manual snapshots have the new retention
/// period. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifySnapshotCopyRetentionPeriod {
    _private: (),
}
impl ModifySnapshotCopyRetentionPeriod {
    /// Creates a new builder-style object to manufacture [`ModifySnapshotCopyRetentionPeriodInput`](crate::input::ModifySnapshotCopyRetentionPeriodInput)
    pub fn builder() -> crate::input::modify_snapshot_copy_retention_period_input::Builder {
        crate::input::modify_snapshot_copy_retention_period_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifySnapshotCopyRetentionPeriod {
    type Output = std::result::Result<
        crate::output::ModifySnapshotCopyRetentionPeriodOutput,
        crate::error::ModifySnapshotCopyRetentionPeriodError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_snapshot_copy_retention_period_error(response)
        } else {
            crate::operation_ser::parse_modify_snapshot_copy_retention_period_response(response)
        }
    }
}

/// <p>Modifies a snapshot schedule. Any schedule associated with a cluster is modified
/// asynchronously.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifySnapshotSchedule {
    _private: (),
}
impl ModifySnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`ModifySnapshotScheduleInput`](crate::input::ModifySnapshotScheduleInput)
    pub fn builder() -> crate::input::modify_snapshot_schedule_input::Builder {
        crate::input::modify_snapshot_schedule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifySnapshotSchedule {
    type Output = std::result::Result<
        crate::output::ModifySnapshotScheduleOutput,
        crate::error::ModifySnapshotScheduleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_snapshot_schedule_error(response)
        } else {
            crate::operation_ser::parse_modify_snapshot_schedule_response(response)
        }
    }
}

/// <p>Modifies a usage limit in a cluster.
/// You can't modify the feature type or period of a usage limit.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyUsageLimit {
    _private: (),
}
impl ModifyUsageLimit {
    /// Creates a new builder-style object to manufacture [`ModifyUsageLimitInput`](crate::input::ModifyUsageLimitInput)
    pub fn builder() -> crate::input::modify_usage_limit_input::Builder {
        crate::input::modify_usage_limit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyUsageLimit {
    type Output = std::result::Result<
        crate::output::ModifyUsageLimitOutput,
        crate::error::ModifyUsageLimitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_modify_usage_limit_error(response)
        } else {
            crate::operation_ser::parse_modify_usage_limit_response(response)
        }
    }
}

/// <p>Pauses a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PauseCluster {
    _private: (),
}
impl PauseCluster {
    /// Creates a new builder-style object to manufacture [`PauseClusterInput`](crate::input::PauseClusterInput)
    pub fn builder() -> crate::input::pause_cluster_input::Builder {
        crate::input::pause_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PauseCluster {
    type Output =
        std::result::Result<crate::output::PauseClusterOutput, crate::error::PauseClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_pause_cluster_error(response)
        } else {
            crate::operation_ser::parse_pause_cluster_response(response)
        }
    }
}

/// <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of
/// reserved node offerings. You can purchase one or more of the offerings. You can call the
/// <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved
/// node offerings. You can call this API by providing a specific reserved node offering and
/// the number of nodes you want to reserve. </p>
/// <p>
/// For more information about reserved node offerings, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PurchaseReservedNodeOffering {
    _private: (),
}
impl PurchaseReservedNodeOffering {
    /// Creates a new builder-style object to manufacture [`PurchaseReservedNodeOfferingInput`](crate::input::PurchaseReservedNodeOfferingInput)
    pub fn builder() -> crate::input::purchase_reserved_node_offering_input::Builder {
        crate::input::purchase_reserved_node_offering_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PurchaseReservedNodeOffering {
    type Output = std::result::Result<
        crate::output::PurchaseReservedNodeOfferingOutput,
        crate::error::PurchaseReservedNodeOfferingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_purchase_reserved_node_offering_error(response)
        } else {
            crate::operation_ser::parse_purchase_reserved_node_offering_response(response)
        }
    }
}

/// <p>Reboots a cluster. This action is taken as soon as possible. It results in a
/// momentary outage to the cluster, during which the cluster status is set to
/// <code>rebooting</code>. A cluster event is created when the reboot is completed. Any
/// pending cluster modifications (see <a>ModifyCluster</a>) are applied at this
/// reboot.
/// For more information about managing clusters, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RebootCluster {
    _private: (),
}
impl RebootCluster {
    /// Creates a new builder-style object to manufacture [`RebootClusterInput`](crate::input::RebootClusterInput)
    pub fn builder() -> crate::input::reboot_cluster_input::Builder {
        crate::input::reboot_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RebootCluster {
    type Output =
        std::result::Result<crate::output::RebootClusterOutput, crate::error::RebootClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_reboot_cluster_error(response)
        } else {
            crate::operation_ser::parse_reboot_cluster_response(response)
        }
    }
}

/// <p>From the consumer account, rejects the specified datashare.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RejectDataShare {
    _private: (),
}
impl RejectDataShare {
    /// Creates a new builder-style object to manufacture [`RejectDataShareInput`](crate::input::RejectDataShareInput)
    pub fn builder() -> crate::input::reject_data_share_input::Builder {
        crate::input::reject_data_share_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RejectDataShare {
    type Output = std::result::Result<
        crate::output::RejectDataShareOutput,
        crate::error::RejectDataShareError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_reject_data_share_error(response)
        } else {
            crate::operation_ser::parse_reject_data_share_response(response)
        }
    }
}

/// <p>Sets one or more parameters of the specified parameter group to their default
/// values and sets the source values of the parameters to "engine-default". To reset the
/// entire parameter group specify the <i>ResetAllParameters</i> parameter.
/// For parameter changes to take effect you must reboot any associated clusters. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResetClusterParameterGroup {
    _private: (),
}
impl ResetClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`ResetClusterParameterGroupInput`](crate::input::ResetClusterParameterGroupInput)
    pub fn builder() -> crate::input::reset_cluster_parameter_group_input::Builder {
        crate::input::reset_cluster_parameter_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResetClusterParameterGroup {
    type Output = std::result::Result<
        crate::output::ResetClusterParameterGroupOutput,
        crate::error::ResetClusterParameterGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_reset_cluster_parameter_group_error(response)
        } else {
            crate::operation_ser::parse_reset_cluster_parameter_group_response(response)
        }
    }
}

/// <p>Changes the size of the cluster. You can change the cluster's type, or change the
/// number or type of nodes. The default behavior is to use the elastic resize method. With
/// an elastic resize, your cluster is available for read and write operations more quickly
/// than with the classic resize method. </p>
/// <p>Elastic resize operations have the following restrictions:</p>
/// <ul>
/// <li>
/// <p>You can only resize clusters of the following types:</p>
/// <ul>
/// <li>
/// <p>dc1.large (if your cluster is in a VPC)</p>
/// </li>
/// <li>
/// <p>dc1.8xlarge (if your cluster is in a VPC)</p>
/// </li>
/// <li>
/// <p>dc2.large</p>
/// </li>
/// <li>
/// <p>dc2.8xlarge</p>
/// </li>
/// <li>
/// <p>ds2.xlarge</p>
/// </li>
/// <li>
/// <p>ds2.8xlarge</p>
/// </li>
/// <li>
/// <p>ra3.xlplus</p>
/// </li>
/// <li>
/// <p>ra3.4xlarge</p>
/// </li>
/// <li>
/// <p>ra3.16xlarge</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>The type of nodes that you add must match the node type for the
/// cluster.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResizeCluster {
    _private: (),
}
impl ResizeCluster {
    /// Creates a new builder-style object to manufacture [`ResizeClusterInput`](crate::input::ResizeClusterInput)
    pub fn builder() -> crate::input::resize_cluster_input::Builder {
        crate::input::resize_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResizeCluster {
    type Output =
        std::result::Result<crate::output::ResizeClusterOutput, crate::error::ResizeClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_resize_cluster_error(response)
        } else {
            crate::operation_ser::parse_resize_cluster_response(response)
        }
    }
}

/// <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting
/// cluster with the same configuration as the original cluster from which the snapshot was
/// created, except that the new cluster is created with the default cluster security and
/// parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different
/// parameter group with the restored cluster. If you are using a DS node type, you can also
/// choose to change to another DS node type of the same size during restore.</p>
/// <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where
/// you want the cluster restored.</p>
/// <p>
/// For more information about working with snapshots, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RestoreFromClusterSnapshot {
    _private: (),
}
impl RestoreFromClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`RestoreFromClusterSnapshotInput`](crate::input::RestoreFromClusterSnapshotInput)
    pub fn builder() -> crate::input::restore_from_cluster_snapshot_input::Builder {
        crate::input::restore_from_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RestoreFromClusterSnapshot {
    type Output = std::result::Result<
        crate::output::RestoreFromClusterSnapshotOutput,
        crate::error::RestoreFromClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_restore_from_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_restore_from_cluster_snapshot_response(response)
        }
    }
}

/// <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must
/// create the new table within the Amazon Redshift cluster that the snapshot was taken
/// from.</p>
/// <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with
/// the same name as an existing table in an Amazon Redshift cluster. That is, you cannot
/// overwrite an existing table in a cluster with a restored table. If you want to replace
/// your original table with a new, restored table, then rename or drop your original table
/// before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your
/// original table, then you can pass the original name of the table as the
/// <code>NewTableName</code> parameter value in the call to
/// <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original
/// table with the table created from the snapshot.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RestoreTableFromClusterSnapshot {
    _private: (),
}
impl RestoreTableFromClusterSnapshot {
    /// Creates a new builder-style object to manufacture [`RestoreTableFromClusterSnapshotInput`](crate::input::RestoreTableFromClusterSnapshotInput)
    pub fn builder() -> crate::input::restore_table_from_cluster_snapshot_input::Builder {
        crate::input::restore_table_from_cluster_snapshot_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RestoreTableFromClusterSnapshot {
    type Output = std::result::Result<
        crate::output::RestoreTableFromClusterSnapshotOutput,
        crate::error::RestoreTableFromClusterSnapshotError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_restore_table_from_cluster_snapshot_error(response)
        } else {
            crate::operation_ser::parse_restore_table_from_cluster_snapshot_response(response)
        }
    }
}

/// <p>Resumes a paused cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResumeCluster {
    _private: (),
}
impl ResumeCluster {
    /// Creates a new builder-style object to manufacture [`ResumeClusterInput`](crate::input::ResumeClusterInput)
    pub fn builder() -> crate::input::resume_cluster_input::Builder {
        crate::input::resume_cluster_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResumeCluster {
    type Output =
        std::result::Result<crate::output::ResumeClusterOutput, crate::error::ResumeClusterError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_resume_cluster_error(response)
        } else {
            crate::operation_ser::parse_resume_cluster_response(response)
        }
    }
}

/// <p>Revokes an ingress rule in an Amazon Redshift security group for a previously authorized
/// IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>.
/// For information about managing security groups, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the
/// <i>Amazon Redshift Cluster Management Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RevokeClusterSecurityGroupIngress {
    _private: (),
}
impl RevokeClusterSecurityGroupIngress {
    /// Creates a new builder-style object to manufacture [`RevokeClusterSecurityGroupIngressInput`](crate::input::RevokeClusterSecurityGroupIngressInput)
    pub fn builder() -> crate::input::revoke_cluster_security_group_ingress_input::Builder {
        crate::input::revoke_cluster_security_group_ingress_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RevokeClusterSecurityGroupIngress {
    type Output = std::result::Result<
        crate::output::RevokeClusterSecurityGroupIngressOutput,
        crate::error::RevokeClusterSecurityGroupIngressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_revoke_cluster_security_group_ingress_error(response)
        } else {
            crate::operation_ser::parse_revoke_cluster_security_group_ingress_response(response)
        }
    }
}

/// <p>Revokes access to a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RevokeEndpointAccess {
    _private: (),
}
impl RevokeEndpointAccess {
    /// Creates a new builder-style object to manufacture [`RevokeEndpointAccessInput`](crate::input::RevokeEndpointAccessInput)
    pub fn builder() -> crate::input::revoke_endpoint_access_input::Builder {
        crate::input::revoke_endpoint_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RevokeEndpointAccess {
    type Output = std::result::Result<
        crate::output::RevokeEndpointAccessOutput,
        crate::error::RevokeEndpointAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_revoke_endpoint_access_error(response)
        } else {
            crate::operation_ser::parse_revoke_endpoint_access_response(response)
        }
    }
}

/// <p>Removes the ability of the specified  Amazon Web Services account to restore the specified
/// snapshot. If the account is currently restoring the snapshot, the restore will run to
/// completion.</p>
/// <p>
/// For more information about working with snapshots, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RevokeSnapshotAccess {
    _private: (),
}
impl RevokeSnapshotAccess {
    /// Creates a new builder-style object to manufacture [`RevokeSnapshotAccessInput`](crate::input::RevokeSnapshotAccessInput)
    pub fn builder() -> crate::input::revoke_snapshot_access_input::Builder {
        crate::input::revoke_snapshot_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RevokeSnapshotAccess {
    type Output = std::result::Result<
        crate::output::RevokeSnapshotAccessOutput,
        crate::error::RevokeSnapshotAccessError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_revoke_snapshot_access_error(response)
        } else {
            crate::operation_ser::parse_revoke_snapshot_access_response(response)
        }
    }
}

/// <p>Rotates the encryption keys for a cluster.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RotateEncryptionKey {
    _private: (),
}
impl RotateEncryptionKey {
    /// Creates a new builder-style object to manufacture [`RotateEncryptionKeyInput`](crate::input::RotateEncryptionKeyInput)
    pub fn builder() -> crate::input::rotate_encryption_key_input::Builder {
        crate::input::rotate_encryption_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RotateEncryptionKey {
    type Output = std::result::Result<
        crate::output::RotateEncryptionKeyOutput,
        crate::error::RotateEncryptionKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_rotate_encryption_key_error(response)
        } else {
            crate::operation_ser::parse_rotate_encryption_key_response(response)
        }
    }
}

/// <p>Updates the status of a partner integration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePartnerStatus {
    _private: (),
}
impl UpdatePartnerStatus {
    /// Creates a new builder-style object to manufacture [`UpdatePartnerStatusInput`](crate::input::UpdatePartnerStatusInput)
    pub fn builder() -> crate::input::update_partner_status_input::Builder {
        crate::input::update_partner_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePartnerStatus {
    type Output = std::result::Result<
        crate::output::UpdatePartnerStatusOutput,
        crate::error::UpdatePartnerStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_partner_status_error(response)
        } else {
            crate::operation_ser::parse_update_partner_status_response(response)
        }
    }
}
