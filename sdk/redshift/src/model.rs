// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartnerIntegrationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    ConnectionFailure,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    RuntimeFailure,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PartnerIntegrationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => PartnerIntegrationStatus::Active,
            "ConnectionFailure" => PartnerIntegrationStatus::ConnectionFailure,
            "Inactive" => PartnerIntegrationStatus::Inactive,
            "RuntimeFailure" => PartnerIntegrationStatus::RuntimeFailure,
            other => PartnerIntegrationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PartnerIntegrationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartnerIntegrationStatus::from(s))
    }
}
impl PartnerIntegrationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PartnerIntegrationStatus::Active => "Active",
            PartnerIntegrationStatus::ConnectionFailure => "ConnectionFailure",
            PartnerIntegrationStatus::Inactive => "Inactive",
            PartnerIntegrationStatus::RuntimeFailure => "RuntimeFailure",
            PartnerIntegrationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Active", "ConnectionFailure", "Inactive", "RuntimeFailure"]
    }
}
impl AsRef<str> for PartnerIntegrationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Cluster {
    /// <p>The unique identifier of the cluster.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The node type for the nodes in the cluster.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p> The current state of the cluster. Possible values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>available</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>available, prep-for-resize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>available, resize-cleanup</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>cancelling-resize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>creating</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>deleting</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>final-snapshot</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>hardware-failure</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>incompatible-hsm</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>incompatible-network</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>incompatible-parameters</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>incompatible-restore</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>modifying</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>paused</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rebooting</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>renaming</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>resizing</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>rotating-keys</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>storage-full</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>updating-hsm</code>
    /// </p>
    /// </li>
    /// </ul>
    pub cluster_status: std::option::Option<std::string::String>,
    /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>Available - The cluster is available for queries. </p>
    /// </li>
    /// <li>
    /// <p>Unavailable - The cluster is not available for queries.</p>
    /// </li>
    /// <li>
    /// <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
    /// </li>
    /// <li>
    /// <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
    /// </li>
    /// <li>
    /// <p>Failed - The cluster failed and is not available for queries.</p>
    /// </li>
    /// </ul>
    pub cluster_availability_status: std::option::Option<std::string::String>,
    /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
    pub modify_status: std::option::Option<std::string::String>,
    /// <p>The admin user name for the cluster. This name is used to connect to the database
    /// that is specified in the <b>DBName</b> parameter. </p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The name of the initial database that was created when the cluster was created.
    /// This same name is returned for the life of the cluster. If an initial database was not
    /// specified, a database named <code>dev</code>dev was created by default. </p>
    pub db_name: std::option::Option<std::string::String>,
    /// <p>The connection endpoint.</p>
    pub endpoint: std::option::Option<crate::model::Endpoint>,
    /// <p>The date and time that the cluster was created.</p>
    pub cluster_create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The number of days that automatic cluster snapshots are retained.</p>
    pub automated_snapshot_retention_period: i32,
    /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
    /// snapshot is retained indefinitely. This setting doesn't change the retention period
    /// of existing snapshots.</p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub manual_snapshot_retention_period: i32,
    /// <p>A list of cluster security group that are associated with the cluster. Each
    /// security group is represented by an element that contains
    /// <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
    /// subelements. </p>
    /// <p>Cluster security groups are used when the cluster is not created in an Amazon
    /// Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
    /// which are listed by the <b>VpcSecurityGroups</b> parameter.
    /// </p>
    pub cluster_security_groups:
        std::option::Option<std::vec::Vec<crate::model::ClusterSecurityGroupMembership>>,
    /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
    /// associated with the cluster. This parameter is returned only if the cluster is in a
    /// VPC.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
    /// <p>The list of cluster parameter groups that are associated with this cluster. Each
    /// parameter group in the list is returned with its status.</p>
    pub cluster_parameter_groups:
        std::option::Option<std::vec::Vec<crate::model::ClusterParameterGroupStatus>>,
    /// <p>The name of the subnet group that is associated with the cluster. This parameter is
    /// valid only when the cluster is in a VPC.</p>
    pub cluster_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The name of the Availability Zone in which the cluster is located.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
    /// maintenance can occur.</p>
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>A value that, if present, indicates that changes to the cluster are pending.
    /// Specific pending changes are identified by subelements.</p>
    pub pending_modified_values: std::option::Option<crate::model::PendingModifiedValues>,
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
    /// will be applied automatically to the cluster during the maintenance window. </p>
    pub allow_version_upgrade: bool,
    /// <p>The number of compute nodes in the cluster.</p>
    pub number_of_nodes: i32,
    /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
    /// accessed from a public network.</p>
    pub publicly_accessible: bool,
    /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
    /// encrypted at rest.</p>
    pub encrypted: bool,
    /// <p>A value that describes the status of a cluster restore action. This parameter
    /// returns null if the cluster was not created by restoring a snapshot.</p>
    pub restore_status: std::option::Option<crate::model::RestoreStatus>,
    /// <p></p>
    pub data_transfer_progress: std::option::Option<crate::model::DataTransferProgress>,
    /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any
    /// hardware security module (HSM) settings changes specified in a modify cluster
    /// command.</p>
    /// <p>Values: active, applying</p>
    pub hsm_status: std::option::Option<crate::model::HsmStatus>,
    /// <p>A value that returns the destination region and retention period that are
    /// configured for cross-region snapshot copy.</p>
    pub cluster_snapshot_copy_status: std::option::Option<crate::model::ClusterSnapshotCopyStatus>,
    /// <p>The public key for the cluster.</p>
    pub cluster_public_key: std::option::Option<std::string::String>,
    /// <p>The nodes in the cluster.</p>
    pub cluster_nodes: std::option::Option<std::vec::Vec<crate::model::ClusterNode>>,
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub elastic_ip_status: std::option::Option<crate::model::ElasticIpStatus>,
    /// <p>The specific revision number of the database in the cluster.</p>
    pub cluster_revision_number: std::option::Option<std::string::String>,
    /// <p>The list of tags for the cluster.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Key Management Service (KMS) key ID of the encryption key used to
    /// encrypt data in the cluster.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    /// the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub enhanced_vpc_routing: bool,
    /// <p>A list of Identity and Access Management (IAM) roles that can be used by the
    /// cluster to access other Amazon Web Services services.</p>
    pub iam_roles: std::option::Option<std::vec::Vec<crate::model::ClusterIamRole>>,
    /// <p>Cluster operations that are waiting to be started.</p>
    pub pending_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name of the maintenance track for the cluster.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The number of nodes that you can resize the cluster to with the elastic resize method.
    /// </p>
    pub elastic_resize_number_of_node_options: std::option::Option<std::string::String>,
    /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
    pub deferred_maintenance_windows:
        std::option::Option<std::vec::Vec<crate::model::DeferredMaintenanceWindow>>,
    /// <p>A unique identifier for the cluster snapshot schedule.</p>
    pub snapshot_schedule_identifier: std::option::Option<std::string::String>,
    /// <p>The current state of the cluster snapshot schedule.</p>
    pub snapshot_schedule_state: std::option::Option<crate::model::ScheduleState>,
    /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
    pub expected_next_snapshot_schedule_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>OnTrack - The next snapshot is expected to be taken on time. </p>
    /// </li>
    /// <li>
    /// <p>Pending - The next snapshot is pending to be taken. </p>
    /// </li>
    /// </ul>
    pub expected_next_snapshot_schedule_time_status: std::option::Option<std::string::String>,
    /// <p>The date and time in UTC when system maintenance can begin.</p>
    pub next_maintenance_window_start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Returns the following:</p>
    /// <ul>
    /// <li>
    /// <p>AllowCancelResize: a boolean value indicating if the resize operation can be
    /// cancelled.</p>
    /// </li>
    /// <li>
    /// <p>ResizeType: Returns ClassicResize</p>
    /// </li>
    /// </ul>
    pub resize_info: std::option::Option<crate::model::ResizeInfo>,
    /// <p>Describes the status of the Availability Zone relocation operation.</p>
    pub availability_zone_relocation_status: std::option::Option<std::string::String>,
    /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
    pub cluster_namespace_arn: std::option::Option<std::string::String>,
    /// <p>The total storage capacity of the cluster in megabytes. </p>
    pub total_storage_capacity_in_mega_bytes: std::option::Option<i64>,
    /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
    pub aqua_configuration: std::option::Option<crate::model::AquaConfiguration>,
}
impl std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Cluster");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("node_type", &self.node_type);
        formatter.field("cluster_status", &self.cluster_status);
        formatter.field(
            "cluster_availability_status",
            &self.cluster_availability_status,
        );
        formatter.field("modify_status", &self.modify_status);
        formatter.field("master_username", &self.master_username);
        formatter.field("db_name", &self.db_name);
        formatter.field("endpoint", &self.endpoint);
        formatter.field("cluster_create_time", &self.cluster_create_time);
        formatter.field(
            "automated_snapshot_retention_period",
            &self.automated_snapshot_retention_period,
        );
        formatter.field(
            "manual_snapshot_retention_period",
            &self.manual_snapshot_retention_period,
        );
        formatter.field("cluster_security_groups", &self.cluster_security_groups);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("cluster_parameter_groups", &self.cluster_parameter_groups);
        formatter.field("cluster_subnet_group_name", &self.cluster_subnet_group_name);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field(
            "preferred_maintenance_window",
            &self.preferred_maintenance_window,
        );
        formatter.field("pending_modified_values", &self.pending_modified_values);
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field("allow_version_upgrade", &self.allow_version_upgrade);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("restore_status", &self.restore_status);
        formatter.field("data_transfer_progress", &self.data_transfer_progress);
        formatter.field("hsm_status", &self.hsm_status);
        formatter.field(
            "cluster_snapshot_copy_status",
            &self.cluster_snapshot_copy_status,
        );
        formatter.field("cluster_public_key", &self.cluster_public_key);
        formatter.field("cluster_nodes", &self.cluster_nodes);
        formatter.field("elastic_ip_status", &self.elastic_ip_status);
        formatter.field("cluster_revision_number", &self.cluster_revision_number);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field("iam_roles", &self.iam_roles);
        formatter.field("pending_actions", &self.pending_actions);
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field(
            "elastic_resize_number_of_node_options",
            &self.elastic_resize_number_of_node_options,
        );
        formatter.field(
            "deferred_maintenance_windows",
            &self.deferred_maintenance_windows,
        );
        formatter.field(
            "snapshot_schedule_identifier",
            &self.snapshot_schedule_identifier,
        );
        formatter.field("snapshot_schedule_state", &self.snapshot_schedule_state);
        formatter.field(
            "expected_next_snapshot_schedule_time",
            &self.expected_next_snapshot_schedule_time,
        );
        formatter.field(
            "expected_next_snapshot_schedule_time_status",
            &self.expected_next_snapshot_schedule_time_status,
        );
        formatter.field(
            "next_maintenance_window_start_time",
            &self.next_maintenance_window_start_time,
        );
        formatter.field("resize_info", &self.resize_info);
        formatter.field(
            "availability_zone_relocation_status",
            &self.availability_zone_relocation_status,
        );
        formatter.field("cluster_namespace_arn", &self.cluster_namespace_arn);
        formatter.field(
            "total_storage_capacity_in_mega_bytes",
            &self.total_storage_capacity_in_mega_bytes,
        );
        formatter.field("aqua_configuration", &self.aqua_configuration);
        formatter.finish()
    }
}
/// See [`Cluster`](crate::model::Cluster)
pub mod cluster {
    /// A builder for [`Cluster`](crate::model::Cluster)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) cluster_status: std::option::Option<std::string::String>,
        pub(crate) cluster_availability_status: std::option::Option<std::string::String>,
        pub(crate) modify_status: std::option::Option<std::string::String>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<crate::model::Endpoint>,
        pub(crate) cluster_create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) automated_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) manual_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) cluster_security_groups:
            std::option::Option<std::vec::Vec<crate::model::ClusterSecurityGroupMembership>>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        pub(crate) cluster_parameter_groups:
            std::option::Option<std::vec::Vec<crate::model::ClusterParameterGroupStatus>>,
        pub(crate) cluster_subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
        pub(crate) pending_modified_values:
            std::option::Option<crate::model::PendingModifiedValues>,
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) allow_version_upgrade: std::option::Option<bool>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) restore_status: std::option::Option<crate::model::RestoreStatus>,
        pub(crate) data_transfer_progress: std::option::Option<crate::model::DataTransferProgress>,
        pub(crate) hsm_status: std::option::Option<crate::model::HsmStatus>,
        pub(crate) cluster_snapshot_copy_status:
            std::option::Option<crate::model::ClusterSnapshotCopyStatus>,
        pub(crate) cluster_public_key: std::option::Option<std::string::String>,
        pub(crate) cluster_nodes: std::option::Option<std::vec::Vec<crate::model::ClusterNode>>,
        pub(crate) elastic_ip_status: std::option::Option<crate::model::ElasticIpStatus>,
        pub(crate) cluster_revision_number: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) iam_roles: std::option::Option<std::vec::Vec<crate::model::ClusterIamRole>>,
        pub(crate) pending_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) elastic_resize_number_of_node_options: std::option::Option<std::string::String>,
        pub(crate) deferred_maintenance_windows:
            std::option::Option<std::vec::Vec<crate::model::DeferredMaintenanceWindow>>,
        pub(crate) snapshot_schedule_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_schedule_state: std::option::Option<crate::model::ScheduleState>,
        pub(crate) expected_next_snapshot_schedule_time:
            std::option::Option<aws_smithy_types::Instant>,
        pub(crate) expected_next_snapshot_schedule_time_status:
            std::option::Option<std::string::String>,
        pub(crate) next_maintenance_window_start_time:
            std::option::Option<aws_smithy_types::Instant>,
        pub(crate) resize_info: std::option::Option<crate::model::ResizeInfo>,
        pub(crate) availability_zone_relocation_status: std::option::Option<std::string::String>,
        pub(crate) cluster_namespace_arn: std::option::Option<std::string::String>,
        pub(crate) total_storage_capacity_in_mega_bytes: std::option::Option<i64>,
        pub(crate) aqua_configuration: std::option::Option<crate::model::AquaConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier of the cluster.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cluster.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The node type for the nodes in the cluster.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type for the nodes in the cluster.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p> The current state of the cluster. Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>available</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available, prep-for-resize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available, resize-cleanup</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelling-resize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>creating</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleting</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>final-snapshot</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hardware-failure</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-hsm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-network</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-parameters</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-restore</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modifying</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>paused</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rebooting</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>renaming</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resizing</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rotating-keys</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>storage-full</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>updating-hsm</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_status = Some(input.into());
            self
        }
        /// <p> The current state of the cluster. Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>available</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available, prep-for-resize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available, resize-cleanup</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelling-resize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>creating</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>deleting</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>final-snapshot</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hardware-failure</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-hsm</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-network</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-parameters</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>incompatible-restore</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modifying</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>paused</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rebooting</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>renaming</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resizing</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>rotating-keys</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>storage-full</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>updating-hsm</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn set_cluster_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_status = input;
            self
        }
        /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>Available - The cluster is available for queries. </p>
        /// </li>
        /// <li>
        /// <p>Unavailable - The cluster is not available for queries.</p>
        /// </li>
        /// <li>
        /// <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
        /// </li>
        /// <li>
        /// <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
        /// </li>
        /// <li>
        /// <p>Failed - The cluster failed and is not available for queries.</p>
        /// </li>
        /// </ul>
        pub fn cluster_availability_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_availability_status = Some(input.into());
            self
        }
        /// <p>The availability status of the cluster for queries. Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>Available - The cluster is available for queries. </p>
        /// </li>
        /// <li>
        /// <p>Unavailable - The cluster is not available for queries.</p>
        /// </li>
        /// <li>
        /// <p>Maintenance - The cluster is intermittently available for queries due to maintenance activities.</p>
        /// </li>
        /// <li>
        /// <p>Modifying - The cluster is intermittently available for queries due to changes that modify the cluster.</p>
        /// </li>
        /// <li>
        /// <p>Failed - The cluster failed and is not available for queries.</p>
        /// </li>
        /// </ul>
        pub fn set_cluster_availability_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_availability_status = input;
            self
        }
        /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
        pub fn modify_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.modify_status = Some(input.into());
            self
        }
        /// <p>The status of a modify operation, if any, initiated for the cluster.</p>
        pub fn set_modify_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.modify_status = input;
            self
        }
        /// <p>The admin user name for the cluster. This name is used to connect to the database
        /// that is specified in the <b>DBName</b> parameter. </p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The admin user name for the cluster. This name is used to connect to the database
        /// that is specified in the <b>DBName</b> parameter. </p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The name of the initial database that was created when the cluster was created.
        /// This same name is returned for the life of the cluster. If an initial database was not
        /// specified, a database named <code>dev</code>dev was created by default. </p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The name of the initial database that was created when the cluster was created.
        /// This same name is returned for the life of the cluster. If an initial database was not
        /// specified, a database named <code>dev</code>dev was created by default. </p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// <p>The connection endpoint.</p>
        pub fn endpoint(mut self, input: crate::model::Endpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>The connection endpoint.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<crate::model::Endpoint>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The date and time that the cluster was created.</p>
        pub fn cluster_create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.cluster_create_time = Some(input);
            self
        }
        /// <p>The date and time that the cluster was created.</p>
        pub fn set_cluster_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.cluster_create_time = input;
            self
        }
        /// <p>The number of days that automatic cluster snapshots are retained.</p>
        pub fn automated_snapshot_retention_period(mut self, input: i32) -> Self {
            self.automated_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The number of days that automatic cluster snapshots are retained.</p>
        pub fn set_automated_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_retention_period = input;
            self
        }
        /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
        /// snapshot is retained indefinitely. This setting doesn't change the retention period
        /// of existing snapshots.</p>
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
            self.manual_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The default number of days to retain a manual snapshot. If the value is -1, the
        /// snapshot is retained indefinitely. This setting doesn't change the retention period
        /// of existing snapshots.</p>
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn set_manual_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_retention_period = input;
            self
        }
        /// Appends an item to `cluster_security_groups`.
        ///
        /// To override the contents of this collection use [`set_cluster_security_groups`](Self::set_cluster_security_groups).
        ///
        /// <p>A list of cluster security group that are associated with the cluster. Each
        /// security group is represented by an element that contains
        /// <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
        /// subelements. </p>
        /// <p>Cluster security groups are used when the cluster is not created in an Amazon
        /// Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
        /// which are listed by the <b>VpcSecurityGroups</b> parameter.
        /// </p>
        pub fn cluster_security_groups(
            mut self,
            input: impl Into<crate::model::ClusterSecurityGroupMembership>,
        ) -> Self {
            let mut v = self.cluster_security_groups.unwrap_or_default();
            v.push(input.into());
            self.cluster_security_groups = Some(v);
            self
        }
        /// <p>A list of cluster security group that are associated with the cluster. Each
        /// security group is represented by an element that contains
        /// <code>ClusterSecurityGroup.Name</code> and <code>ClusterSecurityGroup.Status</code>
        /// subelements. </p>
        /// <p>Cluster security groups are used when the cluster is not created in an Amazon
        /// Virtual Private Cloud (VPC). Clusters that are created in a VPC use VPC security groups,
        /// which are listed by the <b>VpcSecurityGroups</b> parameter.
        /// </p>
        pub fn set_cluster_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterSecurityGroupMembership>>,
        ) -> Self {
            self.cluster_security_groups = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
        /// associated with the cluster. This parameter is returned only if the cluster is in a
        /// VPC.</p>
        pub fn vpc_security_groups(
            mut self,
            input: impl Into<crate::model::VpcSecurityGroupMembership>,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input.into());
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>A list of Amazon Virtual Private Cloud (Amazon VPC) security groups that are
        /// associated with the cluster. This parameter is returned only if the cluster is in a
        /// VPC.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// Appends an item to `cluster_parameter_groups`.
        ///
        /// To override the contents of this collection use [`set_cluster_parameter_groups`](Self::set_cluster_parameter_groups).
        ///
        /// <p>The list of cluster parameter groups that are associated with this cluster. Each
        /// parameter group in the list is returned with its status.</p>
        pub fn cluster_parameter_groups(
            mut self,
            input: impl Into<crate::model::ClusterParameterGroupStatus>,
        ) -> Self {
            let mut v = self.cluster_parameter_groups.unwrap_or_default();
            v.push(input.into());
            self.cluster_parameter_groups = Some(v);
            self
        }
        /// <p>The list of cluster parameter groups that are associated with this cluster. Each
        /// parameter group in the list is returned with its status.</p>
        pub fn set_cluster_parameter_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterParameterGroupStatus>>,
        ) -> Self {
            self.cluster_parameter_groups = input;
            self
        }
        /// <p>The name of the subnet group that is associated with the cluster. This parameter is
        /// valid only when the cluster is in a VPC.</p>
        pub fn cluster_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_subnet_group_name = Some(input.into());
            self
        }
        /// <p>The name of the subnet group that is associated with the cluster. This parameter is
        /// valid only when the cluster is in a VPC.</p>
        pub fn set_cluster_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_subnet_group_name = input;
            self
        }
        /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC the cluster is in, if the cluster is in a VPC.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The name of the Availability Zone in which the cluster is located.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The name of the Availability Zone in which the cluster is located.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
        /// maintenance can occur.</p>
        pub fn preferred_maintenance_window(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = Some(input.into());
            self
        }
        /// <p>The weekly time range, in Universal Coordinated Time (UTC), during which system
        /// maintenance can occur.</p>
        pub fn set_preferred_maintenance_window(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_maintenance_window = input;
            self
        }
        /// <p>A value that, if present, indicates that changes to the cluster are pending.
        /// Specific pending changes are identified by subelements.</p>
        pub fn pending_modified_values(
            mut self,
            input: crate::model::PendingModifiedValues,
        ) -> Self {
            self.pending_modified_values = Some(input);
            self
        }
        /// <p>A value that, if present, indicates that changes to the cluster are pending.
        /// Specific pending changes are identified by subelements.</p>
        pub fn set_pending_modified_values(
            mut self,
            input: std::option::Option<crate::model::PendingModifiedValues>,
        ) -> Self {
            self.pending_modified_values = input;
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
        /// will be applied automatically to the cluster during the maintenance window. </p>
        pub fn allow_version_upgrade(mut self, input: bool) -> Self {
            self.allow_version_upgrade = Some(input);
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that major version upgrades
        /// will be applied automatically to the cluster during the maintenance window. </p>
        pub fn set_allow_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_version_upgrade = input;
            self
        }
        /// <p>The number of compute nodes in the cluster.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The number of compute nodes in the cluster.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
        /// accessed from a public network.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that the cluster can be
        /// accessed from a public network.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
        /// encrypted at rest.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>A boolean value that, if <code>true</code>, indicates that data in the cluster is
        /// encrypted at rest.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>A value that describes the status of a cluster restore action. This parameter
        /// returns null if the cluster was not created by restoring a snapshot.</p>
        pub fn restore_status(mut self, input: crate::model::RestoreStatus) -> Self {
            self.restore_status = Some(input);
            self
        }
        /// <p>A value that describes the status of a cluster restore action. This parameter
        /// returns null if the cluster was not created by restoring a snapshot.</p>
        pub fn set_restore_status(
            mut self,
            input: std::option::Option<crate::model::RestoreStatus>,
        ) -> Self {
            self.restore_status = input;
            self
        }
        /// <p></p>
        pub fn data_transfer_progress(mut self, input: crate::model::DataTransferProgress) -> Self {
            self.data_transfer_progress = Some(input);
            self
        }
        /// <p></p>
        pub fn set_data_transfer_progress(
            mut self,
            input: std::option::Option<crate::model::DataTransferProgress>,
        ) -> Self {
            self.data_transfer_progress = input;
            self
        }
        /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any
        /// hardware security module (HSM) settings changes specified in a modify cluster
        /// command.</p>
        /// <p>Values: active, applying</p>
        pub fn hsm_status(mut self, input: crate::model::HsmStatus) -> Self {
            self.hsm_status = Some(input);
            self
        }
        /// <p>A value that reports whether the Amazon Redshift cluster has finished applying any
        /// hardware security module (HSM) settings changes specified in a modify cluster
        /// command.</p>
        /// <p>Values: active, applying</p>
        pub fn set_hsm_status(
            mut self,
            input: std::option::Option<crate::model::HsmStatus>,
        ) -> Self {
            self.hsm_status = input;
            self
        }
        /// <p>A value that returns the destination region and retention period that are
        /// configured for cross-region snapshot copy.</p>
        pub fn cluster_snapshot_copy_status(
            mut self,
            input: crate::model::ClusterSnapshotCopyStatus,
        ) -> Self {
            self.cluster_snapshot_copy_status = Some(input);
            self
        }
        /// <p>A value that returns the destination region and retention period that are
        /// configured for cross-region snapshot copy.</p>
        pub fn set_cluster_snapshot_copy_status(
            mut self,
            input: std::option::Option<crate::model::ClusterSnapshotCopyStatus>,
        ) -> Self {
            self.cluster_snapshot_copy_status = input;
            self
        }
        /// <p>The public key for the cluster.</p>
        pub fn cluster_public_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_public_key = Some(input.into());
            self
        }
        /// <p>The public key for the cluster.</p>
        pub fn set_cluster_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_public_key = input;
            self
        }
        /// Appends an item to `cluster_nodes`.
        ///
        /// To override the contents of this collection use [`set_cluster_nodes`](Self::set_cluster_nodes).
        ///
        /// <p>The nodes in the cluster.</p>
        pub fn cluster_nodes(mut self, input: impl Into<crate::model::ClusterNode>) -> Self {
            let mut v = self.cluster_nodes.unwrap_or_default();
            v.push(input.into());
            self.cluster_nodes = Some(v);
            self
        }
        /// <p>The nodes in the cluster.</p>
        pub fn set_cluster_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterNode>>,
        ) -> Self {
            self.cluster_nodes = input;
            self
        }
        /// <p>The status of the elastic IP (EIP) address.</p>
        pub fn elastic_ip_status(mut self, input: crate::model::ElasticIpStatus) -> Self {
            self.elastic_ip_status = Some(input);
            self
        }
        /// <p>The status of the elastic IP (EIP) address.</p>
        pub fn set_elastic_ip_status(
            mut self,
            input: std::option::Option<crate::model::ElasticIpStatus>,
        ) -> Self {
            self.elastic_ip_status = input;
            self
        }
        /// <p>The specific revision number of the database in the cluster.</p>
        pub fn cluster_revision_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_revision_number = Some(input.into());
            self
        }
        /// <p>The specific revision number of the database in the cluster.</p>
        pub fn set_cluster_revision_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_revision_number = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the cluster.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the cluster.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Key Management Service (KMS) key ID of the encryption key used to
        /// encrypt data in the cluster.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Key Management Service (KMS) key ID of the encryption key used to
        /// encrypt data in the cluster.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// Appends an item to `iam_roles`.
        ///
        /// To override the contents of this collection use [`set_iam_roles`](Self::set_iam_roles).
        ///
        /// <p>A list of Identity and Access Management (IAM) roles that can be used by the
        /// cluster to access other Amazon Web Services services.</p>
        pub fn iam_roles(mut self, input: impl Into<crate::model::ClusterIamRole>) -> Self {
            let mut v = self.iam_roles.unwrap_or_default();
            v.push(input.into());
            self.iam_roles = Some(v);
            self
        }
        /// <p>A list of Identity and Access Management (IAM) roles that can be used by the
        /// cluster to access other Amazon Web Services services.</p>
        pub fn set_iam_roles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterIamRole>>,
        ) -> Self {
            self.iam_roles = input;
            self
        }
        /// Appends an item to `pending_actions`.
        ///
        /// To override the contents of this collection use [`set_pending_actions`](Self::set_pending_actions).
        ///
        /// <p>Cluster operations that are waiting to be started.</p>
        pub fn pending_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.pending_actions.unwrap_or_default();
            v.push(input.into());
            self.pending_actions = Some(v);
            self
        }
        /// <p>Cluster operations that are waiting to be started.</p>
        pub fn set_pending_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.pending_actions = input;
            self
        }
        /// <p>The name of the maintenance track for the cluster.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track for the cluster.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The number of nodes that you can resize the cluster to with the elastic resize method.
        /// </p>
        pub fn elastic_resize_number_of_node_options(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.elastic_resize_number_of_node_options = Some(input.into());
            self
        }
        /// <p>The number of nodes that you can resize the cluster to with the elastic resize method.
        /// </p>
        pub fn set_elastic_resize_number_of_node_options(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.elastic_resize_number_of_node_options = input;
            self
        }
        /// Appends an item to `deferred_maintenance_windows`.
        ///
        /// To override the contents of this collection use [`set_deferred_maintenance_windows`](Self::set_deferred_maintenance_windows).
        ///
        /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
        pub fn deferred_maintenance_windows(
            mut self,
            input: impl Into<crate::model::DeferredMaintenanceWindow>,
        ) -> Self {
            let mut v = self.deferred_maintenance_windows.unwrap_or_default();
            v.push(input.into());
            self.deferred_maintenance_windows = Some(v);
            self
        }
        /// <p>Describes a group of <code>DeferredMaintenanceWindow</code> objects.</p>
        pub fn set_deferred_maintenance_windows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeferredMaintenanceWindow>>,
        ) -> Self {
            self.deferred_maintenance_windows = input;
            self
        }
        /// <p>A unique identifier for the cluster snapshot schedule.</p>
        pub fn snapshot_schedule_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.snapshot_schedule_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the cluster snapshot schedule.</p>
        pub fn set_snapshot_schedule_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_schedule_identifier = input;
            self
        }
        /// <p>The current state of the cluster snapshot schedule.</p>
        pub fn snapshot_schedule_state(mut self, input: crate::model::ScheduleState) -> Self {
            self.snapshot_schedule_state = Some(input);
            self
        }
        /// <p>The current state of the cluster snapshot schedule.</p>
        pub fn set_snapshot_schedule_state(
            mut self,
            input: std::option::Option<crate::model::ScheduleState>,
        ) -> Self {
            self.snapshot_schedule_state = input;
            self
        }
        /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
        pub fn expected_next_snapshot_schedule_time(
            mut self,
            input: aws_smithy_types::Instant,
        ) -> Self {
            self.expected_next_snapshot_schedule_time = Some(input);
            self
        }
        /// <p>The date and time when the next snapshot is expected to be taken for clusters with a valid snapshot schedule and backups enabled. </p>
        pub fn set_expected_next_snapshot_schedule_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time = input;
            self
        }
        /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>OnTrack - The next snapshot is expected to be taken on time. </p>
        /// </li>
        /// <li>
        /// <p>Pending - The next snapshot is pending to be taken. </p>
        /// </li>
        /// </ul>
        pub fn expected_next_snapshot_schedule_time_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time_status = Some(input.into());
            self
        }
        /// <p> The status of next expected snapshot for clusters having a valid snapshot schedule and backups enabled.  Possible values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>OnTrack - The next snapshot is expected to be taken on time. </p>
        /// </li>
        /// <li>
        /// <p>Pending - The next snapshot is pending to be taken. </p>
        /// </li>
        /// </ul>
        pub fn set_expected_next_snapshot_schedule_time_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_next_snapshot_schedule_time_status = input;
            self
        }
        /// <p>The date and time in UTC when system maintenance can begin.</p>
        pub fn next_maintenance_window_start_time(
            mut self,
            input: aws_smithy_types::Instant,
        ) -> Self {
            self.next_maintenance_window_start_time = Some(input);
            self
        }
        /// <p>The date and time in UTC when system maintenance can begin.</p>
        pub fn set_next_maintenance_window_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.next_maintenance_window_start_time = input;
            self
        }
        /// <p>Returns the following:</p>
        /// <ul>
        /// <li>
        /// <p>AllowCancelResize: a boolean value indicating if the resize operation can be
        /// cancelled.</p>
        /// </li>
        /// <li>
        /// <p>ResizeType: Returns ClassicResize</p>
        /// </li>
        /// </ul>
        pub fn resize_info(mut self, input: crate::model::ResizeInfo) -> Self {
            self.resize_info = Some(input);
            self
        }
        /// <p>Returns the following:</p>
        /// <ul>
        /// <li>
        /// <p>AllowCancelResize: a boolean value indicating if the resize operation can be
        /// cancelled.</p>
        /// </li>
        /// <li>
        /// <p>ResizeType: Returns ClassicResize</p>
        /// </li>
        /// </ul>
        pub fn set_resize_info(
            mut self,
            input: std::option::Option<crate::model::ResizeInfo>,
        ) -> Self {
            self.resize_info = input;
            self
        }
        /// <p>Describes the status of the Availability Zone relocation operation.</p>
        pub fn availability_zone_relocation_status(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.availability_zone_relocation_status = Some(input.into());
            self
        }
        /// <p>Describes the status of the Availability Zone relocation operation.</p>
        pub fn set_availability_zone_relocation_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone_relocation_status = input;
            self
        }
        /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
        pub fn cluster_namespace_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_namespace_arn = Some(input.into());
            self
        }
        /// <p>The namespace Amazon Resource Name (ARN) of the cluster.</p>
        pub fn set_cluster_namespace_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_namespace_arn = input;
            self
        }
        /// <p>The total storage capacity of the cluster in megabytes. </p>
        pub fn total_storage_capacity_in_mega_bytes(mut self, input: i64) -> Self {
            self.total_storage_capacity_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total storage capacity of the cluster in megabytes. </p>
        pub fn set_total_storage_capacity_in_mega_bytes(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.total_storage_capacity_in_mega_bytes = input;
            self
        }
        /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
        pub fn aqua_configuration(mut self, input: crate::model::AquaConfiguration) -> Self {
            self.aqua_configuration = Some(input);
            self
        }
        /// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
        pub fn set_aqua_configuration(
            mut self,
            input: std::option::Option<crate::model::AquaConfiguration>,
        ) -> Self {
            self.aqua_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Cluster`](crate::model::Cluster)
        pub fn build(self) -> crate::model::Cluster {
            crate::model::Cluster {
                cluster_identifier: self.cluster_identifier,
                node_type: self.node_type,
                cluster_status: self.cluster_status,
                cluster_availability_status: self.cluster_availability_status,
                modify_status: self.modify_status,
                master_username: self.master_username,
                db_name: self.db_name,
                endpoint: self.endpoint,
                cluster_create_time: self.cluster_create_time,
                automated_snapshot_retention_period: self
                    .automated_snapshot_retention_period
                    .unwrap_or_default(),
                manual_snapshot_retention_period: self
                    .manual_snapshot_retention_period
                    .unwrap_or_default(),
                cluster_security_groups: self.cluster_security_groups,
                vpc_security_groups: self.vpc_security_groups,
                cluster_parameter_groups: self.cluster_parameter_groups,
                cluster_subnet_group_name: self.cluster_subnet_group_name,
                vpc_id: self.vpc_id,
                availability_zone: self.availability_zone,
                preferred_maintenance_window: self.preferred_maintenance_window,
                pending_modified_values: self.pending_modified_values,
                cluster_version: self.cluster_version,
                allow_version_upgrade: self.allow_version_upgrade.unwrap_or_default(),
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                publicly_accessible: self.publicly_accessible.unwrap_or_default(),
                encrypted: self.encrypted.unwrap_or_default(),
                restore_status: self.restore_status,
                data_transfer_progress: self.data_transfer_progress,
                hsm_status: self.hsm_status,
                cluster_snapshot_copy_status: self.cluster_snapshot_copy_status,
                cluster_public_key: self.cluster_public_key,
                cluster_nodes: self.cluster_nodes,
                elastic_ip_status: self.elastic_ip_status,
                cluster_revision_number: self.cluster_revision_number,
                tags: self.tags,
                kms_key_id: self.kms_key_id,
                enhanced_vpc_routing: self.enhanced_vpc_routing.unwrap_or_default(),
                iam_roles: self.iam_roles,
                pending_actions: self.pending_actions,
                maintenance_track_name: self.maintenance_track_name,
                elastic_resize_number_of_node_options: self.elastic_resize_number_of_node_options,
                deferred_maintenance_windows: self.deferred_maintenance_windows,
                snapshot_schedule_identifier: self.snapshot_schedule_identifier,
                snapshot_schedule_state: self.snapshot_schedule_state,
                expected_next_snapshot_schedule_time: self.expected_next_snapshot_schedule_time,
                expected_next_snapshot_schedule_time_status: self
                    .expected_next_snapshot_schedule_time_status,
                next_maintenance_window_start_time: self.next_maintenance_window_start_time,
                resize_info: self.resize_info,
                availability_zone_relocation_status: self.availability_zone_relocation_status,
                cluster_namespace_arn: self.cluster_namespace_arn,
                total_storage_capacity_in_mega_bytes: self.total_storage_capacity_in_mega_bytes,
                aqua_configuration: self.aqua_configuration,
            }
        }
    }
}
impl Cluster {
    /// Creates a new builder-style object to manufacture [`Cluster`](crate::model::Cluster)
    pub fn builder() -> crate::model::cluster::Builder {
        crate::model::cluster::Builder::default()
    }
}

/// <p>The AQUA (Advanced Query Accelerator) configuration of the cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AquaConfiguration {
    /// <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
    /// <ul>
    /// <li>
    /// <p>enabled - AQUA is enabled.</p>
    /// </li>
    /// <li>
    /// <p>disabled - AQUA is not enabled. </p>
    /// </li>
    /// <li>
    /// <p>applying - AQUA status is being applied. </p>
    /// </li>
    /// </ul>
    pub aqua_status: std::option::Option<crate::model::AquaStatus>,
    /// <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
    /// <ul>
    /// <li>
    /// <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
    /// </li>
    /// <li>
    /// <p>disabled - Don't use AQUA. </p>
    /// </li>
    /// <li>
    /// <p>auto - Amazon Redshift determines whether to use AQUA.</p>
    /// </li>
    /// </ul>
    pub aqua_configuration_status: std::option::Option<crate::model::AquaConfigurationStatus>,
}
impl std::fmt::Debug for AquaConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AquaConfiguration");
        formatter.field("aqua_status", &self.aqua_status);
        formatter.field("aqua_configuration_status", &self.aqua_configuration_status);
        formatter.finish()
    }
}
/// See [`AquaConfiguration`](crate::model::AquaConfiguration)
pub mod aqua_configuration {
    /// A builder for [`AquaConfiguration`](crate::model::AquaConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) aqua_status: std::option::Option<crate::model::AquaStatus>,
        pub(crate) aqua_configuration_status:
            std::option::Option<crate::model::AquaConfigurationStatus>,
    }
    impl Builder {
        /// <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
        /// <ul>
        /// <li>
        /// <p>enabled - AQUA is enabled.</p>
        /// </li>
        /// <li>
        /// <p>disabled - AQUA is not enabled. </p>
        /// </li>
        /// <li>
        /// <p>applying - AQUA status is being applied. </p>
        /// </li>
        /// </ul>
        pub fn aqua_status(mut self, input: crate::model::AquaStatus) -> Self {
            self.aqua_status = Some(input);
            self
        }
        /// <p>The value indicates the status of AQUA on the cluster. Possible values include the following.</p>
        /// <ul>
        /// <li>
        /// <p>enabled - AQUA is enabled.</p>
        /// </li>
        /// <li>
        /// <p>disabled - AQUA is not enabled. </p>
        /// </li>
        /// <li>
        /// <p>applying - AQUA status is being applied. </p>
        /// </li>
        /// </ul>
        pub fn set_aqua_status(
            mut self,
            input: std::option::Option<crate::model::AquaStatus>,
        ) -> Self {
            self.aqua_status = input;
            self
        }
        /// <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
        /// <ul>
        /// <li>
        /// <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
        /// </li>
        /// <li>
        /// <p>disabled - Don't use AQUA. </p>
        /// </li>
        /// <li>
        /// <p>auto - Amazon Redshift determines whether to use AQUA.</p>
        /// </li>
        /// </ul>
        pub fn aqua_configuration_status(
            mut self,
            input: crate::model::AquaConfigurationStatus,
        ) -> Self {
            self.aqua_configuration_status = Some(input);
            self
        }
        /// <p>The value represents how the cluster is configured to use AQUA. Possible values include the following.</p>
        /// <ul>
        /// <li>
        /// <p>enabled - Use AQUA if it is available for the current Amazon Web Services Region and Amazon Redshift node type.</p>
        /// </li>
        /// <li>
        /// <p>disabled - Don't use AQUA. </p>
        /// </li>
        /// <li>
        /// <p>auto - Amazon Redshift determines whether to use AQUA.</p>
        /// </li>
        /// </ul>
        pub fn set_aqua_configuration_status(
            mut self,
            input: std::option::Option<crate::model::AquaConfigurationStatus>,
        ) -> Self {
            self.aqua_configuration_status = input;
            self
        }
        /// Consumes the builder and constructs a [`AquaConfiguration`](crate::model::AquaConfiguration)
        pub fn build(self) -> crate::model::AquaConfiguration {
            crate::model::AquaConfiguration {
                aqua_status: self.aqua_status,
                aqua_configuration_status: self.aqua_configuration_status,
            }
        }
    }
}
impl AquaConfiguration {
    /// Creates a new builder-style object to manufacture [`AquaConfiguration`](crate::model::AquaConfiguration)
    pub fn builder() -> crate::model::aqua_configuration::Builder {
        crate::model::aqua_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AquaConfigurationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Auto,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AquaConfigurationStatus {
    fn from(s: &str) -> Self {
        match s {
            "auto" => AquaConfigurationStatus::Auto,
            "disabled" => AquaConfigurationStatus::Disabled,
            "enabled" => AquaConfigurationStatus::Enabled,
            other => AquaConfigurationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AquaConfigurationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AquaConfigurationStatus::from(s))
    }
}
impl AquaConfigurationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AquaConfigurationStatus::Auto => "auto",
            AquaConfigurationStatus::Disabled => "disabled",
            AquaConfigurationStatus::Enabled => "enabled",
            AquaConfigurationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["auto", "disabled", "enabled"]
    }
}
impl AsRef<str> for AquaConfigurationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AquaStatus {
    #[allow(missing_docs)] // documentation missing in model
    Applying,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AquaStatus {
    fn from(s: &str) -> Self {
        match s {
            "applying" => AquaStatus::Applying,
            "disabled" => AquaStatus::Disabled,
            "enabled" => AquaStatus::Enabled,
            other => AquaStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AquaStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AquaStatus::from(s))
    }
}
impl AquaStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AquaStatus::Applying => "applying",
            AquaStatus::Disabled => "disabled",
            AquaStatus::Enabled => "enabled",
            AquaStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["applying", "disabled", "enabled"]
    }
}
impl AsRef<str> for AquaStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a resize operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResizeInfo {
    /// <p>Returns the value <code>ClassicResize</code>.</p>
    pub resize_type: std::option::Option<std::string::String>,
    /// <p>A boolean value indicating if the resize operation can be cancelled.</p>
    pub allow_cancel_resize: bool,
}
impl std::fmt::Debug for ResizeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResizeInfo");
        formatter.field("resize_type", &self.resize_type);
        formatter.field("allow_cancel_resize", &self.allow_cancel_resize);
        formatter.finish()
    }
}
/// See [`ResizeInfo`](crate::model::ResizeInfo)
pub mod resize_info {
    /// A builder for [`ResizeInfo`](crate::model::ResizeInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resize_type: std::option::Option<std::string::String>,
        pub(crate) allow_cancel_resize: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Returns the value <code>ClassicResize</code>.</p>
        pub fn resize_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resize_type = Some(input.into());
            self
        }
        /// <p>Returns the value <code>ClassicResize</code>.</p>
        pub fn set_resize_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resize_type = input;
            self
        }
        /// <p>A boolean value indicating if the resize operation can be cancelled.</p>
        pub fn allow_cancel_resize(mut self, input: bool) -> Self {
            self.allow_cancel_resize = Some(input);
            self
        }
        /// <p>A boolean value indicating if the resize operation can be cancelled.</p>
        pub fn set_allow_cancel_resize(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_cancel_resize = input;
            self
        }
        /// Consumes the builder and constructs a [`ResizeInfo`](crate::model::ResizeInfo)
        pub fn build(self) -> crate::model::ResizeInfo {
            crate::model::ResizeInfo {
                resize_type: self.resize_type,
                allow_cancel_resize: self.allow_cancel_resize.unwrap_or_default(),
            }
        }
    }
}
impl ResizeInfo {
    /// Creates a new builder-style object to manufacture [`ResizeInfo`](crate::model::ResizeInfo)
    pub fn builder() -> crate::model::resize_info::Builder {
        crate::model::resize_info::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Modifying,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduleState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ScheduleState::Active,
            "FAILED" => ScheduleState::Failed,
            "MODIFYING" => ScheduleState::Modifying,
            other => ScheduleState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleState::from(s))
    }
}
impl ScheduleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleState::Active => "ACTIVE",
            ScheduleState::Failed => "FAILED",
            ScheduleState::Modifying => "MODIFYING",
            ScheduleState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "FAILED", "MODIFYING"]
    }
}
impl AsRef<str> for ScheduleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a deferred maintenance window</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeferredMaintenanceWindow {
    /// <p>A unique identifier for the maintenance window.</p>
    pub defer_maintenance_identifier: std::option::Option<std::string::String>,
    /// <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
    pub defer_maintenance_start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p> A timestamp for the end of the time period when we defer maintenance.</p>
    pub defer_maintenance_end_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for DeferredMaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeferredMaintenanceWindow");
        formatter.field(
            "defer_maintenance_identifier",
            &self.defer_maintenance_identifier,
        );
        formatter.field(
            "defer_maintenance_start_time",
            &self.defer_maintenance_start_time,
        );
        formatter.field(
            "defer_maintenance_end_time",
            &self.defer_maintenance_end_time,
        );
        formatter.finish()
    }
}
/// See [`DeferredMaintenanceWindow`](crate::model::DeferredMaintenanceWindow)
pub mod deferred_maintenance_window {
    /// A builder for [`DeferredMaintenanceWindow`](crate::model::DeferredMaintenanceWindow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) defer_maintenance_identifier: std::option::Option<std::string::String>,
        pub(crate) defer_maintenance_start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) defer_maintenance_end_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>A unique identifier for the maintenance window.</p>
        pub fn defer_maintenance_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.defer_maintenance_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the maintenance window.</p>
        pub fn set_defer_maintenance_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.defer_maintenance_identifier = input;
            self
        }
        /// <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
        pub fn defer_maintenance_start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.defer_maintenance_start_time = Some(input);
            self
        }
        /// <p> A timestamp for the beginning of the time period when we defer maintenance.</p>
        pub fn set_defer_maintenance_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.defer_maintenance_start_time = input;
            self
        }
        /// <p> A timestamp for the end of the time period when we defer maintenance.</p>
        pub fn defer_maintenance_end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.defer_maintenance_end_time = Some(input);
            self
        }
        /// <p> A timestamp for the end of the time period when we defer maintenance.</p>
        pub fn set_defer_maintenance_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.defer_maintenance_end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DeferredMaintenanceWindow`](crate::model::DeferredMaintenanceWindow)
        pub fn build(self) -> crate::model::DeferredMaintenanceWindow {
            crate::model::DeferredMaintenanceWindow {
                defer_maintenance_identifier: self.defer_maintenance_identifier,
                defer_maintenance_start_time: self.defer_maintenance_start_time,
                defer_maintenance_end_time: self.defer_maintenance_end_time,
            }
        }
    }
}
impl DeferredMaintenanceWindow {
    /// Creates a new builder-style object to manufacture [`DeferredMaintenanceWindow`](crate::model::DeferredMaintenanceWindow)
    pub fn builder() -> crate::model::deferred_maintenance_window::Builder {
        crate::model::deferred_maintenance_window::Builder::default()
    }
}

/// <p>An Identity and Access Management (IAM) role that can be used by the associated
/// Amazon Redshift cluster to access other Amazon Web Services services.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterIamRole {
    /// <p>The Amazon Resource Name (ARN) of the IAM role, for example,
    /// <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>A value that describes the status of the IAM role's association with an Amazon
    /// Redshift cluster.</p>
    /// <p>The following are possible statuses and descriptions.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>in-sync</code>: The role is available for use by the cluster.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>adding</code>: The role is in the process of being associated with the
    /// cluster.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>removing</code>: The role is in the process of being disassociated with
    /// the cluster.</p>
    /// </li>
    /// </ul>
    pub apply_status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterIamRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterIamRole");
        formatter.field("iam_role_arn", &self.iam_role_arn);
        formatter.field("apply_status", &self.apply_status);
        formatter.finish()
    }
}
/// See [`ClusterIamRole`](crate::model::ClusterIamRole)
pub mod cluster_iam_role {
    /// A builder for [`ClusterIamRole`](crate::model::ClusterIamRole)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) apply_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM role, for example,
        /// <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role, for example,
        /// <code>arn:aws:iam::123456789012:role/RedshiftCopyUnload</code>. </p>
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>A value that describes the status of the IAM role's association with an Amazon
        /// Redshift cluster.</p>
        /// <p>The following are possible statuses and descriptions.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>in-sync</code>: The role is available for use by the cluster.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>adding</code>: The role is in the process of being associated with the
        /// cluster.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>removing</code>: The role is in the process of being disassociated with
        /// the cluster.</p>
        /// </li>
        /// </ul>
        pub fn apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.apply_status = Some(input.into());
            self
        }
        /// <p>A value that describes the status of the IAM role's association with an Amazon
        /// Redshift cluster.</p>
        /// <p>The following are possible statuses and descriptions.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>in-sync</code>: The role is available for use by the cluster.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>adding</code>: The role is in the process of being associated with the
        /// cluster.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>removing</code>: The role is in the process of being disassociated with
        /// the cluster.</p>
        /// </li>
        /// </ul>
        pub fn set_apply_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.apply_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterIamRole`](crate::model::ClusterIamRole)
        pub fn build(self) -> crate::model::ClusterIamRole {
            crate::model::ClusterIamRole {
                iam_role_arn: self.iam_role_arn,
                apply_status: self.apply_status,
            }
        }
    }
}
impl ClusterIamRole {
    /// Creates a new builder-style object to manufacture [`ClusterIamRole`](crate::model::ClusterIamRole)
    pub fn builder() -> crate::model::cluster_iam_role::Builder {
        crate::model::cluster_iam_role::Builder::default()
    }
}

/// <p>A tag consisting of a name/value pair for a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key, or name, for the resource tag.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the resource tag.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key, or name, for the resource tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key, or name, for the resource tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for the resource tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the resource tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Describes the status of the elastic IP (EIP) address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElasticIpStatus {
    /// <p>The elastic IP (EIP) address for the cluster.</p>
    pub elastic_ip: std::option::Option<std::string::String>,
    /// <p>The status of the elastic IP (EIP) address.</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ElasticIpStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElasticIpStatus");
        formatter.field("elastic_ip", &self.elastic_ip);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ElasticIpStatus`](crate::model::ElasticIpStatus)
pub mod elastic_ip_status {
    /// A builder for [`ElasticIpStatus`](crate::model::ElasticIpStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) elastic_ip: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The elastic IP (EIP) address for the cluster.</p>
        pub fn elastic_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.elastic_ip = Some(input.into());
            self
        }
        /// <p>The elastic IP (EIP) address for the cluster.</p>
        pub fn set_elastic_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.elastic_ip = input;
            self
        }
        /// <p>The status of the elastic IP (EIP) address.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the elastic IP (EIP) address.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ElasticIpStatus`](crate::model::ElasticIpStatus)
        pub fn build(self) -> crate::model::ElasticIpStatus {
            crate::model::ElasticIpStatus {
                elastic_ip: self.elastic_ip,
                status: self.status,
            }
        }
    }
}
impl ElasticIpStatus {
    /// Creates a new builder-style object to manufacture [`ElasticIpStatus`](crate::model::ElasticIpStatus)
    pub fn builder() -> crate::model::elastic_ip_status::Builder {
        crate::model::elastic_ip_status::Builder::default()
    }
}

/// <p>The identifier of a node in a cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterNode {
    /// <p>Whether the node is a leader node or a compute node.</p>
    pub node_role: std::option::Option<std::string::String>,
    /// <p>The private IP address of a node within a cluster.</p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The public IP address of a node within a cluster.</p>
    pub public_ip_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterNode");
        formatter.field("node_role", &self.node_role);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("public_ip_address", &self.public_ip_address);
        formatter.finish()
    }
}
/// See [`ClusterNode`](crate::model::ClusterNode)
pub mod cluster_node {
    /// A builder for [`ClusterNode`](crate::model::ClusterNode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) node_role: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) public_ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Whether the node is a leader node or a compute node.</p>
        pub fn node_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_role = Some(input.into());
            self
        }
        /// <p>Whether the node is a leader node or a compute node.</p>
        pub fn set_node_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_role = input;
            self
        }
        /// <p>The private IP address of a node within a cluster.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The private IP address of a node within a cluster.</p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The public IP address of a node within a cluster.</p>
        pub fn public_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.public_ip_address = Some(input.into());
            self
        }
        /// <p>The public IP address of a node within a cluster.</p>
        pub fn set_public_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.public_ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterNode`](crate::model::ClusterNode)
        pub fn build(self) -> crate::model::ClusterNode {
            crate::model::ClusterNode {
                node_role: self.node_role,
                private_ip_address: self.private_ip_address,
                public_ip_address: self.public_ip_address,
            }
        }
    }
}
impl ClusterNode {
    /// Creates a new builder-style object to manufacture [`ClusterNode`](crate::model::ClusterNode)
    pub fn builder() -> crate::model::cluster_node::Builder {
        crate::model::cluster_node::Builder::default()
    }
}

/// <p>Returns the destination region and retention period that are configured for
/// cross-region snapshot copy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterSnapshotCopyStatus {
    /// <p>The destination region that snapshots are automatically copied to when cross-region
    /// snapshot copy is enabled.</p>
    pub destination_region: std::option::Option<std::string::String>,
    /// <p>The number of days that automated snapshots are retained in the destination region
    /// after they are copied from a source region.</p>
    pub retention_period: i64,
    /// <p>The number of days that automated snapshots are retained in the destination region
    /// after they are copied from a source region. If the value is -1, the manual snapshot is
    /// retained indefinitely. </p>
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub manual_snapshot_retention_period: i32,
    /// <p>The name of the snapshot copy grant.</p>
    pub snapshot_copy_grant_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterSnapshotCopyStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterSnapshotCopyStatus");
        formatter.field("destination_region", &self.destination_region);
        formatter.field("retention_period", &self.retention_period);
        formatter.field(
            "manual_snapshot_retention_period",
            &self.manual_snapshot_retention_period,
        );
        formatter.field("snapshot_copy_grant_name", &self.snapshot_copy_grant_name);
        formatter.finish()
    }
}
/// See [`ClusterSnapshotCopyStatus`](crate::model::ClusterSnapshotCopyStatus)
pub mod cluster_snapshot_copy_status {
    /// A builder for [`ClusterSnapshotCopyStatus`](crate::model::ClusterSnapshotCopyStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_region: std::option::Option<std::string::String>,
        pub(crate) retention_period: std::option::Option<i64>,
        pub(crate) manual_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) snapshot_copy_grant_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination region that snapshots are automatically copied to when cross-region
        /// snapshot copy is enabled.</p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_region = Some(input.into());
            self
        }
        /// <p>The destination region that snapshots are automatically copied to when cross-region
        /// snapshot copy is enabled.</p>
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_region = input;
            self
        }
        /// <p>The number of days that automated snapshots are retained in the destination region
        /// after they are copied from a source region.</p>
        pub fn retention_period(mut self, input: i64) -> Self {
            self.retention_period = Some(input);
            self
        }
        /// <p>The number of days that automated snapshots are retained in the destination region
        /// after they are copied from a source region.</p>
        pub fn set_retention_period(mut self, input: std::option::Option<i64>) -> Self {
            self.retention_period = input;
            self
        }
        /// <p>The number of days that automated snapshots are retained in the destination region
        /// after they are copied from a source region. If the value is -1, the manual snapshot is
        /// retained indefinitely. </p>
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
            self.manual_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The number of days that automated snapshots are retained in the destination region
        /// after they are copied from a source region. If the value is -1, the manual snapshot is
        /// retained indefinitely. </p>
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn set_manual_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_retention_period = input;
            self
        }
        /// <p>The name of the snapshot copy grant.</p>
        pub fn snapshot_copy_grant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_copy_grant_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot copy grant.</p>
        pub fn set_snapshot_copy_grant_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_copy_grant_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSnapshotCopyStatus`](crate::model::ClusterSnapshotCopyStatus)
        pub fn build(self) -> crate::model::ClusterSnapshotCopyStatus {
            crate::model::ClusterSnapshotCopyStatus {
                destination_region: self.destination_region,
                retention_period: self.retention_period.unwrap_or_default(),
                manual_snapshot_retention_period: self
                    .manual_snapshot_retention_period
                    .unwrap_or_default(),
                snapshot_copy_grant_name: self.snapshot_copy_grant_name,
            }
        }
    }
}
impl ClusterSnapshotCopyStatus {
    /// Creates a new builder-style object to manufacture [`ClusterSnapshotCopyStatus`](crate::model::ClusterSnapshotCopyStatus)
    pub fn builder() -> crate::model::cluster_snapshot_copy_status::Builder {
        crate::model::cluster_snapshot_copy_status::Builder::default()
    }
}

/// <p>Describes the status of changes to HSM settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HsmStatus {
    /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
    /// retrieve the data encryption keys stored in an HSM.</p>
    pub hsm_client_certificate_identifier: std::option::Option<std::string::String>,
    /// <p>Specifies the name of the HSM configuration that contains the information the
    /// Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
    pub hsm_configuration_identifier: std::option::Option<std::string::String>,
    /// <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
    /// changes specified in a modify cluster command.</p>
    /// <p>Values: active, applying</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HsmStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HsmStatus");
        formatter.field(
            "hsm_client_certificate_identifier",
            &self.hsm_client_certificate_identifier,
        );
        formatter.field(
            "hsm_configuration_identifier",
            &self.hsm_configuration_identifier,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`HsmStatus`](crate::model::HsmStatus)
pub mod hsm_status {
    /// A builder for [`HsmStatus`](crate::model::HsmStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hsm_client_certificate_identifier: std::option::Option<std::string::String>,
        pub(crate) hsm_configuration_identifier: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
        /// retrieve the data encryption keys stored in an HSM.</p>
        pub fn hsm_client_certificate_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = Some(input.into());
            self
        }
        /// <p>Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to
        /// retrieve the data encryption keys stored in an HSM.</p>
        pub fn set_hsm_client_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = input;
            self
        }
        /// <p>Specifies the name of the HSM configuration that contains the information the
        /// Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
        pub fn hsm_configuration_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = Some(input.into());
            self
        }
        /// <p>Specifies the name of the HSM configuration that contains the information the
        /// Amazon Redshift cluster can use to retrieve and store keys in an HSM.</p>
        pub fn set_hsm_configuration_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = input;
            self
        }
        /// <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
        /// changes specified in a modify cluster command.</p>
        /// <p>Values: active, applying</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Reports whether the Amazon Redshift cluster has finished applying any HSM settings
        /// changes specified in a modify cluster command.</p>
        /// <p>Values: active, applying</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`HsmStatus`](crate::model::HsmStatus)
        pub fn build(self) -> crate::model::HsmStatus {
            crate::model::HsmStatus {
                hsm_client_certificate_identifier: self.hsm_client_certificate_identifier,
                hsm_configuration_identifier: self.hsm_configuration_identifier,
                status: self.status,
            }
        }
    }
}
impl HsmStatus {
    /// Creates a new builder-style object to manufacture [`HsmStatus`](crate::model::HsmStatus)
    pub fn builder() -> crate::model::hsm_status::Builder {
        crate::model::hsm_status::Builder::default()
    }
}

/// <p>Describes the status of a cluster while it is in the process of resizing with an
/// incremental resize.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataTransferProgress {
    /// <p>Describes the status of the cluster. While the transfer is in progress the status is
    /// <code>transferringdata</code>.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>Describes the data transfer rate in MB's per second.</p>
    pub current_rate_in_mega_bytes_per_second: std::option::Option<f64>,
    /// <p>Describes the total amount of data to be transfered in megabytes.</p>
    pub total_data_in_mega_bytes: i64,
    /// <p>Describes the total amount of data that has been transfered in MB's.</p>
    pub data_transferred_in_mega_bytes: i64,
    /// <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
    pub estimated_time_to_completion_in_seconds: std::option::Option<i64>,
    /// <p>Describes the number of seconds that have elapsed during the data transfer.</p>
    pub elapsed_time_in_seconds: std::option::Option<i64>,
}
impl std::fmt::Debug for DataTransferProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataTransferProgress");
        formatter.field("status", &self.status);
        formatter.field(
            "current_rate_in_mega_bytes_per_second",
            &self.current_rate_in_mega_bytes_per_second,
        );
        formatter.field("total_data_in_mega_bytes", &self.total_data_in_mega_bytes);
        formatter.field(
            "data_transferred_in_mega_bytes",
            &self.data_transferred_in_mega_bytes,
        );
        formatter.field(
            "estimated_time_to_completion_in_seconds",
            &self.estimated_time_to_completion_in_seconds,
        );
        formatter.field("elapsed_time_in_seconds", &self.elapsed_time_in_seconds);
        formatter.finish()
    }
}
/// See [`DataTransferProgress`](crate::model::DataTransferProgress)
pub mod data_transfer_progress {
    /// A builder for [`DataTransferProgress`](crate::model::DataTransferProgress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) current_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) total_data_in_mega_bytes: std::option::Option<i64>,
        pub(crate) data_transferred_in_mega_bytes: std::option::Option<i64>,
        pub(crate) estimated_time_to_completion_in_seconds: std::option::Option<i64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Describes the status of the cluster. While the transfer is in progress the status is
        /// <code>transferringdata</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Describes the status of the cluster. While the transfer is in progress the status is
        /// <code>transferringdata</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>Describes the data transfer rate in MB's per second.</p>
        pub fn current_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>Describes the data transfer rate in MB's per second.</p>
        pub fn set_current_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>Describes the total amount of data to be transfered in megabytes.</p>
        pub fn total_data_in_mega_bytes(mut self, input: i64) -> Self {
            self.total_data_in_mega_bytes = Some(input);
            self
        }
        /// <p>Describes the total amount of data to be transfered in megabytes.</p>
        pub fn set_total_data_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.total_data_in_mega_bytes = input;
            self
        }
        /// <p>Describes the total amount of data that has been transfered in MB's.</p>
        pub fn data_transferred_in_mega_bytes(mut self, input: i64) -> Self {
            self.data_transferred_in_mega_bytes = Some(input);
            self
        }
        /// <p>Describes the total amount of data that has been transfered in MB's.</p>
        pub fn set_data_transferred_in_mega_bytes(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.data_transferred_in_mega_bytes = input;
            self
        }
        /// <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
        pub fn estimated_time_to_completion_in_seconds(mut self, input: i64) -> Self {
            self.estimated_time_to_completion_in_seconds = Some(input);
            self
        }
        /// <p>Describes the estimated number of seconds remaining to complete the transfer.</p>
        pub fn set_estimated_time_to_completion_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_time_to_completion_in_seconds = input;
            self
        }
        /// <p>Describes the number of seconds that have elapsed during the data transfer.</p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>Describes the number of seconds that have elapsed during the data transfer.</p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`DataTransferProgress`](crate::model::DataTransferProgress)
        pub fn build(self) -> crate::model::DataTransferProgress {
            crate::model::DataTransferProgress {
                status: self.status,
                current_rate_in_mega_bytes_per_second: self.current_rate_in_mega_bytes_per_second,
                total_data_in_mega_bytes: self.total_data_in_mega_bytes.unwrap_or_default(),
                data_transferred_in_mega_bytes: self
                    .data_transferred_in_mega_bytes
                    .unwrap_or_default(),
                estimated_time_to_completion_in_seconds: self
                    .estimated_time_to_completion_in_seconds,
                elapsed_time_in_seconds: self.elapsed_time_in_seconds,
            }
        }
    }
}
impl DataTransferProgress {
    /// Creates a new builder-style object to manufacture [`DataTransferProgress`](crate::model::DataTransferProgress)
    pub fn builder() -> crate::model::data_transfer_progress::Builder {
        crate::model::data_transfer_progress::Builder::default()
    }
}

/// <p>Describes the status of a cluster restore action. Returns null if the cluster was
/// not created by restoring a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreStatus {
    /// <p>The status of the restore action. Returns starting, restoring, completed, or
    /// failed.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The number of megabytes per second being transferred from the backup storage.
    /// Returns the average rate for a completed backup.
    /// This field is only updated when you restore to DC2 and DS2 node types. </p>
    pub current_restore_rate_in_mega_bytes_per_second: f64,
    /// <p>The size of the set of snapshot data used to restore the cluster.
    /// This field is only updated when you restore to DC2 and DS2 node types. </p>
    pub snapshot_size_in_mega_bytes: i64,
    /// <p>The number of megabytes that have been transferred from snapshot storage.
    /// This field is only updated when you restore to DC2 and DS2 node types. </p>
    pub progress_in_mega_bytes: i64,
    /// <p>The amount of time an in-progress restore has been running, or the amount of time
    /// it took a completed restore to finish.
    /// This field is only updated when you restore to DC2 and DS2 node types. </p>
    pub elapsed_time_in_seconds: i64,
    /// <p>The estimate of the time remaining before the restore will complete. Returns 0 for
    /// a completed restore.
    /// This field is only updated when you restore to DC2 and DS2 node types. </p>
    pub estimated_time_to_completion_in_seconds: i64,
}
impl std::fmt::Debug for RestoreStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreStatus");
        formatter.field("status", &self.status);
        formatter.field(
            "current_restore_rate_in_mega_bytes_per_second",
            &self.current_restore_rate_in_mega_bytes_per_second,
        );
        formatter.field(
            "snapshot_size_in_mega_bytes",
            &self.snapshot_size_in_mega_bytes,
        );
        formatter.field("progress_in_mega_bytes", &self.progress_in_mega_bytes);
        formatter.field("elapsed_time_in_seconds", &self.elapsed_time_in_seconds);
        formatter.field(
            "estimated_time_to_completion_in_seconds",
            &self.estimated_time_to_completion_in_seconds,
        );
        formatter.finish()
    }
}
/// See [`RestoreStatus`](crate::model::RestoreStatus)
pub mod restore_status {
    /// A builder for [`RestoreStatus`](crate::model::RestoreStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) current_restore_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) snapshot_size_in_mega_bytes: std::option::Option<i64>,
        pub(crate) progress_in_mega_bytes: std::option::Option<i64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
        pub(crate) estimated_time_to_completion_in_seconds: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The status of the restore action. Returns starting, restoring, completed, or
        /// failed.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the restore action. Returns starting, restoring, completed, or
        /// failed.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The number of megabytes per second being transferred from the backup storage.
        /// Returns the average rate for a completed backup.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn current_restore_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_restore_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>The number of megabytes per second being transferred from the backup storage.
        /// Returns the average rate for a completed backup.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn set_current_restore_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_restore_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>The size of the set of snapshot data used to restore the cluster.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn snapshot_size_in_mega_bytes(mut self, input: i64) -> Self {
            self.snapshot_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the set of snapshot data used to restore the cluster.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn set_snapshot_size_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.snapshot_size_in_mega_bytes = input;
            self
        }
        /// <p>The number of megabytes that have been transferred from snapshot storage.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn progress_in_mega_bytes(mut self, input: i64) -> Self {
            self.progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The number of megabytes that have been transferred from snapshot storage.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn set_progress_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.progress_in_mega_bytes = input;
            self
        }
        /// <p>The amount of time an in-progress restore has been running, or the amount of time
        /// it took a completed restore to finish.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time an in-progress restore has been running, or the amount of time
        /// it took a completed restore to finish.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// <p>The estimate of the time remaining before the restore will complete. Returns 0 for
        /// a completed restore.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn estimated_time_to_completion_in_seconds(mut self, input: i64) -> Self {
            self.estimated_time_to_completion_in_seconds = Some(input);
            self
        }
        /// <p>The estimate of the time remaining before the restore will complete. Returns 0 for
        /// a completed restore.
        /// This field is only updated when you restore to DC2 and DS2 node types. </p>
        pub fn set_estimated_time_to_completion_in_seconds(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_time_to_completion_in_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`RestoreStatus`](crate::model::RestoreStatus)
        pub fn build(self) -> crate::model::RestoreStatus {
            crate::model::RestoreStatus {
                status: self.status,
                current_restore_rate_in_mega_bytes_per_second: self
                    .current_restore_rate_in_mega_bytes_per_second
                    .unwrap_or_default(),
                snapshot_size_in_mega_bytes: self.snapshot_size_in_mega_bytes.unwrap_or_default(),
                progress_in_mega_bytes: self.progress_in_mega_bytes.unwrap_or_default(),
                elapsed_time_in_seconds: self.elapsed_time_in_seconds.unwrap_or_default(),
                estimated_time_to_completion_in_seconds: self
                    .estimated_time_to_completion_in_seconds
                    .unwrap_or_default(),
            }
        }
    }
}
impl RestoreStatus {
    /// Creates a new builder-style object to manufacture [`RestoreStatus`](crate::model::RestoreStatus)
    pub fn builder() -> crate::model::restore_status::Builder {
        crate::model::restore_status::Builder::default()
    }
}

/// <p>Describes cluster attributes that are in a pending state. A change to one or more
/// the attributes was requested and is in progress or will be applied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PendingModifiedValues {
    /// <p>The pending or in-progress change of the admin user password for the
    /// cluster.</p>
    pub master_user_password: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change of the cluster's node type.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change of the number of nodes in the cluster.</p>
    pub number_of_nodes: std::option::Option<i32>,
    /// <p>The pending or in-progress change of the cluster type.</p>
    pub cluster_type: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change of the service version.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change of the automated snapshot retention
    /// period.</p>
    pub automated_snapshot_retention_period: std::option::Option<i32>,
    /// <p>The pending or in-progress change of the new identifier for the cluster.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The pending or in-progress change of the ability to connect to the cluster from the
    /// public network.</p>
    pub publicly_accessible: std::option::Option<bool>,
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    /// the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub enhanced_vpc_routing: std::option::Option<bool>,
    /// <p>The name of the maintenance track that the cluster will change to during the next
    /// maintenance window.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
    pub encryption_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PendingModifiedValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PendingModifiedValues");
        formatter.field("master_user_password", &self.master_user_password);
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("cluster_type", &self.cluster_type);
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field(
            "automated_snapshot_retention_period",
            &self.automated_snapshot_retention_period,
        );
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("publicly_accessible", &self.publicly_accessible);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field("encryption_type", &self.encryption_type);
        formatter.finish()
    }
}
/// See [`PendingModifiedValues`](crate::model::PendingModifiedValues)
pub mod pending_modified_values {
    /// A builder for [`PendingModifiedValues`](crate::model::PendingModifiedValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) master_user_password: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) cluster_type: std::option::Option<std::string::String>,
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) automated_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) publicly_accessible: std::option::Option<bool>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) encryption_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The pending or in-progress change of the admin user password for the
        /// cluster.</p>
        pub fn master_user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_user_password = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change of the admin user password for the
        /// cluster.</p>
        pub fn set_master_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_user_password = input;
            self
        }
        /// <p>The pending or in-progress change of the cluster's node type.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change of the cluster's node type.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The pending or in-progress change of the number of nodes in the cluster.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The pending or in-progress change of the number of nodes in the cluster.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>The pending or in-progress change of the cluster type.</p>
        pub fn cluster_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_type = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change of the cluster type.</p>
        pub fn set_cluster_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_type = input;
            self
        }
        /// <p>The pending or in-progress change of the service version.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change of the service version.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The pending or in-progress change of the automated snapshot retention
        /// period.</p>
        pub fn automated_snapshot_retention_period(mut self, input: i32) -> Self {
            self.automated_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The pending or in-progress change of the automated snapshot retention
        /// period.</p>
        pub fn set_automated_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automated_snapshot_retention_period = input;
            self
        }
        /// <p>The pending or in-progress change of the new identifier for the cluster.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The pending or in-progress change of the new identifier for the cluster.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The pending or in-progress change of the ability to connect to the cluster from the
        /// public network.</p>
        pub fn publicly_accessible(mut self, input: bool) -> Self {
            self.publicly_accessible = Some(input);
            self
        }
        /// <p>The pending or in-progress change of the ability to connect to the cluster from the
        /// public network.</p>
        pub fn set_publicly_accessible(mut self, input: std::option::Option<bool>) -> Self {
            self.publicly_accessible = input;
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// <p>The name of the maintenance track that the cluster will change to during the next
        /// maintenance window.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track that the cluster will change to during the next
        /// maintenance window.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
        pub fn encryption_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_type = Some(input.into());
            self
        }
        /// <p>The encryption type for a cluster. Possible values are: KMS and None. </p>
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingModifiedValues`](crate::model::PendingModifiedValues)
        pub fn build(self) -> crate::model::PendingModifiedValues {
            crate::model::PendingModifiedValues {
                master_user_password: self.master_user_password,
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes,
                cluster_type: self.cluster_type,
                cluster_version: self.cluster_version,
                automated_snapshot_retention_period: self.automated_snapshot_retention_period,
                cluster_identifier: self.cluster_identifier,
                publicly_accessible: self.publicly_accessible,
                enhanced_vpc_routing: self.enhanced_vpc_routing,
                maintenance_track_name: self.maintenance_track_name,
                encryption_type: self.encryption_type,
            }
        }
    }
}
impl PendingModifiedValues {
    /// Creates a new builder-style object to manufacture [`PendingModifiedValues`](crate::model::PendingModifiedValues)
    pub fn builder() -> crate::model::pending_modified_values::Builder {
        crate::model::pending_modified_values::Builder::default()
    }
}

/// <p>Describes the status of a parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterParameterGroupStatus {
    /// <p>The name of the cluster parameter group.</p>
    pub parameter_group_name: std::option::Option<std::string::String>,
    /// <p>The status of parameter updates.</p>
    pub parameter_apply_status: std::option::Option<std::string::String>,
    /// <p>The list of parameter statuses.</p>
    /// <p>
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    pub cluster_parameter_status_list:
        std::option::Option<std::vec::Vec<crate::model::ClusterParameterStatus>>,
}
impl std::fmt::Debug for ClusterParameterGroupStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterParameterGroupStatus");
        formatter.field("parameter_group_name", &self.parameter_group_name);
        formatter.field("parameter_apply_status", &self.parameter_apply_status);
        formatter.field(
            "cluster_parameter_status_list",
            &self.cluster_parameter_status_list,
        );
        formatter.finish()
    }
}
/// See [`ClusterParameterGroupStatus`](crate::model::ClusterParameterGroupStatus)
pub mod cluster_parameter_group_status {
    /// A builder for [`ClusterParameterGroupStatus`](crate::model::ClusterParameterGroupStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_group_name: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_status: std::option::Option<std::string::String>,
        pub(crate) cluster_parameter_status_list:
            std::option::Option<std::vec::Vec<crate::model::ClusterParameterStatus>>,
    }
    impl Builder {
        /// <p>The name of the cluster parameter group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster parameter group.</p>
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_group_name = input;
            self
        }
        /// <p>The status of parameter updates.</p>
        pub fn parameter_apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_apply_status = Some(input.into());
            self
        }
        /// <p>The status of parameter updates.</p>
        pub fn set_parameter_apply_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_status = input;
            self
        }
        /// Appends an item to `cluster_parameter_status_list`.
        ///
        /// To override the contents of this collection use [`set_cluster_parameter_status_list`](Self::set_cluster_parameter_status_list).
        ///
        /// <p>The list of parameter statuses.</p>
        /// <p>
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        pub fn cluster_parameter_status_list(
            mut self,
            input: impl Into<crate::model::ClusterParameterStatus>,
        ) -> Self {
            let mut v = self.cluster_parameter_status_list.unwrap_or_default();
            v.push(input.into());
            self.cluster_parameter_status_list = Some(v);
            self
        }
        /// <p>The list of parameter statuses.</p>
        /// <p>
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        pub fn set_cluster_parameter_status_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterParameterStatus>>,
        ) -> Self {
            self.cluster_parameter_status_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterGroupStatus`](crate::model::ClusterParameterGroupStatus)
        pub fn build(self) -> crate::model::ClusterParameterGroupStatus {
            crate::model::ClusterParameterGroupStatus {
                parameter_group_name: self.parameter_group_name,
                parameter_apply_status: self.parameter_apply_status,
                cluster_parameter_status_list: self.cluster_parameter_status_list,
            }
        }
    }
}
impl ClusterParameterGroupStatus {
    /// Creates a new builder-style object to manufacture [`ClusterParameterGroupStatus`](crate::model::ClusterParameterGroupStatus)
    pub fn builder() -> crate::model::cluster_parameter_group_status::Builder {
        crate::model::cluster_parameter_group_status::Builder::default()
    }
}

/// <p>Describes the status of a parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterParameterStatus {
    /// <p>The name of the parameter.</p>
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>The status of the parameter that indicates whether the parameter is in sync with
    /// the database, waiting for a cluster reboot, or encountered an error when being
    /// applied.</p>
    /// <p>The following are possible statuses and descriptions.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>in-sync</code>: The parameter value is in sync with the
    /// database.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>pending-reboot</code>: The parameter value will be applied after the
    /// cluster reboots.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>applying</code>: The parameter value is being applied to the
    /// database.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>invalid-parameter</code>: Cannot apply the parameter value because it has
    /// an invalid value or syntax.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>apply-deferred</code>: The parameter contains static property changes. The
    /// changes are deferred until the cluster reboots.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>apply-error</code>: Cannot connect to the cluster. The parameter change
    /// will be applied after the cluster reboots.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>unknown-error</code>: Cannot apply the parameter change right now. The
    /// change will be applied after the cluster reboots.</p>
    /// </li>
    /// </ul>
    pub parameter_apply_status: std::option::Option<std::string::String>,
    /// <p>The error that prevented the parameter from being applied to the
    /// database.</p>
    pub parameter_apply_error_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterParameterStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterParameterStatus");
        formatter.field("parameter_name", &self.parameter_name);
        formatter.field("parameter_apply_status", &self.parameter_apply_status);
        formatter.field(
            "parameter_apply_error_description",
            &self.parameter_apply_error_description,
        );
        formatter.finish()
    }
}
/// See [`ClusterParameterStatus`](crate::model::ClusterParameterStatus)
pub mod cluster_parameter_status {
    /// A builder for [`ClusterParameterStatus`](crate::model::ClusterParameterStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_status: std::option::Option<std::string::String>,
        pub(crate) parameter_apply_error_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>The status of the parameter that indicates whether the parameter is in sync with
        /// the database, waiting for a cluster reboot, or encountered an error when being
        /// applied.</p>
        /// <p>The following are possible statuses and descriptions.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>in-sync</code>: The parameter value is in sync with the
        /// database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pending-reboot</code>: The parameter value will be applied after the
        /// cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>applying</code>: The parameter value is being applied to the
        /// database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>invalid-parameter</code>: Cannot apply the parameter value because it has
        /// an invalid value or syntax.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>apply-deferred</code>: The parameter contains static property changes. The
        /// changes are deferred until the cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>apply-error</code>: Cannot connect to the cluster. The parameter change
        /// will be applied after the cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>unknown-error</code>: Cannot apply the parameter change right now. The
        /// change will be applied after the cluster reboots.</p>
        /// </li>
        /// </ul>
        pub fn parameter_apply_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_apply_status = Some(input.into());
            self
        }
        /// <p>The status of the parameter that indicates whether the parameter is in sync with
        /// the database, waiting for a cluster reboot, or encountered an error when being
        /// applied.</p>
        /// <p>The following are possible statuses and descriptions.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>in-sync</code>: The parameter value is in sync with the
        /// database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pending-reboot</code>: The parameter value will be applied after the
        /// cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>applying</code>: The parameter value is being applied to the
        /// database.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>invalid-parameter</code>: Cannot apply the parameter value because it has
        /// an invalid value or syntax.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>apply-deferred</code>: The parameter contains static property changes. The
        /// changes are deferred until the cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>apply-error</code>: Cannot connect to the cluster. The parameter change
        /// will be applied after the cluster reboots.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>unknown-error</code>: Cannot apply the parameter change right now. The
        /// change will be applied after the cluster reboots.</p>
        /// </li>
        /// </ul>
        pub fn set_parameter_apply_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_status = input;
            self
        }
        /// <p>The error that prevented the parameter from being applied to the
        /// database.</p>
        pub fn parameter_apply_error_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.parameter_apply_error_description = Some(input.into());
            self
        }
        /// <p>The error that prevented the parameter from being applied to the
        /// database.</p>
        pub fn set_parameter_apply_error_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_apply_error_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterStatus`](crate::model::ClusterParameterStatus)
        pub fn build(self) -> crate::model::ClusterParameterStatus {
            crate::model::ClusterParameterStatus {
                parameter_name: self.parameter_name,
                parameter_apply_status: self.parameter_apply_status,
                parameter_apply_error_description: self.parameter_apply_error_description,
            }
        }
    }
}
impl ClusterParameterStatus {
    /// Creates a new builder-style object to manufacture [`ClusterParameterStatus`](crate::model::ClusterParameterStatus)
    pub fn builder() -> crate::model::cluster_parameter_status::Builder {
        crate::model::cluster_parameter_status::Builder::default()
    }
}

/// <p>Describes the members of a VPC security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcSecurityGroupMembership {
    /// <p>The identifier of the VPC security group.</p>
    pub vpc_security_group_id: std::option::Option<std::string::String>,
    /// <p>The status of the VPC security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VpcSecurityGroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcSecurityGroupMembership");
        formatter.field("vpc_security_group_id", &self.vpc_security_group_id);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
pub mod vpc_security_group_membership {
    /// A builder for [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_security_group_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the VPC security group.</p>
        pub fn vpc_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_security_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the VPC security group.</p>
        pub fn set_vpc_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_security_group_id = input;
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the VPC security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
        pub fn build(self) -> crate::model::VpcSecurityGroupMembership {
            crate::model::VpcSecurityGroupMembership {
                vpc_security_group_id: self.vpc_security_group_id,
                status: self.status,
            }
        }
    }
}
impl VpcSecurityGroupMembership {
    /// Creates a new builder-style object to manufacture [`VpcSecurityGroupMembership`](crate::model::VpcSecurityGroupMembership)
    pub fn builder() -> crate::model::vpc_security_group_membership::Builder {
        crate::model::vpc_security_group_membership::Builder::default()
    }
}

/// <p>Describes a cluster security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterSecurityGroupMembership {
    /// <p>The name of the cluster security group.</p>
    pub cluster_security_group_name: std::option::Option<std::string::String>,
    /// <p>The status of the cluster security group.</p>
    pub status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterSecurityGroupMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterSecurityGroupMembership");
        formatter.field(
            "cluster_security_group_name",
            &self.cluster_security_group_name,
        );
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`ClusterSecurityGroupMembership`](crate::model::ClusterSecurityGroupMembership)
pub mod cluster_security_group_membership {
    /// A builder for [`ClusterSecurityGroupMembership`](crate::model::ClusterSecurityGroupMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_security_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the cluster security group.</p>
        pub fn cluster_security_group_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster security group.</p>
        pub fn set_cluster_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = input;
            self
        }
        /// <p>The status of the cluster security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the cluster security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSecurityGroupMembership`](crate::model::ClusterSecurityGroupMembership)
        pub fn build(self) -> crate::model::ClusterSecurityGroupMembership {
            crate::model::ClusterSecurityGroupMembership {
                cluster_security_group_name: self.cluster_security_group_name,
                status: self.status,
            }
        }
    }
}
impl ClusterSecurityGroupMembership {
    /// Creates a new builder-style object to manufacture [`ClusterSecurityGroupMembership`](crate::model::ClusterSecurityGroupMembership)
    pub fn builder() -> crate::model::cluster_security_group_membership::Builder {
        crate::model::cluster_security_group_membership::Builder::default()
    }
}

/// <p>Describes a connection endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Endpoint {
    /// <p>The DNS address of the Cluster.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The port that the database engine is listening on.</p>
    pub port: i32,
    /// <p>Describes a connection endpoint.</p>
    pub vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
}
impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Endpoint");
        formatter.field("address", &self.address);
        formatter.field("port", &self.port);
        formatter.field("vpc_endpoints", &self.vpc_endpoints);
        formatter.finish()
    }
}
/// See [`Endpoint`](crate::model::Endpoint)
pub mod endpoint {
    /// A builder for [`Endpoint`](crate::model::Endpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) vpc_endpoints: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
    }
    impl Builder {
        /// <p>The DNS address of the Cluster.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the Cluster.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The port that the database engine is listening on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that the database engine is listening on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// Appends an item to `vpc_endpoints`.
        ///
        /// To override the contents of this collection use [`set_vpc_endpoints`](Self::set_vpc_endpoints).
        ///
        /// <p>Describes a connection endpoint.</p>
        pub fn vpc_endpoints(mut self, input: impl Into<crate::model::VpcEndpoint>) -> Self {
            let mut v = self.vpc_endpoints.unwrap_or_default();
            v.push(input.into());
            self.vpc_endpoints = Some(v);
            self
        }
        /// <p>Describes a connection endpoint.</p>
        pub fn set_vpc_endpoints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcEndpoint>>,
        ) -> Self {
            self.vpc_endpoints = input;
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint)
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                address: self.address,
                port: self.port.unwrap_or_default(),
                vpc_endpoints: self.vpc_endpoints,
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint)
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VpcEndpoint {
    /// <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The VPC identifier that the endpoint is associated. </p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
}
impl std::fmt::Debug for VpcEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VpcEndpoint");
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("network_interfaces", &self.network_interfaces);
        formatter.finish()
    }
}
/// See [`VpcEndpoint`](crate::model::VpcEndpoint)
pub mod vpc_endpoint {
    /// A builder for [`VpcEndpoint`](crate::model::VpcEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    }
    impl Builder {
        /// <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        /// <p>The connection endpoint ID for connecting an Amazon Redshift cluster through the proxy.</p>
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The VPC identifier that the endpoint is associated. </p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC identifier that the endpoint is associated. </p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
        pub fn network_interfaces(
            mut self,
            input: impl Into<crate::model::NetworkInterface>,
        ) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces = Some(v);
            self
        }
        /// <p>One or more network interfaces of the endpoint. Also known as an interface endpoint. </p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Consumes the builder and constructs a [`VpcEndpoint`](crate::model::VpcEndpoint)
        pub fn build(self) -> crate::model::VpcEndpoint {
            crate::model::VpcEndpoint {
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_id: self.vpc_id,
                network_interfaces: self.network_interfaces,
            }
        }
    }
}
impl VpcEndpoint {
    /// Creates a new builder-style object to manufacture [`VpcEndpoint`](crate::model::VpcEndpoint)
    pub fn builder() -> crate::model::vpc_endpoint::Builder {
        crate::model::vpc_endpoint::Builder::default()
    }
}

/// <p>Describes a network interface. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkInterface {
    /// <p>The network interface identifier. </p>
    pub network_interface_id: std::option::Option<std::string::String>,
    /// <p>The subnet identifier. </p>
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The IPv4 address of the network interface within the subnet. </p>
    pub private_ip_address: std::option::Option<std::string::String>,
    /// <p>The Availability Zone. </p>
    pub availability_zone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkInterface");
        formatter.field("network_interface_id", &self.network_interface_id);
        formatter.field("subnet_id", &self.subnet_id);
        formatter.field("private_ip_address", &self.private_ip_address);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.finish()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface)
pub mod network_interface {
    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) private_ip_address: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The network interface identifier. </p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface_id = Some(input.into());
            self
        }
        /// <p>The network interface identifier. </p>
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface_id = input;
            self
        }
        /// <p>The subnet identifier. </p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The subnet identifier. </p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet. </p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_ip_address = Some(input.into());
            self
        }
        /// <p>The IPv4 address of the network interface within the subnet. </p>
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.private_ip_address = input;
            self
        }
        /// <p>The Availability Zone. </p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone. </p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface)
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                network_interface_id: self.network_interface_id,
                subnet_id: self.subnet_id,
                private_ip_address: self.private_ip_address,
                availability_zone: self.availability_zone,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface)
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>Describes a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Snapshot {
    /// <p>The snapshot identifier that is provided in the request.</p>
    pub snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>The identifier of the cluster for which the snapshot was taken.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
    /// copy of the cluster data as of this exact time.</p>
    pub snapshot_create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The snapshot status. The value of the status depends on the API operation used: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>DescribeClusterSnapshots</a> returns status as "creating",
    /// "available", "final snapshot", or "failed".</p>
    /// </li>
    /// <li>
    /// <p>
    /// <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
    /// <p>The port that the cluster is listening on.</p>
    pub port: i32,
    /// <p>The Availability Zone in which the cluster was created.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The time (UTC) when the cluster was originally created.</p>
    pub cluster_create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The admin user name for the cluster.</p>
    pub master_username: std::option::Option<std::string::String>,
    /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
    pub engine_full_version: std::option::Option<std::string::String>,
    /// <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
    /// and <a>CopyClusterSnapshot</a> are of type "manual". </p>
    pub snapshot_type: std::option::Option<std::string::String>,
    /// <p>The node type of the nodes in the cluster.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The number of nodes in the cluster.</p>
    pub number_of_nodes: i32,
    /// <p>The name of the database that was created when the cluster was created.</p>
    pub db_name: std::option::Option<std::string::String>,
    /// <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
    /// Otherwise, this field is not in the output.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
    pub encrypted: bool,
    /// <p>The Key Management Service (KMS) key ID of the encryption key that was used to
    /// encrypt data in the cluster from which the snapshot was taken.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
    /// of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
    /// keys.</p>
    pub encrypted_with_hsm: bool,
    /// <p>A list of the Amazon Web Services accounts authorized to restore the snapshot. Returns
    /// <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
    /// </p>
    pub accounts_with_restore_access:
        std::option::Option<std::vec::Vec<crate::model::AccountWithRestoreAccess>>,
    /// <p>For manual snapshots, the Amazon Web Services account used to create or copy the snapshot.
    /// For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
    /// actions, such as sharing a manual snapshot.</p>
    pub owner_account: std::option::Option<std::string::String>,
    /// <p>The size of the complete set of backup data that would be used to restore the
    /// cluster.</p>
    pub total_backup_size_in_mega_bytes: f64,
    /// <p>The size of the incremental backup.</p>
    pub actual_incremental_backup_size_in_mega_bytes: f64,
    /// <p>The number of megabytes that have been transferred to the snapshot
    /// backup.</p>
    pub backup_progress_in_mega_bytes: f64,
    /// <p>The number of megabytes per second being transferred to the snapshot backup.
    /// Returns <code>0</code> for a completed backup. </p>
    pub current_backup_rate_in_mega_bytes_per_second: f64,
    /// <p>The estimate of the time remaining before the snapshot backup will complete.
    /// Returns <code>0</code> for a completed backup. </p>
    pub estimated_seconds_to_completion: i64,
    /// <p>The amount of time an in-progress snapshot backup has been running, or the amount
    /// of time it took a completed backup to finish.</p>
    pub elapsed_time_in_seconds: i64,
    /// <p>The source region from which the snapshot was copied.</p>
    pub source_region: std::option::Option<std::string::String>,
    /// <p>The list of tags for the cluster snapshot.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The list of node types that this cluster snapshot is able to restore
    /// into.</p>
    pub restorable_node_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
    /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
    /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
    /// the Amazon Redshift Cluster Management Guide.</p>
    /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
    /// <p>Default: false</p>
    pub enhanced_vpc_routing: bool,
    /// <p>The name of the maintenance track for the snapshot.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
    /// snapshot is retained indefinitely. </p>
    ///
    /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
    pub manual_snapshot_retention_period: std::option::Option<i32>,
    /// <p>The number of days until a manual snapshot will pass its retention period.</p>
    pub manual_snapshot_remaining_days: std::option::Option<i32>,
    /// <p>A timestamp representing the start of the retention period for the snapshot.</p>
    pub snapshot_retention_start_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Snapshot");
        formatter.field("snapshot_identifier", &self.snapshot_identifier);
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("snapshot_create_time", &self.snapshot_create_time);
        formatter.field("status", &self.status);
        formatter.field("port", &self.port);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("cluster_create_time", &self.cluster_create_time);
        formatter.field("master_username", &self.master_username);
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field("engine_full_version", &self.engine_full_version);
        formatter.field("snapshot_type", &self.snapshot_type);
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("db_name", &self.db_name);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("encrypted_with_hsm", &self.encrypted_with_hsm);
        formatter.field(
            "accounts_with_restore_access",
            &self.accounts_with_restore_access,
        );
        formatter.field("owner_account", &self.owner_account);
        formatter.field(
            "total_backup_size_in_mega_bytes",
            &self.total_backup_size_in_mega_bytes,
        );
        formatter.field(
            "actual_incremental_backup_size_in_mega_bytes",
            &self.actual_incremental_backup_size_in_mega_bytes,
        );
        formatter.field(
            "backup_progress_in_mega_bytes",
            &self.backup_progress_in_mega_bytes,
        );
        formatter.field(
            "current_backup_rate_in_mega_bytes_per_second",
            &self.current_backup_rate_in_mega_bytes_per_second,
        );
        formatter.field(
            "estimated_seconds_to_completion",
            &self.estimated_seconds_to_completion,
        );
        formatter.field("elapsed_time_in_seconds", &self.elapsed_time_in_seconds);
        formatter.field("source_region", &self.source_region);
        formatter.field("tags", &self.tags);
        formatter.field("restorable_node_types", &self.restorable_node_types);
        formatter.field("enhanced_vpc_routing", &self.enhanced_vpc_routing);
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field(
            "manual_snapshot_retention_period",
            &self.manual_snapshot_retention_period,
        );
        formatter.field(
            "manual_snapshot_remaining_days",
            &self.manual_snapshot_remaining_days,
        );
        formatter.field(
            "snapshot_retention_start_time",
            &self.snapshot_retention_start_time,
        );
        formatter.finish()
    }
}
/// See [`Snapshot`](crate::model::Snapshot)
pub mod snapshot {
    /// A builder for [`Snapshot`](crate::model::Snapshot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) cluster_create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) master_username: std::option::Option<std::string::String>,
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) engine_full_version: std::option::Option<std::string::String>,
        pub(crate) snapshot_type: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) db_name: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) encrypted_with_hsm: std::option::Option<bool>,
        pub(crate) accounts_with_restore_access:
            std::option::Option<std::vec::Vec<crate::model::AccountWithRestoreAccess>>,
        pub(crate) owner_account: std::option::Option<std::string::String>,
        pub(crate) total_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) actual_incremental_backup_size_in_mega_bytes: std::option::Option<f64>,
        pub(crate) backup_progress_in_mega_bytes: std::option::Option<f64>,
        pub(crate) current_backup_rate_in_mega_bytes_per_second: std::option::Option<f64>,
        pub(crate) estimated_seconds_to_completion: std::option::Option<i64>,
        pub(crate) elapsed_time_in_seconds: std::option::Option<i64>,
        pub(crate) source_region: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) restorable_node_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) enhanced_vpc_routing: std::option::Option<bool>,
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) manual_snapshot_retention_period: std::option::Option<i32>,
        pub(crate) manual_snapshot_remaining_days: std::option::Option<i32>,
        pub(crate) snapshot_retention_start_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The snapshot identifier that is provided in the request.</p>
        pub fn snapshot_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The snapshot identifier that is provided in the request.</p>
        pub fn set_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_identifier = input;
            self
        }
        /// <p>The identifier of the cluster for which the snapshot was taken.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the cluster for which the snapshot was taken.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
        /// copy of the cluster data as of this exact time.</p>
        pub fn snapshot_create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.snapshot_create_time = Some(input);
            self
        }
        /// <p>The time (in UTC format) when Amazon Redshift began the snapshot. A snapshot contains a
        /// copy of the cluster data as of this exact time.</p>
        pub fn set_snapshot_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.snapshot_create_time = input;
            self
        }
        /// <p>The snapshot status. The value of the status depends on the API operation used: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>DescribeClusterSnapshots</a> returns status as "creating",
        /// "available", "final snapshot", or "failed".</p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The snapshot status. The value of the status depends on the API operation used: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <a>CreateClusterSnapshot</a> and <a>CopyClusterSnapshot</a> returns status as "creating". </p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>DescribeClusterSnapshots</a> returns status as "creating",
        /// "available", "final snapshot", or "failed".</p>
        /// </li>
        /// <li>
        /// <p>
        /// <a>DeleteClusterSnapshot</a> returns status as "deleted".</p>
        /// </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The port that the cluster is listening on.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port that the cluster is listening on.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The Availability Zone in which the cluster was created.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        /// <p>The Availability Zone in which the cluster was created.</p>
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The time (UTC) when the cluster was originally created.</p>
        pub fn cluster_create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.cluster_create_time = Some(input);
            self
        }
        /// <p>The time (UTC) when the cluster was originally created.</p>
        pub fn set_cluster_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.cluster_create_time = input;
            self
        }
        /// <p>The admin user name for the cluster.</p>
        pub fn master_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.master_username = Some(input.into());
            self
        }
        /// <p>The admin user name for the cluster.</p>
        pub fn set_master_username(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.master_username = input;
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The version ID of the Amazon Redshift engine that is running on the cluster.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
        pub fn engine_full_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.engine_full_version = Some(input.into());
            self
        }
        /// <p>The cluster version of the cluster used to create the snapshot. For example, 1.0.15503. </p>
        pub fn set_engine_full_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.engine_full_version = input;
            self
        }
        /// <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
        /// and <a>CopyClusterSnapshot</a> are of type "manual". </p>
        pub fn snapshot_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_type = Some(input.into());
            self
        }
        /// <p>The snapshot type. Snapshots created using <a>CreateClusterSnapshot</a>
        /// and <a>CopyClusterSnapshot</a> are of type "manual". </p>
        pub fn set_snapshot_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_type = input;
            self
        }
        /// <p>The node type of the nodes in the cluster.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type of the nodes in the cluster.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The number of nodes in the cluster.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The number of nodes in the cluster.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>The name of the database that was created when the cluster was created.</p>
        pub fn db_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.db_name = Some(input.into());
            self
        }
        /// <p>The name of the database that was created when the cluster was created.</p>
        pub fn set_db_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.db_name = input;
            self
        }
        /// <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
        /// Otherwise, this field is not in the output.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC identifier of the cluster if the snapshot is from a cluster in a VPC.
        /// Otherwise, this field is not in the output.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        /// <p>If <code>true</code>, the data in the snapshot is encrypted at rest.</p>
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The Key Management Service (KMS) key ID of the encryption key that was used to
        /// encrypt data in the cluster from which the snapshot was taken.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Key Management Service (KMS) key ID of the encryption key that was used to
        /// encrypt data in the cluster from which the snapshot was taken.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
        /// of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
        /// keys.</p>
        pub fn encrypted_with_hsm(mut self, input: bool) -> Self {
            self.encrypted_with_hsm = Some(input);
            self
        }
        /// <p>A boolean that indicates whether the snapshot data is encrypted using the HSM keys
        /// of the source cluster. <code>true</code> indicates that the data is encrypted using HSM
        /// keys.</p>
        pub fn set_encrypted_with_hsm(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted_with_hsm = input;
            self
        }
        /// Appends an item to `accounts_with_restore_access`.
        ///
        /// To override the contents of this collection use [`set_accounts_with_restore_access`](Self::set_accounts_with_restore_access).
        ///
        /// <p>A list of the Amazon Web Services accounts authorized to restore the snapshot. Returns
        /// <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
        /// </p>
        pub fn accounts_with_restore_access(
            mut self,
            input: impl Into<crate::model::AccountWithRestoreAccess>,
        ) -> Self {
            let mut v = self.accounts_with_restore_access.unwrap_or_default();
            v.push(input.into());
            self.accounts_with_restore_access = Some(v);
            self
        }
        /// <p>A list of the Amazon Web Services accounts authorized to restore the snapshot. Returns
        /// <code>null</code> if no accounts are authorized. Visible only to the snapshot owner.
        /// </p>
        pub fn set_accounts_with_restore_access(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccountWithRestoreAccess>>,
        ) -> Self {
            self.accounts_with_restore_access = input;
            self
        }
        /// <p>For manual snapshots, the Amazon Web Services account used to create or copy the snapshot.
        /// For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
        /// actions, such as sharing a manual snapshot.</p>
        pub fn owner_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account = Some(input.into());
            self
        }
        /// <p>For manual snapshots, the Amazon Web Services account used to create or copy the snapshot.
        /// For automatic snapshots, the owner of the cluster. The owner can perform all snapshot
        /// actions, such as sharing a manual snapshot.</p>
        pub fn set_owner_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account = input;
            self
        }
        /// <p>The size of the complete set of backup data that would be used to restore the
        /// cluster.</p>
        pub fn total_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.total_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the complete set of backup data that would be used to restore the
        /// cluster.</p>
        pub fn set_total_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.total_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The size of the incremental backup.</p>
        pub fn actual_incremental_backup_size_in_mega_bytes(mut self, input: f64) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = Some(input);
            self
        }
        /// <p>The size of the incremental backup.</p>
        pub fn set_actual_incremental_backup_size_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.actual_incremental_backup_size_in_mega_bytes = input;
            self
        }
        /// <p>The number of megabytes that have been transferred to the snapshot
        /// backup.</p>
        pub fn backup_progress_in_mega_bytes(mut self, input: f64) -> Self {
            self.backup_progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The number of megabytes that have been transferred to the snapshot
        /// backup.</p>
        pub fn set_backup_progress_in_mega_bytes(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.backup_progress_in_mega_bytes = input;
            self
        }
        /// <p>The number of megabytes per second being transferred to the snapshot backup.
        /// Returns <code>0</code> for a completed backup. </p>
        pub fn current_backup_rate_in_mega_bytes_per_second(mut self, input: f64) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = Some(input);
            self
        }
        /// <p>The number of megabytes per second being transferred to the snapshot backup.
        /// Returns <code>0</code> for a completed backup. </p>
        pub fn set_current_backup_rate_in_mega_bytes_per_second(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.current_backup_rate_in_mega_bytes_per_second = input;
            self
        }
        /// <p>The estimate of the time remaining before the snapshot backup will complete.
        /// Returns <code>0</code> for a completed backup. </p>
        pub fn estimated_seconds_to_completion(mut self, input: i64) -> Self {
            self.estimated_seconds_to_completion = Some(input);
            self
        }
        /// <p>The estimate of the time remaining before the snapshot backup will complete.
        /// Returns <code>0</code> for a completed backup. </p>
        pub fn set_estimated_seconds_to_completion(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.estimated_seconds_to_completion = input;
            self
        }
        /// <p>The amount of time an in-progress snapshot backup has been running, or the amount
        /// of time it took a completed backup to finish.</p>
        pub fn elapsed_time_in_seconds(mut self, input: i64) -> Self {
            self.elapsed_time_in_seconds = Some(input);
            self
        }
        /// <p>The amount of time an in-progress snapshot backup has been running, or the amount
        /// of time it took a completed backup to finish.</p>
        pub fn set_elapsed_time_in_seconds(mut self, input: std::option::Option<i64>) -> Self {
            self.elapsed_time_in_seconds = input;
            self
        }
        /// <p>The source region from which the snapshot was copied.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_region = Some(input.into());
            self
        }
        /// <p>The source region from which the snapshot was copied.</p>
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_region = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the cluster snapshot.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the cluster snapshot.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `restorable_node_types`.
        ///
        /// To override the contents of this collection use [`set_restorable_node_types`](Self::set_restorable_node_types).
        ///
        /// <p>The list of node types that this cluster snapshot is able to restore
        /// into.</p>
        pub fn restorable_node_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.restorable_node_types.unwrap_or_default();
            v.push(input.into());
            self.restorable_node_types = Some(v);
            self
        }
        /// <p>The list of node types that this cluster snapshot is able to restore
        /// into.</p>
        pub fn set_restorable_node_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.restorable_node_types = input;
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn enhanced_vpc_routing(mut self, input: bool) -> Self {
            self.enhanced_vpc_routing = Some(input);
            self
        }
        /// <p>An option that specifies whether to create the cluster with enhanced VPC routing
        /// enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a
        /// VPC. For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in
        /// the Amazon Redshift Cluster Management Guide.</p>
        /// <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p>
        /// <p>Default: false</p>
        pub fn set_enhanced_vpc_routing(mut self, input: std::option::Option<bool>) -> Self {
            self.enhanced_vpc_routing = input;
            self
        }
        /// <p>The name of the maintenance track for the snapshot.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track for the snapshot.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
        /// snapshot is retained indefinitely. </p>
        ///
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn manual_snapshot_retention_period(mut self, input: i32) -> Self {
            self.manual_snapshot_retention_period = Some(input);
            self
        }
        /// <p>The number of days that a manual snapshot is retained. If the value is -1, the manual
        /// snapshot is retained indefinitely. </p>
        ///
        /// <p>The value must be either -1 or an integer between 1 and 3,653.</p>
        pub fn set_manual_snapshot_retention_period(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_retention_period = input;
            self
        }
        /// <p>The number of days until a manual snapshot will pass its retention period.</p>
        pub fn manual_snapshot_remaining_days(mut self, input: i32) -> Self {
            self.manual_snapshot_remaining_days = Some(input);
            self
        }
        /// <p>The number of days until a manual snapshot will pass its retention period.</p>
        pub fn set_manual_snapshot_remaining_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.manual_snapshot_remaining_days = input;
            self
        }
        /// <p>A timestamp representing the start of the retention period for the snapshot.</p>
        pub fn snapshot_retention_start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.snapshot_retention_start_time = Some(input);
            self
        }
        /// <p>A timestamp representing the start of the retention period for the snapshot.</p>
        pub fn set_snapshot_retention_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.snapshot_retention_start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Snapshot`](crate::model::Snapshot)
        pub fn build(self) -> crate::model::Snapshot {
            crate::model::Snapshot {
                snapshot_identifier: self.snapshot_identifier,
                cluster_identifier: self.cluster_identifier,
                snapshot_create_time: self.snapshot_create_time,
                status: self.status,
                port: self.port.unwrap_or_default(),
                availability_zone: self.availability_zone,
                cluster_create_time: self.cluster_create_time,
                master_username: self.master_username,
                cluster_version: self.cluster_version,
                engine_full_version: self.engine_full_version,
                snapshot_type: self.snapshot_type,
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                db_name: self.db_name,
                vpc_id: self.vpc_id,
                encrypted: self.encrypted.unwrap_or_default(),
                kms_key_id: self.kms_key_id,
                encrypted_with_hsm: self.encrypted_with_hsm.unwrap_or_default(),
                accounts_with_restore_access: self.accounts_with_restore_access,
                owner_account: self.owner_account,
                total_backup_size_in_mega_bytes: self
                    .total_backup_size_in_mega_bytes
                    .unwrap_or_default(),
                actual_incremental_backup_size_in_mega_bytes: self
                    .actual_incremental_backup_size_in_mega_bytes
                    .unwrap_or_default(),
                backup_progress_in_mega_bytes: self
                    .backup_progress_in_mega_bytes
                    .unwrap_or_default(),
                current_backup_rate_in_mega_bytes_per_second: self
                    .current_backup_rate_in_mega_bytes_per_second
                    .unwrap_or_default(),
                estimated_seconds_to_completion: self
                    .estimated_seconds_to_completion
                    .unwrap_or_default(),
                elapsed_time_in_seconds: self.elapsed_time_in_seconds.unwrap_or_default(),
                source_region: self.source_region,
                tags: self.tags,
                restorable_node_types: self.restorable_node_types,
                enhanced_vpc_routing: self.enhanced_vpc_routing.unwrap_or_default(),
                maintenance_track_name: self.maintenance_track_name,
                manual_snapshot_retention_period: self.manual_snapshot_retention_period,
                manual_snapshot_remaining_days: self.manual_snapshot_remaining_days,
                snapshot_retention_start_time: self.snapshot_retention_start_time,
            }
        }
    }
}
impl Snapshot {
    /// Creates a new builder-style object to manufacture [`Snapshot`](crate::model::Snapshot)
    pub fn builder() -> crate::model::snapshot::Builder {
        crate::model::snapshot::Builder::default()
    }
}

/// <p>Describes an Amazon Web Services account authorized to restore a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountWithRestoreAccess {
    /// <p>The identifier of an Amazon Web Services account authorized to restore a
    /// snapshot.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The identifier of an Amazon Web Services support account authorized to restore a
    /// snapshot. For Amazon Web Services Support, the identifier is <code>amazon-redshift-support</code>. </p>
    pub account_alias: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountWithRestoreAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountWithRestoreAccess");
        formatter.field("account_id", &self.account_id);
        formatter.field("account_alias", &self.account_alias);
        formatter.finish()
    }
}
/// See [`AccountWithRestoreAccess`](crate::model::AccountWithRestoreAccess)
pub mod account_with_restore_access {
    /// A builder for [`AccountWithRestoreAccess`](crate::model::AccountWithRestoreAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) account_alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of an Amazon Web Services account authorized to restore a
        /// snapshot.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The identifier of an Amazon Web Services account authorized to restore a
        /// snapshot.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The identifier of an Amazon Web Services support account authorized to restore a
        /// snapshot. For Amazon Web Services Support, the identifier is <code>amazon-redshift-support</code>. </p>
        pub fn account_alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_alias = Some(input.into());
            self
        }
        /// <p>The identifier of an Amazon Web Services support account authorized to restore a
        /// snapshot. For Amazon Web Services Support, the identifier is <code>amazon-redshift-support</code>. </p>
        pub fn set_account_alias(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.account_alias = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountWithRestoreAccess`](crate::model::AccountWithRestoreAccess)
        pub fn build(self) -> crate::model::AccountWithRestoreAccess {
            crate::model::AccountWithRestoreAccess {
                account_id: self.account_id,
                account_alias: self.account_alias,
            }
        }
    }
}
impl AccountWithRestoreAccess {
    /// Creates a new builder-style object to manufacture [`AccountWithRestoreAccess`](crate::model::AccountWithRestoreAccess)
    pub fn builder() -> crate::model::account_with_restore_access::Builder {
        crate::model::account_with_restore_access::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AuthorizationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Authorized,
    #[allow(missing_docs)] // documentation missing in model
    Revoking,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AuthorizationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Authorized" => AuthorizationStatus::Authorized,
            "Revoking" => AuthorizationStatus::Revoking,
            other => AuthorizationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AuthorizationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AuthorizationStatus::from(s))
    }
}
impl AuthorizationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AuthorizationStatus::Authorized => "Authorized",
            AuthorizationStatus::Revoking => "Revoking",
            AuthorizationStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Authorized", "Revoking"]
    }
}
impl AsRef<str> for AuthorizationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterSecurityGroup {
    /// <p>The name of the cluster security group to which the operation was
    /// applied.</p>
    pub cluster_security_group_name: std::option::Option<std::string::String>,
    /// <p>A description of the security group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A list of EC2 security groups that are permitted to access clusters associated with
    /// this cluster security group.</p>
    pub ec2_security_groups: std::option::Option<std::vec::Vec<crate::model::Ec2SecurityGroup>>,
    /// <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
    /// with this cluster security group.</p>
    pub ip_ranges: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
    /// <p>The list of tags for the cluster security group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ClusterSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterSecurityGroup");
        formatter.field(
            "cluster_security_group_name",
            &self.cluster_security_group_name,
        );
        formatter.field("description", &self.description);
        formatter.field("ec2_security_groups", &self.ec2_security_groups);
        formatter.field("ip_ranges", &self.ip_ranges);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ClusterSecurityGroup`](crate::model::ClusterSecurityGroup)
pub mod cluster_security_group {
    /// A builder for [`ClusterSecurityGroup`](crate::model::ClusterSecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_security_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_security_groups:
            std::option::Option<std::vec::Vec<crate::model::Ec2SecurityGroup>>,
        pub(crate) ip_ranges: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the cluster security group to which the operation was
        /// applied.</p>
        pub fn cluster_security_group_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster security group to which the operation was
        /// applied.</p>
        pub fn set_cluster_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_security_group_name = input;
            self
        }
        /// <p>A description of the security group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the security group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ec2_security_groups`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_groups`](Self::set_ec2_security_groups).
        ///
        /// <p>A list of EC2 security groups that are permitted to access clusters associated with
        /// this cluster security group.</p>
        pub fn ec2_security_groups(
            mut self,
            input: impl Into<crate::model::Ec2SecurityGroup>,
        ) -> Self {
            let mut v = self.ec2_security_groups.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_groups = Some(v);
            self
        }
        /// <p>A list of EC2 security groups that are permitted to access clusters associated with
        /// this cluster security group.</p>
        pub fn set_ec2_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ec2SecurityGroup>>,
        ) -> Self {
            self.ec2_security_groups = input;
            self
        }
        /// Appends an item to `ip_ranges`.
        ///
        /// To override the contents of this collection use [`set_ip_ranges`](Self::set_ip_ranges).
        ///
        /// <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
        /// with this cluster security group.</p>
        pub fn ip_ranges(mut self, input: impl Into<crate::model::IpRange>) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input.into());
            self.ip_ranges = Some(v);
            self
        }
        /// <p>A list of IP ranges (CIDR blocks) that are permitted to access clusters associated
        /// with this cluster security group.</p>
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpRange>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the cluster security group.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the cluster security group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSecurityGroup`](crate::model::ClusterSecurityGroup)
        pub fn build(self) -> crate::model::ClusterSecurityGroup {
            crate::model::ClusterSecurityGroup {
                cluster_security_group_name: self.cluster_security_group_name,
                description: self.description,
                ec2_security_groups: self.ec2_security_groups,
                ip_ranges: self.ip_ranges,
                tags: self.tags,
            }
        }
    }
}
impl ClusterSecurityGroup {
    /// Creates a new builder-style object to manufacture [`ClusterSecurityGroup`](crate::model::ClusterSecurityGroup)
    pub fn builder() -> crate::model::cluster_security_group::Builder {
        crate::model::cluster_security_group::Builder::default()
    }
}

/// <p>Describes an IP range used in a security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IpRange {
    /// <p>The status of the IP range, for example, "authorized".</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
    pub cidrip: std::option::Option<std::string::String>,
    /// <p>The list of tags for the IP range.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for IpRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IpRange");
        formatter.field("status", &self.status);
        formatter.field("cidrip", &self.cidrip);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`IpRange`](crate::model::IpRange)
pub mod ip_range {
    /// A builder for [`IpRange`](crate::model::IpRange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) cidrip: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The status of the IP range, for example, "authorized".</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the IP range, for example, "authorized".</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
        pub fn cidrip(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidrip = Some(input.into());
            self
        }
        /// <p>The IP range in Classless Inter-Domain Routing (CIDR) notation.</p>
        pub fn set_cidrip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidrip = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the IP range.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the IP range.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`IpRange`](crate::model::IpRange)
        pub fn build(self) -> crate::model::IpRange {
            crate::model::IpRange {
                status: self.status,
                cidrip: self.cidrip,
                tags: self.tags,
            }
        }
    }
}
impl IpRange {
    /// Creates a new builder-style object to manufacture [`IpRange`](crate::model::IpRange)
    pub fn builder() -> crate::model::ip_range::Builder {
        crate::model::ip_range::Builder::default()
    }
}

/// <p>Describes an Amazon EC2 security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2SecurityGroup {
    /// <p>The status of the EC2 security group.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The name of the EC2 Security Group.</p>
    pub ec2_security_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the EC2 security group specified in the
    /// <code>EC2SecurityGroupName</code> field. </p>
    pub ec2_security_group_owner_id: std::option::Option<std::string::String>,
    /// <p>The list of tags for the EC2 security group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for Ec2SecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2SecurityGroup");
        formatter.field("status", &self.status);
        formatter.field("ec2_security_group_name", &self.ec2_security_group_name);
        formatter.field(
            "ec2_security_group_owner_id",
            &self.ec2_security_group_owner_id,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Ec2SecurityGroup`](crate::model::Ec2SecurityGroup)
pub mod ec2_security_group {
    /// A builder for [`Ec2SecurityGroup`](crate::model::Ec2SecurityGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_name: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_owner_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The status of the EC2 security group.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the EC2 security group.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The name of the EC2 Security Group.</p>
        pub fn ec2_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_security_group_name = Some(input.into());
            self
        }
        /// <p>The name of the EC2 Security Group.</p>
        pub fn set_ec2_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_security_group_name = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the EC2 security group specified in the
        /// <code>EC2SecurityGroupName</code> field. </p>
        pub fn ec2_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.ec2_security_group_owner_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the EC2 security group specified in the
        /// <code>EC2SecurityGroupName</code> field. </p>
        pub fn set_ec2_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_security_group_owner_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the EC2 security group.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the EC2 security group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2SecurityGroup`](crate::model::Ec2SecurityGroup)
        pub fn build(self) -> crate::model::Ec2SecurityGroup {
            crate::model::Ec2SecurityGroup {
                status: self.status,
                ec2_security_group_name: self.ec2_security_group_name,
                ec2_security_group_owner_id: self.ec2_security_group_owner_id,
                tags: self.tags,
            }
        }
    }
}
impl Ec2SecurityGroup {
    /// Creates a new builder-style object to manufacture [`Ec2SecurityGroup`](crate::model::Ec2SecurityGroup)
    pub fn builder() -> crate::model::ec2_security_group::Builder {
        crate::model::ec2_security_group::Builder::default()
    }
}

/// <p>Describes the status of a <a>RestoreTableFromClusterSnapshot</a>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TableRestoreStatus {
    /// <p>The unique identifier for the table restore request.</p>
    pub table_restore_request_id: std::option::Option<std::string::String>,
    /// <p>A value that describes the current state of the table restore request.</p>
    /// <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
    /// <code>PENDING</code>, <code>IN_PROGRESS</code>
    /// </p>
    pub status: std::option::Option<crate::model::TableRestoreStatusType>,
    /// <p>A description of the status of the table restore request. Status values include
    /// <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
    /// <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The time that the table restore request was made, in Universal Coordinated Time
    /// (UTC).</p>
    pub request_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
    pub progress_in_mega_bytes: std::option::Option<i64>,
    /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
    pub total_data_in_mega_bytes: std::option::Option<i64>,
    /// <p>The identifier of the Amazon Redshift cluster that the table is being restored
    /// to.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The identifier of the snapshot that the table is being restored from.</p>
    pub snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>The name of the source database that contains the table being restored.</p>
    pub source_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the source schema that contains the table being restored.</p>
    pub source_schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the source table being restored.</p>
    pub source_table_name: std::option::Option<std::string::String>,
    /// <p>The name of the database to restore the table to.</p>
    pub target_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the schema to restore the table to.</p>
    pub target_schema_name: std::option::Option<std::string::String>,
    /// <p>The name of the table to create as a result of the table restore request.</p>
    pub new_table_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TableRestoreStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableRestoreStatus");
        formatter.field("table_restore_request_id", &self.table_restore_request_id);
        formatter.field("status", &self.status);
        formatter.field("message", &self.message);
        formatter.field("request_time", &self.request_time);
        formatter.field("progress_in_mega_bytes", &self.progress_in_mega_bytes);
        formatter.field("total_data_in_mega_bytes", &self.total_data_in_mega_bytes);
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("snapshot_identifier", &self.snapshot_identifier);
        formatter.field("source_database_name", &self.source_database_name);
        formatter.field("source_schema_name", &self.source_schema_name);
        formatter.field("source_table_name", &self.source_table_name);
        formatter.field("target_database_name", &self.target_database_name);
        formatter.field("target_schema_name", &self.target_schema_name);
        formatter.field("new_table_name", &self.new_table_name);
        formatter.finish()
    }
}
/// See [`TableRestoreStatus`](crate::model::TableRestoreStatus)
pub mod table_restore_status {
    /// A builder for [`TableRestoreStatus`](crate::model::TableRestoreStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_restore_request_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TableRestoreStatusType>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) progress_in_mega_bytes: std::option::Option<i64>,
        pub(crate) total_data_in_mega_bytes: std::option::Option<i64>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) source_database_name: std::option::Option<std::string::String>,
        pub(crate) source_schema_name: std::option::Option<std::string::String>,
        pub(crate) source_table_name: std::option::Option<std::string::String>,
        pub(crate) target_database_name: std::option::Option<std::string::String>,
        pub(crate) target_schema_name: std::option::Option<std::string::String>,
        pub(crate) new_table_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the table restore request.</p>
        pub fn table_restore_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.table_restore_request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the table restore request.</p>
        pub fn set_table_restore_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.table_restore_request_id = input;
            self
        }
        /// <p>A value that describes the current state of the table restore request.</p>
        /// <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        /// <code>PENDING</code>, <code>IN_PROGRESS</code>
        /// </p>
        pub fn status(mut self, input: crate::model::TableRestoreStatusType) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>A value that describes the current state of the table restore request.</p>
        /// <p>Valid Values: <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        /// <code>PENDING</code>, <code>IN_PROGRESS</code>
        /// </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TableRestoreStatusType>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>A description of the status of the table restore request. Status values include
        /// <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        /// <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the status of the table restore request. Status values include
        /// <code>SUCCEEDED</code>, <code>FAILED</code>, <code>CANCELED</code>,
        /// <code>PENDING</code>, <code>IN_PROGRESS</code>.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time that the table restore request was made, in Universal Coordinated Time
        /// (UTC).</p>
        pub fn request_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.request_time = Some(input);
            self
        }
        /// <p>The time that the table restore request was made, in Universal Coordinated Time
        /// (UTC).</p>
        pub fn set_request_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.request_time = input;
            self
        }
        /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
        pub fn progress_in_mega_bytes(mut self, input: i64) -> Self {
            self.progress_in_mega_bytes = Some(input);
            self
        }
        /// <p>The amount of data restored to the new table so far, in megabytes (MB).</p>
        pub fn set_progress_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.progress_in_mega_bytes = input;
            self
        }
        /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
        pub fn total_data_in_mega_bytes(mut self, input: i64) -> Self {
            self.total_data_in_mega_bytes = Some(input);
            self
        }
        /// <p>The total amount of data to restore to the new table, in megabytes (MB).</p>
        pub fn set_total_data_in_mega_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.total_data_in_mega_bytes = input;
            self
        }
        /// <p>The identifier of the Amazon Redshift cluster that the table is being restored
        /// to.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Redshift cluster that the table is being restored
        /// to.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The identifier of the snapshot that the table is being restored from.</p>
        pub fn snapshot_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the snapshot that the table is being restored from.</p>
        pub fn set_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_identifier = input;
            self
        }
        /// <p>The name of the source database that contains the table being restored.</p>
        pub fn source_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_database_name = Some(input.into());
            self
        }
        /// <p>The name of the source database that contains the table being restored.</p>
        pub fn set_source_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_database_name = input;
            self
        }
        /// <p>The name of the source schema that contains the table being restored.</p>
        pub fn source_schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_schema_name = Some(input.into());
            self
        }
        /// <p>The name of the source schema that contains the table being restored.</p>
        pub fn set_source_schema_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_schema_name = input;
            self
        }
        /// <p>The name of the source table being restored.</p>
        pub fn source_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_table_name = Some(input.into());
            self
        }
        /// <p>The name of the source table being restored.</p>
        pub fn set_source_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_table_name = input;
            self
        }
        /// <p>The name of the database to restore the table to.</p>
        pub fn target_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_database_name = Some(input.into());
            self
        }
        /// <p>The name of the database to restore the table to.</p>
        pub fn set_target_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_database_name = input;
            self
        }
        /// <p>The name of the schema to restore the table to.</p>
        pub fn target_schema_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_schema_name = Some(input.into());
            self
        }
        /// <p>The name of the schema to restore the table to.</p>
        pub fn set_target_schema_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.target_schema_name = input;
            self
        }
        /// <p>The name of the table to create as a result of the table restore request.</p>
        pub fn new_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.new_table_name = Some(input.into());
            self
        }
        /// <p>The name of the table to create as a result of the table restore request.</p>
        pub fn set_new_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.new_table_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TableRestoreStatus`](crate::model::TableRestoreStatus)
        pub fn build(self) -> crate::model::TableRestoreStatus {
            crate::model::TableRestoreStatus {
                table_restore_request_id: self.table_restore_request_id,
                status: self.status,
                message: self.message,
                request_time: self.request_time,
                progress_in_mega_bytes: self.progress_in_mega_bytes,
                total_data_in_mega_bytes: self.total_data_in_mega_bytes,
                cluster_identifier: self.cluster_identifier,
                snapshot_identifier: self.snapshot_identifier,
                source_database_name: self.source_database_name,
                source_schema_name: self.source_schema_name,
                source_table_name: self.source_table_name,
                target_database_name: self.target_database_name,
                target_schema_name: self.target_schema_name,
                new_table_name: self.new_table_name,
            }
        }
    }
}
impl TableRestoreStatus {
    /// Creates a new builder-style object to manufacture [`TableRestoreStatus`](crate::model::TableRestoreStatus)
    pub fn builder() -> crate::model::table_restore_status::Builder {
        crate::model::table_restore_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableRestoreStatusType {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TableRestoreStatusType {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => TableRestoreStatusType::Canceled,
            "FAILED" => TableRestoreStatusType::Failed,
            "IN_PROGRESS" => TableRestoreStatusType::InProgress,
            "PENDING" => TableRestoreStatusType::Pending,
            "SUCCEEDED" => TableRestoreStatusType::Succeeded,
            other => TableRestoreStatusType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TableRestoreStatusType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TableRestoreStatusType::from(s))
    }
}
impl TableRestoreStatusType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TableRestoreStatusType::Canceled => "CANCELED",
            TableRestoreStatusType::Failed => "FAILED",
            TableRestoreStatusType::InProgress => "IN_PROGRESS",
            TableRestoreStatusType::Pending => "PENDING",
            TableRestoreStatusType::Succeeded => "SUCCEEDED",
            TableRestoreStatusType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CANCELED", "FAILED", "IN_PROGRESS", "PENDING", "SUCCEEDED"]
    }
}
impl AsRef<str> for TableRestoreStatusType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a parameter in a cluster parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parameter {
    /// <p>The name of the parameter.</p>
    pub parameter_name: std::option::Option<std::string::String>,
    /// <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
    /// then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
    pub parameter_value: std::option::Option<std::string::String>,
    /// <p>A description of the parameter.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The source of the parameter value, such as "engine-default" or "user".</p>
    pub source: std::option::Option<std::string::String>,
    /// <p>The data type of the parameter.</p>
    pub data_type: std::option::Option<std::string::String>,
    /// <p>The valid range of values for the parameter.</p>
    pub allowed_values: std::option::Option<std::string::String>,
    /// <p>Specifies how to apply the WLM configuration parameter. Some properties can be
    /// applied dynamically, while other properties require that any associated clusters be
    /// rebooted for the configuration changes to be applied.
    /// For more information about parameters and parameter groups, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
    pub apply_type: std::option::Option<crate::model::ParameterApplyType>,
    /// <p>If <code>true</code>, the parameter can be modified. Some parameters have security
    /// or operational implications that prevent them from being changed. </p>
    pub is_modifiable: bool,
    /// <p>The earliest engine version to which the parameter can apply.</p>
    pub minimum_engine_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parameter");
        formatter.field("parameter_name", &self.parameter_name);
        formatter.field("parameter_value", &self.parameter_value);
        formatter.field("description", &self.description);
        formatter.field("source", &self.source);
        formatter.field("data_type", &self.data_type);
        formatter.field("allowed_values", &self.allowed_values);
        formatter.field("apply_type", &self.apply_type);
        formatter.field("is_modifiable", &self.is_modifiable);
        formatter.field("minimum_engine_version", &self.minimum_engine_version);
        formatter.finish()
    }
}
/// See [`Parameter`](crate::model::Parameter)
pub mod parameter {
    /// A builder for [`Parameter`](crate::model::Parameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_name: std::option::Option<std::string::String>,
        pub(crate) parameter_value: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<std::string::String>,
        pub(crate) allowed_values: std::option::Option<std::string::String>,
        pub(crate) apply_type: std::option::Option<crate::model::ParameterApplyType>,
        pub(crate) is_modifiable: std::option::Option<bool>,
        pub(crate) minimum_engine_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter.</p>
        pub fn parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_name = Some(input.into());
            self
        }
        /// <p>The name of the parameter.</p>
        pub fn set_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_name = input;
            self
        }
        /// <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
        /// then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
        pub fn parameter_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_value = Some(input.into());
            self
        }
        /// <p>The value of the parameter. If <code>ParameterName</code> is <code>wlm_json_configuration</code>,
        /// then the maximum size of <code>ParameterValue</code> is 8000 characters.</p>
        pub fn set_parameter_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_value = input;
            self
        }
        /// <p>A description of the parameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the parameter.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The source of the parameter value, such as "engine-default" or "user".</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source of the parameter value, such as "engine-default" or "user".</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// <p>The data type of the parameter.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        /// <p>The data type of the parameter.</p>
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The valid range of values for the parameter.</p>
        pub fn allowed_values(mut self, input: impl Into<std::string::String>) -> Self {
            self.allowed_values = Some(input.into());
            self
        }
        /// <p>The valid range of values for the parameter.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>Specifies how to apply the WLM configuration parameter. Some properties can be
        /// applied dynamically, while other properties require that any associated clusters be
        /// rebooted for the configuration changes to be applied.
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        pub fn apply_type(mut self, input: crate::model::ParameterApplyType) -> Self {
            self.apply_type = Some(input);
            self
        }
        /// <p>Specifies how to apply the WLM configuration parameter. Some properties can be
        /// applied dynamically, while other properties require that any associated clusters be
        /// rebooted for the configuration changes to be applied.
        /// For more information about parameters and parameter groups, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
        pub fn set_apply_type(
            mut self,
            input: std::option::Option<crate::model::ParameterApplyType>,
        ) -> Self {
            self.apply_type = input;
            self
        }
        /// <p>If <code>true</code>, the parameter can be modified. Some parameters have security
        /// or operational implications that prevent them from being changed. </p>
        pub fn is_modifiable(mut self, input: bool) -> Self {
            self.is_modifiable = Some(input);
            self
        }
        /// <p>If <code>true</code>, the parameter can be modified. Some parameters have security
        /// or operational implications that prevent them from being changed. </p>
        pub fn set_is_modifiable(mut self, input: std::option::Option<bool>) -> Self {
            self.is_modifiable = input;
            self
        }
        /// <p>The earliest engine version to which the parameter can apply.</p>
        pub fn minimum_engine_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.minimum_engine_version = Some(input.into());
            self
        }
        /// <p>The earliest engine version to which the parameter can apply.</p>
        pub fn set_minimum_engine_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.minimum_engine_version = input;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter)
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                parameter_name: self.parameter_name,
                parameter_value: self.parameter_value,
                description: self.description,
                source: self.source,
                data_type: self.data_type,
                allowed_values: self.allowed_values,
                apply_type: self.apply_type,
                is_modifiable: self.is_modifiable.unwrap_or_default(),
                minimum_engine_version: self.minimum_engine_version,
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter)
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParameterApplyType {
    #[allow(missing_docs)] // documentation missing in model
    Dynamic,
    #[allow(missing_docs)] // documentation missing in model
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ParameterApplyType {
    fn from(s: &str) -> Self {
        match s {
            "dynamic" => ParameterApplyType::Dynamic,
            "static" => ParameterApplyType::Static,
            other => ParameterApplyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ParameterApplyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParameterApplyType::from(s))
    }
}
impl ParameterApplyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParameterApplyType::Dynamic => "dynamic",
            ParameterApplyType::Static => "static",
            ParameterApplyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["dynamic", "static"]
    }
}
impl AsRef<str> for ParameterApplyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The association of a datashare from a producer account with a data consumer.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataShareAssociation {
    /// <p>The name of the consumer accounts that have an association with a producer
    /// datashare.</p>
    pub consumer_identifier: std::option::Option<std::string::String>,
    /// <p>The status of the datashare that is associated.</p>
    pub status: std::option::Option<crate::model::DataShareStatus>,
    /// <p>The creation date of the datashare that is associated.</p>
    pub created_date: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status change data of the datashare that is associated.</p>
    pub status_change_date: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for DataShareAssociation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataShareAssociation");
        formatter.field("consumer_identifier", &self.consumer_identifier);
        formatter.field("status", &self.status);
        formatter.field("created_date", &self.created_date);
        formatter.field("status_change_date", &self.status_change_date);
        formatter.finish()
    }
}
/// See [`DataShareAssociation`](crate::model::DataShareAssociation)
pub mod data_share_association {
    /// A builder for [`DataShareAssociation`](crate::model::DataShareAssociation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) consumer_identifier: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DataShareStatus>,
        pub(crate) created_date: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) status_change_date: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the consumer accounts that have an association with a producer
        /// datashare.</p>
        pub fn consumer_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.consumer_identifier = Some(input.into());
            self
        }
        /// <p>The name of the consumer accounts that have an association with a producer
        /// datashare.</p>
        pub fn set_consumer_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.consumer_identifier = input;
            self
        }
        /// <p>The status of the datashare that is associated.</p>
        pub fn status(mut self, input: crate::model::DataShareStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the datashare that is associated.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataShareStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The creation date of the datashare that is associated.</p>
        pub fn created_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_date = Some(input);
            self
        }
        /// <p>The creation date of the datashare that is associated.</p>
        pub fn set_created_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_date = input;
            self
        }
        /// <p>The status change data of the datashare that is associated.</p>
        pub fn status_change_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.status_change_date = Some(input);
            self
        }
        /// <p>The status change data of the datashare that is associated.</p>
        pub fn set_status_change_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.status_change_date = input;
            self
        }
        /// Consumes the builder and constructs a [`DataShareAssociation`](crate::model::DataShareAssociation)
        pub fn build(self) -> crate::model::DataShareAssociation {
            crate::model::DataShareAssociation {
                consumer_identifier: self.consumer_identifier,
                status: self.status,
                created_date: self.created_date,
                status_change_date: self.status_change_date,
            }
        }
    }
}
impl DataShareAssociation {
    /// Creates a new builder-style object to manufacture [`DataShareAssociation`](crate::model::DataShareAssociation)
    pub fn builder() -> crate::model::data_share_association::Builder {
        crate::model::data_share_association::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataShareStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Authorized,
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deauthorized,
    #[allow(missing_docs)] // documentation missing in model
    PendingAuthorization,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataShareStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DataShareStatus::Active,
            "AUTHORIZED" => DataShareStatus::Authorized,
            "AVAILABLE" => DataShareStatus::Available,
            "DEAUTHORIZED" => DataShareStatus::Deauthorized,
            "PENDING_AUTHORIZATION" => DataShareStatus::PendingAuthorization,
            "REJECTED" => DataShareStatus::Rejected,
            other => DataShareStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataShareStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataShareStatus::from(s))
    }
}
impl DataShareStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataShareStatus::Active => "ACTIVE",
            DataShareStatus::Authorized => "AUTHORIZED",
            DataShareStatus::Available => "AVAILABLE",
            DataShareStatus::Deauthorized => "DEAUTHORIZED",
            DataShareStatus::PendingAuthorization => "PENDING_AUTHORIZATION",
            DataShareStatus::Rejected => "REJECTED",
            DataShareStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "AUTHORIZED",
            "AVAILABLE",
            "DEAUTHORIZED",
            "PENDING_AUTHORIZATION",
            "REJECTED",
        ]
    }
}
impl AsRef<str> for DataShareStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a reserved node. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node
/// offerings. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedNode {
    /// <p>The unique identifier for the reservation.</p>
    pub reserved_node_id: std::option::Option<std::string::String>,
    /// <p>The identifier for the reserved node offering.</p>
    pub reserved_node_offering_id: std::option::Option<std::string::String>,
    /// <p>The node type of the reserved node.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The time the reservation started. You purchase a reserved node offering for a
    /// duration. This is the start time of that duration.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The duration of the node reservation in seconds.</p>
    pub duration: i32,
    /// <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
    pub fixed_price: f64,
    /// <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
    pub usage_price: f64,
    /// <p>The currency code for the reserved cluster.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The number of reserved compute nodes.</p>
    pub node_count: i32,
    /// <p>The state of the reserved compute node.</p>
    /// <p>Possible Values:</p>
    /// <ul>
    /// <li>
    /// <p>pending-payment-This reserved node has recently been purchased, and the
    /// sale has been approved, but payment has not yet been confirmed.</p>
    /// </li>
    /// <li>
    /// <p>active-This reserved node is owned by the caller and is available for
    /// use.</p>
    /// </li>
    /// <li>
    /// <p>payment-failed-Payment failed for the purchase attempt.</p>
    /// </li>
    /// <li>
    /// <p>retired-The reserved node is no longer available. </p>
    /// </li>
    /// <li>
    /// <p>exchanging-The owner is exchanging the reserved node for another reserved
    /// node.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<std::string::String>,
    /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
    /// offering.</p>
    pub offering_type: std::option::Option<std::string::String>,
    /// <p>The recurring charges for the reserved node.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    /// <p></p>
    pub reserved_node_offering_type: std::option::Option<crate::model::ReservedNodeOfferingType>,
}
impl std::fmt::Debug for ReservedNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedNode");
        formatter.field("reserved_node_id", &self.reserved_node_id);
        formatter.field("reserved_node_offering_id", &self.reserved_node_offering_id);
        formatter.field("node_type", &self.node_type);
        formatter.field("start_time", &self.start_time);
        formatter.field("duration", &self.duration);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("node_count", &self.node_count);
        formatter.field("state", &self.state);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.field(
            "reserved_node_offering_type",
            &self.reserved_node_offering_type,
        );
        formatter.finish()
    }
}
/// See [`ReservedNode`](crate::model::ReservedNode)
pub mod reserved_node {
    /// A builder for [`ReservedNode`](crate::model::ReservedNode)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_node_id: std::option::Option<std::string::String>,
        pub(crate) reserved_node_offering_id: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) node_count: std::option::Option<i32>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) offering_type: std::option::Option<std::string::String>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        pub(crate) reserved_node_offering_type:
            std::option::Option<crate::model::ReservedNodeOfferingType>,
    }
    impl Builder {
        /// <p>The unique identifier for the reservation.</p>
        pub fn reserved_node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_node_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the reservation.</p>
        pub fn set_reserved_node_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_node_id = input;
            self
        }
        /// <p>The identifier for the reserved node offering.</p>
        pub fn reserved_node_offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_node_offering_id = Some(input.into());
            self
        }
        /// <p>The identifier for the reserved node offering.</p>
        pub fn set_reserved_node_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_node_offering_id = input;
            self
        }
        /// <p>The node type of the reserved node.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type of the reserved node.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The time the reservation started. You purchase a reserved node offering for a
        /// duration. This is the start time of that duration.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time the reservation started. You purchase a reserved node offering for a
        /// duration. This is the start time of that duration.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The duration of the node reservation in seconds.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration of the node reservation in seconds.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The fixed cost Amazon Redshift charges you for this reserved node.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The hourly rate Amazon Redshift charges you for this reserved node.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the reserved cluster.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the reserved cluster.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The number of reserved compute nodes.</p>
        pub fn node_count(mut self, input: i32) -> Self {
            self.node_count = Some(input);
            self
        }
        /// <p>The number of reserved compute nodes.</p>
        pub fn set_node_count(mut self, input: std::option::Option<i32>) -> Self {
            self.node_count = input;
            self
        }
        /// <p>The state of the reserved compute node.</p>
        /// <p>Possible Values:</p>
        /// <ul>
        /// <li>
        /// <p>pending-payment-This reserved node has recently been purchased, and the
        /// sale has been approved, but payment has not yet been confirmed.</p>
        /// </li>
        /// <li>
        /// <p>active-This reserved node is owned by the caller and is available for
        /// use.</p>
        /// </li>
        /// <li>
        /// <p>payment-failed-Payment failed for the purchase attempt.</p>
        /// </li>
        /// <li>
        /// <p>retired-The reserved node is no longer available. </p>
        /// </li>
        /// <li>
        /// <p>exchanging-The owner is exchanging the reserved node for another reserved
        /// node.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state of the reserved compute node.</p>
        /// <p>Possible Values:</p>
        /// <ul>
        /// <li>
        /// <p>pending-payment-This reserved node has recently been purchased, and the
        /// sale has been approved, but payment has not yet been confirmed.</p>
        /// </li>
        /// <li>
        /// <p>active-This reserved node is owned by the caller and is available for
        /// use.</p>
        /// </li>
        /// <li>
        /// <p>payment-failed-Payment failed for the purchase attempt.</p>
        /// </li>
        /// <li>
        /// <p>retired-The reserved node is no longer available. </p>
        /// </li>
        /// <li>
        /// <p>exchanging-The owner is exchanging the reserved node for another reserved
        /// node.</p>
        /// </li>
        /// </ul>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        /// offering.</p>
        pub fn offering_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_type = Some(input.into());
            self
        }
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        /// offering.</p>
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.offering_type = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The recurring charges for the reserved node.</p>
        pub fn recurring_charges(
            mut self,
            input: impl Into<crate::model::RecurringCharge>,
        ) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input.into());
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The recurring charges for the reserved node.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// <p></p>
        pub fn reserved_node_offering_type(
            mut self,
            input: crate::model::ReservedNodeOfferingType,
        ) -> Self {
            self.reserved_node_offering_type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_reserved_node_offering_type(
            mut self,
            input: std::option::Option<crate::model::ReservedNodeOfferingType>,
        ) -> Self {
            self.reserved_node_offering_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNode`](crate::model::ReservedNode)
        pub fn build(self) -> crate::model::ReservedNode {
            crate::model::ReservedNode {
                reserved_node_id: self.reserved_node_id,
                reserved_node_offering_id: self.reserved_node_offering_id,
                node_type: self.node_type,
                start_time: self.start_time,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price.unwrap_or_default(),
                usage_price: self.usage_price.unwrap_or_default(),
                currency_code: self.currency_code,
                node_count: self.node_count.unwrap_or_default(),
                state: self.state,
                offering_type: self.offering_type,
                recurring_charges: self.recurring_charges,
                reserved_node_offering_type: self.reserved_node_offering_type,
            }
        }
    }
}
impl ReservedNode {
    /// Creates a new builder-style object to manufacture [`ReservedNode`](crate::model::ReservedNode)
    pub fn builder() -> crate::model::reserved_node::Builder {
        crate::model::reserved_node::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReservedNodeOfferingType {
    #[allow(missing_docs)] // documentation missing in model
    Regular,
    #[allow(missing_docs)] // documentation missing in model
    Upgradable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReservedNodeOfferingType {
    fn from(s: &str) -> Self {
        match s {
            "Regular" => ReservedNodeOfferingType::Regular,
            "Upgradable" => ReservedNodeOfferingType::Upgradable,
            other => ReservedNodeOfferingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReservedNodeOfferingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReservedNodeOfferingType::from(s))
    }
}
impl ReservedNodeOfferingType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReservedNodeOfferingType::Regular => "Regular",
            ReservedNodeOfferingType::Upgradable => "Upgradable",
            ReservedNodeOfferingType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["Regular", "Upgradable"]
    }
}
impl AsRef<str> for ReservedNodeOfferingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a recurring charge.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecurringCharge {
    /// <p>The amount charged per the period of time specified by the recurring charge
    /// frequency.</p>
    pub recurring_charge_amount: f64,
    /// <p>The frequency at which the recurring charge amount is applied.</p>
    pub recurring_charge_frequency: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RecurringCharge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecurringCharge");
        formatter.field("recurring_charge_amount", &self.recurring_charge_amount);
        formatter.field(
            "recurring_charge_frequency",
            &self.recurring_charge_frequency,
        );
        formatter.finish()
    }
}
/// See [`RecurringCharge`](crate::model::RecurringCharge)
pub mod recurring_charge {
    /// A builder for [`RecurringCharge`](crate::model::RecurringCharge)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recurring_charge_amount: std::option::Option<f64>,
        pub(crate) recurring_charge_frequency: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The amount charged per the period of time specified by the recurring charge
        /// frequency.</p>
        pub fn recurring_charge_amount(mut self, input: f64) -> Self {
            self.recurring_charge_amount = Some(input);
            self
        }
        /// <p>The amount charged per the period of time specified by the recurring charge
        /// frequency.</p>
        pub fn set_recurring_charge_amount(mut self, input: std::option::Option<f64>) -> Self {
            self.recurring_charge_amount = input;
            self
        }
        /// <p>The frequency at which the recurring charge amount is applied.</p>
        pub fn recurring_charge_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.recurring_charge_frequency = Some(input.into());
            self
        }
        /// <p>The frequency at which the recurring charge amount is applied.</p>
        pub fn set_recurring_charge_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recurring_charge_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`RecurringCharge`](crate::model::RecurringCharge)
        pub fn build(self) -> crate::model::RecurringCharge {
            crate::model::RecurringCharge {
                recurring_charge_amount: self.recurring_charge_amount.unwrap_or_default(),
                recurring_charge_frequency: self.recurring_charge_frequency,
            }
        }
    }
}
impl RecurringCharge {
    /// Creates a new builder-style object to manufacture [`RecurringCharge`](crate::model::RecurringCharge)
    pub fn builder() -> crate::model::recurring_charge::Builder {
        crate::model::recurring_charge::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitBreachAction {
    #[allow(missing_docs)] // documentation missing in model
    Disable,
    #[allow(missing_docs)] // documentation missing in model
    EmitMetric,
    #[allow(missing_docs)] // documentation missing in model
    Log,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitBreachAction {
    fn from(s: &str) -> Self {
        match s {
            "disable" => UsageLimitBreachAction::Disable,
            "emit-metric" => UsageLimitBreachAction::EmitMetric,
            "log" => UsageLimitBreachAction::Log,
            other => UsageLimitBreachAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitBreachAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitBreachAction::from(s))
    }
}
impl UsageLimitBreachAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitBreachAction::Disable => "disable",
            UsageLimitBreachAction::EmitMetric => "emit-metric",
            UsageLimitBreachAction::Log => "log",
            UsageLimitBreachAction::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["disable", "emit-metric", "log"]
    }
}
impl AsRef<str> for UsageLimitBreachAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitPeriod {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Monthly,
    #[allow(missing_docs)] // documentation missing in model
    Weekly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitPeriod {
    fn from(s: &str) -> Self {
        match s {
            "daily" => UsageLimitPeriod::Daily,
            "monthly" => UsageLimitPeriod::Monthly,
            "weekly" => UsageLimitPeriod::Weekly,
            other => UsageLimitPeriod::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitPeriod {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitPeriod::from(s))
    }
}
impl UsageLimitPeriod {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitPeriod::Daily => "daily",
            UsageLimitPeriod::Monthly => "monthly",
            UsageLimitPeriod::Weekly => "weekly",
            UsageLimitPeriod::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["daily", "monthly", "weekly"]
    }
}
impl AsRef<str> for UsageLimitPeriod {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitLimitType {
    #[allow(missing_docs)] // documentation missing in model
    DataScanned,
    #[allow(missing_docs)] // documentation missing in model
    Time,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitLimitType {
    fn from(s: &str) -> Self {
        match s {
            "data-scanned" => UsageLimitLimitType::DataScanned,
            "time" => UsageLimitLimitType::Time,
            other => UsageLimitLimitType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitLimitType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitLimitType::from(s))
    }
}
impl UsageLimitLimitType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitLimitType::DataScanned => "data-scanned",
            UsageLimitLimitType::Time => "time",
            UsageLimitLimitType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["data-scanned", "time"]
    }
}
impl AsRef<str> for UsageLimitLimitType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UsageLimitFeatureType {
    #[allow(missing_docs)] // documentation missing in model
    ConcurrencyScaling,
    #[allow(missing_docs)] // documentation missing in model
    Spectrum,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for UsageLimitFeatureType {
    fn from(s: &str) -> Self {
        match s {
            "concurrency-scaling" => UsageLimitFeatureType::ConcurrencyScaling,
            "spectrum" => UsageLimitFeatureType::Spectrum,
            other => UsageLimitFeatureType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for UsageLimitFeatureType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UsageLimitFeatureType::from(s))
    }
}
impl UsageLimitFeatureType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UsageLimitFeatureType::ConcurrencyScaling => "concurrency-scaling",
            UsageLimitFeatureType::Spectrum => "spectrum",
            UsageLimitFeatureType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["concurrency-scaling", "spectrum"]
    }
}
impl AsRef<str> for UsageLimitFeatureType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterAssociatedToSchedule {
    /// <p></p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p></p>
    pub schedule_association_state: std::option::Option<crate::model::ScheduleState>,
}
impl std::fmt::Debug for ClusterAssociatedToSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterAssociatedToSchedule");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field(
            "schedule_association_state",
            &self.schedule_association_state,
        );
        formatter.finish()
    }
}
/// See [`ClusterAssociatedToSchedule`](crate::model::ClusterAssociatedToSchedule)
pub mod cluster_associated_to_schedule {
    /// A builder for [`ClusterAssociatedToSchedule`](crate::model::ClusterAssociatedToSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) schedule_association_state: std::option::Option<crate::model::ScheduleState>,
    }
    impl Builder {
        /// <p></p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p></p>
        pub fn schedule_association_state(mut self, input: crate::model::ScheduleState) -> Self {
            self.schedule_association_state = Some(input);
            self
        }
        /// <p></p>
        pub fn set_schedule_association_state(
            mut self,
            input: std::option::Option<crate::model::ScheduleState>,
        ) -> Self {
            self.schedule_association_state = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterAssociatedToSchedule`](crate::model::ClusterAssociatedToSchedule)
        pub fn build(self) -> crate::model::ClusterAssociatedToSchedule {
            crate::model::ClusterAssociatedToSchedule {
                cluster_identifier: self.cluster_identifier,
                schedule_association_state: self.schedule_association_state,
            }
        }
    }
}
impl ClusterAssociatedToSchedule {
    /// Creates a new builder-style object to manufacture [`ClusterAssociatedToSchedule`](crate::model::ClusterAssociatedToSchedule)
    pub fn builder() -> crate::model::cluster_associated_to_schedule::Builder {
        crate::model::cluster_associated_to_schedule::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledActionState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduledActionState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ScheduledActionState::Active,
            "DISABLED" => ScheduledActionState::Disabled,
            other => ScheduledActionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduledActionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledActionState::from(s))
    }
}
impl ScheduledActionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledActionState::Active => "ACTIVE",
            ScheduledActionState::Disabled => "DISABLED",
            ScheduledActionState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "DISABLED"]
    }
}
impl AsRef<str> for ScheduledActionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledActionType {
    /// <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
    pub resize_cluster: std::option::Option<crate::model::ResizeClusterMessage>,
    /// <p>An action that runs a <code>PauseCluster</code> API operation. </p>
    pub pause_cluster: std::option::Option<crate::model::PauseClusterMessage>,
    /// <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
    pub resume_cluster: std::option::Option<crate::model::ResumeClusterMessage>,
}
impl std::fmt::Debug for ScheduledActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledActionType");
        formatter.field("resize_cluster", &self.resize_cluster);
        formatter.field("pause_cluster", &self.pause_cluster);
        formatter.field("resume_cluster", &self.resume_cluster);
        formatter.finish()
    }
}
/// See [`ScheduledActionType`](crate::model::ScheduledActionType)
pub mod scheduled_action_type {
    /// A builder for [`ScheduledActionType`](crate::model::ScheduledActionType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resize_cluster: std::option::Option<crate::model::ResizeClusterMessage>,
        pub(crate) pause_cluster: std::option::Option<crate::model::PauseClusterMessage>,
        pub(crate) resume_cluster: std::option::Option<crate::model::ResumeClusterMessage>,
    }
    impl Builder {
        /// <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
        pub fn resize_cluster(mut self, input: crate::model::ResizeClusterMessage) -> Self {
            self.resize_cluster = Some(input);
            self
        }
        /// <p>An action that runs a <code>ResizeCluster</code> API operation. </p>
        pub fn set_resize_cluster(
            mut self,
            input: std::option::Option<crate::model::ResizeClusterMessage>,
        ) -> Self {
            self.resize_cluster = input;
            self
        }
        /// <p>An action that runs a <code>PauseCluster</code> API operation. </p>
        pub fn pause_cluster(mut self, input: crate::model::PauseClusterMessage) -> Self {
            self.pause_cluster = Some(input);
            self
        }
        /// <p>An action that runs a <code>PauseCluster</code> API operation. </p>
        pub fn set_pause_cluster(
            mut self,
            input: std::option::Option<crate::model::PauseClusterMessage>,
        ) -> Self {
            self.pause_cluster = input;
            self
        }
        /// <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
        pub fn resume_cluster(mut self, input: crate::model::ResumeClusterMessage) -> Self {
            self.resume_cluster = Some(input);
            self
        }
        /// <p>An action that runs a <code>ResumeCluster</code> API operation. </p>
        pub fn set_resume_cluster(
            mut self,
            input: std::option::Option<crate::model::ResumeClusterMessage>,
        ) -> Self {
            self.resume_cluster = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionType`](crate::model::ScheduledActionType)
        pub fn build(self) -> crate::model::ScheduledActionType {
            crate::model::ScheduledActionType {
                resize_cluster: self.resize_cluster,
                pause_cluster: self.pause_cluster,
                resume_cluster: self.resume_cluster,
            }
        }
    }
}
impl ScheduledActionType {
    /// Creates a new builder-style object to manufacture [`ScheduledActionType`](crate::model::ScheduledActionType)
    pub fn builder() -> crate::model::scheduled_action_type::Builder {
        crate::model::scheduled_action_type::Builder::default()
    }
}

/// <p>Describes a resume cluster operation. For example, a scheduled action to run the <code>ResumeCluster</code> API operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResumeClusterMessage {
    /// <p>The identifier of the cluster to be resumed.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResumeClusterMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResumeClusterMessage");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.finish()
    }
}
/// See [`ResumeClusterMessage`](crate::model::ResumeClusterMessage)
pub mod resume_cluster_message {
    /// A builder for [`ResumeClusterMessage`](crate::model::ResumeClusterMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the cluster to be resumed.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the cluster to be resumed.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`ResumeClusterMessage`](crate::model::ResumeClusterMessage)
        pub fn build(self) -> crate::model::ResumeClusterMessage {
            crate::model::ResumeClusterMessage {
                cluster_identifier: self.cluster_identifier,
            }
        }
    }
}
impl ResumeClusterMessage {
    /// Creates a new builder-style object to manufacture [`ResumeClusterMessage`](crate::model::ResumeClusterMessage)
    pub fn builder() -> crate::model::resume_cluster_message::Builder {
        crate::model::resume_cluster_message::Builder::default()
    }
}

/// <p>Describes a pause cluster operation. For example, a scheduled action to run the <code>PauseCluster</code> API operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PauseClusterMessage {
    /// <p>The identifier of the cluster to be paused.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PauseClusterMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PauseClusterMessage");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.finish()
    }
}
/// See [`PauseClusterMessage`](crate::model::PauseClusterMessage)
pub mod pause_cluster_message {
    /// A builder for [`PauseClusterMessage`](crate::model::PauseClusterMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the cluster to be paused.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the cluster to be paused.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`PauseClusterMessage`](crate::model::PauseClusterMessage)
        pub fn build(self) -> crate::model::PauseClusterMessage {
            crate::model::PauseClusterMessage {
                cluster_identifier: self.cluster_identifier,
            }
        }
    }
}
impl PauseClusterMessage {
    /// Creates a new builder-style object to manufacture [`PauseClusterMessage`](crate::model::PauseClusterMessage)
    pub fn builder() -> crate::model::pause_cluster_message::Builder {
        crate::model::pause_cluster_message::Builder::default()
    }
}

/// <p>Describes a resize cluster operation. For example, a scheduled action to run the <code>ResizeCluster</code> API operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResizeClusterMessage {
    /// <p>The unique identifier for the cluster to resize.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The new cluster type for the specified cluster.</p>
    pub cluster_type: std::option::Option<std::string::String>,
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    pub number_of_nodes: std::option::Option<i32>,
    /// <p>A boolean value indicating whether the resize operation is using the classic resize
    /// process. If you don't provide this parameter or set the value to
    /// <code>false</code>, the resize type is elastic. </p>
    pub classic: std::option::Option<bool>,
}
impl std::fmt::Debug for ResizeClusterMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResizeClusterMessage");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("cluster_type", &self.cluster_type);
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field("classic", &self.classic);
        formatter.finish()
    }
}
/// See [`ResizeClusterMessage`](crate::model::ResizeClusterMessage)
pub mod resize_cluster_message {
    /// A builder for [`ResizeClusterMessage`](crate::model::ResizeClusterMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) cluster_type: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) classic: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The unique identifier for the cluster to resize.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier for the cluster to resize.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The new cluster type for the specified cluster.</p>
        pub fn cluster_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_type = Some(input.into());
            self
        }
        /// <p>The new cluster type for the specified cluster.</p>
        pub fn set_cluster_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_type = input;
            self
        }
        /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>A boolean value indicating whether the resize operation is using the classic resize
        /// process. If you don't provide this parameter or set the value to
        /// <code>false</code>, the resize type is elastic. </p>
        pub fn classic(mut self, input: bool) -> Self {
            self.classic = Some(input);
            self
        }
        /// <p>A boolean value indicating whether the resize operation is using the classic resize
        /// process. If you don't provide this parameter or set the value to
        /// <code>false</code>, the resize type is elastic. </p>
        pub fn set_classic(mut self, input: std::option::Option<bool>) -> Self {
            self.classic = input;
            self
        }
        /// Consumes the builder and constructs a [`ResizeClusterMessage`](crate::model::ResizeClusterMessage)
        pub fn build(self) -> crate::model::ResizeClusterMessage {
            crate::model::ResizeClusterMessage {
                cluster_identifier: self.cluster_identifier,
                cluster_type: self.cluster_type,
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes,
                classic: self.classic,
            }
        }
    }
}
impl ResizeClusterMessage {
    /// Creates a new builder-style object to manufacture [`ResizeClusterMessage`](crate::model::ResizeClusterMessage)
    pub fn builder() -> crate::model::resize_cluster_message::Builder {
        crate::model::resize_cluster_message::Builder::default()
    }
}

/// <p>Describes event subscriptions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventSubscription {
    /// <p>The Amazon Web Services account associated with the Amazon Redshift event notification
    /// subscription.</p>
    pub customer_aws_id: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Redshift event notification subscription.</p>
    pub cust_subscription_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
    /// notification subscription.</p>
    pub sns_topic_arn: std::option::Option<std::string::String>,
    /// <p>The status of the Amazon Redshift event notification subscription.</p>
    /// <p>Constraints:</p>
    /// <ul>
    /// <li>
    /// <p>Can be one of the following: active | no-permission |
    /// topic-not-exist</p>
    /// </li>
    /// <li>
    /// <p>The status "no-permission" indicates that Amazon Redshift no longer has
    /// permission to post to the Amazon SNS topic. The status "topic-not-exist"
    /// indicates that the topic was deleted after the subscription was
    /// created.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<std::string::String>,
    /// <p>The date and time the Amazon Redshift event notification subscription was
    /// created.</p>
    pub subscription_creation_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The source type of the events returned by the Amazon Redshift event notification, such as
    /// cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>A list of the sources that publish events to the Amazon Redshift event notification
    /// subscription.</p>
    pub source_ids_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The list of Amazon Redshift event categories specified in the event notification
    /// subscription.</p>
    /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
    pub event_categories_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The event severity specified in the Amazon Redshift event notification
    /// subscription.</p>
    /// <p>Values: ERROR, INFO</p>
    pub severity: std::option::Option<std::string::String>,
    /// <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
    /// indicates that the subscription is enabled.</p>
    pub enabled: bool,
    /// <p>The list of tags for the event subscription.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for EventSubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventSubscription");
        formatter.field("customer_aws_id", &self.customer_aws_id);
        formatter.field("cust_subscription_id", &self.cust_subscription_id);
        formatter.field("sns_topic_arn", &self.sns_topic_arn);
        formatter.field("status", &self.status);
        formatter.field(
            "subscription_creation_time",
            &self.subscription_creation_time,
        );
        formatter.field("source_type", &self.source_type);
        formatter.field("source_ids_list", &self.source_ids_list);
        formatter.field("event_categories_list", &self.event_categories_list);
        formatter.field("severity", &self.severity);
        formatter.field("enabled", &self.enabled);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`EventSubscription`](crate::model::EventSubscription)
pub mod event_subscription {
    /// A builder for [`EventSubscription`](crate::model::EventSubscription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_aws_id: std::option::Option<std::string::String>,
        pub(crate) cust_subscription_id: std::option::Option<std::string::String>,
        pub(crate) sns_topic_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) subscription_creation_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) source_ids_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) event_categories_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account associated with the Amazon Redshift event notification
        /// subscription.</p>
        pub fn customer_aws_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_aws_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account associated with the Amazon Redshift event notification
        /// subscription.</p>
        pub fn set_customer_aws_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_aws_id = input;
            self
        }
        /// <p>The name of the Amazon Redshift event notification subscription.</p>
        pub fn cust_subscription_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cust_subscription_id = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Redshift event notification subscription.</p>
        pub fn set_cust_subscription_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cust_subscription_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
        /// notification subscription.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sns_topic_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic used by the event
        /// notification subscription.</p>
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sns_topic_arn = input;
            self
        }
        /// <p>The status of the Amazon Redshift event notification subscription.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Can be one of the following: active | no-permission |
        /// topic-not-exist</p>
        /// </li>
        /// <li>
        /// <p>The status "no-permission" indicates that Amazon Redshift no longer has
        /// permission to post to the Amazon SNS topic. The status "topic-not-exist"
        /// indicates that the topic was deleted after the subscription was
        /// created.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the Amazon Redshift event notification subscription.</p>
        /// <p>Constraints:</p>
        /// <ul>
        /// <li>
        /// <p>Can be one of the following: active | no-permission |
        /// topic-not-exist</p>
        /// </li>
        /// <li>
        /// <p>The status "no-permission" indicates that Amazon Redshift no longer has
        /// permission to post to the Amazon SNS topic. The status "topic-not-exist"
        /// indicates that the topic was deleted after the subscription was
        /// created.</p>
        /// </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time the Amazon Redshift event notification subscription was
        /// created.</p>
        pub fn subscription_creation_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.subscription_creation_time = Some(input);
            self
        }
        /// <p>The date and time the Amazon Redshift event notification subscription was
        /// created.</p>
        pub fn set_subscription_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.subscription_creation_time = input;
            self
        }
        /// <p>The source type of the events returned by the Amazon Redshift event notification, such as
        /// cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type of the events returned by the Amazon Redshift event notification, such as
        /// cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, or scheduled-action. </p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Appends an item to `source_ids_list`.
        ///
        /// To override the contents of this collection use [`set_source_ids_list`](Self::set_source_ids_list).
        ///
        /// <p>A list of the sources that publish events to the Amazon Redshift event notification
        /// subscription.</p>
        pub fn source_ids_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.source_ids_list.unwrap_or_default();
            v.push(input.into());
            self.source_ids_list = Some(v);
            self
        }
        /// <p>A list of the sources that publish events to the Amazon Redshift event notification
        /// subscription.</p>
        pub fn set_source_ids_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.source_ids_list = input;
            self
        }
        /// Appends an item to `event_categories_list`.
        ///
        /// To override the contents of this collection use [`set_event_categories_list`](Self::set_event_categories_list).
        ///
        /// <p>The list of Amazon Redshift event categories specified in the event notification
        /// subscription.</p>
        /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
        pub fn event_categories_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_categories_list.unwrap_or_default();
            v.push(input.into());
            self.event_categories_list = Some(v);
            self
        }
        /// <p>The list of Amazon Redshift event categories specified in the event notification
        /// subscription.</p>
        /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
        pub fn set_event_categories_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_categories_list = input;
            self
        }
        /// <p>The event severity specified in the Amazon Redshift event notification
        /// subscription.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        /// <p>The event severity specified in the Amazon Redshift event notification
        /// subscription.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
        /// indicates that the subscription is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>A boolean value indicating whether the subscription is enabled; <code>true</code>
        /// indicates that the subscription is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the event subscription.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the event subscription.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscription`](crate::model::EventSubscription)
        pub fn build(self) -> crate::model::EventSubscription {
            crate::model::EventSubscription {
                customer_aws_id: self.customer_aws_id,
                cust_subscription_id: self.cust_subscription_id,
                sns_topic_arn: self.sns_topic_arn,
                status: self.status,
                subscription_creation_time: self.subscription_creation_time,
                source_type: self.source_type,
                source_ids_list: self.source_ids_list,
                event_categories_list: self.event_categories_list,
                severity: self.severity,
                enabled: self.enabled.unwrap_or_default(),
                tags: self.tags,
            }
        }
    }
}
impl EventSubscription {
    /// Creates a new builder-style object to manufacture [`EventSubscription`](crate::model::EventSubscription)
    pub fn builder() -> crate::model::event_subscription::Builder {
        crate::model::event_subscription::Builder::default()
    }
}

/// <p>Describes a subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterSubnetGroup {
    /// <p>The name of the cluster subnet group.</p>
    pub cluster_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>The description of the cluster subnet group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The VPC ID of the cluster subnet group.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
    /// <code>Incomplete</code> and <code>Invalid</code>. </p>
    pub subnet_group_status: std::option::Option<std::string::String>,
    /// <p>A list of the VPC <a>Subnet</a> elements. </p>
    pub subnets: std::option::Option<std::vec::Vec<crate::model::Subnet>>,
    /// <p>The list of tags for the cluster subnet group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ClusterSubnetGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterSubnetGroup");
        formatter.field("cluster_subnet_group_name", &self.cluster_subnet_group_name);
        formatter.field("description", &self.description);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_group_status", &self.subnet_group_status);
        formatter.field("subnets", &self.subnets);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ClusterSubnetGroup`](crate::model::ClusterSubnetGroup)
pub mod cluster_subnet_group {
    /// A builder for [`ClusterSubnetGroup`](crate::model::ClusterSubnetGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_group_status: std::option::Option<std::string::String>,
        pub(crate) subnets: std::option::Option<std::vec::Vec<crate::model::Subnet>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the cluster subnet group.</p>
        pub fn cluster_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_subnet_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster subnet group.</p>
        pub fn set_cluster_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_subnet_group_name = input;
            self
        }
        /// <p>The description of the cluster subnet group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the cluster subnet group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The VPC ID of the cluster subnet group.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        /// <p>The VPC ID of the cluster subnet group.</p>
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        /// <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
        /// <code>Incomplete</code> and <code>Invalid</code>. </p>
        pub fn subnet_group_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_group_status = Some(input.into());
            self
        }
        /// <p>The status of the cluster subnet group. Possible values are <code>Complete</code>,
        /// <code>Incomplete</code> and <code>Invalid</code>. </p>
        pub fn set_subnet_group_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_group_status = input;
            self
        }
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>A list of the VPC <a>Subnet</a> elements. </p>
        pub fn subnets(mut self, input: impl Into<crate::model::Subnet>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>A list of the VPC <a>Subnet</a> elements. </p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Subnet>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the cluster subnet group.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the cluster subnet group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterSubnetGroup`](crate::model::ClusterSubnetGroup)
        pub fn build(self) -> crate::model::ClusterSubnetGroup {
            crate::model::ClusterSubnetGroup {
                cluster_subnet_group_name: self.cluster_subnet_group_name,
                description: self.description,
                vpc_id: self.vpc_id,
                subnet_group_status: self.subnet_group_status,
                subnets: self.subnets,
                tags: self.tags,
            }
        }
    }
}
impl ClusterSubnetGroup {
    /// Creates a new builder-style object to manufacture [`ClusterSubnetGroup`](crate::model::ClusterSubnetGroup)
    pub fn builder() -> crate::model::cluster_subnet_group::Builder {
        crate::model::cluster_subnet_group::Builder::default()
    }
}

/// <p>Describes a subnet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Subnet {
    /// <p>The identifier of the subnet.</p>
    pub subnet_identifier: std::option::Option<std::string::String>,
    /// <p></p>
    pub subnet_availability_zone: std::option::Option<crate::model::AvailabilityZone>,
    /// <p>The status of the subnet.</p>
    pub subnet_status: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Subnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Subnet");
        formatter.field("subnet_identifier", &self.subnet_identifier);
        formatter.field("subnet_availability_zone", &self.subnet_availability_zone);
        formatter.field("subnet_status", &self.subnet_status);
        formatter.finish()
    }
}
/// See [`Subnet`](crate::model::Subnet)
pub mod subnet {
    /// A builder for [`Subnet`](crate::model::Subnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_identifier: std::option::Option<std::string::String>,
        pub(crate) subnet_availability_zone: std::option::Option<crate::model::AvailabilityZone>,
        pub(crate) subnet_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the subnet.</p>
        pub fn subnet_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet.</p>
        pub fn set_subnet_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_identifier = input;
            self
        }
        /// <p></p>
        pub fn subnet_availability_zone(mut self, input: crate::model::AvailabilityZone) -> Self {
            self.subnet_availability_zone = Some(input);
            self
        }
        /// <p></p>
        pub fn set_subnet_availability_zone(
            mut self,
            input: std::option::Option<crate::model::AvailabilityZone>,
        ) -> Self {
            self.subnet_availability_zone = input;
            self
        }
        /// <p>The status of the subnet.</p>
        pub fn subnet_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_status = Some(input.into());
            self
        }
        /// <p>The status of the subnet.</p>
        pub fn set_subnet_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_status = input;
            self
        }
        /// Consumes the builder and constructs a [`Subnet`](crate::model::Subnet)
        pub fn build(self) -> crate::model::Subnet {
            crate::model::Subnet {
                subnet_identifier: self.subnet_identifier,
                subnet_availability_zone: self.subnet_availability_zone,
                subnet_status: self.subnet_status,
            }
        }
    }
}
impl Subnet {
    /// Creates a new builder-style object to manufacture [`Subnet`](crate::model::Subnet)
    pub fn builder() -> crate::model::subnet::Builder {
        crate::model::subnet::Builder::default()
    }
}

/// <p>Describes an availability zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AvailabilityZone {
    /// <p>The name of the availability zone.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p></p>
    pub supported_platforms: std::option::Option<std::vec::Vec<crate::model::SupportedPlatform>>,
}
impl std::fmt::Debug for AvailabilityZone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AvailabilityZone");
        formatter.field("name", &self.name);
        formatter.field("supported_platforms", &self.supported_platforms);
        formatter.finish()
    }
}
/// See [`AvailabilityZone`](crate::model::AvailabilityZone)
pub mod availability_zone {
    /// A builder for [`AvailabilityZone`](crate::model::AvailabilityZone)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) supported_platforms:
            std::option::Option<std::vec::Vec<crate::model::SupportedPlatform>>,
    }
    impl Builder {
        /// <p>The name of the availability zone.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the availability zone.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `supported_platforms`.
        ///
        /// To override the contents of this collection use [`set_supported_platforms`](Self::set_supported_platforms).
        ///
        /// <p></p>
        pub fn supported_platforms(
            mut self,
            input: impl Into<crate::model::SupportedPlatform>,
        ) -> Self {
            let mut v = self.supported_platforms.unwrap_or_default();
            v.push(input.into());
            self.supported_platforms = Some(v);
            self
        }
        /// <p></p>
        pub fn set_supported_platforms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SupportedPlatform>>,
        ) -> Self {
            self.supported_platforms = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailabilityZone`](crate::model::AvailabilityZone)
        pub fn build(self) -> crate::model::AvailabilityZone {
            crate::model::AvailabilityZone {
                name: self.name,
                supported_platforms: self.supported_platforms,
            }
        }
    }
}
impl AvailabilityZone {
    /// Creates a new builder-style object to manufacture [`AvailabilityZone`](crate::model::AvailabilityZone)
    pub fn builder() -> crate::model::availability_zone::Builder {
        crate::model::availability_zone::Builder::default()
    }
}

/// <p>A list of supported platforms for orderable clusters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SupportedPlatform {
    /// <p></p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SupportedPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SupportedPlatform");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}
/// See [`SupportedPlatform`](crate::model::SupportedPlatform)
pub mod supported_platform {
    /// A builder for [`SupportedPlatform`](crate::model::SupportedPlatform)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p></p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`SupportedPlatform`](crate::model::SupportedPlatform)
        pub fn build(self) -> crate::model::SupportedPlatform {
            crate::model::SupportedPlatform { name: self.name }
        }
    }
}
impl SupportedPlatform {
    /// Creates a new builder-style object to manufacture [`SupportedPlatform`](crate::model::SupportedPlatform)
    pub fn builder() -> crate::model::supported_platform::Builder {
        crate::model::supported_platform::Builder::default()
    }
}

/// <p>Describes a reserved node offering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedNodeOffering {
    /// <p>The offering identifier.</p>
    pub reserved_node_offering_id: std::option::Option<std::string::String>,
    /// <p>The node type offered by the reserved node offering.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The duration, in seconds, for which the offering will reserve the node.</p>
    pub duration: i32,
    /// <p>The upfront fixed charge you will pay to purchase the specific reserved node
    /// offering.</p>
    pub fixed_price: f64,
    /// <p>The rate you are charged for each hour the cluster that is using the offering is
    /// running.</p>
    pub usage_price: f64,
    /// <p>The currency code for the compute nodes offering.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
    /// offering.</p>
    pub offering_type: std::option::Option<std::string::String>,
    /// <p>The charge to your account regardless of whether you are creating any clusters
    /// using the node offering. Recurring charges are only in effect for heavy-utilization
    /// reserved nodes.</p>
    pub recurring_charges: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
    /// <p></p>
    pub reserved_node_offering_type: std::option::Option<crate::model::ReservedNodeOfferingType>,
}
impl std::fmt::Debug for ReservedNodeOffering {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedNodeOffering");
        formatter.field("reserved_node_offering_id", &self.reserved_node_offering_id);
        formatter.field("node_type", &self.node_type);
        formatter.field("duration", &self.duration);
        formatter.field("fixed_price", &self.fixed_price);
        formatter.field("usage_price", &self.usage_price);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("offering_type", &self.offering_type);
        formatter.field("recurring_charges", &self.recurring_charges);
        formatter.field(
            "reserved_node_offering_type",
            &self.reserved_node_offering_type,
        );
        formatter.finish()
    }
}
/// See [`ReservedNodeOffering`](crate::model::ReservedNodeOffering)
pub mod reserved_node_offering {
    /// A builder for [`ReservedNodeOffering`](crate::model::ReservedNodeOffering)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reserved_node_offering_id: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) fixed_price: std::option::Option<f64>,
        pub(crate) usage_price: std::option::Option<f64>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) offering_type: std::option::Option<std::string::String>,
        pub(crate) recurring_charges:
            std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        pub(crate) reserved_node_offering_type:
            std::option::Option<crate::model::ReservedNodeOfferingType>,
    }
    impl Builder {
        /// <p>The offering identifier.</p>
        pub fn reserved_node_offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_node_offering_id = Some(input.into());
            self
        }
        /// <p>The offering identifier.</p>
        pub fn set_reserved_node_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_node_offering_id = input;
            self
        }
        /// <p>The node type offered by the reserved node offering.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type offered by the reserved node offering.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the node.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration, in seconds, for which the offering will reserve the node.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific reserved node
        /// offering.</p>
        pub fn fixed_price(mut self, input: f64) -> Self {
            self.fixed_price = Some(input);
            self
        }
        /// <p>The upfront fixed charge you will pay to purchase the specific reserved node
        /// offering.</p>
        pub fn set_fixed_price(mut self, input: std::option::Option<f64>) -> Self {
            self.fixed_price = input;
            self
        }
        /// <p>The rate you are charged for each hour the cluster that is using the offering is
        /// running.</p>
        pub fn usage_price(mut self, input: f64) -> Self {
            self.usage_price = Some(input);
            self
        }
        /// <p>The rate you are charged for each hour the cluster that is using the offering is
        /// running.</p>
        pub fn set_usage_price(mut self, input: std::option::Option<f64>) -> Self {
            self.usage_price = input;
            self
        }
        /// <p>The currency code for the compute nodes offering.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        /// <p>The currency code for the compute nodes offering.</p>
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        /// offering.</p>
        pub fn offering_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_type = Some(input.into());
            self
        }
        /// <p>The anticipated utilization of the reserved node, as defined in the reserved node
        /// offering.</p>
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.offering_type = input;
            self
        }
        /// Appends an item to `recurring_charges`.
        ///
        /// To override the contents of this collection use [`set_recurring_charges`](Self::set_recurring_charges).
        ///
        /// <p>The charge to your account regardless of whether you are creating any clusters
        /// using the node offering. Recurring charges are only in effect for heavy-utilization
        /// reserved nodes.</p>
        pub fn recurring_charges(
            mut self,
            input: impl Into<crate::model::RecurringCharge>,
        ) -> Self {
            let mut v = self.recurring_charges.unwrap_or_default();
            v.push(input.into());
            self.recurring_charges = Some(v);
            self
        }
        /// <p>The charge to your account regardless of whether you are creating any clusters
        /// using the node offering. Recurring charges are only in effect for heavy-utilization
        /// reserved nodes.</p>
        pub fn set_recurring_charges(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecurringCharge>>,
        ) -> Self {
            self.recurring_charges = input;
            self
        }
        /// <p></p>
        pub fn reserved_node_offering_type(
            mut self,
            input: crate::model::ReservedNodeOfferingType,
        ) -> Self {
            self.reserved_node_offering_type = Some(input);
            self
        }
        /// <p></p>
        pub fn set_reserved_node_offering_type(
            mut self,
            input: std::option::Option<crate::model::ReservedNodeOfferingType>,
        ) -> Self {
            self.reserved_node_offering_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedNodeOffering`](crate::model::ReservedNodeOffering)
        pub fn build(self) -> crate::model::ReservedNodeOffering {
            crate::model::ReservedNodeOffering {
                reserved_node_offering_id: self.reserved_node_offering_id,
                node_type: self.node_type,
                duration: self.duration.unwrap_or_default(),
                fixed_price: self.fixed_price.unwrap_or_default(),
                usage_price: self.usage_price.unwrap_or_default(),
                currency_code: self.currency_code,
                offering_type: self.offering_type,
                recurring_charges: self.recurring_charges,
                reserved_node_offering_type: self.reserved_node_offering_type,
            }
        }
    }
}
impl ReservedNodeOffering {
    /// Creates a new builder-style object to manufacture [`ReservedNodeOffering`](crate::model::ReservedNodeOffering)
    pub fn builder() -> crate::model::reserved_node_offering::Builder {
        crate::model::reserved_node_offering::Builder::default()
    }
}

/// <p>Describes a usage limit object for a cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UsageLimit {
    /// <p>The identifier of the usage limit.</p>
    pub usage_limit_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the cluster with a usage limit.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The Amazon Redshift feature to which the limit applies.</p>
    pub feature_type: std::option::Option<crate::model::UsageLimitFeatureType>,
    /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
    pub limit_type: std::option::Option<crate::model::UsageLimitLimitType>,
    /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
    pub amount: i64,
    /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
    pub period: std::option::Option<crate::model::UsageLimitPeriod>,
    /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <b>log</b> - To log an event in a system table. The default is log.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>emit-metric</b> - To emit CloudWatch metrics.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <b>disable</b> - To disable the feature until the next usage period begins.</p>
    /// </li>
    /// </ul>
    pub breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
    /// <p>A list of tag instances.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for UsageLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UsageLimit");
        formatter.field("usage_limit_id", &self.usage_limit_id);
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("feature_type", &self.feature_type);
        formatter.field("limit_type", &self.limit_type);
        formatter.field("amount", &self.amount);
        formatter.field("period", &self.period);
        formatter.field("breach_action", &self.breach_action);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`UsageLimit`](crate::model::UsageLimit)
pub mod usage_limit {
    /// A builder for [`UsageLimit`](crate::model::UsageLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) usage_limit_id: std::option::Option<std::string::String>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) feature_type: std::option::Option<crate::model::UsageLimitFeatureType>,
        pub(crate) limit_type: std::option::Option<crate::model::UsageLimitLimitType>,
        pub(crate) amount: std::option::Option<i64>,
        pub(crate) period: std::option::Option<crate::model::UsageLimitPeriod>,
        pub(crate) breach_action: std::option::Option<crate::model::UsageLimitBreachAction>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The identifier of the usage limit.</p>
        pub fn usage_limit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_limit_id = Some(input.into());
            self
        }
        /// <p>The identifier of the usage limit.</p>
        pub fn set_usage_limit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.usage_limit_id = input;
            self
        }
        /// <p>The identifier of the cluster with a usage limit.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the cluster with a usage limit.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The Amazon Redshift feature to which the limit applies.</p>
        pub fn feature_type(mut self, input: crate::model::UsageLimitFeatureType) -> Self {
            self.feature_type = Some(input);
            self
        }
        /// <p>The Amazon Redshift feature to which the limit applies.</p>
        pub fn set_feature_type(
            mut self,
            input: std::option::Option<crate::model::UsageLimitFeatureType>,
        ) -> Self {
            self.feature_type = input;
            self
        }
        /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
        pub fn limit_type(mut self, input: crate::model::UsageLimitLimitType) -> Self {
            self.limit_type = Some(input);
            self
        }
        /// <p>The type of limit. Depending on the feature type, this can be based on a time duration or data size.</p>
        pub fn set_limit_type(
            mut self,
            input: std::option::Option<crate::model::UsageLimitLimitType>,
        ) -> Self {
            self.limit_type = input;
            self
        }
        /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
        pub fn amount(mut self, input: i64) -> Self {
            self.amount = Some(input);
            self
        }
        /// <p>The limit amount. If time-based, this amount is in minutes. If data-based, this amount is in terabytes (TB).</p>
        pub fn set_amount(mut self, input: std::option::Option<i64>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
        pub fn period(mut self, input: crate::model::UsageLimitPeriod) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The time period that the amount applies to. A <code>weekly</code> period begins on Sunday. The default is <code>monthly</code>. </p>
        pub fn set_period(
            mut self,
            input: std::option::Option<crate::model::UsageLimitPeriod>,
        ) -> Self {
            self.period = input;
            self
        }
        /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>log</b> - To log an event in a system table. The default is log.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>emit-metric</b> - To emit CloudWatch metrics.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>disable</b> - To disable the feature until the next usage period begins.</p>
        /// </li>
        /// </ul>
        pub fn breach_action(mut self, input: crate::model::UsageLimitBreachAction) -> Self {
            self.breach_action = Some(input);
            self
        }
        /// <p>The action that Amazon Redshift takes when the limit is reached. Possible values are: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>log</b> - To log an event in a system table. The default is log.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>emit-metric</b> - To emit CloudWatch metrics.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>disable</b> - To disable the feature until the next usage period begins.</p>
        /// </li>
        /// </ul>
        pub fn set_breach_action(
            mut self,
            input: std::option::Option<crate::model::UsageLimitBreachAction>,
        ) -> Self {
            self.breach_action = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tag instances.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of tag instances.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`UsageLimit`](crate::model::UsageLimit)
        pub fn build(self) -> crate::model::UsageLimit {
            crate::model::UsageLimit {
                usage_limit_id: self.usage_limit_id,
                cluster_identifier: self.cluster_identifier,
                feature_type: self.feature_type,
                limit_type: self.limit_type,
                amount: self.amount.unwrap_or_default(),
                period: self.period,
                breach_action: self.breach_action,
                tags: self.tags,
            }
        }
    }
}
impl UsageLimit {
    /// Creates a new builder-style object to manufacture [`UsageLimit`](crate::model::UsageLimit)
    pub fn builder() -> crate::model::usage_limit::Builder {
        crate::model::usage_limit::Builder::default()
    }
}

/// <p>A tag and its associated resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TaggedResource {
    /// <p>The tag for the resource.</p>
    pub tag: std::option::Option<crate::model::Tag>,
    /// <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
    /// <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
    pub resource_name: std::option::Option<std::string::String>,
    /// <p>The type of resource with which the tag is associated. Valid resource types are: </p>
    /// <ul>
    /// <li>
    /// <p>Cluster</p>
    /// </li>
    /// <li>
    /// <p>CIDR/IP</p>
    /// </li>
    /// <li>
    /// <p>EC2 security group</p>
    /// </li>
    /// <li>
    /// <p>Snapshot</p>
    /// </li>
    /// <li>
    /// <p>Cluster security group</p>
    /// </li>
    /// <li>
    /// <p>Subnet group</p>
    /// </li>
    /// <li>
    /// <p>HSM connection</p>
    /// </li>
    /// <li>
    /// <p>HSM certificate</p>
    /// </li>
    /// <li>
    /// <p>Parameter group</p>
    /// </li>
    /// </ul>
    /// <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
    /// Amazon Redshift Cluster Management Guide. </p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TaggedResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TaggedResource");
        formatter.field("tag", &self.tag);
        formatter.field("resource_name", &self.resource_name);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
/// See [`TaggedResource`](crate::model::TaggedResource)
pub mod tagged_resource {
    /// A builder for [`TaggedResource`](crate::model::TaggedResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag: std::option::Option<crate::model::Tag>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag for the resource.</p>
        pub fn tag(mut self, input: crate::model::Tag) -> Self {
            self.tag = Some(input);
            self
        }
        /// <p>The tag for the resource.</p>
        pub fn set_tag(mut self, input: std::option::Option<crate::model::Tag>) -> Self {
            self.tag = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
        /// <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) with which the tag is associated, for example:
        /// <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>.</p>
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// <p>The type of resource with which the tag is associated. Valid resource types are: </p>
        /// <ul>
        /// <li>
        /// <p>Cluster</p>
        /// </li>
        /// <li>
        /// <p>CIDR/IP</p>
        /// </li>
        /// <li>
        /// <p>EC2 security group</p>
        /// </li>
        /// <li>
        /// <p>Snapshot</p>
        /// </li>
        /// <li>
        /// <p>Cluster security group</p>
        /// </li>
        /// <li>
        /// <p>Subnet group</p>
        /// </li>
        /// <li>
        /// <p>HSM connection</p>
        /// </li>
        /// <li>
        /// <p>HSM certificate</p>
        /// </li>
        /// <li>
        /// <p>Parameter group</p>
        /// </li>
        /// </ul>
        /// <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
        /// Amazon Redshift Cluster Management Guide. </p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of resource with which the tag is associated. Valid resource types are: </p>
        /// <ul>
        /// <li>
        /// <p>Cluster</p>
        /// </li>
        /// <li>
        /// <p>CIDR/IP</p>
        /// </li>
        /// <li>
        /// <p>EC2 security group</p>
        /// </li>
        /// <li>
        /// <p>Snapshot</p>
        /// </li>
        /// <li>
        /// <p>Cluster security group</p>
        /// </li>
        /// <li>
        /// <p>Subnet group</p>
        /// </li>
        /// <li>
        /// <p>HSM connection</p>
        /// </li>
        /// <li>
        /// <p>HSM certificate</p>
        /// </li>
        /// <li>
        /// <p>Parameter group</p>
        /// </li>
        /// </ul>
        /// <p>For more information about Amazon Redshift resource types and constructing ARNs, go to
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Constructing an Amazon Redshift Amazon Resource Name (ARN)</a> in the
        /// Amazon Redshift Cluster Management Guide. </p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`TaggedResource`](crate::model::TaggedResource)
        pub fn build(self) -> crate::model::TaggedResource {
            crate::model::TaggedResource {
                tag: self.tag,
                resource_name: self.resource_name,
                resource_type: self.resource_type,
            }
        }
    }
}
impl TaggedResource {
    /// Creates a new builder-style object to manufacture [`TaggedResource`](crate::model::TaggedResource)
    pub fn builder() -> crate::model::tagged_resource::Builder {
        crate::model::tagged_resource::Builder::default()
    }
}

/// <p>Describes a snapshot schedule. You can set a regular interval for creating
/// snapshots of a cluster. You can also schedule snapshots for specific dates. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotSchedule {
    /// <p>A list of ScheduleDefinitions.</p>
    pub schedule_definitions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A unique identifier for the schedule.</p>
    pub schedule_identifier: std::option::Option<std::string::String>,
    /// <p>The description of the schedule.</p>
    pub schedule_description: std::option::Option<std::string::String>,
    /// <p>An optional set of tags describing the schedule.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p></p>
    pub next_invocations: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
    /// <p>The number of clusters associated with the schedule.</p>
    pub associated_cluster_count: std::option::Option<i32>,
    /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
    pub associated_clusters:
        std::option::Option<std::vec::Vec<crate::model::ClusterAssociatedToSchedule>>,
}
impl std::fmt::Debug for SnapshotSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotSchedule");
        formatter.field("schedule_definitions", &self.schedule_definitions);
        formatter.field("schedule_identifier", &self.schedule_identifier);
        formatter.field("schedule_description", &self.schedule_description);
        formatter.field("tags", &self.tags);
        formatter.field("next_invocations", &self.next_invocations);
        formatter.field("associated_cluster_count", &self.associated_cluster_count);
        formatter.field("associated_clusters", &self.associated_clusters);
        formatter.finish()
    }
}
/// See [`SnapshotSchedule`](crate::model::SnapshotSchedule)
pub mod snapshot_schedule {
    /// A builder for [`SnapshotSchedule`](crate::model::SnapshotSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) schedule_definitions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) schedule_identifier: std::option::Option<std::string::String>,
        pub(crate) schedule_description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) next_invocations: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
        pub(crate) associated_cluster_count: std::option::Option<i32>,
        pub(crate) associated_clusters:
            std::option::Option<std::vec::Vec<crate::model::ClusterAssociatedToSchedule>>,
    }
    impl Builder {
        /// Appends an item to `schedule_definitions`.
        ///
        /// To override the contents of this collection use [`set_schedule_definitions`](Self::set_schedule_definitions).
        ///
        /// <p>A list of ScheduleDefinitions.</p>
        pub fn schedule_definitions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.schedule_definitions.unwrap_or_default();
            v.push(input.into());
            self.schedule_definitions = Some(v);
            self
        }
        /// <p>A list of ScheduleDefinitions.</p>
        pub fn set_schedule_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.schedule_definitions = input;
            self
        }
        /// <p>A unique identifier for the schedule.</p>
        pub fn schedule_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the schedule.</p>
        pub fn set_schedule_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_identifier = input;
            self
        }
        /// <p>The description of the schedule.</p>
        pub fn schedule_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule_description = Some(input.into());
            self
        }
        /// <p>The description of the schedule.</p>
        pub fn set_schedule_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.schedule_description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>An optional set of tags describing the schedule.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>An optional set of tags describing the schedule.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Appends an item to `next_invocations`.
        ///
        /// To override the contents of this collection use [`set_next_invocations`](Self::set_next_invocations).
        ///
        /// <p></p>
        pub fn next_invocations(mut self, input: impl Into<aws_smithy_types::Instant>) -> Self {
            let mut v = self.next_invocations.unwrap_or_default();
            v.push(input.into());
            self.next_invocations = Some(v);
            self
        }
        /// <p></p>
        pub fn set_next_invocations(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
        ) -> Self {
            self.next_invocations = input;
            self
        }
        /// <p>The number of clusters associated with the schedule.</p>
        pub fn associated_cluster_count(mut self, input: i32) -> Self {
            self.associated_cluster_count = Some(input);
            self
        }
        /// <p>The number of clusters associated with the schedule.</p>
        pub fn set_associated_cluster_count(mut self, input: std::option::Option<i32>) -> Self {
            self.associated_cluster_count = input;
            self
        }
        /// Appends an item to `associated_clusters`.
        ///
        /// To override the contents of this collection use [`set_associated_clusters`](Self::set_associated_clusters).
        ///
        /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
        pub fn associated_clusters(
            mut self,
            input: impl Into<crate::model::ClusterAssociatedToSchedule>,
        ) -> Self {
            let mut v = self.associated_clusters.unwrap_or_default();
            v.push(input.into());
            self.associated_clusters = Some(v);
            self
        }
        /// <p>A list of clusters associated with the schedule. A maximum of 100 clusters is returned.</p>
        pub fn set_associated_clusters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClusterAssociatedToSchedule>>,
        ) -> Self {
            self.associated_clusters = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotSchedule`](crate::model::SnapshotSchedule)
        pub fn build(self) -> crate::model::SnapshotSchedule {
            crate::model::SnapshotSchedule {
                schedule_definitions: self.schedule_definitions,
                schedule_identifier: self.schedule_identifier,
                schedule_description: self.schedule_description,
                tags: self.tags,
                next_invocations: self.next_invocations,
                associated_cluster_count: self.associated_cluster_count,
                associated_clusters: self.associated_clusters,
            }
        }
    }
}
impl SnapshotSchedule {
    /// Creates a new builder-style object to manufacture [`SnapshotSchedule`](crate::model::SnapshotSchedule)
    pub fn builder() -> crate::model::snapshot_schedule::Builder {
        crate::model::snapshot_schedule::Builder::default()
    }
}

/// <p>The snapshot copy grant that grants Amazon Redshift permission to encrypt copied
/// snapshots with the specified customer master key (CMK) from Amazon Web Services KMS in the destination
/// region.</p>
/// <p>
/// For more information about managing snapshot copy grants, go to
/// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a>
/// in the <i>Amazon Redshift Cluster Management Guide</i>.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotCopyGrant {
    /// <p>The name of the snapshot copy grant.</p>
    pub snapshot_copy_grant_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the customer master key (CMK) in Amazon Web Services KMS to which
    /// Amazon Redshift is granted permission.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>A list of tag instances.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for SnapshotCopyGrant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotCopyGrant");
        formatter.field("snapshot_copy_grant_name", &self.snapshot_copy_grant_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`SnapshotCopyGrant`](crate::model::SnapshotCopyGrant)
pub mod snapshot_copy_grant {
    /// A builder for [`SnapshotCopyGrant`](crate::model::SnapshotCopyGrant)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_copy_grant_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the snapshot copy grant.</p>
        pub fn snapshot_copy_grant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_copy_grant_name = Some(input.into());
            self
        }
        /// <p>The name of the snapshot copy grant.</p>
        pub fn set_snapshot_copy_grant_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_copy_grant_name = input;
            self
        }
        /// <p>The unique identifier of the customer master key (CMK) in Amazon Web Services KMS to which
        /// Amazon Redshift is granted permission.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the customer master key (CMK) in Amazon Web Services KMS to which
        /// Amazon Redshift is granted permission.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tag instances.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of tag instances.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotCopyGrant`](crate::model::SnapshotCopyGrant)
        pub fn build(self) -> crate::model::SnapshotCopyGrant {
            crate::model::SnapshotCopyGrant {
                snapshot_copy_grant_name: self.snapshot_copy_grant_name,
                kms_key_id: self.kms_key_id,
                tags: self.tags,
            }
        }
    }
}
impl SnapshotCopyGrant {
    /// Creates a new builder-style object to manufacture [`SnapshotCopyGrant`](crate::model::SnapshotCopyGrant)
    pub fn builder() -> crate::model::snapshot_copy_grant::Builder {
        crate::model::snapshot_copy_grant::Builder::default()
    }
}

/// <p>Describes a scheduled action. You can use a scheduled action to trigger some Amazon Redshift API operations on a schedule.
/// For information about which API operations can be scheduled, see  <a>ScheduledActionType</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledAction {
    /// <p>The name of the scheduled action. </p>
    pub scheduled_action_name: std::option::Option<std::string::String>,
    /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
    /// <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
    pub target_action: std::option::Option<crate::model::ScheduledActionType>,
    /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
    /// Schedule invocations must be separated by at least one hour.</p>
    /// <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
    /// <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
    /// For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
    /// in the <i>Amazon CloudWatch Events User Guide</i>.</p>
    pub schedule: std::option::Option<std::string::String>,
    /// <p>The IAM role to assume to run the scheduled action.
    /// This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
    /// This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
    ///
    /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
    /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
    /// in the <i>Amazon Redshift Cluster Management Guide</i>.
    /// </p>
    pub iam_role: std::option::Option<std::string::String>,
    /// <p>The description of the scheduled action. </p>
    pub scheduled_action_description: std::option::Option<std::string::String>,
    /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
    pub state: std::option::Option<crate::model::ScheduledActionState>,
    /// <p>List of times when the scheduled action will run. </p>
    pub next_invocations: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
    /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for ScheduledAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledAction");
        formatter.field("scheduled_action_name", &self.scheduled_action_name);
        formatter.field("target_action", &self.target_action);
        formatter.field("schedule", &self.schedule);
        formatter.field("iam_role", &self.iam_role);
        formatter.field(
            "scheduled_action_description",
            &self.scheduled_action_description,
        );
        formatter.field("state", &self.state);
        formatter.field("next_invocations", &self.next_invocations);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.finish()
    }
}
/// See [`ScheduledAction`](crate::model::ScheduledAction)
pub mod scheduled_action {
    /// A builder for [`ScheduledAction`](crate::model::ScheduledAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_action_name: std::option::Option<std::string::String>,
        pub(crate) target_action: std::option::Option<crate::model::ScheduledActionType>,
        pub(crate) schedule: std::option::Option<std::string::String>,
        pub(crate) iam_role: std::option::Option<std::string::String>,
        pub(crate) scheduled_action_description: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ScheduledActionState>,
        pub(crate) next_invocations: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the scheduled action. </p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_action_name = Some(input.into());
            self
        }
        /// <p>The name of the scheduled action. </p>
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_name = input;
            self
        }
        /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
        /// <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
        pub fn target_action(mut self, input: crate::model::ScheduledActionType) -> Self {
            self.target_action = Some(input);
            self
        }
        /// <p>A JSON format string of the Amazon Redshift API operation with input parameters. </p>
        /// <p>"<code>{\"ResizeCluster\":{\"NodeType\":\"ds2.8xlarge\",\"ClusterIdentifier\":\"my-test-cluster\",\"NumberOfNodes\":3}}</code>". </p>
        pub fn set_target_action(
            mut self,
            input: std::option::Option<crate::model::ScheduledActionType>,
        ) -> Self {
            self.target_action = input;
            self
        }
        /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
        /// Schedule invocations must be separated by at least one hour.</p>
        /// <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
        /// <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
        /// For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
        /// in the <i>Amazon CloudWatch Events User Guide</i>.</p>
        pub fn schedule(mut self, input: impl Into<std::string::String>) -> Self {
            self.schedule = Some(input.into());
            self
        }
        /// <p>The schedule for a one-time (at format) or recurring (cron format) scheduled action.
        /// Schedule invocations must be separated by at least one hour.</p>
        /// <p>Format of at expressions is "<code>at(yyyy-mm-ddThh:mm:ss)</code>". For example, "<code>at(2016-03-04T17:27:00)</code>".</p>
        /// <p>Format of cron expressions is "<code>cron(Minutes Hours Day-of-month Month Day-of-week Year)</code>".
        /// For example, "<code>cron(0 10 ? * MON *)</code>". For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions">Cron Expressions</a>
        /// in the <i>Amazon CloudWatch Events User Guide</i>.</p>
        pub fn set_schedule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The IAM role to assume to run the scheduled action.
        /// This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
        /// This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
        ///
        /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.
        /// </p>
        pub fn iam_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role = Some(input.into());
            self
        }
        /// <p>The IAM role to assume to run the scheduled action.
        /// This IAM role must have permission to run the Amazon Redshift API operation in the scheduled action.
        /// This IAM role must allow the Amazon Redshift scheduler (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.
        ///
        /// For more information about the IAM role to use with the Amazon Redshift scheduler, see
        /// <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html">Using Identity-Based Policies for Amazon Redshift</a>
        /// in the <i>Amazon Redshift Cluster Management Guide</i>.
        /// </p>
        pub fn set_iam_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role = input;
            self
        }
        /// <p>The description of the scheduled action. </p>
        pub fn scheduled_action_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.scheduled_action_description = Some(input.into());
            self
        }
        /// <p>The description of the scheduled action. </p>
        pub fn set_scheduled_action_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_description = input;
            self
        }
        /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
        pub fn state(mut self, input: crate::model::ScheduledActionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the scheduled action. For example, <code>DISABLED</code>. </p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ScheduledActionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Appends an item to `next_invocations`.
        ///
        /// To override the contents of this collection use [`set_next_invocations`](Self::set_next_invocations).
        ///
        /// <p>List of times when the scheduled action will run. </p>
        pub fn next_invocations(mut self, input: impl Into<aws_smithy_types::Instant>) -> Self {
            let mut v = self.next_invocations.unwrap_or_default();
            v.push(input.into());
            self.next_invocations = Some(v);
            self
        }
        /// <p>List of times when the scheduled action will run. </p>
        pub fn set_next_invocations(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::Instant>>,
        ) -> Self {
            self.next_invocations = input;
            self
        }
        /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger. </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger. </p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledAction`](crate::model::ScheduledAction)
        pub fn build(self) -> crate::model::ScheduledAction {
            crate::model::ScheduledAction {
                scheduled_action_name: self.scheduled_action_name,
                target_action: self.target_action,
                schedule: self.schedule,
                iam_role: self.iam_role,
                scheduled_action_description: self.scheduled_action_description,
                state: self.state,
                next_invocations: self.next_invocations,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl ScheduledAction {
    /// Creates a new builder-style object to manufacture [`ScheduledAction`](crate::model::ScheduledAction)
    pub fn builder() -> crate::model::scheduled_action::Builder {
        crate::model::scheduled_action::Builder::default()
    }
}

/// <p>A set of elements to filter the returned scheduled actions. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledActionFilter {
    /// <p>The type of element to filter. </p>
    pub name: std::option::Option<crate::model::ScheduledActionFilterName>,
    /// <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ScheduledActionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledActionFilter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`ScheduledActionFilter`](crate::model::ScheduledActionFilter)
pub mod scheduled_action_filter {
    /// A builder for [`ScheduledActionFilter`](crate::model::ScheduledActionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::ScheduledActionFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The type of element to filter. </p>
        pub fn name(mut self, input: crate::model::ScheduledActionFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The type of element to filter. </p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::ScheduledActionFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>List of values. Compare if the value (of type defined by <code>Name</code>) equals an item in the list of scheduled actions. </p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledActionFilter`](crate::model::ScheduledActionFilter)
        pub fn build(self) -> crate::model::ScheduledActionFilter {
            crate::model::ScheduledActionFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl ScheduledActionFilter {
    /// Creates a new builder-style object to manufacture [`ScheduledActionFilter`](crate::model::ScheduledActionFilter)
    pub fn builder() -> crate::model::scheduled_action_filter::Builder {
        crate::model::scheduled_action_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledActionFilterName {
    #[allow(missing_docs)] // documentation missing in model
    ClusterIdentifier,
    #[allow(missing_docs)] // documentation missing in model
    IamRole,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduledActionFilterName {
    fn from(s: &str) -> Self {
        match s {
            "cluster-identifier" => ScheduledActionFilterName::ClusterIdentifier,
            "iam-role" => ScheduledActionFilterName::IamRole,
            other => ScheduledActionFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduledActionFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledActionFilterName::from(s))
    }
}
impl ScheduledActionFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledActionFilterName::ClusterIdentifier => "cluster-identifier",
            ScheduledActionFilterName::IamRole => "iam-role",
            ScheduledActionFilterName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["cluster-identifier", "iam-role"]
    }
}
impl AsRef<str> for ScheduledActionFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduledActionTypeValues {
    #[allow(missing_docs)] // documentation missing in model
    PauseCluster,
    #[allow(missing_docs)] // documentation missing in model
    ResizeCluster,
    #[allow(missing_docs)] // documentation missing in model
    ResumeCluster,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScheduledActionTypeValues {
    fn from(s: &str) -> Self {
        match s {
            "PauseCluster" => ScheduledActionTypeValues::PauseCluster,
            "ResizeCluster" => ScheduledActionTypeValues::ResizeCluster,
            "ResumeCluster" => ScheduledActionTypeValues::ResumeCluster,
            other => ScheduledActionTypeValues::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScheduledActionTypeValues {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduledActionTypeValues::from(s))
    }
}
impl ScheduledActionTypeValues {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduledActionTypeValues::PauseCluster => "PauseCluster",
            ScheduledActionTypeValues::ResizeCluster => "ResizeCluster",
            ScheduledActionTypeValues::ResumeCluster => "ResumeCluster",
            ScheduledActionTypeValues::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PauseCluster", "ResizeCluster", "ResumeCluster"]
    }
}
impl AsRef<str> for ScheduledActionTypeValues {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a partner integration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PartnerIntegrationInfo {
    /// <p>The name of the database that receives data from a partner.</p>
    pub database_name: std::option::Option<std::string::String>,
    /// <p>The name of the partner.</p>
    pub partner_name: std::option::Option<std::string::String>,
    /// <p>The partner integration status.</p>
    pub status: std::option::Option<crate::model::PartnerIntegrationStatus>,
    /// <p>The status message provided by the partner.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The date (UTC) that the partner integration was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
    pub updated_at: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for PartnerIntegrationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PartnerIntegrationInfo");
        formatter.field("database_name", &self.database_name);
        formatter.field("partner_name", &self.partner_name);
        formatter.field("status", &self.status);
        formatter.field("status_message", &self.status_message);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`PartnerIntegrationInfo`](crate::model::PartnerIntegrationInfo)
pub mod partner_integration_info {
    /// A builder for [`PartnerIntegrationInfo`](crate::model::PartnerIntegrationInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_name: std::option::Option<std::string::String>,
        pub(crate) partner_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::PartnerIntegrationStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the database that receives data from a partner.</p>
        pub fn database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_name = Some(input.into());
            self
        }
        /// <p>The name of the database that receives data from a partner.</p>
        pub fn set_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_name = input;
            self
        }
        /// <p>The name of the partner.</p>
        pub fn partner_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.partner_name = Some(input.into());
            self
        }
        /// <p>The name of the partner.</p>
        pub fn set_partner_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.partner_name = input;
            self
        }
        /// <p>The partner integration status.</p>
        pub fn status(mut self, input: crate::model::PartnerIntegrationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The partner integration status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PartnerIntegrationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The status message provided by the partner.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message provided by the partner.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The date (UTC) that the partner integration was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date (UTC) that the partner integration was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date (UTC) that the partner integration status was last updated by the partner.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`PartnerIntegrationInfo`](crate::model::PartnerIntegrationInfo)
        pub fn build(self) -> crate::model::PartnerIntegrationInfo {
            crate::model::PartnerIntegrationInfo {
                database_name: self.database_name,
                partner_name: self.partner_name,
                status: self.status,
                status_message: self.status_message,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl PartnerIntegrationInfo {
    /// Creates a new builder-style object to manufacture [`PartnerIntegrationInfo`](crate::model::PartnerIntegrationInfo)
    pub fn builder() -> crate::model::partner_integration_info::Builder {
        crate::model::partner_integration_info::Builder::default()
    }
}

/// <p>Describes an orderable cluster option.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OrderableClusterOption {
    /// <p>The version of the orderable cluster.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The cluster type, for example <code>multi-node</code>. </p>
    pub cluster_type: std::option::Option<std::string::String>,
    /// <p>The node type for the orderable cluster.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>A list of availability zones for the orderable cluster.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
}
impl std::fmt::Debug for OrderableClusterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OrderableClusterOption");
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field("cluster_type", &self.cluster_type);
        formatter.field("node_type", &self.node_type);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.finish()
    }
}
/// See [`OrderableClusterOption`](crate::model::OrderableClusterOption)
pub mod orderable_cluster_option {
    /// A builder for [`OrderableClusterOption`](crate::model::OrderableClusterOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) cluster_type: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) availability_zones:
            std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
    }
    impl Builder {
        /// <p>The version of the orderable cluster.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The version of the orderable cluster.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The cluster type, for example <code>multi-node</code>. </p>
        pub fn cluster_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_type = Some(input.into());
            self
        }
        /// <p>The cluster type, for example <code>multi-node</code>. </p>
        pub fn set_cluster_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cluster_type = input;
            self
        }
        /// <p>The node type for the orderable cluster.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type for the orderable cluster.</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// Appends an item to `availability_zones`.
        ///
        /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
        ///
        /// <p>A list of availability zones for the orderable cluster.</p>
        pub fn availability_zones(
            mut self,
            input: impl Into<crate::model::AvailabilityZone>,
        ) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        /// <p>A list of availability zones for the orderable cluster.</p>
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AvailabilityZone>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        /// Consumes the builder and constructs a [`OrderableClusterOption`](crate::model::OrderableClusterOption)
        pub fn build(self) -> crate::model::OrderableClusterOption {
            crate::model::OrderableClusterOption {
                cluster_version: self.cluster_version,
                cluster_type: self.cluster_type,
                node_type: self.node_type,
                availability_zones: self.availability_zones,
            }
        }
    }
}
impl OrderableClusterOption {
    /// Creates a new builder-style object to manufacture [`OrderableClusterOption`](crate::model::OrderableClusterOption)
    pub fn builder() -> crate::model::orderable_cluster_option::Builder {
        crate::model::orderable_cluster_option::Builder::default()
    }
}

/// <p>A list of node configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeConfigurationOption {
    /// <p>The node type, such as, "ds2.8xlarge".</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The number of nodes.</p>
    pub number_of_nodes: i32,
    /// <p>The estimated disk utilizaton percentage.</p>
    pub estimated_disk_utilization_percent: std::option::Option<f64>,
    /// <p>The category of the node configuration recommendation.</p>
    pub mode: std::option::Option<crate::model::Mode>,
}
impl std::fmt::Debug for NodeConfigurationOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeConfigurationOption");
        formatter.field("node_type", &self.node_type);
        formatter.field("number_of_nodes", &self.number_of_nodes);
        formatter.field(
            "estimated_disk_utilization_percent",
            &self.estimated_disk_utilization_percent,
        );
        formatter.field("mode", &self.mode);
        formatter.finish()
    }
}
/// See [`NodeConfigurationOption`](crate::model::NodeConfigurationOption)
pub mod node_configuration_option {
    /// A builder for [`NodeConfigurationOption`](crate::model::NodeConfigurationOption)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) number_of_nodes: std::option::Option<i32>,
        pub(crate) estimated_disk_utilization_percent: std::option::Option<f64>,
        pub(crate) mode: std::option::Option<crate::model::Mode>,
    }
    impl Builder {
        /// <p>The node type, such as, "ds2.8xlarge".</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        /// <p>The node type, such as, "ds2.8xlarge".</p>
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The number of nodes.</p>
        pub fn number_of_nodes(mut self, input: i32) -> Self {
            self.number_of_nodes = Some(input);
            self
        }
        /// <p>The number of nodes.</p>
        pub fn set_number_of_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_nodes = input;
            self
        }
        /// <p>The estimated disk utilizaton percentage.</p>
        pub fn estimated_disk_utilization_percent(mut self, input: f64) -> Self {
            self.estimated_disk_utilization_percent = Some(input);
            self
        }
        /// <p>The estimated disk utilizaton percentage.</p>
        pub fn set_estimated_disk_utilization_percent(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.estimated_disk_utilization_percent = input;
            self
        }
        /// <p>The category of the node configuration recommendation.</p>
        pub fn mode(mut self, input: crate::model::Mode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The category of the node configuration recommendation.</p>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::Mode>) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeConfigurationOption`](crate::model::NodeConfigurationOption)
        pub fn build(self) -> crate::model::NodeConfigurationOption {
            crate::model::NodeConfigurationOption {
                node_type: self.node_type,
                number_of_nodes: self.number_of_nodes.unwrap_or_default(),
                estimated_disk_utilization_percent: self.estimated_disk_utilization_percent,
                mode: self.mode,
            }
        }
    }
}
impl NodeConfigurationOption {
    /// Creates a new builder-style object to manufacture [`NodeConfigurationOption`](crate::model::NodeConfigurationOption)
    pub fn builder() -> crate::model::node_configuration_option::Builder {
        crate::model::node_configuration_option::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Mode {
    #[allow(missing_docs)] // documentation missing in model
    HighPerformance,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Mode {
    fn from(s: &str) -> Self {
        match s {
            "high-performance" => Mode::HighPerformance,
            "standard" => Mode::Standard,
            other => Mode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Mode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Mode::from(s))
    }
}
impl Mode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Mode::HighPerformance => "high-performance",
            Mode::Standard => "standard",
            Mode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["high-performance", "standard"]
    }
}
impl AsRef<str> for Mode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A set of elements to filter the returned node configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeConfigurationOptionsFilter {
    /// <p>The name of the element to filter.</p>
    pub name: std::option::Option<crate::model::NodeConfigurationOptionsFilterName>,
    /// <p>The filter operator.
    /// If filter Name is NodeType only the 'in' operator is supported.
    /// Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
    /// Provide two values to evaluate for 'between'.
    /// Provide a list of values for 'in'.</p>
    pub operator: std::option::Option<crate::model::OperatorType>,
    /// <p>List of values. Compare Name using Operator to Values.
    /// If filter Name is NumberOfNodes, then values can range from 0 to 200.
    /// If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
    /// For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for NodeConfigurationOptionsFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeConfigurationOptionsFilter");
        formatter.field("name", &self.name);
        formatter.field("operator", &self.operator);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`NodeConfigurationOptionsFilter`](crate::model::NodeConfigurationOptionsFilter)
pub mod node_configuration_options_filter {
    /// A builder for [`NodeConfigurationOptionsFilter`](crate::model::NodeConfigurationOptionsFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::NodeConfigurationOptionsFilterName>,
        pub(crate) operator: std::option::Option<crate::model::OperatorType>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the element to filter.</p>
        pub fn name(mut self, input: crate::model::NodeConfigurationOptionsFilterName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The name of the element to filter.</p>
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::NodeConfigurationOptionsFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        /// <p>The filter operator.
        /// If filter Name is NodeType only the 'in' operator is supported.
        /// Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
        /// Provide two values to evaluate for 'between'.
        /// Provide a list of values for 'in'.</p>
        pub fn operator(mut self, input: crate::model::OperatorType) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>The filter operator.
        /// If filter Name is NodeType only the 'in' operator is supported.
        /// Provide one value to evaluate for 'eq', 'lt', 'le', 'gt', and 'ge'.
        /// Provide two values to evaluate for 'between'.
        /// Provide a list of values for 'in'.</p>
        pub fn set_operator(
            mut self,
            input: std::option::Option<crate::model::OperatorType>,
        ) -> Self {
            self.operator = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>List of values. Compare Name using Operator to Values.
        /// If filter Name is NumberOfNodes, then values can range from 0 to 200.
        /// If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
        /// For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>List of values. Compare Name using Operator to Values.
        /// If filter Name is NumberOfNodes, then values can range from 0 to 200.
        /// If filter Name is EstimatedDiskUtilizationPercent, then values can range from 0 to 100.
        /// For example, filter NumberOfNodes (name) GT (operator) 3 (values).</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeConfigurationOptionsFilter`](crate::model::NodeConfigurationOptionsFilter)
        pub fn build(self) -> crate::model::NodeConfigurationOptionsFilter {
            crate::model::NodeConfigurationOptionsFilter {
                name: self.name,
                operator: self.operator,
                values: self.values,
            }
        }
    }
}
impl NodeConfigurationOptionsFilter {
    /// Creates a new builder-style object to manufacture [`NodeConfigurationOptionsFilter`](crate::model::NodeConfigurationOptionsFilter)
    pub fn builder() -> crate::model::node_configuration_options_filter::Builder {
        crate::model::node_configuration_options_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OperatorType {
    #[allow(missing_docs)] // documentation missing in model
    Between,
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OperatorType {
    fn from(s: &str) -> Self {
        match s {
            "between" => OperatorType::Between,
            "eq" => OperatorType::Eq,
            "ge" => OperatorType::Ge,
            "gt" => OperatorType::Gt,
            "in" => OperatorType::In,
            "le" => OperatorType::Le,
            "lt" => OperatorType::Lt,
            other => OperatorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OperatorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OperatorType::from(s))
    }
}
impl OperatorType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OperatorType::Between => "between",
            OperatorType::Eq => "eq",
            OperatorType::Ge => "ge",
            OperatorType::Gt => "gt",
            OperatorType::In => "in",
            OperatorType::Le => "le",
            OperatorType::Lt => "lt",
            OperatorType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["between", "eq", "ge", "gt", "in", "le", "lt"]
    }
}
impl AsRef<str> for OperatorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NodeConfigurationOptionsFilterName {
    #[allow(missing_docs)] // documentation missing in model
    EstimatedDiskUtilizationPercent,
    #[allow(missing_docs)] // documentation missing in model
    Mode,
    #[allow(missing_docs)] // documentation missing in model
    NodeType,
    #[allow(missing_docs)] // documentation missing in model
    NumNodes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NodeConfigurationOptionsFilterName {
    fn from(s: &str) -> Self {
        match s {
            "EstimatedDiskUtilizationPercent" => {
                NodeConfigurationOptionsFilterName::EstimatedDiskUtilizationPercent
            }
            "Mode" => NodeConfigurationOptionsFilterName::Mode,
            "NodeType" => NodeConfigurationOptionsFilterName::NodeType,
            "NumberOfNodes" => NodeConfigurationOptionsFilterName::NumNodes,
            other => NodeConfigurationOptionsFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NodeConfigurationOptionsFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NodeConfigurationOptionsFilterName::from(s))
    }
}
impl NodeConfigurationOptionsFilterName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NodeConfigurationOptionsFilterName::EstimatedDiskUtilizationPercent => {
                "EstimatedDiskUtilizationPercent"
            }
            NodeConfigurationOptionsFilterName::Mode => "Mode",
            NodeConfigurationOptionsFilterName::NodeType => "NodeType",
            NodeConfigurationOptionsFilterName::NumNodes => "NumberOfNodes",
            NodeConfigurationOptionsFilterName::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "EstimatedDiskUtilizationPercent",
            "Mode",
            "NodeType",
            "NumberOfNodes",
        ]
    }
}
impl AsRef<str> for NodeConfigurationOptionsFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActionType {
    #[allow(missing_docs)] // documentation missing in model
    RecommendNodeConfig,
    #[allow(missing_docs)] // documentation missing in model
    ResizeCluster,
    #[allow(missing_docs)] // documentation missing in model
    RestoreCluster,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActionType {
    fn from(s: &str) -> Self {
        match s {
            "recommend-node-config" => ActionType::RecommendNodeConfig,
            "resize-cluster" => ActionType::ResizeCluster,
            "restore-cluster" => ActionType::RestoreCluster,
            other => ActionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActionType::from(s))
    }
}
impl ActionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ActionType::RecommendNodeConfig => "recommend-node-config",
            ActionType::ResizeCluster => "resize-cluster",
            ActionType::RestoreCluster => "restore-cluster",
            ActionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["recommend-node-config", "resize-cluster", "restore-cluster"]
    }
}
impl AsRef<str> for ActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information about an HSM configuration, which is an object that describes
/// to Amazon Redshift clusters the information they require to connect to an HSM where they can
/// store database encryption keys.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HsmConfiguration {
    /// <p>The name of the Amazon Redshift HSM configuration.</p>
    pub hsm_configuration_identifier: std::option::Option<std::string::String>,
    /// <p>A text description of the HSM configuration.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
    pub hsm_ip_address: std::option::Option<std::string::String>,
    /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
    /// database encryption keys.</p>
    pub hsm_partition_name: std::option::Option<std::string::String>,
    /// <p>The list of tags for the HSM configuration.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for HsmConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HsmConfiguration");
        formatter.field(
            "hsm_configuration_identifier",
            &self.hsm_configuration_identifier,
        );
        formatter.field("description", &self.description);
        formatter.field("hsm_ip_address", &self.hsm_ip_address);
        formatter.field("hsm_partition_name", &self.hsm_partition_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`HsmConfiguration`](crate::model::HsmConfiguration)
pub mod hsm_configuration {
    /// A builder for [`HsmConfiguration`](crate::model::HsmConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hsm_configuration_identifier: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) hsm_ip_address: std::option::Option<std::string::String>,
        pub(crate) hsm_partition_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the Amazon Redshift HSM configuration.</p>
        pub fn hsm_configuration_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Redshift HSM configuration.</p>
        pub fn set_hsm_configuration_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_configuration_identifier = input;
            self
        }
        /// <p>A text description of the HSM configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A text description of the HSM configuration.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
        pub fn hsm_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.hsm_ip_address = Some(input.into());
            self
        }
        /// <p>The IP address that the Amazon Redshift cluster must use to access the HSM.</p>
        pub fn set_hsm_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_ip_address = input;
            self
        }
        /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
        /// database encryption keys.</p>
        pub fn hsm_partition_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.hsm_partition_name = Some(input.into());
            self
        }
        /// <p>The name of the partition in the HSM where the Amazon Redshift clusters will store their
        /// database encryption keys.</p>
        pub fn set_hsm_partition_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_partition_name = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the HSM configuration.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the HSM configuration.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HsmConfiguration`](crate::model::HsmConfiguration)
        pub fn build(self) -> crate::model::HsmConfiguration {
            crate::model::HsmConfiguration {
                hsm_configuration_identifier: self.hsm_configuration_identifier,
                description: self.description,
                hsm_ip_address: self.hsm_ip_address,
                hsm_partition_name: self.hsm_partition_name,
                tags: self.tags,
            }
        }
    }
}
impl HsmConfiguration {
    /// Creates a new builder-style object to manufacture [`HsmConfiguration`](crate::model::HsmConfiguration)
    pub fn builder() -> crate::model::hsm_configuration::Builder {
        crate::model::hsm_configuration::Builder::default()
    }
}

/// <p>Returns information about an HSM client certificate. The certificate is stored in a
/// secure Hardware Storage Module (HSM), and used by the Amazon Redshift cluster to encrypt data
/// files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HsmClientCertificate {
    /// <p>The identifier of the HSM client certificate.</p>
    pub hsm_client_certificate_identifier: std::option::Option<std::string::String>,
    /// <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
    /// register the public key in the HSM.</p>
    pub hsm_client_certificate_public_key: std::option::Option<std::string::String>,
    /// <p>The list of tags for the HSM client certificate.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for HsmClientCertificate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HsmClientCertificate");
        formatter.field(
            "hsm_client_certificate_identifier",
            &self.hsm_client_certificate_identifier,
        );
        formatter.field(
            "hsm_client_certificate_public_key",
            &self.hsm_client_certificate_public_key,
        );
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`HsmClientCertificate`](crate::model::HsmClientCertificate)
pub mod hsm_client_certificate {
    /// A builder for [`HsmClientCertificate`](crate::model::HsmClientCertificate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hsm_client_certificate_identifier: std::option::Option<std::string::String>,
        pub(crate) hsm_client_certificate_public_key: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The identifier of the HSM client certificate.</p>
        pub fn hsm_client_certificate_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the HSM client certificate.</p>
        pub fn set_hsm_client_certificate_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_identifier = input;
            self
        }
        /// <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
        /// register the public key in the HSM.</p>
        pub fn hsm_client_certificate_public_key(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_public_key = Some(input.into());
            self
        }
        /// <p>The public key that the Amazon Redshift cluster will use to connect to the HSM. You must
        /// register the public key in the HSM.</p>
        pub fn set_hsm_client_certificate_public_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hsm_client_certificate_public_key = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the HSM client certificate.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the HSM client certificate.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`HsmClientCertificate`](crate::model::HsmClientCertificate)
        pub fn build(self) -> crate::model::HsmClientCertificate {
            crate::model::HsmClientCertificate {
                hsm_client_certificate_identifier: self.hsm_client_certificate_identifier,
                hsm_client_certificate_public_key: self.hsm_client_certificate_public_key,
                tags: self.tags,
            }
        }
    }
}
impl HsmClientCertificate {
    /// Creates a new builder-style object to manufacture [`HsmClientCertificate`](crate::model::HsmClientCertificate)
    pub fn builder() -> crate::model::hsm_client_certificate::Builder {
        crate::model::hsm_client_certificate::Builder::default()
    }
}

/// <p>Describes an event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Event {
    /// <p>The identifier for the source of the event.</p>
    pub source_identifier: std::option::Option<std::string::String>,
    /// <p>The source type for this event.</p>
    pub source_type: std::option::Option<crate::model::SourceType>,
    /// <p>The text of this event.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>A list of the event categories.</p>
    /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
    pub event_categories: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The severity of the event.</p>
    /// <p>Values: ERROR, INFO</p>
    pub severity: std::option::Option<std::string::String>,
    /// <p>The date and time of the event.</p>
    pub date: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The identifier of the event.</p>
    pub event_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Event");
        formatter.field("source_identifier", &self.source_identifier);
        formatter.field("source_type", &self.source_type);
        formatter.field("message", &self.message);
        formatter.field("event_categories", &self.event_categories);
        formatter.field("severity", &self.severity);
        formatter.field("date", &self.date);
        formatter.field("event_id", &self.event_id);
        formatter.finish()
    }
}
/// See [`Event`](crate::model::Event)
pub mod event {
    /// A builder for [`Event`](crate::model::Event)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_identifier: std::option::Option<std::string::String>,
        pub(crate) source_type: std::option::Option<crate::model::SourceType>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) event_categories: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) severity: std::option::Option<std::string::String>,
        pub(crate) date: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) event_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier for the source of the event.</p>
        pub fn source_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_identifier = Some(input.into());
            self
        }
        /// <p>The identifier for the source of the event.</p>
        pub fn set_source_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_identifier = input;
            self
        }
        /// <p>The source type for this event.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>The source type for this event.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// <p>The text of this event.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The text of this event.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `event_categories`.
        ///
        /// To override the contents of this collection use [`set_event_categories`](Self::set_event_categories).
        ///
        /// <p>A list of the event categories.</p>
        /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
        pub fn event_categories(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_categories.unwrap_or_default();
            v.push(input.into());
            self.event_categories = Some(v);
            self
        }
        /// <p>A list of the event categories.</p>
        /// <p>Values: Configuration, Management, Monitoring, Security, Pending</p>
        pub fn set_event_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_categories = input;
            self
        }
        /// <p>The severity of the event.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        /// <p>The severity of the event.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// <p>The date and time of the event.</p>
        pub fn date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.date = Some(input);
            self
        }
        /// <p>The date and time of the event.</p>
        pub fn set_date(mut self, input: std::option::Option<aws_smithy_types::Instant>) -> Self {
            self.date = input;
            self
        }
        /// <p>The identifier of the event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The identifier of the event.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Event`](crate::model::Event)
        pub fn build(self) -> crate::model::Event {
            crate::model::Event {
                source_identifier: self.source_identifier,
                source_type: self.source_type,
                message: self.message,
                event_categories: self.event_categories,
                severity: self.severity,
                date: self.date,
                event_id: self.event_id,
            }
        }
    }
}
impl Event {
    /// Creates a new builder-style object to manufacture [`Event`](crate::model::Event)
    pub fn builder() -> crate::model::event::Builder {
        crate::model::event::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceType {
    #[allow(missing_docs)] // documentation missing in model
    Cluster,
    #[allow(missing_docs)] // documentation missing in model
    ClusterParameterGroup,
    #[allow(missing_docs)] // documentation missing in model
    ClusterSecurityGroup,
    #[allow(missing_docs)] // documentation missing in model
    ClusterSnapshot,
    #[allow(missing_docs)] // documentation missing in model
    ScheduledAction,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SourceType {
    fn from(s: &str) -> Self {
        match s {
            "cluster" => SourceType::Cluster,
            "cluster-parameter-group" => SourceType::ClusterParameterGroup,
            "cluster-security-group" => SourceType::ClusterSecurityGroup,
            "cluster-snapshot" => SourceType::ClusterSnapshot,
            "scheduled-action" => SourceType::ScheduledAction,
            other => SourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceType::from(s))
    }
}
impl SourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceType::Cluster => "cluster",
            SourceType::ClusterParameterGroup => "cluster-parameter-group",
            SourceType::ClusterSecurityGroup => "cluster-security-group",
            SourceType::ClusterSnapshot => "cluster-snapshot",
            SourceType::ScheduledAction => "scheduled-action",
            SourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "cluster",
            "cluster-parameter-group",
            "cluster-security-group",
            "cluster-snapshot",
            "scheduled-action",
        ]
    }
}
impl AsRef<str> for SourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes event categories.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventCategoriesMap {
    /// <p>The source type, such as cluster or cluster-snapshot, that the returned categories
    /// belong to.</p>
    pub source_type: std::option::Option<std::string::String>,
    /// <p>The events in the event category.</p>
    pub events: std::option::Option<std::vec::Vec<crate::model::EventInfoMap>>,
}
impl std::fmt::Debug for EventCategoriesMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventCategoriesMap");
        formatter.field("source_type", &self.source_type);
        formatter.field("events", &self.events);
        formatter.finish()
    }
}
/// See [`EventCategoriesMap`](crate::model::EventCategoriesMap)
pub mod event_categories_map {
    /// A builder for [`EventCategoriesMap`](crate::model::EventCategoriesMap)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_type: std::option::Option<std::string::String>,
        pub(crate) events: std::option::Option<std::vec::Vec<crate::model::EventInfoMap>>,
    }
    impl Builder {
        /// <p>The source type, such as cluster or cluster-snapshot, that the returned categories
        /// belong to.</p>
        pub fn source_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_type = Some(input.into());
            self
        }
        /// <p>The source type, such as cluster or cluster-snapshot, that the returned categories
        /// belong to.</p>
        pub fn set_source_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source_type = input;
            self
        }
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The events in the event category.</p>
        pub fn events(mut self, input: impl Into<crate::model::EventInfoMap>) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input.into());
            self.events = Some(v);
            self
        }
        /// <p>The events in the event category.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EventInfoMap>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// Consumes the builder and constructs a [`EventCategoriesMap`](crate::model::EventCategoriesMap)
        pub fn build(self) -> crate::model::EventCategoriesMap {
            crate::model::EventCategoriesMap {
                source_type: self.source_type,
                events: self.events,
            }
        }
    }
}
impl EventCategoriesMap {
    /// Creates a new builder-style object to manufacture [`EventCategoriesMap`](crate::model::EventCategoriesMap)
    pub fn builder() -> crate::model::event_categories_map::Builder {
        crate::model::event_categories_map::Builder::default()
    }
}

/// <p>Describes event information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventInfoMap {
    /// <p>The identifier of an Amazon Redshift event.</p>
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The category of an Amazon Redshift event.</p>
    pub event_categories: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The description of an Amazon Redshift event.</p>
    pub event_description: std::option::Option<std::string::String>,
    /// <p>The severity of the event.</p>
    /// <p>Values: ERROR, INFO</p>
    pub severity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventInfoMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventInfoMap");
        formatter.field("event_id", &self.event_id);
        formatter.field("event_categories", &self.event_categories);
        formatter.field("event_description", &self.event_description);
        formatter.field("severity", &self.severity);
        formatter.finish()
    }
}
/// See [`EventInfoMap`](crate::model::EventInfoMap)
pub mod event_info_map {
    /// A builder for [`EventInfoMap`](crate::model::EventInfoMap)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_categories: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) event_description: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of an Amazon Redshift event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The identifier of an Amazon Redshift event.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// Appends an item to `event_categories`.
        ///
        /// To override the contents of this collection use [`set_event_categories`](Self::set_event_categories).
        ///
        /// <p>The category of an Amazon Redshift event.</p>
        pub fn event_categories(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_categories.unwrap_or_default();
            v.push(input.into());
            self.event_categories = Some(v);
            self
        }
        /// <p>The category of an Amazon Redshift event.</p>
        pub fn set_event_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_categories = input;
            self
        }
        /// <p>The description of an Amazon Redshift event.</p>
        pub fn event_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_description = Some(input.into());
            self
        }
        /// <p>The description of an Amazon Redshift event.</p>
        pub fn set_event_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_description = input;
            self
        }
        /// <p>The severity of the event.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn severity(mut self, input: impl Into<std::string::String>) -> Self {
            self.severity = Some(input.into());
            self
        }
        /// <p>The severity of the event.</p>
        /// <p>Values: ERROR, INFO</p>
        pub fn set_severity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.severity = input;
            self
        }
        /// Consumes the builder and constructs a [`EventInfoMap`](crate::model::EventInfoMap)
        pub fn build(self) -> crate::model::EventInfoMap {
            crate::model::EventInfoMap {
                event_id: self.event_id,
                event_categories: self.event_categories,
                event_description: self.event_description,
                severity: self.severity,
            }
        }
    }
}
impl EventInfoMap {
    /// Creates a new builder-style object to manufacture [`EventInfoMap`](crate::model::EventInfoMap)
    pub fn builder() -> crate::model::event_info_map::Builder {
        crate::model::event_info_map::Builder::default()
    }
}

/// <p>Describes an endpoint authorization for authorizing Redshift-managed VPC endpoint access to a cluster across Amazon Web Services accounts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointAuthorization {
    /// <p>The Amazon Web Services account ID of the cluster owner.</p>
    pub grantor: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the grantee of the cluster.</p>
    pub grantee: std::option::Option<std::string::String>,
    /// <p>The cluster identifier.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The time (UTC) when the authorization was created.</p>
    pub authorize_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The status of the cluster.</p>
    pub cluster_status: std::option::Option<std::string::String>,
    /// <p>The status of the authorization action.</p>
    pub status: std::option::Option<crate::model::AuthorizationStatus>,
    /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
    pub allowed_all_vp_cs: bool,
    /// <p>The VPCs allowed access to the cluster.</p>
    pub allowed_vp_cs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
    pub endpoint_count: i32,
}
impl std::fmt::Debug for EndpointAuthorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointAuthorization");
        formatter.field("grantor", &self.grantor);
        formatter.field("grantee", &self.grantee);
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("authorize_time", &self.authorize_time);
        formatter.field("cluster_status", &self.cluster_status);
        formatter.field("status", &self.status);
        formatter.field("allowed_all_vp_cs", &self.allowed_all_vp_cs);
        formatter.field("allowed_vp_cs", &self.allowed_vp_cs);
        formatter.field("endpoint_count", &self.endpoint_count);
        formatter.finish()
    }
}
/// See [`EndpointAuthorization`](crate::model::EndpointAuthorization)
pub mod endpoint_authorization {
    /// A builder for [`EndpointAuthorization`](crate::model::EndpointAuthorization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grantor: std::option::Option<std::string::String>,
        pub(crate) grantee: std::option::Option<std::string::String>,
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) authorize_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) cluster_status: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AuthorizationStatus>,
        pub(crate) allowed_all_vp_cs: std::option::Option<bool>,
        pub(crate) allowed_vp_cs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) endpoint_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Web Services account ID of the cluster owner.</p>
        pub fn grantor(mut self, input: impl Into<std::string::String>) -> Self {
            self.grantor = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the cluster owner.</p>
        pub fn set_grantor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grantor = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the grantee of the cluster.</p>
        pub fn grantee(mut self, input: impl Into<std::string::String>) -> Self {
            self.grantee = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the grantee of the cluster.</p>
        pub fn set_grantee(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grantee = input;
            self
        }
        /// <p>The cluster identifier.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The cluster identifier.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The time (UTC) when the authorization was created.</p>
        pub fn authorize_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.authorize_time = Some(input);
            self
        }
        /// <p>The time (UTC) when the authorization was created.</p>
        pub fn set_authorize_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.authorize_time = input;
            self
        }
        /// <p>The status of the cluster.</p>
        pub fn cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_status = Some(input.into());
            self
        }
        /// <p>The status of the cluster.</p>
        pub fn set_cluster_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_status = input;
            self
        }
        /// <p>The status of the authorization action.</p>
        pub fn status(mut self, input: crate::model::AuthorizationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the authorization action.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AuthorizationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
        pub fn allowed_all_vp_cs(mut self, input: bool) -> Self {
            self.allowed_all_vp_cs = Some(input);
            self
        }
        /// <p>Indicates whether all VPCs in the grantee account are allowed access to the cluster.</p>
        pub fn set_allowed_all_vp_cs(mut self, input: std::option::Option<bool>) -> Self {
            self.allowed_all_vp_cs = input;
            self
        }
        /// Appends an item to `allowed_vp_cs`.
        ///
        /// To override the contents of this collection use [`set_allowed_vp_cs`](Self::set_allowed_vp_cs).
        ///
        /// <p>The VPCs allowed access to the cluster.</p>
        pub fn allowed_vp_cs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_vp_cs.unwrap_or_default();
            v.push(input.into());
            self.allowed_vp_cs = Some(v);
            self
        }
        /// <p>The VPCs allowed access to the cluster.</p>
        pub fn set_allowed_vp_cs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_vp_cs = input;
            self
        }
        /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
        pub fn endpoint_count(mut self, input: i32) -> Self {
            self.endpoint_count = Some(input);
            self
        }
        /// <p>The number of Redshift-managed VPC endpoints created for the authorization.</p>
        pub fn set_endpoint_count(mut self, input: std::option::Option<i32>) -> Self {
            self.endpoint_count = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAuthorization`](crate::model::EndpointAuthorization)
        pub fn build(self) -> crate::model::EndpointAuthorization {
            crate::model::EndpointAuthorization {
                grantor: self.grantor,
                grantee: self.grantee,
                cluster_identifier: self.cluster_identifier,
                authorize_time: self.authorize_time,
                cluster_status: self.cluster_status,
                status: self.status,
                allowed_all_vp_cs: self.allowed_all_vp_cs.unwrap_or_default(),
                allowed_vp_cs: self.allowed_vp_cs,
                endpoint_count: self.endpoint_count.unwrap_or_default(),
            }
        }
    }
}
impl EndpointAuthorization {
    /// Creates a new builder-style object to manufacture [`EndpointAuthorization`](crate::model::EndpointAuthorization)
    pub fn builder() -> crate::model::endpoint_authorization::Builder {
        crate::model::endpoint_authorization::Builder::default()
    }
}

/// <p>Describes a Redshift-managed VPC endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointAccess {
    /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID of the owner of the cluster.</p>
    pub resource_owner: std::option::Option<std::string::String>,
    /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
    pub subnet_group_name: std::option::Option<std::string::String>,
    /// <p>The status of the endpoint.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The name of the endpoint.</p>
    pub endpoint_name: std::option::Option<std::string::String>,
    /// <p>The time (UTC) that the endpoint was created.</p>
    pub endpoint_create_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The port number on which the cluster accepts incoming connections.</p>
    pub port: i32,
    /// <p>The DNS address of the endpoint.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The security groups associated with the endpoint.</p>
    pub vpc_security_groups:
        std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
    /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
    pub vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
}
impl std::fmt::Debug for EndpointAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointAccess");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("resource_owner", &self.resource_owner);
        formatter.field("subnet_group_name", &self.subnet_group_name);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("endpoint_name", &self.endpoint_name);
        formatter.field("endpoint_create_time", &self.endpoint_create_time);
        formatter.field("port", &self.port);
        formatter.field("address", &self.address);
        formatter.field("vpc_security_groups", &self.vpc_security_groups);
        formatter.field("vpc_endpoint", &self.vpc_endpoint);
        formatter.finish()
    }
}
/// See [`EndpointAccess`](crate::model::EndpointAccess)
pub mod endpoint_access {
    /// A builder for [`EndpointAccess`](crate::model::EndpointAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) resource_owner: std::option::Option<std::string::String>,
        pub(crate) subnet_group_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) endpoint_name: std::option::Option<std::string::String>,
        pub(crate) endpoint_create_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) port: std::option::Option<i32>,
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) vpc_security_groups:
            std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        pub(crate) vpc_endpoint: std::option::Option<crate::model::VpcEndpoint>,
    }
    impl Builder {
        /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The cluster identifier of the cluster associated with the endpoint.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the cluster.</p>
        pub fn resource_owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID of the owner of the cluster.</p>
        pub fn set_resource_owner(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_owner = input;
            self
        }
        /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
        pub fn subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_group_name = Some(input.into());
            self
        }
        /// <p>The subnet group name where Amazon Redshift chooses to deploy the endpoint.</p>
        pub fn set_subnet_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subnet_group_name = input;
            self
        }
        /// <p>The status of the endpoint.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>The status of the endpoint.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn endpoint_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_name = Some(input.into());
            self
        }
        /// <p>The name of the endpoint.</p>
        pub fn set_endpoint_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_name = input;
            self
        }
        /// <p>The time (UTC) that the endpoint was created.</p>
        pub fn endpoint_create_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.endpoint_create_time = Some(input);
            self
        }
        /// <p>The time (UTC) that the endpoint was created.</p>
        pub fn set_endpoint_create_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.endpoint_create_time = input;
            self
        }
        /// <p>The port number on which the cluster accepts incoming connections.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.port = Some(input);
            self
        }
        /// <p>The port number on which the cluster accepts incoming connections.</p>
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.port = input;
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The DNS address of the endpoint.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Appends an item to `vpc_security_groups`.
        ///
        /// To override the contents of this collection use [`set_vpc_security_groups`](Self::set_vpc_security_groups).
        ///
        /// <p>The security groups associated with the endpoint.</p>
        pub fn vpc_security_groups(
            mut self,
            input: impl Into<crate::model::VpcSecurityGroupMembership>,
        ) -> Self {
            let mut v = self.vpc_security_groups.unwrap_or_default();
            v.push(input.into());
            self.vpc_security_groups = Some(v);
            self
        }
        /// <p>The security groups associated with the endpoint.</p>
        pub fn set_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VpcSecurityGroupMembership>>,
        ) -> Self {
            self.vpc_security_groups = input;
            self
        }
        /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
        pub fn vpc_endpoint(mut self, input: crate::model::VpcEndpoint) -> Self {
            self.vpc_endpoint = Some(input);
            self
        }
        /// <p>The connection endpoint for connecting to an Amazon Redshift cluster through the proxy.</p>
        pub fn set_vpc_endpoint(
            mut self,
            input: std::option::Option<crate::model::VpcEndpoint>,
        ) -> Self {
            self.vpc_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointAccess`](crate::model::EndpointAccess)
        pub fn build(self) -> crate::model::EndpointAccess {
            crate::model::EndpointAccess {
                cluster_identifier: self.cluster_identifier,
                resource_owner: self.resource_owner,
                subnet_group_name: self.subnet_group_name,
                endpoint_status: self.endpoint_status,
                endpoint_name: self.endpoint_name,
                endpoint_create_time: self.endpoint_create_time,
                port: self.port.unwrap_or_default(),
                address: self.address,
                vpc_security_groups: self.vpc_security_groups,
                vpc_endpoint: self.vpc_endpoint,
            }
        }
    }
}
impl EndpointAccess {
    /// Creates a new builder-style object to manufacture [`EndpointAccess`](crate::model::EndpointAccess)
    pub fn builder() -> crate::model::endpoint_access::Builder {
        crate::model::endpoint_access::Builder::default()
    }
}

/// <p>Describes the default cluster parameters for a parameter group family.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultClusterParameters {
    /// <p>The name of the cluster parameter group family to which the engine default
    /// parameters apply.</p>
    pub parameter_group_family: std::option::Option<std::string::String>,
    /// <p>A value that indicates the starting point for the next set of response records in a
    /// subsequent request. If a value is returned in a response, you can retrieve the next set
    /// of records by providing this returned marker value in the <code>Marker</code> parameter
    /// and retrying the command. If the <code>Marker</code> field is empty, all response
    /// records have been retrieved for the request. </p>
    pub marker: std::option::Option<std::string::String>,
    /// <p>The list of cluster default parameters.</p>
    pub parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
}
impl std::fmt::Debug for DefaultClusterParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultClusterParameters");
        formatter.field("parameter_group_family", &self.parameter_group_family);
        formatter.field("marker", &self.marker);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`DefaultClusterParameters`](crate::model::DefaultClusterParameters)
pub mod default_cluster_parameters {
    /// A builder for [`DefaultClusterParameters`](crate::model::DefaultClusterParameters)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_group_family: std::option::Option<std::string::String>,
        pub(crate) marker: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    }
    impl Builder {
        /// <p>The name of the cluster parameter group family to which the engine default
        /// parameters apply.</p>
        pub fn parameter_group_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_group_family = Some(input.into());
            self
        }
        /// <p>The name of the cluster parameter group family to which the engine default
        /// parameters apply.</p>
        pub fn set_parameter_group_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_group_family = input;
            self
        }
        /// <p>A value that indicates the starting point for the next set of response records in a
        /// subsequent request. If a value is returned in a response, you can retrieve the next set
        /// of records by providing this returned marker value in the <code>Marker</code> parameter
        /// and retrying the command. If the <code>Marker</code> field is empty, all response
        /// records have been retrieved for the request. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.marker = Some(input.into());
            self
        }
        /// <p>A value that indicates the starting point for the next set of response records in a
        /// subsequent request. If a value is returned in a response, you can retrieve the next set
        /// of records by providing this returned marker value in the <code>Marker</code> parameter
        /// and retrying the command. If the <code>Marker</code> field is empty, all response
        /// records have been retrieved for the request. </p>
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.marker = input;
            self
        }
        /// Appends an item to `parameters`.
        ///
        /// To override the contents of this collection use [`set_parameters`](Self::set_parameters).
        ///
        /// <p>The list of cluster default parameters.</p>
        pub fn parameters(mut self, input: impl Into<crate::model::Parameter>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(input.into());
            self.parameters = Some(v);
            self
        }
        /// <p>The list of cluster default parameters.</p>
        pub fn set_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultClusterParameters`](crate::model::DefaultClusterParameters)
        pub fn build(self) -> crate::model::DefaultClusterParameters {
            crate::model::DefaultClusterParameters {
                parameter_group_family: self.parameter_group_family,
                marker: self.marker,
                parameters: self.parameters,
            }
        }
    }
}
impl DefaultClusterParameters {
    /// Creates a new builder-style object to manufacture [`DefaultClusterParameters`](crate::model::DefaultClusterParameters)
    pub fn builder() -> crate::model::default_cluster_parameters::Builder {
        crate::model::default_cluster_parameters::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataShare {
    /// <p>An Amazon Resource Name (ARN) that references the datashare that is owned by a specific namespace of the producer cluster. A datashare ARN is in the <code>arn:aws:redshift:{region}:{account-id}:{datashare}:{namespace-guid}/{datashare-name}</code> format.</p>
    pub data_share_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the producer.</p>
    pub producer_arn: std::option::Option<std::string::String>,
    /// <p>A value that specifies whether the datashare can be shared to a publicly accessible  cluster.</p>
    pub allow_publicly_accessible_consumers: bool,
    /// <p>A value that specifies when the datashare has an association between a producer and data consumers.</p>
    pub data_share_associations:
        std::option::Option<std::vec::Vec<crate::model::DataShareAssociation>>,
}
impl std::fmt::Debug for DataShare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataShare");
        formatter.field("data_share_arn", &self.data_share_arn);
        formatter.field("producer_arn", &self.producer_arn);
        formatter.field(
            "allow_publicly_accessible_consumers",
            &self.allow_publicly_accessible_consumers,
        );
        formatter.field("data_share_associations", &self.data_share_associations);
        formatter.finish()
    }
}
/// See [`DataShare`](crate::model::DataShare)
pub mod data_share {
    /// A builder for [`DataShare`](crate::model::DataShare)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_share_arn: std::option::Option<std::string::String>,
        pub(crate) producer_arn: std::option::Option<std::string::String>,
        pub(crate) allow_publicly_accessible_consumers: std::option::Option<bool>,
        pub(crate) data_share_associations:
            std::option::Option<std::vec::Vec<crate::model::DataShareAssociation>>,
    }
    impl Builder {
        /// <p>An Amazon Resource Name (ARN) that references the datashare that is owned by a specific namespace of the producer cluster. A datashare ARN is in the <code>arn:aws:redshift:{region}:{account-id}:{datashare}:{namespace-guid}/{datashare-name}</code> format.</p>
        pub fn data_share_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_share_arn = Some(input.into());
            self
        }
        /// <p>An Amazon Resource Name (ARN) that references the datashare that is owned by a specific namespace of the producer cluster. A datashare ARN is in the <code>arn:aws:redshift:{region}:{account-id}:{datashare}:{namespace-guid}/{datashare-name}</code> format.</p>
        pub fn set_data_share_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_share_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the producer.</p>
        pub fn producer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.producer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the producer.</p>
        pub fn set_producer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.producer_arn = input;
            self
        }
        /// <p>A value that specifies whether the datashare can be shared to a publicly accessible  cluster.</p>
        pub fn allow_publicly_accessible_consumers(mut self, input: bool) -> Self {
            self.allow_publicly_accessible_consumers = Some(input);
            self
        }
        /// <p>A value that specifies whether the datashare can be shared to a publicly accessible  cluster.</p>
        pub fn set_allow_publicly_accessible_consumers(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.allow_publicly_accessible_consumers = input;
            self
        }
        /// Appends an item to `data_share_associations`.
        ///
        /// To override the contents of this collection use [`set_data_share_associations`](Self::set_data_share_associations).
        ///
        /// <p>A value that specifies when the datashare has an association between a producer and data consumers.</p>
        pub fn data_share_associations(
            mut self,
            input: impl Into<crate::model::DataShareAssociation>,
        ) -> Self {
            let mut v = self.data_share_associations.unwrap_or_default();
            v.push(input.into());
            self.data_share_associations = Some(v);
            self
        }
        /// <p>A value that specifies when the datashare has an association between a producer and data consumers.</p>
        pub fn set_data_share_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DataShareAssociation>>,
        ) -> Self {
            self.data_share_associations = input;
            self
        }
        /// Consumes the builder and constructs a [`DataShare`](crate::model::DataShare)
        pub fn build(self) -> crate::model::DataShare {
            crate::model::DataShare {
                data_share_arn: self.data_share_arn,
                producer_arn: self.producer_arn,
                allow_publicly_accessible_consumers: self
                    .allow_publicly_accessible_consumers
                    .unwrap_or_default(),
                data_share_associations: self.data_share_associations,
            }
        }
    }
}
impl DataShare {
    /// Creates a new builder-style object to manufacture [`DataShare`](crate::model::DataShare)
    pub fn builder() -> crate::model::data_share::Builder {
        crate::model::data_share::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataShareStatusForProducer {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Authorized,
    #[allow(missing_docs)] // documentation missing in model
    Deauthorized,
    #[allow(missing_docs)] // documentation missing in model
    PendingAuthorization,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataShareStatusForProducer {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DataShareStatusForProducer::Active,
            "AUTHORIZED" => DataShareStatusForProducer::Authorized,
            "DEAUTHORIZED" => DataShareStatusForProducer::Deauthorized,
            "PENDING_AUTHORIZATION" => DataShareStatusForProducer::PendingAuthorization,
            "REJECTED" => DataShareStatusForProducer::Rejected,
            other => DataShareStatusForProducer::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataShareStatusForProducer {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataShareStatusForProducer::from(s))
    }
}
impl DataShareStatusForProducer {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataShareStatusForProducer::Active => "ACTIVE",
            DataShareStatusForProducer::Authorized => "AUTHORIZED",
            DataShareStatusForProducer::Deauthorized => "DEAUTHORIZED",
            DataShareStatusForProducer::PendingAuthorization => "PENDING_AUTHORIZATION",
            DataShareStatusForProducer::Rejected => "REJECTED",
            DataShareStatusForProducer::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "AUTHORIZED",
            "DEAUTHORIZED",
            "PENDING_AUTHORIZATION",
            "REJECTED",
        ]
    }
}
impl AsRef<str> for DataShareStatusForProducer {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataShareStatusForConsumer {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Available,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataShareStatusForConsumer {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DataShareStatusForConsumer::Active,
            "AVAILABLE" => DataShareStatusForConsumer::Available,
            other => DataShareStatusForConsumer::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataShareStatusForConsumer {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataShareStatusForConsumer::from(s))
    }
}
impl DataShareStatusForConsumer {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataShareStatusForConsumer::Active => "ACTIVE",
            DataShareStatusForConsumer::Available => "AVAILABLE",
            DataShareStatusForConsumer::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "AVAILABLE"]
    }
}
impl AsRef<str> for DataShareStatusForConsumer {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a cluster version, including the parameter group family and description
/// of the version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterVersion {
    /// <p>The version number used by the cluster.</p>
    pub cluster_version: std::option::Option<std::string::String>,
    /// <p>The name of the cluster parameter group family for the cluster.</p>
    pub cluster_parameter_group_family: std::option::Option<std::string::String>,
    /// <p>The description of the cluster version.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterVersion");
        formatter.field("cluster_version", &self.cluster_version);
        formatter.field(
            "cluster_parameter_group_family",
            &self.cluster_parameter_group_family,
        );
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`ClusterVersion`](crate::model::ClusterVersion)
pub mod cluster_version {
    /// A builder for [`ClusterVersion`](crate::model::ClusterVersion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_version: std::option::Option<std::string::String>,
        pub(crate) cluster_parameter_group_family: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version number used by the cluster.</p>
        pub fn cluster_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_version = Some(input.into());
            self
        }
        /// <p>The version number used by the cluster.</p>
        pub fn set_cluster_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_version = input;
            self
        }
        /// <p>The name of the cluster parameter group family for the cluster.</p>
        pub fn cluster_parameter_group_family(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cluster_parameter_group_family = Some(input.into());
            self
        }
        /// <p>The name of the cluster parameter group family for the cluster.</p>
        pub fn set_cluster_parameter_group_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_parameter_group_family = input;
            self
        }
        /// <p>The description of the cluster version.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the cluster version.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterVersion`](crate::model::ClusterVersion)
        pub fn build(self) -> crate::model::ClusterVersion {
            crate::model::ClusterVersion {
                cluster_version: self.cluster_version,
                cluster_parameter_group_family: self.cluster_parameter_group_family,
                description: self.description,
            }
        }
    }
}
impl ClusterVersion {
    /// Creates a new builder-style object to manufacture [`ClusterVersion`](crate::model::ClusterVersion)
    pub fn builder() -> crate::model::cluster_version::Builder {
        crate::model::cluster_version::Builder::default()
    }
}

/// <p>Defines a maintenance track that determines which Amazon Redshift version to apply
/// during a maintenance window. If the value for <code>MaintenanceTrack</code> is
/// <code>current</code>, the cluster is updated to the most recently certified
/// maintenance release. If the value is <code>trailing</code>, the cluster is updated to
/// the previously certified maintenance release. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaintenanceTrack {
    /// <p>The name of the maintenance track. Possible values are <code>current</code> and
    /// <code>trailing</code>.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The version number for the cluster release.</p>
    pub database_version: std::option::Option<std::string::String>,
    /// <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
    /// track. </p>
    pub update_targets: std::option::Option<std::vec::Vec<crate::model::UpdateTarget>>,
}
impl std::fmt::Debug for MaintenanceTrack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaintenanceTrack");
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field("database_version", &self.database_version);
        formatter.field("update_targets", &self.update_targets);
        formatter.finish()
    }
}
/// See [`MaintenanceTrack`](crate::model::MaintenanceTrack)
pub mod maintenance_track {
    /// A builder for [`MaintenanceTrack`](crate::model::MaintenanceTrack)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) database_version: std::option::Option<std::string::String>,
        pub(crate) update_targets: std::option::Option<std::vec::Vec<crate::model::UpdateTarget>>,
    }
    impl Builder {
        /// <p>The name of the maintenance track. Possible values are <code>current</code> and
        /// <code>trailing</code>.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the maintenance track. Possible values are <code>current</code> and
        /// <code>trailing</code>.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The version number for the cluster release.</p>
        pub fn database_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_version = Some(input.into());
            self
        }
        /// <p>The version number for the cluster release.</p>
        pub fn set_database_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_version = input;
            self
        }
        /// Appends an item to `update_targets`.
        ///
        /// To override the contents of this collection use [`set_update_targets`](Self::set_update_targets).
        ///
        /// <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
        /// track. </p>
        pub fn update_targets(mut self, input: impl Into<crate::model::UpdateTarget>) -> Self {
            let mut v = self.update_targets.unwrap_or_default();
            v.push(input.into());
            self.update_targets = Some(v);
            self
        }
        /// <p>An array of <a>UpdateTarget</a> objects to update with the maintenance
        /// track. </p>
        pub fn set_update_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateTarget>>,
        ) -> Self {
            self.update_targets = input;
            self
        }
        /// Consumes the builder and constructs a [`MaintenanceTrack`](crate::model::MaintenanceTrack)
        pub fn build(self) -> crate::model::MaintenanceTrack {
            crate::model::MaintenanceTrack {
                maintenance_track_name: self.maintenance_track_name,
                database_version: self.database_version,
                update_targets: self.update_targets,
            }
        }
    }
}
impl MaintenanceTrack {
    /// Creates a new builder-style object to manufacture [`MaintenanceTrack`](crate::model::MaintenanceTrack)
    pub fn builder() -> crate::model::maintenance_track::Builder {
        crate::model::maintenance_track::Builder::default()
    }
}

/// <p>A maintenance track that you can switch the current track to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateTarget {
    /// <p>The name of the new maintenance track.</p>
    pub maintenance_track_name: std::option::Option<std::string::String>,
    /// <p>The cluster version for the new maintenance track.</p>
    pub database_version: std::option::Option<std::string::String>,
    /// <p>A list of operations supported by the maintenance track.</p>
    pub supported_operations: std::option::Option<std::vec::Vec<crate::model::SupportedOperation>>,
}
impl std::fmt::Debug for UpdateTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateTarget");
        formatter.field("maintenance_track_name", &self.maintenance_track_name);
        formatter.field("database_version", &self.database_version);
        formatter.field("supported_operations", &self.supported_operations);
        formatter.finish()
    }
}
/// See [`UpdateTarget`](crate::model::UpdateTarget)
pub mod update_target {
    /// A builder for [`UpdateTarget`](crate::model::UpdateTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maintenance_track_name: std::option::Option<std::string::String>,
        pub(crate) database_version: std::option::Option<std::string::String>,
        pub(crate) supported_operations:
            std::option::Option<std::vec::Vec<crate::model::SupportedOperation>>,
    }
    impl Builder {
        /// <p>The name of the new maintenance track.</p>
        pub fn maintenance_track_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.maintenance_track_name = Some(input.into());
            self
        }
        /// <p>The name of the new maintenance track.</p>
        pub fn set_maintenance_track_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maintenance_track_name = input;
            self
        }
        /// <p>The cluster version for the new maintenance track.</p>
        pub fn database_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_version = Some(input.into());
            self
        }
        /// <p>The cluster version for the new maintenance track.</p>
        pub fn set_database_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_version = input;
            self
        }
        /// Appends an item to `supported_operations`.
        ///
        /// To override the contents of this collection use [`set_supported_operations`](Self::set_supported_operations).
        ///
        /// <p>A list of operations supported by the maintenance track.</p>
        pub fn supported_operations(
            mut self,
            input: impl Into<crate::model::SupportedOperation>,
        ) -> Self {
            let mut v = self.supported_operations.unwrap_or_default();
            v.push(input.into());
            self.supported_operations = Some(v);
            self
        }
        /// <p>A list of operations supported by the maintenance track.</p>
        pub fn set_supported_operations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SupportedOperation>>,
        ) -> Self {
            self.supported_operations = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTarget`](crate::model::UpdateTarget)
        pub fn build(self) -> crate::model::UpdateTarget {
            crate::model::UpdateTarget {
                maintenance_track_name: self.maintenance_track_name,
                database_version: self.database_version,
                supported_operations: self.supported_operations,
            }
        }
    }
}
impl UpdateTarget {
    /// Creates a new builder-style object to manufacture [`UpdateTarget`](crate::model::UpdateTarget)
    pub fn builder() -> crate::model::update_target::Builder {
        crate::model::update_target::Builder::default()
    }
}

/// <p>Describes the operations that are allowed on a maintenance track.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SupportedOperation {
    /// <p>A list of the supported operations.</p>
    pub operation_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SupportedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SupportedOperation");
        formatter.field("operation_name", &self.operation_name);
        formatter.finish()
    }
}
/// See [`SupportedOperation`](crate::model::SupportedOperation)
pub mod supported_operation {
    /// A builder for [`SupportedOperation`](crate::model::SupportedOperation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A list of the supported operations.</p>
        pub fn operation_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.operation_name = Some(input.into());
            self
        }
        /// <p>A list of the supported operations.</p>
        pub fn set_operation_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.operation_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SupportedOperation`](crate::model::SupportedOperation)
        pub fn build(self) -> crate::model::SupportedOperation {
            crate::model::SupportedOperation {
                operation_name: self.operation_name,
            }
        }
    }
}
impl SupportedOperation {
    /// Creates a new builder-style object to manufacture [`SupportedOperation`](crate::model::SupportedOperation)
    pub fn builder() -> crate::model::supported_operation::Builder {
        crate::model::supported_operation::Builder::default()
    }
}

/// <p>Describes a sorting entity</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotSortingEntity {
    /// <p>The category for sorting the snapshots.</p>
    pub attribute: std::option::Option<crate::model::SnapshotAttributeToSortBy>,
    /// <p>The order for listing the attributes.</p>
    pub sort_order: std::option::Option<crate::model::SortByOrder>,
}
impl std::fmt::Debug for SnapshotSortingEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotSortingEntity");
        formatter.field("attribute", &self.attribute);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}
/// See [`SnapshotSortingEntity`](crate::model::SnapshotSortingEntity)
pub mod snapshot_sorting_entity {
    /// A builder for [`SnapshotSortingEntity`](crate::model::SnapshotSortingEntity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::SnapshotAttributeToSortBy>,
        pub(crate) sort_order: std::option::Option<crate::model::SortByOrder>,
    }
    impl Builder {
        /// <p>The category for sorting the snapshots.</p>
        pub fn attribute(mut self, input: crate::model::SnapshotAttributeToSortBy) -> Self {
            self.attribute = Some(input);
            self
        }
        /// <p>The category for sorting the snapshots.</p>
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::SnapshotAttributeToSortBy>,
        ) -> Self {
            self.attribute = input;
            self
        }
        /// <p>The order for listing the attributes.</p>
        pub fn sort_order(mut self, input: crate::model::SortByOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>The order for listing the attributes.</p>
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortByOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotSortingEntity`](crate::model::SnapshotSortingEntity)
        pub fn build(self) -> crate::model::SnapshotSortingEntity {
            crate::model::SnapshotSortingEntity {
                attribute: self.attribute,
                sort_order: self.sort_order,
            }
        }
    }
}
impl SnapshotSortingEntity {
    /// Creates a new builder-style object to manufacture [`SnapshotSortingEntity`](crate::model::SnapshotSortingEntity)
    pub fn builder() -> crate::model::snapshot_sorting_entity::Builder {
        crate::model::snapshot_sorting_entity::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortByOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortByOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASC" => SortByOrder::Ascending,
            "DESC" => SortByOrder::Descending,
            other => SortByOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortByOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortByOrder::from(s))
    }
}
impl SortByOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortByOrder::Ascending => "ASC",
            SortByOrder::Descending => "DESC",
            SortByOrder::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ASC", "DESC"]
    }
}
impl AsRef<str> for SortByOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SnapshotAttributeToSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreateTime,
    #[allow(missing_docs)] // documentation missing in model
    SourceType,
    #[allow(missing_docs)] // documentation missing in model
    TotalSize,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SnapshotAttributeToSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_TIME" => SnapshotAttributeToSortBy::CreateTime,
            "SOURCE_TYPE" => SnapshotAttributeToSortBy::SourceType,
            "TOTAL_SIZE" => SnapshotAttributeToSortBy::TotalSize,
            other => SnapshotAttributeToSortBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SnapshotAttributeToSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SnapshotAttributeToSortBy::from(s))
    }
}
impl SnapshotAttributeToSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SnapshotAttributeToSortBy::CreateTime => "CREATE_TIME",
            SnapshotAttributeToSortBy::SourceType => "SOURCE_TYPE",
            SnapshotAttributeToSortBy::TotalSize => "TOTAL_SIZE",
            SnapshotAttributeToSortBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CREATE_TIME", "SOURCE_TYPE", "TOTAL_SIZE"]
    }
}
impl AsRef<str> for SnapshotAttributeToSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterParameterGroup {
    /// <p>The name of the cluster parameter group.</p>
    pub parameter_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the cluster parameter group family that this cluster parameter group is
    /// compatible with.</p>
    pub parameter_group_family: std::option::Option<std::string::String>,
    /// <p>The description of the parameter group.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The list of tags for the cluster parameter group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ClusterParameterGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterParameterGroup");
        formatter.field("parameter_group_name", &self.parameter_group_name);
        formatter.field("parameter_group_family", &self.parameter_group_family);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ClusterParameterGroup`](crate::model::ClusterParameterGroup)
pub mod cluster_parameter_group {
    /// A builder for [`ClusterParameterGroup`](crate::model::ClusterParameterGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_group_name: std::option::Option<std::string::String>,
        pub(crate) parameter_group_family: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the cluster parameter group.</p>
        pub fn parameter_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_group_name = Some(input.into());
            self
        }
        /// <p>The name of the cluster parameter group.</p>
        pub fn set_parameter_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_group_name = input;
            self
        }
        /// <p>The name of the cluster parameter group family that this cluster parameter group is
        /// compatible with.</p>
        pub fn parameter_group_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_group_family = Some(input.into());
            self
        }
        /// <p>The name of the cluster parameter group family that this cluster parameter group is
        /// compatible with.</p>
        pub fn set_parameter_group_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_group_family = input;
            self
        }
        /// <p>The description of the parameter group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the parameter group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tags for the cluster parameter group.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of tags for the cluster parameter group.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterParameterGroup`](crate::model::ClusterParameterGroup)
        pub fn build(self) -> crate::model::ClusterParameterGroup {
            crate::model::ClusterParameterGroup {
                parameter_group_name: self.parameter_group_name,
                parameter_group_family: self.parameter_group_family,
                description: self.description,
                tags: self.tags,
            }
        }
    }
}
impl ClusterParameterGroup {
    /// Creates a new builder-style object to manufacture [`ClusterParameterGroup`](crate::model::ClusterParameterGroup)
    pub fn builder() -> crate::model::cluster_parameter_group::Builder {
        crate::model::cluster_parameter_group::Builder::default()
    }
}

/// <p>Describes a <code>ClusterDbRevision</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterDbRevision {
    /// <p>The unique identifier of the cluster.</p>
    pub cluster_identifier: std::option::Option<std::string::String>,
    /// <p>A string representing the current cluster version.</p>
    pub current_database_revision: std::option::Option<std::string::String>,
    /// <p>The date on which the database revision was released.</p>
    pub database_revision_release_date: std::option::Option<aws_smithy_types::Instant>,
    /// <p>A list of <code>RevisionTarget</code> objects, where each object describes the
    /// database revision that a cluster can be updated to.</p>
    pub revision_targets: std::option::Option<std::vec::Vec<crate::model::RevisionTarget>>,
}
impl std::fmt::Debug for ClusterDbRevision {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterDbRevision");
        formatter.field("cluster_identifier", &self.cluster_identifier);
        formatter.field("current_database_revision", &self.current_database_revision);
        formatter.field(
            "database_revision_release_date",
            &self.database_revision_release_date,
        );
        formatter.field("revision_targets", &self.revision_targets);
        formatter.finish()
    }
}
/// See [`ClusterDbRevision`](crate::model::ClusterDbRevision)
pub mod cluster_db_revision {
    /// A builder for [`ClusterDbRevision`](crate::model::ClusterDbRevision)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) current_database_revision: std::option::Option<std::string::String>,
        pub(crate) database_revision_release_date: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) revision_targets:
            std::option::Option<std::vec::Vec<crate::model::RevisionTarget>>,
    }
    impl Builder {
        /// <p>The unique identifier of the cluster.</p>
        pub fn cluster_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.cluster_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cluster.</p>
        pub fn set_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cluster_identifier = input;
            self
        }
        /// <p>A string representing the current cluster version.</p>
        pub fn current_database_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_database_revision = Some(input.into());
            self
        }
        /// <p>A string representing the current cluster version.</p>
        pub fn set_current_database_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_database_revision = input;
            self
        }
        /// <p>The date on which the database revision was released.</p>
        pub fn database_revision_release_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.database_revision_release_date = Some(input);
            self
        }
        /// <p>The date on which the database revision was released.</p>
        pub fn set_database_revision_release_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.database_revision_release_date = input;
            self
        }
        /// Appends an item to `revision_targets`.
        ///
        /// To override the contents of this collection use [`set_revision_targets`](Self::set_revision_targets).
        ///
        /// <p>A list of <code>RevisionTarget</code> objects, where each object describes the
        /// database revision that a cluster can be updated to.</p>
        pub fn revision_targets(mut self, input: impl Into<crate::model::RevisionTarget>) -> Self {
            let mut v = self.revision_targets.unwrap_or_default();
            v.push(input.into());
            self.revision_targets = Some(v);
            self
        }
        /// <p>A list of <code>RevisionTarget</code> objects, where each object describes the
        /// database revision that a cluster can be updated to.</p>
        pub fn set_revision_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RevisionTarget>>,
        ) -> Self {
            self.revision_targets = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterDbRevision`](crate::model::ClusterDbRevision)
        pub fn build(self) -> crate::model::ClusterDbRevision {
            crate::model::ClusterDbRevision {
                cluster_identifier: self.cluster_identifier,
                current_database_revision: self.current_database_revision,
                database_revision_release_date: self.database_revision_release_date,
                revision_targets: self.revision_targets,
            }
        }
    }
}
impl ClusterDbRevision {
    /// Creates a new builder-style object to manufacture [`ClusterDbRevision`](crate::model::ClusterDbRevision)
    pub fn builder() -> crate::model::cluster_db_revision::Builder {
        crate::model::cluster_db_revision::Builder::default()
    }
}

/// <p>Describes a <code>RevisionTarget</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevisionTarget {
    /// <p>A unique string that identifies the version to update the cluster to. You can use this
    /// value in <a>ModifyClusterDbRevision</a>.</p>
    pub database_revision: std::option::Option<std::string::String>,
    /// <p>A string that describes the changes and features that will be applied to the cluster
    /// when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The date on which the database revision was released.</p>
    pub database_revision_release_date: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for RevisionTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RevisionTarget");
        formatter.field("database_revision", &self.database_revision);
        formatter.field("description", &self.description);
        formatter.field(
            "database_revision_release_date",
            &self.database_revision_release_date,
        );
        formatter.finish()
    }
}
/// See [`RevisionTarget`](crate::model::RevisionTarget)
pub mod revision_target {
    /// A builder for [`RevisionTarget`](crate::model::RevisionTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) database_revision: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) database_revision_release_date: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>A unique string that identifies the version to update the cluster to. You can use this
        /// value in <a>ModifyClusterDbRevision</a>.</p>
        pub fn database_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_revision = Some(input.into());
            self
        }
        /// <p>A unique string that identifies the version to update the cluster to. You can use this
        /// value in <a>ModifyClusterDbRevision</a>.</p>
        pub fn set_database_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_revision = input;
            self
        }
        /// <p>A string that describes the changes and features that will be applied to the cluster
        /// when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A string that describes the changes and features that will be applied to the cluster
        /// when it is updated to the corresponding <a>ClusterDbRevision</a>.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date on which the database revision was released.</p>
        pub fn database_revision_release_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.database_revision_release_date = Some(input);
            self
        }
        /// <p>The date on which the database revision was released.</p>
        pub fn set_database_revision_release_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.database_revision_release_date = input;
            self
        }
        /// Consumes the builder and constructs a [`RevisionTarget`](crate::model::RevisionTarget)
        pub fn build(self) -> crate::model::RevisionTarget {
            crate::model::RevisionTarget {
                database_revision: self.database_revision,
                description: self.description,
                database_revision_release_date: self.database_revision_release_date,
            }
        }
    }
}
impl RevisionTarget {
    /// Creates a new builder-style object to manufacture [`RevisionTarget`](crate::model::RevisionTarget)
    pub fn builder() -> crate::model::revision_target::Builder {
        crate::model::revision_target::Builder::default()
    }
}

/// <p>Describes an authentication profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthenticationProfile {
    /// <p>The name of the authentication profile.</p>
    pub authentication_profile_name: std::option::Option<std::string::String>,
    /// <p>The content of the authentication profile in JSON format.
    /// The maximum length of the JSON string is determined by a quota for your account.</p>
    pub authentication_profile_content: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthenticationProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthenticationProfile");
        formatter.field(
            "authentication_profile_name",
            &self.authentication_profile_name,
        );
        formatter.field(
            "authentication_profile_content",
            &self.authentication_profile_content,
        );
        formatter.finish()
    }
}
/// See [`AuthenticationProfile`](crate::model::AuthenticationProfile)
pub mod authentication_profile {
    /// A builder for [`AuthenticationProfile`](crate::model::AuthenticationProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authentication_profile_name: std::option::Option<std::string::String>,
        pub(crate) authentication_profile_content: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the authentication profile.</p>
        pub fn authentication_profile_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.authentication_profile_name = Some(input.into());
            self
        }
        /// <p>The name of the authentication profile.</p>
        pub fn set_authentication_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_profile_name = input;
            self
        }
        /// <p>The content of the authentication profile in JSON format.
        /// The maximum length of the JSON string is determined by a quota for your account.</p>
        pub fn authentication_profile_content(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.authentication_profile_content = Some(input.into());
            self
        }
        /// <p>The content of the authentication profile in JSON format.
        /// The maximum length of the JSON string is determined by a quota for your account.</p>
        pub fn set_authentication_profile_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authentication_profile_content = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthenticationProfile`](crate::model::AuthenticationProfile)
        pub fn build(self) -> crate::model::AuthenticationProfile {
            crate::model::AuthenticationProfile {
                authentication_profile_name: self.authentication_profile_name,
                authentication_profile_content: self.authentication_profile_content,
            }
        }
    }
}
impl AuthenticationProfile {
    /// Creates a new builder-style object to manufacture [`AuthenticationProfile`](crate::model::AuthenticationProfile)
    pub fn builder() -> crate::model::authentication_profile::Builder {
        crate::model::authentication_profile::Builder::default()
    }
}

/// <p>A name value pair that describes an aspect of an account. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountAttribute {
    /// <p>The name of the attribute.</p>
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>A list of attribute values.</p>
    pub attribute_values: std::option::Option<std::vec::Vec<crate::model::AttributeValueTarget>>,
}
impl std::fmt::Debug for AccountAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountAttribute");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_values", &self.attribute_values);
        formatter.finish()
    }
}
/// See [`AccountAttribute`](crate::model::AccountAttribute)
pub mod account_attribute {
    /// A builder for [`AccountAttribute`](crate::model::AccountAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_values:
            std::option::Option<std::vec::Vec<crate::model::AttributeValueTarget>>,
    }
    impl Builder {
        /// <p>The name of the attribute.</p>
        pub fn attribute_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
            self
        }
        /// <p>The name of the attribute.</p>
        pub fn set_attribute_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_name = input;
            self
        }
        /// Appends an item to `attribute_values`.
        ///
        /// To override the contents of this collection use [`set_attribute_values`](Self::set_attribute_values).
        ///
        /// <p>A list of attribute values.</p>
        pub fn attribute_values(
            mut self,
            input: impl Into<crate::model::AttributeValueTarget>,
        ) -> Self {
            let mut v = self.attribute_values.unwrap_or_default();
            v.push(input.into());
            self.attribute_values = Some(v);
            self
        }
        /// <p>A list of attribute values.</p>
        pub fn set_attribute_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttributeValueTarget>>,
        ) -> Self {
            self.attribute_values = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountAttribute`](crate::model::AccountAttribute)
        pub fn build(self) -> crate::model::AccountAttribute {
            crate::model::AccountAttribute {
                attribute_name: self.attribute_name,
                attribute_values: self.attribute_values,
            }
        }
    }
}
impl AccountAttribute {
    /// Creates a new builder-style object to manufacture [`AccountAttribute`](crate::model::AccountAttribute)
    pub fn builder() -> crate::model::account_attribute::Builder {
        crate::model::account_attribute::Builder::default()
    }
}

/// <p>Describes an attribute value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeValueTarget {
    /// <p>The value of the attribute.</p>
    pub attribute_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AttributeValueTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeValueTarget");
        formatter.field("attribute_value", &self.attribute_value);
        formatter.finish()
    }
}
/// See [`AttributeValueTarget`](crate::model::AttributeValueTarget)
pub mod attribute_value_target {
    /// A builder for [`AttributeValueTarget`](crate::model::AttributeValueTarget)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value of the attribute.</p>
        pub fn attribute_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_value = Some(input.into());
            self
        }
        /// <p>The value of the attribute.</p>
        pub fn set_attribute_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_value = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeValueTarget`](crate::model::AttributeValueTarget)
        pub fn build(self) -> crate::model::AttributeValueTarget {
            crate::model::AttributeValueTarget {
                attribute_value: self.attribute_value,
            }
        }
    }
}
impl AttributeValueTarget {
    /// Creates a new builder-style object to manufacture [`AttributeValueTarget`](crate::model::AttributeValueTarget)
    pub fn builder() -> crate::model::attribute_value_target::Builder {
        crate::model::attribute_value_target::Builder::default()
    }
}

/// <p>Describes the errors returned by a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotErrorMessage {
    /// <p>A unique identifier for the snapshot returning the error.</p>
    pub snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the cluster.</p>
    pub snapshot_cluster_identifier: std::option::Option<std::string::String>,
    /// <p>The failure code for the error.</p>
    pub failure_code: std::option::Option<std::string::String>,
    /// <p>The text message describing the error.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotErrorMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotErrorMessage");
        formatter.field("snapshot_identifier", &self.snapshot_identifier);
        formatter.field(
            "snapshot_cluster_identifier",
            &self.snapshot_cluster_identifier,
        );
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`SnapshotErrorMessage`](crate::model::SnapshotErrorMessage)
pub mod snapshot_error_message {
    /// A builder for [`SnapshotErrorMessage`](crate::model::SnapshotErrorMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_cluster_identifier: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<std::string::String>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier for the snapshot returning the error.</p>
        pub fn snapshot_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the snapshot returning the error.</p>
        pub fn set_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_identifier = input;
            self
        }
        /// <p>A unique identifier for the cluster.</p>
        pub fn snapshot_cluster_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.snapshot_cluster_identifier = Some(input.into());
            self
        }
        /// <p>A unique identifier for the cluster.</p>
        pub fn set_snapshot_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_cluster_identifier = input;
            self
        }
        /// <p>The failure code for the error.</p>
        pub fn failure_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_code = Some(input.into());
            self
        }
        /// <p>The failure code for the error.</p>
        pub fn set_failure_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The text message describing the error.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The text message describing the error.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotErrorMessage`](crate::model::SnapshotErrorMessage)
        pub fn build(self) -> crate::model::SnapshotErrorMessage {
            crate::model::SnapshotErrorMessage {
                snapshot_identifier: self.snapshot_identifier,
                snapshot_cluster_identifier: self.snapshot_cluster_identifier,
                failure_code: self.failure_code,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl SnapshotErrorMessage {
    /// Creates a new builder-style object to manufacture [`SnapshotErrorMessage`](crate::model::SnapshotErrorMessage)
    pub fn builder() -> crate::model::snapshot_error_message::Builder {
        crate::model::snapshot_error_message::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteClusterSnapshotMessage {
    /// <p>The unique identifier of the manual snapshot to be deleted.</p>
    /// <p>Constraints: Must be the name of an existing snapshot that is in the
    /// <code>available</code>, <code>failed</code>, or <code>cancelled</code>
    /// state.</p>
    pub snapshot_identifier: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
    /// is required if your IAM user has a policy containing a snapshot resource element that
    /// specifies anything other than * for the cluster name.</p>
    /// <p>Constraints: Must be the name of valid cluster.</p>
    pub snapshot_cluster_identifier: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteClusterSnapshotMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteClusterSnapshotMessage");
        formatter.field("snapshot_identifier", &self.snapshot_identifier);
        formatter.field(
            "snapshot_cluster_identifier",
            &self.snapshot_cluster_identifier,
        );
        formatter.finish()
    }
}
/// See [`DeleteClusterSnapshotMessage`](crate::model::DeleteClusterSnapshotMessage)
pub mod delete_cluster_snapshot_message {
    /// A builder for [`DeleteClusterSnapshotMessage`](crate::model::DeleteClusterSnapshotMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_identifier: std::option::Option<std::string::String>,
        pub(crate) snapshot_cluster_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the manual snapshot to be deleted.</p>
        /// <p>Constraints: Must be the name of an existing snapshot that is in the
        /// <code>available</code>, <code>failed</code>, or <code>cancelled</code>
        /// state.</p>
        pub fn snapshot_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier of the manual snapshot to be deleted.</p>
        /// <p>Constraints: Must be the name of an existing snapshot that is in the
        /// <code>available</code>, <code>failed</code>, or <code>cancelled</code>
        /// state.</p>
        pub fn set_snapshot_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_identifier = input;
            self
        }
        /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
        /// is required if your IAM user has a policy containing a snapshot resource element that
        /// specifies anything other than * for the cluster name.</p>
        /// <p>Constraints: Must be the name of valid cluster.</p>
        pub fn snapshot_cluster_identifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.snapshot_cluster_identifier = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cluster the snapshot was created from. This parameter
        /// is required if your IAM user has a policy containing a snapshot resource element that
        /// specifies anything other than * for the cluster name.</p>
        /// <p>Constraints: Must be the name of valid cluster.</p>
        pub fn set_snapshot_cluster_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.snapshot_cluster_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteClusterSnapshotMessage`](crate::model::DeleteClusterSnapshotMessage)
        pub fn build(self) -> crate::model::DeleteClusterSnapshotMessage {
            crate::model::DeleteClusterSnapshotMessage {
                snapshot_identifier: self.snapshot_identifier,
                snapshot_cluster_identifier: self.snapshot_cluster_identifier,
            }
        }
    }
}
impl DeleteClusterSnapshotMessage {
    /// Creates a new builder-style object to manufacture [`DeleteClusterSnapshotMessage`](crate::model::DeleteClusterSnapshotMessage)
    pub fn builder() -> crate::model::delete_cluster_snapshot_message::Builder {
        crate::model::delete_cluster_snapshot_message::Builder::default()
    }
}
