// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    #[allow(missing_docs)] // documentation missing in model
    AccessDeniedException(crate::error::AccessDeniedException),
    /// Non-retryable exception. Attempted to create already existing object or chunk. This message contains a checksum of already presented data.
    DataAlreadyExistsException(crate::error::DataAlreadyExistsException),
    /// Non-retryable exception, indicates client error (wrong argument passed to API). See exception message for details.
    IllegalArgumentException(crate::error::IllegalArgumentException),
    /// Non-retryable exception. Indicates the KMS key usage is incorrect. See exception message for details.
    KmsInvalidKeyUsageException(crate::error::KmsInvalidKeyUsageException),
    /// Retryalble exception. Indicated issues while reading an input stream due to the networking issues or connection drop on the client side.
    NotReadableInputStreamException(crate::error::NotReadableInputStreamException),
    /// Non-retryable exception. Attempted to make an operation on non-existing or expired resource.
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// Retryable exception. In general indicates internal failure that can be fixed by retry.
    RetryableException(crate::error::RetryableException),
    /// Deprecated. To be removed from the model.
    ServiceInternalException(crate::error::ServiceInternalException),
    /// Retryable exception, indicates internal server error.
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// Increased rate over throttling limits. Can be retried with exponential backoff.
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::DataAlreadyExistsException(inner) => inner.fmt(f),
            Error::IllegalArgumentException(inner) => inner.fmt(f),
            Error::KmsInvalidKeyUsageException(inner) => inner.fmt(f),
            Error::NotReadableInputStreamException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::RetryableException(inner) => inner.fmt(f),
            Error::ServiceInternalException(inner) => inner.fmt(f),
            Error::ServiceUnavailableException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteObjectError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteObjectError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteObjectError> for Error {
    fn from(err: crate::error::DeleteObjectError) -> Self {
        match err {
            crate::error::DeleteObjectError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::DeleteObjectError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::DeleteObjectError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteObjectError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::DeleteObjectError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::DeleteObjectError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::DeleteObjectError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::DeleteObjectError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetChunkError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetChunkError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetChunkError> for Error {
    fn from(err: crate::error::GetChunkError) -> Self {
        match err {
            crate::error::GetChunkError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::GetChunkError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::GetChunkError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::GetChunkError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::GetChunkError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::GetChunkError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::GetChunkError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::GetChunkError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetObjectMetadataError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetObjectMetadataError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetObjectMetadataError> for Error {
    fn from(err: crate::error::GetObjectMetadataError) -> Self {
        match err {
            crate::error::GetObjectMetadataError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::GetObjectMetadataError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::GetObjectMetadataError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::GetObjectMetadataError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::GetObjectMetadataError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::GetObjectMetadataError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::GetObjectMetadataError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::GetObjectMetadataError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::GetObjectMetadataError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListChunksError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListChunksError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListChunksError> for Error {
    fn from(err: crate::error::ListChunksError) -> Self {
        match err {
            crate::error::ListChunksError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::ListChunksError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::ListChunksError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListChunksError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::ListChunksError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::ListChunksError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::ListChunksError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListObjectsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListObjectsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListObjectsError> for Error {
    fn from(err: crate::error::ListObjectsError) -> Self {
        match err {
            crate::error::ListObjectsError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::ListObjectsError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::ListObjectsError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::ListObjectsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListObjectsError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::ListObjectsError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::ListObjectsError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::ListObjectsError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::ListObjectsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::NotifyObjectCompleteError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::NotifyObjectCompleteError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::NotifyObjectCompleteError> for Error {
    fn from(err: crate::error::NotifyObjectCompleteError) -> Self {
        match err {
            crate::error::NotifyObjectCompleteError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::NotifyObjectCompleteError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::NotifyObjectCompleteError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::NotifyObjectCompleteError::NotReadableInputStreamException(inner) => {
                Error::NotReadableInputStreamException(inner)
            }
            crate::error::NotifyObjectCompleteError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::NotifyObjectCompleteError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::NotifyObjectCompleteError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::NotifyObjectCompleteError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::NotifyObjectCompleteError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutChunkError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutChunkError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutChunkError> for Error {
    fn from(err: crate::error::PutChunkError) -> Self {
        match err {
            crate::error::PutChunkError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::PutChunkError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::PutChunkError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::PutChunkError::NotReadableInputStreamException(inner) => {
                Error::NotReadableInputStreamException(inner)
            }
            crate::error::PutChunkError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::PutChunkError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::PutChunkError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::PutChunkError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::PutChunkError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutObjectError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutObjectError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutObjectError> for Error {
    fn from(err: crate::error::PutObjectError) -> Self {
        match err {
            crate::error::PutObjectError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::PutObjectError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::PutObjectError::KmsInvalidKeyUsageException(inner) => {
                Error::KmsInvalidKeyUsageException(inner)
            }
            crate::error::PutObjectError::NotReadableInputStreamException(inner) => {
                Error::NotReadableInputStreamException(inner)
            }
            crate::error::PutObjectError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::PutObjectError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::PutObjectError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::PutObjectError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::PutObjectError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartObjectError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::StartObjectError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartObjectError> for Error {
    fn from(err: crate::error::StartObjectError) -> Self {
        match err {
            crate::error::StartObjectError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::error::StartObjectError::DataAlreadyExistsException(inner) => {
                Error::DataAlreadyExistsException(inner)
            }
            crate::error::StartObjectError::IllegalArgumentException(inner) => {
                Error::IllegalArgumentException(inner)
            }
            crate::error::StartObjectError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::StartObjectError::RetryableException(inner) => {
                Error::RetryableException(inner)
            }
            crate::error::StartObjectError::ServiceInternalException(inner) => {
                Error::ServiceInternalException(inner)
            }
            crate::error::StartObjectError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::error::StartObjectError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::StartObjectError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::DataAlreadyExistsException(e) => e.request_id(),
            Self::IllegalArgumentException(e) => e.request_id(),
            Self::KmsInvalidKeyUsageException(e) => e.request_id(),
            Self::NotReadableInputStreamException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::RetryableException(e) => e.request_id(),
            Self::ServiceInternalException(e) => e.request_id(),
            Self::ServiceUnavailableException(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
