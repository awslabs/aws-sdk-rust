// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`DeleteObjectInput`](crate::input::DeleteObjectInput).
pub mod delete_object_input {
    
    /// A builder for [`DeleteObjectInput`](crate::input::DeleteObjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
        pub(crate) object_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Backup job Id for the in-progress backup.
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        /// Backup job Id for the in-progress backup.
        pub fn set_backup_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_job_id = input; self
        }
        /// The name of the Object.
        pub fn object_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_name = Some(input.into());
            self
        }
        /// The name of the Object.
        pub fn set_object_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_name = input; self
        }
        /// Consumes the builder and constructs a [`DeleteObjectInput`](crate::input::DeleteObjectInput).
        pub fn build(self) -> Result<crate::input::DeleteObjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteObjectInput {
                    backup_job_id: self.backup_job_id
                    ,
                    object_name: self.object_name
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteObjectInput {
    /// Consumes the builder and constructs an Operation<[`DeleteObject`](crate::operation::DeleteObject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteObject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteObjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.backup_job_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))?;
                let backup_job_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if backup_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))
                            }
                let input_2 = &_input.object_name;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))?;
                let object_name = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if object_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))
                            }
                write!(output, "/backup-jobs/{BackupJobId}/object/{ObjectName}", BackupJobId = backup_job_id, ObjectName = object_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteObjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteObject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteObject", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteObjectInput`](crate::input::DeleteObjectInput).
    pub fn builder() -> crate::input::delete_object_input::Builder {
        crate::input::delete_object_input::Builder::default()
    }
}

/// See [`GetChunkInput`](crate::input::GetChunkInput).
pub mod get_chunk_input {
    
    /// A builder for [`GetChunkInput`](crate::input::GetChunkInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_job_id: std::option::Option<std::string::String>,
        pub(crate) chunk_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Storage job id
        pub fn storage_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_job_id = Some(input.into());
            self
        }
        /// Storage job id
        pub fn set_storage_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_job_id = input; self
        }
        /// Chunk token
        pub fn chunk_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.chunk_token = Some(input.into());
            self
        }
        /// Chunk token
        pub fn set_chunk_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.chunk_token = input; self
        }
        /// Consumes the builder and constructs a [`GetChunkInput`](crate::input::GetChunkInput).
        pub fn build(self) -> Result<crate::input::GetChunkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetChunkInput {
                    storage_job_id: self.storage_job_id
                    ,
                    chunk_token: self.chunk_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetChunkInput {
    /// Consumes the builder and constructs an Operation<[`GetChunk`](crate::operation::GetChunk)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetChunk, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetChunkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.storage_job_id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))?;
                let storage_job_id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if storage_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))
                            }
                let input_4 = &_input.chunk_token;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("chunk_token", "cannot be empty or unset"))?;
                let chunk_token = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if chunk_token.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("chunk_token", "cannot be empty or unset"))
                            }
                write!(output, "/restore-jobs/{StorageJobId}/chunk/{ChunkToken}", StorageJobId = storage_job_id, ChunkToken = chunk_token).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetChunkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetChunk::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetChunk", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetChunkInput`](crate::input::GetChunkInput).
    pub fn builder() -> crate::input::get_chunk_input::Builder {
        crate::input::get_chunk_input::Builder::default()
    }
}

/// See [`GetObjectMetadataInput`](crate::input::GetObjectMetadataInput).
pub mod get_object_metadata_input {
    
    /// A builder for [`GetObjectMetadataInput`](crate::input::GetObjectMetadataInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_job_id: std::option::Option<std::string::String>,
        pub(crate) object_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Backup job id for the in-progress backup.
        pub fn storage_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_job_id = Some(input.into());
            self
        }
        /// Backup job id for the in-progress backup.
        pub fn set_storage_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_job_id = input; self
        }
        /// Object token.
        pub fn object_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_token = Some(input.into());
            self
        }
        /// Object token.
        pub fn set_object_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_token = input; self
        }
        /// Consumes the builder and constructs a [`GetObjectMetadataInput`](crate::input::GetObjectMetadataInput).
        pub fn build(self) -> Result<crate::input::GetObjectMetadataInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetObjectMetadataInput {
                    storage_job_id: self.storage_job_id
                    ,
                    object_token: self.object_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetObjectMetadataInput {
    /// Consumes the builder and constructs an Operation<[`GetObjectMetadata`](crate::operation::GetObjectMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetObjectMetadata, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetObjectMetadataInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.storage_job_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))?;
                let storage_job_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if storage_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))
                            }
                let input_6 = &_input.object_token;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_token", "cannot be empty or unset"))?;
                let object_token = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if object_token.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_token", "cannot be empty or unset"))
                            }
                write!(output, "/restore-jobs/{StorageJobId}/object/{ObjectToken}/metadata", StorageJobId = storage_job_id, ObjectToken = object_token).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetObjectMetadataInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetObjectMetadata::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetObjectMetadata", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetObjectMetadataInput`](crate::input::GetObjectMetadataInput).
    pub fn builder() -> crate::input::get_object_metadata_input::Builder {
        crate::input::get_object_metadata_input::Builder::default()
    }
}

/// See [`ListChunksInput`](crate::input::ListChunksInput).
pub mod list_chunks_input {
    
    /// A builder for [`ListChunksInput`](crate::input::ListChunksInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_job_id: std::option::Option<std::string::String>,
        pub(crate) object_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Storage job id
        pub fn storage_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_job_id = Some(input.into());
            self
        }
        /// Storage job id
        pub fn set_storage_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_job_id = input; self
        }
        /// Object token
        pub fn object_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_token = Some(input.into());
            self
        }
        /// Object token
        pub fn set_object_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_token = input; self
        }
        /// Maximum number of chunks
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// Maximum number of chunks
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Pagination token
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// Pagination token
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListChunksInput`](crate::input::ListChunksInput).
        pub fn build(self) -> Result<crate::input::ListChunksInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListChunksInput {
                    storage_job_id: self.storage_job_id
                    ,
                    object_token: self.object_token
                    ,
                    max_results: self.max_results
                        .unwrap_or_default()
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListChunksInput {
    /// Consumes the builder and constructs an Operation<[`ListChunks`](crate::operation::ListChunks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListChunks, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListChunksInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.storage_job_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))?;
                let storage_job_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if storage_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))
                            }
                let input_8 = &_input.object_token;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_token", "cannot be empty or unset"))?;
                let object_token = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if object_token.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_token", "cannot be empty or unset"))
                            }
                write!(output, "/restore-jobs/{StorageJobId}/chunks/{ObjectToken}/list", StorageJobId = storage_job_id, ObjectToken = object_token).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListChunksInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if _input.max_results != 0 {
                    query.push_kv("max-results", aws_smithy_types::primitive::Encoder::from(_input.max_results).encode());
                }
                if let Some(inner_9) = &_input.next_token {
                     {
                        query.push_kv("next-token", &aws_smithy_http::query::fmt_string(&inner_9));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListChunksInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListChunks::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListChunks", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListChunksInput`](crate::input::ListChunksInput).
    pub fn builder() -> crate::input::list_chunks_input::Builder {
        crate::input::list_chunks_input::Builder::default()
    }
}

/// See [`ListObjectsInput`](crate::input::ListObjectsInput).
pub mod list_objects_input {
    
    /// A builder for [`ListObjectsInput`](crate::input::ListObjectsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) storage_job_id: std::option::Option<std::string::String>,
        pub(crate) starting_object_name: std::option::Option<std::string::String>,
        pub(crate) starting_object_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) created_before: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_after: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// Storage job id
        pub fn storage_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage_job_id = Some(input.into());
            self
        }
        /// Storage job id
        pub fn set_storage_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage_job_id = input; self
        }
        /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
        pub fn starting_object_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_object_name = Some(input.into());
            self
        }
        /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
        pub fn set_starting_object_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_object_name = input; self
        }
        /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
        pub fn starting_object_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.starting_object_prefix = Some(input.into());
            self
        }
        /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
        pub fn set_starting_object_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.starting_object_prefix = input; self
        }
        /// Maximum objects count
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// Maximum objects count
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// Pagination token
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// Pagination token
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// (Optional) Created before filter
        pub fn created_before(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_before = Some(input);
            self
        }
        /// (Optional) Created before filter
        pub fn set_created_before(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_before = input; self
        }
        /// (Optional) Created after filter
        pub fn created_after(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_after = Some(input);
            self
        }
        /// (Optional) Created after filter
        pub fn set_created_after(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_after = input; self
        }
        /// Consumes the builder and constructs a [`ListObjectsInput`](crate::input::ListObjectsInput).
        pub fn build(self) -> Result<crate::input::ListObjectsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListObjectsInput {
                    storage_job_id: self.storage_job_id
                    ,
                    starting_object_name: self.starting_object_name
                    ,
                    starting_object_prefix: self.starting_object_prefix
                    ,
                    max_results: self.max_results
                        .unwrap_or_default()
                    ,
                    next_token: self.next_token
                    ,
                    created_before: self.created_before
                    ,
                    created_after: self.created_after
                    ,
                }
            )
        }
    }
    
    
}
impl ListObjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListObjects`](crate::operation::ListObjects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListObjects, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListObjectsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.storage_job_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))?;
                let storage_job_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if storage_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("storage_job_id", "cannot be empty or unset"))
                            }
                write!(output, "/restore-jobs/{StorageJobId}/objects/list", StorageJobId = storage_job_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListObjectsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_11) = &_input.starting_object_name {
                     {
                        query.push_kv("starting-object-name", &aws_smithy_http::query::fmt_string(&inner_11));
                    }
                }
                if let Some(inner_12) = &_input.starting_object_prefix {
                     {
                        query.push_kv("starting-object-prefix", &aws_smithy_http::query::fmt_string(&inner_12));
                    }
                }
                if _input.max_results != 0 {
                    query.push_kv("max-results", aws_smithy_types::primitive::Encoder::from(_input.max_results).encode());
                }
                if let Some(inner_13) = &_input.next_token {
                     {
                        query.push_kv("next-token", &aws_smithy_http::query::fmt_string(&inner_13));
                    }
                }
                if let Some(inner_14) = &_input.created_before {
                     {
                        query.push_kv("created-before", &aws_smithy_http::query::fmt_timestamp(inner_14, aws_smithy_types::date_time::Format::DateTime)?);
                    }
                }
                if let Some(inner_15) = &_input.created_after {
                     {
                        query.push_kv("created-after", &aws_smithy_http::query::fmt_timestamp(inner_15, aws_smithy_types::date_time::Format::DateTime)?);
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListObjectsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListObjects::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListObjects", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListObjectsInput`](crate::input::ListObjectsInput).
    pub fn builder() -> crate::input::list_objects_input::Builder {
        crate::input::list_objects_input::Builder::default()
    }
}

/// See [`NotifyObjectCompleteInput`](crate::input::NotifyObjectCompleteInput).
pub mod notify_object_complete_input {
    
    /// A builder for [`NotifyObjectCompleteInput`](crate::input::NotifyObjectCompleteInput).
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) object_checksum: std::option::Option<std::string::String>,
        pub(crate) object_checksum_algorithm: std::option::Option<crate::model::SummaryChecksumAlgorithm>,
        pub(crate) metadata_string: std::option::Option<std::string::String>,
        pub(crate) metadata_blob: std::option::Option<aws_smithy_http::byte_stream::ByteStream>,
        pub(crate) metadata_blob_length: std::option::Option<i64>,
        pub(crate) metadata_blob_checksum: std::option::Option<std::string::String>,
        pub(crate) metadata_blob_checksum_algorithm: std::option::Option<crate::model::DataChecksumAlgorithm>,
    }
    impl Builder {
        /// Backup job Id for the in-progress backup
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        /// Backup job Id for the in-progress backup
        pub fn set_backup_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_job_id = input; self
        }
        /// Upload Id for the in-progress upload
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        /// Upload Id for the in-progress upload
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input; self
        }
        /// Object checksum
        pub fn object_checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_checksum = Some(input.into());
            self
        }
        /// Object checksum
        pub fn set_object_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_checksum = input; self
        }
        /// Checksum algorithm
        pub fn object_checksum_algorithm(mut self, input: crate::model::SummaryChecksumAlgorithm) -> Self {
            self.object_checksum_algorithm = Some(input);
            self
        }
        /// Checksum algorithm
        pub fn set_object_checksum_algorithm(mut self, input: std::option::Option<crate::model::SummaryChecksumAlgorithm>) -> Self {
            self.object_checksum_algorithm = input; self
        }
        /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
        pub fn metadata_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_string = Some(input.into());
            self
        }
        /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
        pub fn set_metadata_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata_string = input; self
        }
        /// Optional metadata associated with an Object. Maximum length is 4MB.
        pub fn metadata_blob(mut self, input: aws_smithy_http::byte_stream::ByteStream) -> Self {
            self.metadata_blob = Some(input);
            self
        }
        /// Optional metadata associated with an Object. Maximum length is 4MB.
        pub fn set_metadata_blob(mut self, input: std::option::Option<aws_smithy_http::byte_stream::ByteStream>) -> Self {
            self.metadata_blob = input; self
        }
        /// The size of MetadataBlob.
        pub fn metadata_blob_length(mut self, input: i64) -> Self {
            self.metadata_blob_length = Some(input);
            self
        }
        /// The size of MetadataBlob.
        pub fn set_metadata_blob_length(mut self, input: std::option::Option<i64>) -> Self {
            self.metadata_blob_length = input; self
        }
        /// Checksum of MetadataBlob.
        pub fn metadata_blob_checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_blob_checksum = Some(input.into());
            self
        }
        /// Checksum of MetadataBlob.
        pub fn set_metadata_blob_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata_blob_checksum = input; self
        }
        /// Checksum algorithm.
        pub fn metadata_blob_checksum_algorithm(mut self, input: crate::model::DataChecksumAlgorithm) -> Self {
            self.metadata_blob_checksum_algorithm = Some(input);
            self
        }
        /// Checksum algorithm.
        pub fn set_metadata_blob_checksum_algorithm(mut self, input: std::option::Option<crate::model::DataChecksumAlgorithm>) -> Self {
            self.metadata_blob_checksum_algorithm = input; self
        }
        /// Consumes the builder and constructs a [`NotifyObjectCompleteInput`](crate::input::NotifyObjectCompleteInput).
        pub fn build(self) -> Result<crate::input::NotifyObjectCompleteInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::NotifyObjectCompleteInput {
                    backup_job_id: self.backup_job_id
                    ,
                    upload_id: self.upload_id
                    ,
                    object_checksum: self.object_checksum
                    ,
                    object_checksum_algorithm: self.object_checksum_algorithm
                    ,
                    metadata_string: self.metadata_string
                    ,
                    metadata_blob: self.metadata_blob
                        .unwrap_or_default()
                    ,
                    metadata_blob_length: self.metadata_blob_length
                        .unwrap_or_default()
                    ,
                    metadata_blob_checksum: self.metadata_blob_checksum
                    ,
                    metadata_blob_checksum_algorithm: self.metadata_blob_checksum_algorithm
                    ,
                }
            )
        }
    }
    
    
}
impl NotifyObjectCompleteInput {
    /// Consumes the builder and constructs an Operation<[`NotifyObjectComplete`](crate::operation::NotifyObjectComplete)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::NotifyObjectComplete, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::NotifyObjectCompleteInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.backup_job_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))?;
                let backup_job_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if backup_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))
                            }
                let input_17 = &_input.upload_id;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("upload_id", "cannot be empty or unset"))?;
                let upload_id = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if upload_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("upload_id", "cannot be empty or unset"))
                            }
                write!(output, "/backup-jobs/{BackupJobId}/object/{UploadId}/complete", BackupJobId = backup_job_id, UploadId = upload_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::NotifyObjectCompleteInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_18 = &_input.object_checksum;
                let inner_18 = inner_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_checksum", "cannot be empty or unset"))?;
                if inner_18.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_checksum", "cannot be empty or unset"));
                }
                query.push_kv("checksum", &aws_smithy_http::query::fmt_string(&inner_18));
                let inner_19 = &_input.object_checksum_algorithm;
                let inner_19 = inner_19.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_checksum_algorithm", "cannot be empty or unset"))?;
                query.push_kv("checksum-algorithm", &aws_smithy_http::query::fmt_string(&inner_19));
                if let Some(inner_20) = &_input.metadata_string {
                     {
                        query.push_kv("metadata-string", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                if _input.metadata_blob_length != 0 {
                    query.push_kv("metadata-blob-length", aws_smithy_types::primitive::Encoder::from(_input.metadata_blob_length).encode());
                }
                if let Some(inner_21) = &_input.metadata_blob_checksum {
                     {
                        query.push_kv("metadata-checksum", &aws_smithy_http::query::fmt_string(&inner_21));
                    }
                }
                if let Some(inner_22) = &_input.metadata_blob_checksum_algorithm {
                     {
                        query.push_kv("metadata-checksum-algorithm", &aws_smithy_http::query::fmt_string(&inner_22));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::NotifyObjectCompleteInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/octet-stream");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_notify_object_complete_input( self.metadata_blob)?
            .into_inner()
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        request.properties_mut().insert(aws_sig_auth::signer::SignableBody::UnsignedPayload);
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::NotifyObjectComplete::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("NotifyObjectComplete", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`NotifyObjectCompleteInput`](crate::input::NotifyObjectCompleteInput).
    pub fn builder() -> crate::input::notify_object_complete_input::Builder {
        crate::input::notify_object_complete_input::Builder::default()
    }
}

/// See [`PutChunkInput`](crate::input::PutChunkInput).
pub mod put_chunk_input {
    
    /// A builder for [`PutChunkInput`](crate::input::PutChunkInput).
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
        pub(crate) upload_id: std::option::Option<std::string::String>,
        pub(crate) chunk_index: std::option::Option<i64>,
        pub(crate) data: std::option::Option<aws_smithy_http::byte_stream::ByteStream>,
        pub(crate) length: std::option::Option<i64>,
        pub(crate) checksum: std::option::Option<std::string::String>,
        pub(crate) checksum_algorithm: std::option::Option<crate::model::DataChecksumAlgorithm>,
    }
    impl Builder {
        /// Backup job Id for the in-progress backup.
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        /// Backup job Id for the in-progress backup.
        pub fn set_backup_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_job_id = input; self
        }
        /// Upload Id for the in-progress upload.
        pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_id = Some(input.into());
            self
        }
        /// Upload Id for the in-progress upload.
        pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upload_id = input; self
        }
        /// Describes this chunk's position relative to the other chunks
        pub fn chunk_index(mut self, input: i64) -> Self {
            self.chunk_index = Some(input);
            self
        }
        /// Describes this chunk's position relative to the other chunks
        pub fn set_chunk_index(mut self, input: std::option::Option<i64>) -> Self {
            self.chunk_index = input; self
        }
        /// Data to be uploaded
        pub fn data(mut self, input: aws_smithy_http::byte_stream::ByteStream) -> Self {
            self.data = Some(input);
            self
        }
        /// Data to be uploaded
        pub fn set_data(mut self, input: std::option::Option<aws_smithy_http::byte_stream::ByteStream>) -> Self {
            self.data = input; self
        }
        /// Data length
        pub fn length(mut self, input: i64) -> Self {
            self.length = Some(input);
            self
        }
        /// Data length
        pub fn set_length(mut self, input: std::option::Option<i64>) -> Self {
            self.length = input; self
        }
        /// Data checksum
        pub fn checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.checksum = Some(input.into());
            self
        }
        /// Data checksum
        pub fn set_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.checksum = input; self
        }
        /// Checksum algorithm
        pub fn checksum_algorithm(mut self, input: crate::model::DataChecksumAlgorithm) -> Self {
            self.checksum_algorithm = Some(input);
            self
        }
        /// Checksum algorithm
        pub fn set_checksum_algorithm(mut self, input: std::option::Option<crate::model::DataChecksumAlgorithm>) -> Self {
            self.checksum_algorithm = input; self
        }
        /// Consumes the builder and constructs a [`PutChunkInput`](crate::input::PutChunkInput).
        pub fn build(self) -> Result<crate::input::PutChunkInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutChunkInput {
                    backup_job_id: self.backup_job_id
                    ,
                    upload_id: self.upload_id
                    ,
                    chunk_index: self.chunk_index
                        .unwrap_or_default()
                    ,
                    data: self.data
                        .unwrap_or_default()
                    ,
                    length: self.length
                        .unwrap_or_default()
                    ,
                    checksum: self.checksum
                    ,
                    checksum_algorithm: self.checksum_algorithm
                    ,
                }
            )
        }
    }
    
    
}
impl PutChunkInput {
    /// Consumes the builder and constructs an Operation<[`PutChunk`](crate::operation::PutChunk)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutChunk, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutChunkInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.backup_job_id;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))?;
                let backup_job_id = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if backup_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))
                            }
                let input_24 = &_input.upload_id;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("upload_id", "cannot be empty or unset"))?;
                let upload_id = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if upload_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("upload_id", "cannot be empty or unset"))
                            }
                let input_25 = &_input.chunk_index;
                let mut chunk_index_encoder = aws_smithy_types::primitive::Encoder::from(*input_25); let chunk_index = chunk_index_encoder.encode();
                if chunk_index.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("chunk_index", "cannot be empty or unset"))
                            }
                write!(output, "/backup-jobs/{BackupJobId}/chunk/{UploadId}/{ChunkIndex}", BackupJobId = backup_job_id, UploadId = upload_id, ChunkIndex = chunk_index).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::PutChunkInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_26 = &_input.length;
                query.push_kv("length", aws_smithy_types::primitive::Encoder::from(*inner_26).encode());
                let inner_27 = &_input.checksum;
                let inner_27 = inner_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("checksum", "cannot be empty or unset"))?;
                if inner_27.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("checksum", "cannot be empty or unset"));
                }
                query.push_kv("checksum", &aws_smithy_http::query::fmt_string(&inner_27));
                let inner_28 = &_input.checksum_algorithm;
                let inner_28 = inner_28.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("checksum_algorithm", "cannot be empty or unset"))?;
                query.push_kv("checksum-algorithm", &aws_smithy_http::query::fmt_string(&inner_28));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutChunkInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/octet-stream");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_put_chunk_input( self.data)?
            .into_inner()
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        request.properties_mut().insert(aws_sig_auth::signer::SignableBody::UnsignedPayload);
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutChunk::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutChunk", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutChunkInput`](crate::input::PutChunkInput).
    pub fn builder() -> crate::input::put_chunk_input::Builder {
        crate::input::put_chunk_input::Builder::default()
    }
}

/// See [`PutObjectInput`](crate::input::PutObjectInput).
pub mod put_object_input {
    
    /// A builder for [`PutObjectInput`](crate::input::PutObjectInput).
    #[derive(std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
        pub(crate) object_name: std::option::Option<std::string::String>,
        pub(crate) metadata_string: std::option::Option<std::string::String>,
        pub(crate) inline_chunk: std::option::Option<aws_smithy_http::byte_stream::ByteStream>,
        pub(crate) inline_chunk_length: std::option::Option<i64>,
        pub(crate) inline_chunk_checksum: std::option::Option<std::string::String>,
        pub(crate) inline_chunk_checksum_algorithm: std::option::Option<std::string::String>,
        pub(crate) object_checksum: std::option::Option<std::string::String>,
        pub(crate) object_checksum_algorithm: std::option::Option<crate::model::SummaryChecksumAlgorithm>,
        pub(crate) throw_on_duplicate: std::option::Option<bool>,
    }
    impl Builder {
        /// Backup job Id for the in-progress backup.
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        /// Backup job Id for the in-progress backup.
        pub fn set_backup_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_job_id = input; self
        }
        /// The name of the Object to be uploaded.
        pub fn object_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_name = Some(input.into());
            self
        }
        /// The name of the Object to be uploaded.
        pub fn set_object_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_name = input; self
        }
        /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
        pub fn metadata_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata_string = Some(input.into());
            self
        }
        /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
        pub fn set_metadata_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata_string = input; self
        }
        /// Inline chunk data to be uploaded.
        pub fn inline_chunk(mut self, input: aws_smithy_http::byte_stream::ByteStream) -> Self {
            self.inline_chunk = Some(input);
            self
        }
        /// Inline chunk data to be uploaded.
        pub fn set_inline_chunk(mut self, input: std::option::Option<aws_smithy_http::byte_stream::ByteStream>) -> Self {
            self.inline_chunk = input; self
        }
        /// Length of the inline chunk data.
        pub fn inline_chunk_length(mut self, input: i64) -> Self {
            self.inline_chunk_length = Some(input);
            self
        }
        /// Length of the inline chunk data.
        pub fn set_inline_chunk_length(mut self, input: std::option::Option<i64>) -> Self {
            self.inline_chunk_length = input; self
        }
        /// Inline chunk checksum
        pub fn inline_chunk_checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.inline_chunk_checksum = Some(input.into());
            self
        }
        /// Inline chunk checksum
        pub fn set_inline_chunk_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inline_chunk_checksum = input; self
        }
        /// Inline chunk checksum algorithm
        pub fn inline_chunk_checksum_algorithm(mut self, input: impl Into<std::string::String>) -> Self {
            self.inline_chunk_checksum_algorithm = Some(input.into());
            self
        }
        /// Inline chunk checksum algorithm
        pub fn set_inline_chunk_checksum_algorithm(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inline_chunk_checksum_algorithm = input; self
        }
        /// object checksum
        pub fn object_checksum(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_checksum = Some(input.into());
            self
        }
        /// object checksum
        pub fn set_object_checksum(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_checksum = input; self
        }
        /// object checksum algorithm
        pub fn object_checksum_algorithm(mut self, input: crate::model::SummaryChecksumAlgorithm) -> Self {
            self.object_checksum_algorithm = Some(input);
            self
        }
        /// object checksum algorithm
        pub fn set_object_checksum_algorithm(mut self, input: std::option::Option<crate::model::SummaryChecksumAlgorithm>) -> Self {
            self.object_checksum_algorithm = input; self
        }
        /// Throw an exception if Object name is already exist.
        pub fn throw_on_duplicate(mut self, input: bool) -> Self {
            self.throw_on_duplicate = Some(input);
            self
        }
        /// Throw an exception if Object name is already exist.
        pub fn set_throw_on_duplicate(mut self, input: std::option::Option<bool>) -> Self {
            self.throw_on_duplicate = input; self
        }
        /// Consumes the builder and constructs a [`PutObjectInput`](crate::input::PutObjectInput).
        pub fn build(self) -> Result<crate::input::PutObjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutObjectInput {
                    backup_job_id: self.backup_job_id
                    ,
                    object_name: self.object_name
                    ,
                    metadata_string: self.metadata_string
                    ,
                    inline_chunk: self.inline_chunk
                        .unwrap_or_default()
                    ,
                    inline_chunk_length: self.inline_chunk_length
                        .unwrap_or_default()
                    ,
                    inline_chunk_checksum: self.inline_chunk_checksum
                    ,
                    inline_chunk_checksum_algorithm: self.inline_chunk_checksum_algorithm
                    ,
                    object_checksum: self.object_checksum
                    ,
                    object_checksum_algorithm: self.object_checksum_algorithm
                    ,
                    throw_on_duplicate: self.throw_on_duplicate
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl PutObjectInput {
    /// Consumes the builder and constructs an Operation<[`PutObject`](crate::operation::PutObject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutObject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutObjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_29 = &_input.backup_job_id;
                let input_29 = input_29.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))?;
                let backup_job_id = aws_smithy_http::label::fmt_string(input_29, aws_smithy_http::label::EncodingStrategy::Default);
                if backup_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))
                            }
                let input_30 = &_input.object_name;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))?;
                let object_name = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if object_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))
                            }
                write!(output, "/backup-jobs/{BackupJobId}/object/{ObjectName}/put-object", BackupJobId = backup_job_id, ObjectName = object_name).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::PutObjectInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_31) = &_input.metadata_string {
                     {
                        query.push_kv("metadata-string", &aws_smithy_http::query::fmt_string(&inner_31));
                    }
                }
                if _input.inline_chunk_length != 0 {
                    query.push_kv("length", aws_smithy_types::primitive::Encoder::from(_input.inline_chunk_length).encode());
                }
                if let Some(inner_32) = &_input.inline_chunk_checksum {
                     {
                        query.push_kv("checksum", &aws_smithy_http::query::fmt_string(&inner_32));
                    }
                }
                if let Some(inner_33) = &_input.inline_chunk_checksum_algorithm {
                     {
                        query.push_kv("checksum-algorithm", &aws_smithy_http::query::fmt_string(&inner_33));
                    }
                }
                if let Some(inner_34) = &_input.object_checksum {
                     {
                        query.push_kv("object-checksum", &aws_smithy_http::query::fmt_string(&inner_34));
                    }
                }
                if let Some(inner_35) = &_input.object_checksum_algorithm {
                     {
                        query.push_kv("object-checksum-algorithm", &aws_smithy_http::query::fmt_string(&inner_35));
                    }
                }
                if _input.throw_on_duplicate {
                    query.push_kv("throwOnDuplicate", aws_smithy_types::primitive::Encoder::from(_input.throw_on_duplicate).encode());
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutObjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/octet-stream");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_payload_put_object_input( self.inline_chunk)?
            .into_inner()
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        signing_config.signing_options.content_sha256_header = true;
        request.properties_mut().insert(aws_sig_auth::signer::SignableBody::UnsignedPayload);
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutObject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutObject", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutObjectInput`](crate::input::PutObjectInput).
    pub fn builder() -> crate::input::put_object_input::Builder {
        crate::input::put_object_input::Builder::default()
    }
}

/// See [`StartObjectInput`](crate::input::StartObjectInput).
pub mod start_object_input {
    
    /// A builder for [`StartObjectInput`](crate::input::StartObjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_job_id: std::option::Option<std::string::String>,
        pub(crate) object_name: std::option::Option<std::string::String>,
        pub(crate) throw_on_duplicate: std::option::Option<bool>,
    }
    impl Builder {
        /// Backup job Id for the in-progress backup
        pub fn backup_job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_job_id = Some(input.into());
            self
        }
        /// Backup job Id for the in-progress backup
        pub fn set_backup_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_job_id = input; self
        }
        /// Name for the object.
        pub fn object_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.object_name = Some(input.into());
            self
        }
        /// Name for the object.
        pub fn set_object_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.object_name = input; self
        }
        /// Throw an exception if Object name is already exist.
        pub fn throw_on_duplicate(mut self, input: bool) -> Self {
            self.throw_on_duplicate = Some(input);
            self
        }
        /// Throw an exception if Object name is already exist.
        pub fn set_throw_on_duplicate(mut self, input: std::option::Option<bool>) -> Self {
            self.throw_on_duplicate = input; self
        }
        /// Consumes the builder and constructs a [`StartObjectInput`](crate::input::StartObjectInput).
        pub fn build(self) -> Result<crate::input::StartObjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::StartObjectInput {
                    backup_job_id: self.backup_job_id
                    ,
                    object_name: self.object_name
                    ,
                    throw_on_duplicate: self.throw_on_duplicate
                        .unwrap_or_default()
                    ,
                }
            )
        }
    }
    
    
}
impl StartObjectInput {
    /// Consumes the builder and constructs an Operation<[`StartObject`](crate::operation::StartObject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::StartObject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::StartObjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_36 = &_input.backup_job_id;
                let input_36 = input_36.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))?;
                let backup_job_id = aws_smithy_http::label::fmt_string(input_36, aws_smithy_http::label::EncodingStrategy::Default);
                if backup_job_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("backup_job_id", "cannot be empty or unset"))
                            }
                let input_37 = &_input.object_name;
                let input_37 = input_37.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))?;
                let object_name = aws_smithy_http::label::fmt_string(input_37, aws_smithy_http::label::EncodingStrategy::Default);
                if object_name.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("object_name", "cannot be empty or unset"))
                            }
                write!(output, "/backup-jobs/{BackupJobId}/object/{ObjectName}", BackupJobId = backup_job_id, ObjectName = object_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::StartObjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_object(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::StartObject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("StartObject", "backupstorage"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartObjectInput`](crate::input::StartObjectInput).
    pub fn builder() -> crate::input::start_object_input::Builder {
        crate::input::start_object_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartObjectInput  {
    /// Backup job Id for the in-progress backup
    #[doc(hidden)]
    pub backup_job_id: std::option::Option<std::string::String>,
    /// Name for the object.
    #[doc(hidden)]
    pub object_name: std::option::Option<std::string::String>,
    /// Throw an exception if Object name is already exist.
    #[doc(hidden)]
    pub throw_on_duplicate: bool,
}
impl StartObjectInput {
    /// Backup job Id for the in-progress backup
    pub fn backup_job_id(&self) -> std::option::Option<& str> {
        self.backup_job_id.as_deref()
    }
    /// Name for the object.
    pub fn object_name(&self) -> std::option::Option<& str> {
        self.object_name.as_deref()
    }
    /// Throw an exception if Object name is already exist.
    pub fn throw_on_duplicate(&self) -> bool {
        self.throw_on_duplicate
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutObjectInput  {
    /// Backup job Id for the in-progress backup.
    #[doc(hidden)]
    pub backup_job_id: std::option::Option<std::string::String>,
    /// The name of the Object to be uploaded.
    #[doc(hidden)]
    pub object_name: std::option::Option<std::string::String>,
    /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
    #[doc(hidden)]
    pub metadata_string: std::option::Option<std::string::String>,
    /// Inline chunk data to be uploaded.
    pub inline_chunk: aws_smithy_http::byte_stream::ByteStream,
    /// Length of the inline chunk data.
    #[doc(hidden)]
    pub inline_chunk_length: i64,
    /// Inline chunk checksum
    #[doc(hidden)]
    pub inline_chunk_checksum: std::option::Option<std::string::String>,
    /// Inline chunk checksum algorithm
    #[doc(hidden)]
    pub inline_chunk_checksum_algorithm: std::option::Option<std::string::String>,
    /// object checksum
    #[doc(hidden)]
    pub object_checksum: std::option::Option<std::string::String>,
    /// object checksum algorithm
    #[doc(hidden)]
    pub object_checksum_algorithm: std::option::Option<crate::model::SummaryChecksumAlgorithm>,
    /// Throw an exception if Object name is already exist.
    #[doc(hidden)]
    pub throw_on_duplicate: bool,
}
impl PutObjectInput {
    /// Backup job Id for the in-progress backup.
    pub fn backup_job_id(&self) -> std::option::Option<& str> {
        self.backup_job_id.as_deref()
    }
    /// The name of the Object to be uploaded.
    pub fn object_name(&self) -> std::option::Option<& str> {
        self.object_name.as_deref()
    }
    /// Store user defined metadata like backup checksum, disk ids, restore metadata etc.
    pub fn metadata_string(&self) -> std::option::Option<& str> {
        self.metadata_string.as_deref()
    }
    /// Inline chunk data to be uploaded.
    pub fn inline_chunk(&self) -> & aws_smithy_http::byte_stream::ByteStream {
        &self.inline_chunk
    }
    /// Length of the inline chunk data.
    pub fn inline_chunk_length(&self) -> i64 {
        self.inline_chunk_length
    }
    /// Inline chunk checksum
    pub fn inline_chunk_checksum(&self) -> std::option::Option<& str> {
        self.inline_chunk_checksum.as_deref()
    }
    /// Inline chunk checksum algorithm
    pub fn inline_chunk_checksum_algorithm(&self) -> std::option::Option<& str> {
        self.inline_chunk_checksum_algorithm.as_deref()
    }
    /// object checksum
    pub fn object_checksum(&self) -> std::option::Option<& str> {
        self.object_checksum.as_deref()
    }
    /// object checksum algorithm
    pub fn object_checksum_algorithm(&self) -> std::option::Option<& crate::model::SummaryChecksumAlgorithm> {
        self.object_checksum_algorithm.as_ref()
    }
    /// Throw an exception if Object name is already exist.
    pub fn throw_on_duplicate(&self) -> bool {
        self.throw_on_duplicate
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutChunkInput  {
    /// Backup job Id for the in-progress backup.
    #[doc(hidden)]
    pub backup_job_id: std::option::Option<std::string::String>,
    /// Upload Id for the in-progress upload.
    #[doc(hidden)]
    pub upload_id: std::option::Option<std::string::String>,
    /// Describes this chunk's position relative to the other chunks
    #[doc(hidden)]
    pub chunk_index: i64,
    /// Data to be uploaded
    pub data: aws_smithy_http::byte_stream::ByteStream,
    /// Data length
    #[doc(hidden)]
    pub length: i64,
    /// Data checksum
    #[doc(hidden)]
    pub checksum: std::option::Option<std::string::String>,
    /// Checksum algorithm
    #[doc(hidden)]
    pub checksum_algorithm: std::option::Option<crate::model::DataChecksumAlgorithm>,
}
impl PutChunkInput {
    /// Backup job Id for the in-progress backup.
    pub fn backup_job_id(&self) -> std::option::Option<& str> {
        self.backup_job_id.as_deref()
    }
    /// Upload Id for the in-progress upload.
    pub fn upload_id(&self) -> std::option::Option<& str> {
        self.upload_id.as_deref()
    }
    /// Describes this chunk's position relative to the other chunks
    pub fn chunk_index(&self) -> i64 {
        self.chunk_index
    }
    /// Data to be uploaded
    pub fn data(&self) -> & aws_smithy_http::byte_stream::ByteStream {
        &self.data
    }
    /// Data length
    pub fn length(&self) -> i64 {
        self.length
    }
    /// Data checksum
    pub fn checksum(&self) -> std::option::Option<& str> {
        self.checksum.as_deref()
    }
    /// Checksum algorithm
    pub fn checksum_algorithm(&self) -> std::option::Option<& crate::model::DataChecksumAlgorithm> {
        self.checksum_algorithm.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct NotifyObjectCompleteInput  {
    /// Backup job Id for the in-progress backup
    #[doc(hidden)]
    pub backup_job_id: std::option::Option<std::string::String>,
    /// Upload Id for the in-progress upload
    #[doc(hidden)]
    pub upload_id: std::option::Option<std::string::String>,
    /// Object checksum
    #[doc(hidden)]
    pub object_checksum: std::option::Option<std::string::String>,
    /// Checksum algorithm
    #[doc(hidden)]
    pub object_checksum_algorithm: std::option::Option<crate::model::SummaryChecksumAlgorithm>,
    /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
    #[doc(hidden)]
    pub metadata_string: std::option::Option<std::string::String>,
    /// Optional metadata associated with an Object. Maximum length is 4MB.
    pub metadata_blob: aws_smithy_http::byte_stream::ByteStream,
    /// The size of MetadataBlob.
    #[doc(hidden)]
    pub metadata_blob_length: i64,
    /// Checksum of MetadataBlob.
    #[doc(hidden)]
    pub metadata_blob_checksum: std::option::Option<std::string::String>,
    /// Checksum algorithm.
    #[doc(hidden)]
    pub metadata_blob_checksum_algorithm: std::option::Option<crate::model::DataChecksumAlgorithm>,
}
impl NotifyObjectCompleteInput {
    /// Backup job Id for the in-progress backup
    pub fn backup_job_id(&self) -> std::option::Option<& str> {
        self.backup_job_id.as_deref()
    }
    /// Upload Id for the in-progress upload
    pub fn upload_id(&self) -> std::option::Option<& str> {
        self.upload_id.as_deref()
    }
    /// Object checksum
    pub fn object_checksum(&self) -> std::option::Option<& str> {
        self.object_checksum.as_deref()
    }
    /// Checksum algorithm
    pub fn object_checksum_algorithm(&self) -> std::option::Option<& crate::model::SummaryChecksumAlgorithm> {
        self.object_checksum_algorithm.as_ref()
    }
    /// Optional metadata associated with an Object. Maximum string length is 256 bytes.
    pub fn metadata_string(&self) -> std::option::Option<& str> {
        self.metadata_string.as_deref()
    }
    /// Optional metadata associated with an Object. Maximum length is 4MB.
    pub fn metadata_blob(&self) -> & aws_smithy_http::byte_stream::ByteStream {
        &self.metadata_blob
    }
    /// The size of MetadataBlob.
    pub fn metadata_blob_length(&self) -> i64 {
        self.metadata_blob_length
    }
    /// Checksum of MetadataBlob.
    pub fn metadata_blob_checksum(&self) -> std::option::Option<& str> {
        self.metadata_blob_checksum.as_deref()
    }
    /// Checksum algorithm.
    pub fn metadata_blob_checksum_algorithm(&self) -> std::option::Option<& crate::model::DataChecksumAlgorithm> {
        self.metadata_blob_checksum_algorithm.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListObjectsInput  {
    /// Storage job id
    #[doc(hidden)]
    pub storage_job_id: std::option::Option<std::string::String>,
    /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
    #[doc(hidden)]
    pub starting_object_name: std::option::Option<std::string::String>,
    /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
    #[doc(hidden)]
    pub starting_object_prefix: std::option::Option<std::string::String>,
    /// Maximum objects count
    #[doc(hidden)]
    pub max_results: i32,
    /// Pagination token
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// (Optional) Created before filter
    #[doc(hidden)]
    pub created_before: std::option::Option<aws_smithy_types::DateTime>,
    /// (Optional) Created after filter
    #[doc(hidden)]
    pub created_after: std::option::Option<aws_smithy_types::DateTime>,
}
impl ListObjectsInput {
    /// Storage job id
    pub fn storage_job_id(&self) -> std::option::Option<& str> {
        self.storage_job_id.as_deref()
    }
    /// Optional, specifies the starting Object name to list from. Ignored if NextToken is not NULL
    pub fn starting_object_name(&self) -> std::option::Option<& str> {
        self.starting_object_name.as_deref()
    }
    /// Optional, specifies the starting Object prefix to list from. Ignored if NextToken is not NULL
    pub fn starting_object_prefix(&self) -> std::option::Option<& str> {
        self.starting_object_prefix.as_deref()
    }
    /// Maximum objects count
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// Pagination token
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// (Optional) Created before filter
    pub fn created_before(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_before.as_ref()
    }
    /// (Optional) Created after filter
    pub fn created_after(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_after.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListChunksInput  {
    /// Storage job id
    #[doc(hidden)]
    pub storage_job_id: std::option::Option<std::string::String>,
    /// Object token
    #[doc(hidden)]
    pub object_token: std::option::Option<std::string::String>,
    /// Maximum number of chunks
    #[doc(hidden)]
    pub max_results: i32,
    /// Pagination token
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListChunksInput {
    /// Storage job id
    pub fn storage_job_id(&self) -> std::option::Option<& str> {
        self.storage_job_id.as_deref()
    }
    /// Object token
    pub fn object_token(&self) -> std::option::Option<& str> {
        self.object_token.as_deref()
    }
    /// Maximum number of chunks
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// Pagination token
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetObjectMetadataInput  {
    /// Backup job id for the in-progress backup.
    #[doc(hidden)]
    pub storage_job_id: std::option::Option<std::string::String>,
    /// Object token.
    #[doc(hidden)]
    pub object_token: std::option::Option<std::string::String>,
}
impl GetObjectMetadataInput {
    /// Backup job id for the in-progress backup.
    pub fn storage_job_id(&self) -> std::option::Option<& str> {
        self.storage_job_id.as_deref()
    }
    /// Object token.
    pub fn object_token(&self) -> std::option::Option<& str> {
        self.object_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetChunkInput  {
    /// Storage job id
    #[doc(hidden)]
    pub storage_job_id: std::option::Option<std::string::String>,
    /// Chunk token
    #[doc(hidden)]
    pub chunk_token: std::option::Option<std::string::String>,
}
impl GetChunkInput {
    /// Storage job id
    pub fn storage_job_id(&self) -> std::option::Option<& str> {
        self.storage_job_id.as_deref()
    }
    /// Chunk token
    pub fn chunk_token(&self) -> std::option::Option<& str> {
        self.chunk_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteObjectInput  {
    /// Backup job Id for the in-progress backup.
    #[doc(hidden)]
    pub backup_job_id: std::option::Option<std::string::String>,
    /// The name of the Object.
    #[doc(hidden)]
    pub object_name: std::option::Option<std::string::String>,
}
impl DeleteObjectInput {
    /// Backup job Id for the in-progress backup.
    pub fn backup_job_id(&self) -> std::option::Option<& str> {
        self.backup_job_id.as_deref()
    }
    /// The name of the Object.
    pub fn object_name(&self) -> std::option::Option<& str> {
        self.object_name.as_deref()
    }
}

