// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `CreateAndAttachS3AccessPoint`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateAndAttachS3AccessPoint;
impl CreateAndAttachS3AccessPoint {
    /// Creates a new `CreateAndAttachS3AccessPoint`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput,
    ) -> ::std::result::Result<
        crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        use ::tracing::Instrument;
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("FSx", "CreateAndAttachS3AccessPoint", input, runtime_plugins, stop_point)
            // Create a parent span for the entire operation. Includes a random, internal-only,
            // seven-digit ID for the operation orchestration so that it can be correlated in the logs.
            .instrument(::tracing::debug_span!(
                "FSx.CreateAndAttachS3AccessPoint",
                "rpc.service" = "FSx",
                "rpc.method" = "CreateAndAttachS3AccessPoint",
                "sdk_invocation_id" = ::fastrand::u32(1_000_000..10_000_000),
                "rpc.system" = "aws-api",
            ))
            .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins
            .with_operation_plugin(crate::client_idempotency_token::IdempotencyTokenRuntimePlugin::new(
                |token_provider, input| {
                    let input: &mut crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput =
                        input.downcast_mut().expect("correct type");
                    if input.client_request_token.is_none() {
                        input.client_request_token = ::std::option::Option::Some(token_provider.make_idempotency_token());
                    }
                },
            ))
            .with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
                ::aws_runtime::auth::sigv4::SCHEME_ID,
            ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for CreateAndAttachS3AccessPoint {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("CreateAndAttachS3AccessPoint");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            CreateAndAttachS3AccessPointRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            CreateAndAttachS3AccessPointResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new(
            "CreateAndAttachS3AccessPoint",
            "FSx",
        ));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("CreateAndAttachS3AccessPoint")
            .with_interceptor(::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::default())
            .with_interceptor(CreateAndAttachS3AccessPointEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct CreateAndAttachS3AccessPointResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for CreateAndAttachS3AccessPointResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_create_and_attach_s3_access_point::de_create_and_attach_s3_access_point_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_create_and_attach_s3_access_point::de_create_and_attach_s3_access_point_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct CreateAndAttachS3AccessPointRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for CreateAndAttachS3AccessPointRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "AWSSimbaAPIService_v20180301.CreateAndAttachS3AccessPoint",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(
            crate::protocol_serde::shape_create_and_attach_s3_access_point::ser_create_and_attach_s3_access_point_input(&input)?,
        );
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct CreateAndAttachS3AccessPointEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for CreateAndAttachS3AccessPointEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "CreateAndAttachS3AccessPointEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<CreateAndAttachS3AccessPointInput>()
            .ok_or("failed to downcast to CreateAndAttachS3AccessPointInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

// The get_* functions below are generated from JMESPath expressions in the
// operationContextParams trait. They target the operation's input shape.

/// Error type for the `CreateAndAttachS3AccessPointError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateAndAttachS3AccessPointError {
    /// <p>An access point with that name already exists in the Amazon Web Services Region in your Amazon Web Services account.</p>
    AccessPointAlreadyOwnedByYou(crate::types::error::AccessPointAlreadyOwnedByYou),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::types::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::types::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::types::error::InternalServerError),
    /// <p>The access point specified doesn't exist.</p>
    InvalidAccessPoint(crate::types::error::InvalidAccessPoint),
    /// <p>The action or operation requested is invalid. Verify that the action is typed correctly.</p>
    InvalidRequest(crate::types::error::InvalidRequest),
    /// <p>You have reached the maximum number of S3 access points attachments allowed for your account in this Amazon Web Services Region, or for the file system. For more information, or to request an increase, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/limits.html">Service quotas on FSx resources</a> in the FSx for OpenZFS User Guide.</p>
    TooManyAccessPoints(crate::types::error::TooManyAccessPoints),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::types::error::UnsupportedOperation),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::types::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-CreateAndAttachS3AccessPointError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl CreateAndAttachS3AccessPointError {
    /// Creates the `CreateAndAttachS3AccessPointError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `CreateAndAttachS3AccessPointError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessPointAlreadyOwnedByYou(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::BadRequest(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::IncompatibleParameterError(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InternalServerError(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidAccessPoint(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRequest(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::TooManyAccessPoints(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::UnsupportedOperation(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::VolumeNotFound(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::AccessPointAlreadyOwnedByYou`.
    pub fn is_access_point_already_owned_by_you(&self) -> bool {
        matches!(self, Self::AccessPointAlreadyOwnedByYou(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::InvalidAccessPoint`.
    pub fn is_invalid_access_point(&self) -> bool {
        matches!(self, Self::InvalidAccessPoint(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::InvalidRequest`.
    pub fn is_invalid_request(&self) -> bool {
        matches!(self, Self::InvalidRequest(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::TooManyAccessPoints`.
    pub fn is_too_many_access_points(&self) -> bool {
        matches!(self, Self::TooManyAccessPoints(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
    /// Returns `true` if the error kind is `CreateAndAttachS3AccessPointError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl ::std::error::Error for CreateAndAttachS3AccessPointError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::AccessPointAlreadyOwnedByYou(_inner) => ::std::option::Option::Some(_inner),
            Self::BadRequest(_inner) => ::std::option::Option::Some(_inner),
            Self::IncompatibleParameterError(_inner) => ::std::option::Option::Some(_inner),
            Self::InternalServerError(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAccessPoint(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRequest(_inner) => ::std::option::Option::Some(_inner),
            Self::TooManyAccessPoints(_inner) => ::std::option::Option::Some(_inner),
            Self::UnsupportedOperation(_inner) => ::std::option::Option::Some(_inner),
            Self::VolumeNotFound(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for CreateAndAttachS3AccessPointError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::AccessPointAlreadyOwnedByYou(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidAccessPoint(_inner) => _inner.fmt(f),
            Self::InvalidRequest(_inner) => _inner.fmt(f),
            Self::TooManyAccessPoints(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for CreateAndAttachS3AccessPointError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateAndAttachS3AccessPointError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessPointAlreadyOwnedByYou(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BadRequest(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::IncompatibleParameterError(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InternalServerError(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAccessPoint(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRequest(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TooManyAccessPoints(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::UnsupportedOperation(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::VolumeNotFound(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for CreateAndAttachS3AccessPointError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::create_and_attach_s3_access_point::CreateAndAttachS3AccessPointError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::create_and_attach_s3_access_point::_create_and_attach_s3_access_point_output::CreateAndAttachS3AccessPointOutput;

pub use crate::operation::create_and_attach_s3_access_point::_create_and_attach_s3_access_point_input::CreateAndAttachS3AccessPointInput;

mod _create_and_attach_s3_access_point_input;

mod _create_and_attach_s3_access_point_output;

/// Builders
pub mod builders;
