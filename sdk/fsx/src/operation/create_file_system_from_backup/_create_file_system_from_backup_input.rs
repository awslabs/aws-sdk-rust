// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The request object for the <code>CreateFileSystemFromBackup</code> operation.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateFileSystemFromBackupInput {
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub backup_id: ::std::option::Option<::std::string::String>,
    /// <p>A string of up to 63 ASCII characters that Amazon FSx uses to ensure idempotent creation. This string is automatically filled on your behalf when you use the Command Line Interface (CLI) or an Amazon Web Services SDK.</p>
    pub client_request_token: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code> file system deployment types, provide exactly two subnet IDs, one for the preferred file server and one for the standby file server. You specify one of these subnets as the preferred subnet using the <code>WindowsConfiguration &gt; PreferredSubnetID</code> property.</p>
    /// <p>Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types, Lustre file systems, and OpenZFS file systems provide exactly one subnet ID. The file server is launched in that subnet's Availability Zone.</p>
    pub subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups apply to all network interfaces. This value isn't returned in later <code>DescribeFileSystem</code> requests.</p>
    pub security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The tags to be applied to the file system at file system creation. The key value of the <code>Name</code> tag appears in the console as the file system name.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub windows_configuration: ::std::option::Option<crate::types::CreateFileSystemWindowsConfiguration>,
    /// <p>The Lustre configuration for the file system being created.</p> <note>
    /// <p>The following parameters are not supported for file systems with a data repository association created with .</p>
    /// <ul>
    /// <li> <p> <code>AutoImportPolicy</code> </p> </li>
    /// <li> <p> <code>ExportPath</code> </p> </li>
    /// <li> <p> <code>ImportedFileChunkSize</code> </p> </li>
    /// <li> <p> <code>ImportPath</code> </p> </li>
    /// </ul>
    /// </note>
    pub lustre_configuration: ::std::option::Option<crate::types::CreateFileSystemLustreConfiguration>,
    /// <p>Sets the storage type for the Windows or OpenZFS file system that you're creating from a backup. Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    /// <ul>
    /// <li> <p>Set to <code>SSD</code> to use solid state drive storage. SSD is supported on all Windows and OpenZFS deployment types.</p> </li>
    /// <li> <p>Set to <code>HDD</code> to use hard disk drive storage. HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> FSx for Windows File Server file system deployment types.</p> </li>
    /// </ul>
    /// <p> The default value is <code>SSD</code>. </p> <note>
    /// <p>HDD and SSD storage types have different minimum storage capacity requirements. A restored file system's storage capacity is tied to the file system that was backed up. You can create a file system that uses HDD storage from a backup of a file system that used SSD storage if the original SSD file system had a storage capacity of at least 2000 GiB.</p>
    /// </note>
    pub storage_type: ::std::option::Option<crate::types::StorageType>,
    /// <p>Specifies the ID of the Key Management Service (KMS) key to use for encrypting data on Amazon FSx file systems, as follows:</p>
    /// <ul>
    /// <li> <p>Amazon FSx for Lustre <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types only.</p> <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> types are encrypted using the Amazon FSx service KMS key for your account.</p> </li>
    /// <li> <p>Amazon FSx for NetApp ONTAP</p> </li>
    /// <li> <p>Amazon FSx for OpenZFS</p> </li>
    /// <li> <p>Amazon FSx for Windows File Server</p> </li>
    /// </ul>
    /// <p>If a <code>KmsKeyId</code> isn't specified, the Amazon FSx-managed KMS key for your account is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a> in the <i>Key Management Service API Reference</i>.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>Sets the version for the Amazon FSx for Lustre file system that you're creating from a backup. Valid values are <code>2.10</code>, <code>2.12</code>, and <code>2.15</code>.</p>
    /// <p>You don't need to specify <code>FileSystemTypeVersion</code> because it will be applied using the backup's <code>FileSystemTypeVersion</code> setting. If you choose to specify <code>FileSystemTypeVersion</code> when creating from backup, the value must match the backup's <code>FileSystemTypeVersion</code> setting.</p>
    pub file_system_type_version: ::std::option::Option<::std::string::String>,
    /// <p>The OpenZFS configuration for the file system that's being created. </p>
    pub open_zfs_configuration: ::std::option::Option<crate::types::CreateFileSystemOpenZfsConfiguration>,
    /// <p>Sets the storage capacity of the OpenZFS file system that you're creating from a backup, in gibibytes (GiB). Valid values are from 64 GiB up to 524,288 GiB (512 TiB). However, the value that you specify must be equal to or greater than the backup's storage capacity value. If you don't use the <code>StorageCapacity</code> parameter, the default is the backup's <code>StorageCapacity</code> value.</p>
    /// <p>If used to create a file system other than OpenZFS, you must provide a value that matches the backup's <code>StorageCapacity</code> value. If you provide any other value, Amazon FSx responds with a 400 Bad Request. </p>
    pub storage_capacity: ::std::option::Option<i32>,
}
impl CreateFileSystemFromBackupInput {
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub fn backup_id(&self) -> ::std::option::Option<&str> {
        self.backup_id.as_deref()
    }
    /// <p>A string of up to 63 ASCII characters that Amazon FSx uses to ensure idempotent creation. This string is automatically filled on your behalf when you use the Command Line Interface (CLI) or an Amazon Web Services SDK.</p>
    pub fn client_request_token(&self) -> ::std::option::Option<&str> {
        self.client_request_token.as_deref()
    }
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code> file system deployment types, provide exactly two subnet IDs, one for the preferred file server and one for the standby file server. You specify one of these subnets as the preferred subnet using the <code>WindowsConfiguration &gt; PreferredSubnetID</code> property.</p>
    /// <p>Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types, Lustre file systems, and OpenZFS file systems provide exactly one subnet ID. The file server is launched in that subnet's Availability Zone.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.subnet_ids.is_none()`.
    pub fn subnet_ids(&self) -> &[::std::string::String] {
        self.subnet_ids.as_deref().unwrap_or_default()
    }
    /// <p>A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups apply to all network interfaces. This value isn't returned in later <code>DescribeFileSystem</code> requests.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.security_group_ids.is_none()`.
    pub fn security_group_ids(&self) -> &[::std::string::String] {
        self.security_group_ids.as_deref().unwrap_or_default()
    }
    /// <p>The tags to be applied to the file system at file system creation. The key value of the <code>Name</code> tag appears in the console as the file system name.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub fn windows_configuration(&self) -> ::std::option::Option<&crate::types::CreateFileSystemWindowsConfiguration> {
        self.windows_configuration.as_ref()
    }
    /// <p>The Lustre configuration for the file system being created.</p> <note>
    /// <p>The following parameters are not supported for file systems with a data repository association created with .</p>
    /// <ul>
    /// <li> <p> <code>AutoImportPolicy</code> </p> </li>
    /// <li> <p> <code>ExportPath</code> </p> </li>
    /// <li> <p> <code>ImportedFileChunkSize</code> </p> </li>
    /// <li> <p> <code>ImportPath</code> </p> </li>
    /// </ul>
    /// </note>
    pub fn lustre_configuration(&self) -> ::std::option::Option<&crate::types::CreateFileSystemLustreConfiguration> {
        self.lustre_configuration.as_ref()
    }
    /// <p>Sets the storage type for the Windows or OpenZFS file system that you're creating from a backup. Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    /// <ul>
    /// <li> <p>Set to <code>SSD</code> to use solid state drive storage. SSD is supported on all Windows and OpenZFS deployment types.</p> </li>
    /// <li> <p>Set to <code>HDD</code> to use hard disk drive storage. HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> FSx for Windows File Server file system deployment types.</p> </li>
    /// </ul>
    /// <p> The default value is <code>SSD</code>. </p> <note>
    /// <p>HDD and SSD storage types have different minimum storage capacity requirements. A restored file system's storage capacity is tied to the file system that was backed up. You can create a file system that uses HDD storage from a backup of a file system that used SSD storage if the original SSD file system had a storage capacity of at least 2000 GiB.</p>
    /// </note>
    pub fn storage_type(&self) -> ::std::option::Option<&crate::types::StorageType> {
        self.storage_type.as_ref()
    }
    /// <p>Specifies the ID of the Key Management Service (KMS) key to use for encrypting data on Amazon FSx file systems, as follows:</p>
    /// <ul>
    /// <li> <p>Amazon FSx for Lustre <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types only.</p> <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> types are encrypted using the Amazon FSx service KMS key for your account.</p> </li>
    /// <li> <p>Amazon FSx for NetApp ONTAP</p> </li>
    /// <li> <p>Amazon FSx for OpenZFS</p> </li>
    /// <li> <p>Amazon FSx for Windows File Server</p> </li>
    /// </ul>
    /// <p>If a <code>KmsKeyId</code> isn't specified, the Amazon FSx-managed KMS key for your account is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a> in the <i>Key Management Service API Reference</i>.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>Sets the version for the Amazon FSx for Lustre file system that you're creating from a backup. Valid values are <code>2.10</code>, <code>2.12</code>, and <code>2.15</code>.</p>
    /// <p>You don't need to specify <code>FileSystemTypeVersion</code> because it will be applied using the backup's <code>FileSystemTypeVersion</code> setting. If you choose to specify <code>FileSystemTypeVersion</code> when creating from backup, the value must match the backup's <code>FileSystemTypeVersion</code> setting.</p>
    pub fn file_system_type_version(&self) -> ::std::option::Option<&str> {
        self.file_system_type_version.as_deref()
    }
    /// <p>The OpenZFS configuration for the file system that's being created. </p>
    pub fn open_zfs_configuration(&self) -> ::std::option::Option<&crate::types::CreateFileSystemOpenZfsConfiguration> {
        self.open_zfs_configuration.as_ref()
    }
    /// <p>Sets the storage capacity of the OpenZFS file system that you're creating from a backup, in gibibytes (GiB). Valid values are from 64 GiB up to 524,288 GiB (512 TiB). However, the value that you specify must be equal to or greater than the backup's storage capacity value. If you don't use the <code>StorageCapacity</code> parameter, the default is the backup's <code>StorageCapacity</code> value.</p>
    /// <p>If used to create a file system other than OpenZFS, you must provide a value that matches the backup's <code>StorageCapacity</code> value. If you provide any other value, Amazon FSx responds with a 400 Bad Request. </p>
    pub fn storage_capacity(&self) -> ::std::option::Option<i32> {
        self.storage_capacity
    }
}
impl CreateFileSystemFromBackupInput {
    /// Creates a new builder-style object to manufacture [`CreateFileSystemFromBackupInput`](crate::operation::create_file_system_from_backup::CreateFileSystemFromBackupInput).
    pub fn builder() -> crate::operation::create_file_system_from_backup::builders::CreateFileSystemFromBackupInputBuilder {
        crate::operation::create_file_system_from_backup::builders::CreateFileSystemFromBackupInputBuilder::default()
    }
}

/// A builder for [`CreateFileSystemFromBackupInput`](crate::operation::create_file_system_from_backup::CreateFileSystemFromBackupInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateFileSystemFromBackupInputBuilder {
    pub(crate) backup_id: ::std::option::Option<::std::string::String>,
    pub(crate) client_request_token: ::std::option::Option<::std::string::String>,
    pub(crate) subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) windows_configuration: ::std::option::Option<crate::types::CreateFileSystemWindowsConfiguration>,
    pub(crate) lustre_configuration: ::std::option::Option<crate::types::CreateFileSystemLustreConfiguration>,
    pub(crate) storage_type: ::std::option::Option<crate::types::StorageType>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) file_system_type_version: ::std::option::Option<::std::string::String>,
    pub(crate) open_zfs_configuration: ::std::option::Option<crate::types::CreateFileSystemOpenZfsConfiguration>,
    pub(crate) storage_capacity: ::std::option::Option<i32>,
}
impl CreateFileSystemFromBackupInputBuilder {
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    /// This field is required.
    pub fn backup_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.backup_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub fn set_backup_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.backup_id = input;
        self
    }
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub fn get_backup_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.backup_id
    }
    /// <p>A string of up to 63 ASCII characters that Amazon FSx uses to ensure idempotent creation. This string is automatically filled on your behalf when you use the Command Line Interface (CLI) or an Amazon Web Services SDK.</p>
    pub fn client_request_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_request_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A string of up to 63 ASCII characters that Amazon FSx uses to ensure idempotent creation. This string is automatically filled on your behalf when you use the Command Line Interface (CLI) or an Amazon Web Services SDK.</p>
    pub fn set_client_request_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_request_token = input;
        self
    }
    /// <p>A string of up to 63 ASCII characters that Amazon FSx uses to ensure idempotent creation. This string is automatically filled on your behalf when you use the Command Line Interface (CLI) or an Amazon Web Services SDK.</p>
    pub fn get_client_request_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_request_token
    }
    /// Appends an item to `subnet_ids`.
    ///
    /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
    ///
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code> file system deployment types, provide exactly two subnet IDs, one for the preferred file server and one for the standby file server. You specify one of these subnets as the preferred subnet using the <code>WindowsConfiguration &gt; PreferredSubnetID</code> property.</p>
    /// <p>Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types, Lustre file systems, and OpenZFS file systems provide exactly one subnet ID. The file server is launched in that subnet's Availability Zone.</p>
    pub fn subnet_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.subnet_ids.unwrap_or_default();
        v.push(input.into());
        self.subnet_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code> file system deployment types, provide exactly two subnet IDs, one for the preferred file server and one for the standby file server. You specify one of these subnets as the preferred subnet using the <code>WindowsConfiguration &gt; PreferredSubnetID</code> property.</p>
    /// <p>Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types, Lustre file systems, and OpenZFS file systems provide exactly one subnet ID. The file server is launched in that subnet's Availability Zone.</p>
    pub fn set_subnet_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.subnet_ids = input;
        self
    }
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code> file system deployment types, provide exactly two subnet IDs, one for the preferred file server and one for the standby file server. You specify one of these subnets as the preferred subnet using the <code>WindowsConfiguration &gt; PreferredSubnetID</code> property.</p>
    /// <p>Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types, Lustre file systems, and OpenZFS file systems provide exactly one subnet ID. The file server is launched in that subnet's Availability Zone.</p>
    pub fn get_subnet_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.subnet_ids
    }
    /// Appends an item to `security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups apply to all network interfaces. This value isn't returned in later <code>DescribeFileSystem</code> requests.</p>
    pub fn security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.security_group_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups apply to all network interfaces. This value isn't returned in later <code>DescribeFileSystem</code> requests.</p>
    pub fn set_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.security_group_ids = input;
        self
    }
    /// <p>A list of IDs for the security groups that apply to the specified network interfaces created for file system access. These security groups apply to all network interfaces. This value isn't returned in later <code>DescribeFileSystem</code> requests.</p>
    pub fn get_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.security_group_ids
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags to be applied to the file system at file system creation. The key value of the <code>Name</code> tag appears in the console as the file system name.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The tags to be applied to the file system at file system creation. The key value of the <code>Name</code> tag appears in the console as the file system name.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags to be applied to the file system at file system creation. The key value of the <code>Name</code> tag appears in the console as the file system name.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub fn windows_configuration(mut self, input: crate::types::CreateFileSystemWindowsConfiguration) -> Self {
        self.windows_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub fn set_windows_configuration(mut self, input: ::std::option::Option<crate::types::CreateFileSystemWindowsConfiguration>) -> Self {
        self.windows_configuration = input;
        self
    }
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub fn get_windows_configuration(&self) -> &::std::option::Option<crate::types::CreateFileSystemWindowsConfiguration> {
        &self.windows_configuration
    }
    /// <p>The Lustre configuration for the file system being created.</p> <note>
    /// <p>The following parameters are not supported for file systems with a data repository association created with .</p>
    /// <ul>
    /// <li> <p> <code>AutoImportPolicy</code> </p> </li>
    /// <li> <p> <code>ExportPath</code> </p> </li>
    /// <li> <p> <code>ImportedFileChunkSize</code> </p> </li>
    /// <li> <p> <code>ImportPath</code> </p> </li>
    /// </ul>
    /// </note>
    pub fn lustre_configuration(mut self, input: crate::types::CreateFileSystemLustreConfiguration) -> Self {
        self.lustre_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Lustre configuration for the file system being created.</p> <note>
    /// <p>The following parameters are not supported for file systems with a data repository association created with .</p>
    /// <ul>
    /// <li> <p> <code>AutoImportPolicy</code> </p> </li>
    /// <li> <p> <code>ExportPath</code> </p> </li>
    /// <li> <p> <code>ImportedFileChunkSize</code> </p> </li>
    /// <li> <p> <code>ImportPath</code> </p> </li>
    /// </ul>
    /// </note>
    pub fn set_lustre_configuration(mut self, input: ::std::option::Option<crate::types::CreateFileSystemLustreConfiguration>) -> Self {
        self.lustre_configuration = input;
        self
    }
    /// <p>The Lustre configuration for the file system being created.</p> <note>
    /// <p>The following parameters are not supported for file systems with a data repository association created with .</p>
    /// <ul>
    /// <li> <p> <code>AutoImportPolicy</code> </p> </li>
    /// <li> <p> <code>ExportPath</code> </p> </li>
    /// <li> <p> <code>ImportedFileChunkSize</code> </p> </li>
    /// <li> <p> <code>ImportPath</code> </p> </li>
    /// </ul>
    /// </note>
    pub fn get_lustre_configuration(&self) -> &::std::option::Option<crate::types::CreateFileSystemLustreConfiguration> {
        &self.lustre_configuration
    }
    /// <p>Sets the storage type for the Windows or OpenZFS file system that you're creating from a backup. Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    /// <ul>
    /// <li> <p>Set to <code>SSD</code> to use solid state drive storage. SSD is supported on all Windows and OpenZFS deployment types.</p> </li>
    /// <li> <p>Set to <code>HDD</code> to use hard disk drive storage. HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> FSx for Windows File Server file system deployment types.</p> </li>
    /// </ul>
    /// <p> The default value is <code>SSD</code>. </p> <note>
    /// <p>HDD and SSD storage types have different minimum storage capacity requirements. A restored file system's storage capacity is tied to the file system that was backed up. You can create a file system that uses HDD storage from a backup of a file system that used SSD storage if the original SSD file system had a storage capacity of at least 2000 GiB.</p>
    /// </note>
    pub fn storage_type(mut self, input: crate::types::StorageType) -> Self {
        self.storage_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the storage type for the Windows or OpenZFS file system that you're creating from a backup. Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    /// <ul>
    /// <li> <p>Set to <code>SSD</code> to use solid state drive storage. SSD is supported on all Windows and OpenZFS deployment types.</p> </li>
    /// <li> <p>Set to <code>HDD</code> to use hard disk drive storage. HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> FSx for Windows File Server file system deployment types.</p> </li>
    /// </ul>
    /// <p> The default value is <code>SSD</code>. </p> <note>
    /// <p>HDD and SSD storage types have different minimum storage capacity requirements. A restored file system's storage capacity is tied to the file system that was backed up. You can create a file system that uses HDD storage from a backup of a file system that used SSD storage if the original SSD file system had a storage capacity of at least 2000 GiB.</p>
    /// </note>
    pub fn set_storage_type(mut self, input: ::std::option::Option<crate::types::StorageType>) -> Self {
        self.storage_type = input;
        self
    }
    /// <p>Sets the storage type for the Windows or OpenZFS file system that you're creating from a backup. Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    /// <ul>
    /// <li> <p>Set to <code>SSD</code> to use solid state drive storage. SSD is supported on all Windows and OpenZFS deployment types.</p> </li>
    /// <li> <p>Set to <code>HDD</code> to use hard disk drive storage. HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> FSx for Windows File Server file system deployment types.</p> </li>
    /// </ul>
    /// <p> The default value is <code>SSD</code>. </p> <note>
    /// <p>HDD and SSD storage types have different minimum storage capacity requirements. A restored file system's storage capacity is tied to the file system that was backed up. You can create a file system that uses HDD storage from a backup of a file system that used SSD storage if the original SSD file system had a storage capacity of at least 2000 GiB.</p>
    /// </note>
    pub fn get_storage_type(&self) -> &::std::option::Option<crate::types::StorageType> {
        &self.storage_type
    }
    /// <p>Specifies the ID of the Key Management Service (KMS) key to use for encrypting data on Amazon FSx file systems, as follows:</p>
    /// <ul>
    /// <li> <p>Amazon FSx for Lustre <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types only.</p> <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> types are encrypted using the Amazon FSx service KMS key for your account.</p> </li>
    /// <li> <p>Amazon FSx for NetApp ONTAP</p> </li>
    /// <li> <p>Amazon FSx for OpenZFS</p> </li>
    /// <li> <p>Amazon FSx for Windows File Server</p> </li>
    /// </ul>
    /// <p>If a <code>KmsKeyId</code> isn't specified, the Amazon FSx-managed KMS key for your account is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a> in the <i>Key Management Service API Reference</i>.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the ID of the Key Management Service (KMS) key to use for encrypting data on Amazon FSx file systems, as follows:</p>
    /// <ul>
    /// <li> <p>Amazon FSx for Lustre <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types only.</p> <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> types are encrypted using the Amazon FSx service KMS key for your account.</p> </li>
    /// <li> <p>Amazon FSx for NetApp ONTAP</p> </li>
    /// <li> <p>Amazon FSx for OpenZFS</p> </li>
    /// <li> <p>Amazon FSx for Windows File Server</p> </li>
    /// </ul>
    /// <p>If a <code>KmsKeyId</code> isn't specified, the Amazon FSx-managed KMS key for your account is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a> in the <i>Key Management Service API Reference</i>.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>Specifies the ID of the Key Management Service (KMS) key to use for encrypting data on Amazon FSx file systems, as follows:</p>
    /// <ul>
    /// <li> <p>Amazon FSx for Lustre <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types only.</p> <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> types are encrypted using the Amazon FSx service KMS key for your account.</p> </li>
    /// <li> <p>Amazon FSx for NetApp ONTAP</p> </li>
    /// <li> <p>Amazon FSx for OpenZFS</p> </li>
    /// <li> <p>Amazon FSx for Windows File Server</p> </li>
    /// </ul>
    /// <p>If a <code>KmsKeyId</code> isn't specified, the Amazon FSx-managed KMS key for your account is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a> in the <i>Key Management Service API Reference</i>.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// <p>Sets the version for the Amazon FSx for Lustre file system that you're creating from a backup. Valid values are <code>2.10</code>, <code>2.12</code>, and <code>2.15</code>.</p>
    /// <p>You don't need to specify <code>FileSystemTypeVersion</code> because it will be applied using the backup's <code>FileSystemTypeVersion</code> setting. If you choose to specify <code>FileSystemTypeVersion</code> when creating from backup, the value must match the backup's <code>FileSystemTypeVersion</code> setting.</p>
    pub fn file_system_type_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.file_system_type_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Sets the version for the Amazon FSx for Lustre file system that you're creating from a backup. Valid values are <code>2.10</code>, <code>2.12</code>, and <code>2.15</code>.</p>
    /// <p>You don't need to specify <code>FileSystemTypeVersion</code> because it will be applied using the backup's <code>FileSystemTypeVersion</code> setting. If you choose to specify <code>FileSystemTypeVersion</code> when creating from backup, the value must match the backup's <code>FileSystemTypeVersion</code> setting.</p>
    pub fn set_file_system_type_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.file_system_type_version = input;
        self
    }
    /// <p>Sets the version for the Amazon FSx for Lustre file system that you're creating from a backup. Valid values are <code>2.10</code>, <code>2.12</code>, and <code>2.15</code>.</p>
    /// <p>You don't need to specify <code>FileSystemTypeVersion</code> because it will be applied using the backup's <code>FileSystemTypeVersion</code> setting. If you choose to specify <code>FileSystemTypeVersion</code> when creating from backup, the value must match the backup's <code>FileSystemTypeVersion</code> setting.</p>
    pub fn get_file_system_type_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.file_system_type_version
    }
    /// <p>The OpenZFS configuration for the file system that's being created. </p>
    pub fn open_zfs_configuration(mut self, input: crate::types::CreateFileSystemOpenZfsConfiguration) -> Self {
        self.open_zfs_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The OpenZFS configuration for the file system that's being created. </p>
    pub fn set_open_zfs_configuration(mut self, input: ::std::option::Option<crate::types::CreateFileSystemOpenZfsConfiguration>) -> Self {
        self.open_zfs_configuration = input;
        self
    }
    /// <p>The OpenZFS configuration for the file system that's being created. </p>
    pub fn get_open_zfs_configuration(&self) -> &::std::option::Option<crate::types::CreateFileSystemOpenZfsConfiguration> {
        &self.open_zfs_configuration
    }
    /// <p>Sets the storage capacity of the OpenZFS file system that you're creating from a backup, in gibibytes (GiB). Valid values are from 64 GiB up to 524,288 GiB (512 TiB). However, the value that you specify must be equal to or greater than the backup's storage capacity value. If you don't use the <code>StorageCapacity</code> parameter, the default is the backup's <code>StorageCapacity</code> value.</p>
    /// <p>If used to create a file system other than OpenZFS, you must provide a value that matches the backup's <code>StorageCapacity</code> value. If you provide any other value, Amazon FSx responds with a 400 Bad Request. </p>
    pub fn storage_capacity(mut self, input: i32) -> Self {
        self.storage_capacity = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the storage capacity of the OpenZFS file system that you're creating from a backup, in gibibytes (GiB). Valid values are from 64 GiB up to 524,288 GiB (512 TiB). However, the value that you specify must be equal to or greater than the backup's storage capacity value. If you don't use the <code>StorageCapacity</code> parameter, the default is the backup's <code>StorageCapacity</code> value.</p>
    /// <p>If used to create a file system other than OpenZFS, you must provide a value that matches the backup's <code>StorageCapacity</code> value. If you provide any other value, Amazon FSx responds with a 400 Bad Request. </p>
    pub fn set_storage_capacity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.storage_capacity = input;
        self
    }
    /// <p>Sets the storage capacity of the OpenZFS file system that you're creating from a backup, in gibibytes (GiB). Valid values are from 64 GiB up to 524,288 GiB (512 TiB). However, the value that you specify must be equal to or greater than the backup's storage capacity value. If you don't use the <code>StorageCapacity</code> parameter, the default is the backup's <code>StorageCapacity</code> value.</p>
    /// <p>If used to create a file system other than OpenZFS, you must provide a value that matches the backup's <code>StorageCapacity</code> value. If you provide any other value, Amazon FSx responds with a 400 Bad Request. </p>
    pub fn get_storage_capacity(&self) -> &::std::option::Option<i32> {
        &self.storage_capacity
    }
    /// Consumes the builder and constructs a [`CreateFileSystemFromBackupInput`](crate::operation::create_file_system_from_backup::CreateFileSystemFromBackupInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_file_system_from_backup::CreateFileSystemFromBackupInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_file_system_from_backup::CreateFileSystemFromBackupInput {
            backup_id: self.backup_id,
            client_request_token: self.client_request_token,
            subnet_ids: self.subnet_ids,
            security_group_ids: self.security_group_ids,
            tags: self.tags,
            windows_configuration: self.windows_configuration,
            lustre_configuration: self.lustre_configuration,
            storage_type: self.storage_type,
            kms_key_id: self.kms_key_id,
            file_system_type_version: self.file_system_type_version,
            open_zfs_configuration: self.open_zfs_configuration,
            storage_capacity: self.storage_capacity,
        })
    }
}
