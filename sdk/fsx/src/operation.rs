// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Use this action to associate one or more Domain Name Server (DNS) aliases with an existing Amazon FSx for Windows File Server file system.
/// A file system can have a maximum of 50 DNS aliases associated with it at any one time. If you try to
/// associate a DNS alias that is already associated with the file system, FSx takes no action on that alias in the request.
/// For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a> and
/// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/walkthrough05-file-system-custom-CNAME.html">Walkthrough 5: Using DNS aliases to access your file system</a>, including
/// additional steps you must take to be able to access your file system using a DNS alias.</p>
/// <p>The system response shows the DNS aliases that
/// Amazon FSx is attempting to associate with the file system.
/// Use the  API
/// operation to monitor the status of the aliases Amazon FSx is
/// associating with the file system.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateFileSystemAliases {
    _private: (),
}
impl AssociateFileSystemAliases {
    /// Creates a new builder-style object to manufacture [`AssociateFileSystemAliasesInput`](crate::input::AssociateFileSystemAliasesInput)
    pub fn builder() -> crate::input::associate_file_system_aliases_input::Builder {
        crate::input::associate_file_system_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateFileSystemAliases {
    type Output = std::result::Result<
        crate::output::AssociateFileSystemAliasesOutput,
        crate::error::AssociateFileSystemAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_file_system_aliases_error(response)
        } else {
            crate::operation_deser::parse_associate_file_system_aliases_response(response)
        }
    }
}

/// <p>Cancels an existing Amazon FSx for Lustre data repository task if that task is in either the
/// <code>PENDING</code> or <code>EXECUTING</code> state. When you cancel a task, Amazon FSx does the following.</p>
/// <ul>
/// <li>
/// <p>Any files that FSx has already exported are not reverted.</p>
/// </li>
/// <li>
/// <p>FSx continues to export any files that are "in-flight" when the cancel operation is received.</p>
/// </li>
/// <li>
/// <p>FSx does not export any files that have not yet been exported.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelDataRepositoryTask {
    _private: (),
}
impl CancelDataRepositoryTask {
    /// Creates a new builder-style object to manufacture [`CancelDataRepositoryTaskInput`](crate::input::CancelDataRepositoryTaskInput)
    pub fn builder() -> crate::input::cancel_data_repository_task_input::Builder {
        crate::input::cancel_data_repository_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelDataRepositoryTask {
    type Output = std::result::Result<
        crate::output::CancelDataRepositoryTaskOutput,
        crate::error::CancelDataRepositoryTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_data_repository_task_error(response)
        } else {
            crate::operation_deser::parse_cancel_data_repository_task_response(response)
        }
    }
}

/// <p>Copies an existing backup within the same Amazon Web Services account to another Amazon Web Services Region
/// (cross-Region copy) or within the same Amazon Web Services Region (in-Region copy). You can have up to five
/// backup copy requests in progress to a single destination Region per account.</p>
/// <p>You can use cross-Region backup copies for cross-region disaster recovery.
/// You periodically take backups and copy them to another Region so that in the
/// event of a disaster in the primary Region, you can restore from backup and recover
/// availability quickly in the other Region. You can make cross-Region copies
/// only within your Amazon Web Services partition.</p>
/// <p> You can also use backup copies to clone your file data set to another Region
/// or within the same Region.</p>
/// <p>You can use the <code>SourceRegion</code> parameter to specify the Amazon Web Services Region
/// from which the backup will be copied. For example, if you make the call from the
/// <code>us-west-1</code> Region and want to copy a backup from the <code>us-east-2</code>
/// Region, you specify <code>us-east-2</code> in the <code>SourceRegion</code> parameter
/// to make a cross-Region copy. If you don't specify a Region, the backup copy is
/// created in the same Region where the request is sent from (in-Region copy).</p>
/// <p>For more information on creating backup copies, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#copy-backups">
/// Copying backups</a> in the <i>Amazon FSx for Windows User Guide</i> and
/// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html#copy-backups">Copying backups</a>
/// in the <i>Amazon FSx for Lustre User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CopyBackup {
    _private: (),
}
impl CopyBackup {
    /// Creates a new builder-style object to manufacture [`CopyBackupInput`](crate::input::CopyBackupInput)
    pub fn builder() -> crate::input::copy_backup_input::Builder {
        crate::input::copy_backup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CopyBackup {
    type Output =
        std::result::Result<crate::output::CopyBackupOutput, crate::error::CopyBackupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_copy_backup_error(response)
        } else {
            crate::operation_deser::parse_copy_backup_response(response)
        }
    }
}

/// <p>Creates a backup of an existing Amazon FSx for Windows File Server
/// or Amazon FSx for Lustre file system, or of an Amazon FSx for NetApp ONTAP
/// volume. Creating regular backups is a best practice, enabling you to restore
/// a file system or volume from a backup if an issue arises with the original
/// file system or volume.</p>
/// <p>For Amazon FSx for Lustre file systems, you can create a backup only
/// for file systems with the following configuration:</p>
/// <ul>
/// <li>
/// <p>a Persistent deployment type</p>
/// </li>
/// <li>
/// <p>is <i>not</i> linked to a data repository.</p>
/// </li>
/// </ul>
/// <p>For more information about backups, see the following:</p>
/// <ul>
/// <li>
/// <p>For Amazon FSx for Lustre,
/// see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with FSx for Lustre backups</a>.</p>
/// </li>
/// <li>
/// <p>For Amazon FSx for Windows,
/// see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html">Working with FSx for Windows backups</a>.</p>
/// </li>
/// <li>
/// <p>For Amazon FSx for NetApp ONTAP,
/// see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/using-backups.html">Working with FSx for NetApp ONTAP backups</a>.</p>
/// </li>
/// </ul>
/// <p>If a backup with the specified client request token exists, and the parameters
/// match, this operation returns the description of the existing backup. If a backup
/// specified client request token exists, and the parameters don't match, this
/// operation returns <code>IncompatibleParameterError</code>. If a backup with the
/// specified client request token doesn't exist, <code>CreateBackup</code> does the
/// following: </p>
/// <ul>
/// <li>
/// <p>Creates a new Amazon FSx backup with an assigned ID, and an initial
/// lifecycle state of <code>CREATING</code>.</p>
/// </li>
/// <li>
/// <p>Returns the description of the backup.</p>
/// </li>
/// </ul>
/// <p>By using the idempotent operation, you can retry a <code>CreateBackup</code>
/// operation without the risk of creating an extra backup. This approach can be useful when
/// an initial call fails in a way that makes it unclear whether a backup was created. If
/// you use the same client request token and the initial call created a backup, the
/// operation returns a successful result because all the parameters are the same.</p>
/// <p>The <code>CreateBackup</code> operation returns while the backup's
/// lifecycle state is still <code>CREATING</code>. You can check the backup creation
/// status by calling the <a>DescribeBackups</a> operation, which returns the
/// backup state along with other information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBackup {
    _private: (),
}
impl CreateBackup {
    /// Creates a new builder-style object to manufacture [`CreateBackupInput`](crate::input::CreateBackupInput)
    pub fn builder() -> crate::input::create_backup_input::Builder {
        crate::input::create_backup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBackup {
    type Output =
        std::result::Result<crate::output::CreateBackupOutput, crate::error::CreateBackupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_backup_error(response)
        } else {
            crate::operation_deser::parse_create_backup_response(response)
        }
    }
}

/// <p>Creates an Amazon FSx for Lustre data repository task. You use data repository tasks
/// to perform bulk operations between your Amazon FSx file system and its linked data
/// repository. An example of a data repository task is
/// exporting any data and metadata changes, including POSIX metadata, to files, directories, and symbolic links (symlinks) from your FSx file system to its linked data repository. A
/// <code>CreateDataRepositoryTask</code> operation will fail if a data repository is not
/// linked to the FSx file system. To learn more about data repository tasks, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-repository-tasks.html">Data Repository Tasks</a>.
/// To learn more about linking a data repository to your file system, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/create-fs-linked-data-repo.html">Linking your file system to an S3 bucket</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDataRepositoryTask {
    _private: (),
}
impl CreateDataRepositoryTask {
    /// Creates a new builder-style object to manufacture [`CreateDataRepositoryTaskInput`](crate::input::CreateDataRepositoryTaskInput)
    pub fn builder() -> crate::input::create_data_repository_task_input::Builder {
        crate::input::create_data_repository_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDataRepositoryTask {
    type Output = std::result::Result<
        crate::output::CreateDataRepositoryTaskOutput,
        crate::error::CreateDataRepositoryTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_data_repository_task_error(response)
        } else {
            crate::operation_deser::parse_create_data_repository_task_response(response)
        }
    }
}

/// <p>Creates a new, empty Amazon FSx file system.</p>
/// <p>If a file system with the specified client request token exists and the parameters
/// match, <code>CreateFileSystem</code> returns the description of the existing file
/// system. If a file system specified client request token exists and the parameters
/// don't match, this call returns <code>IncompatibleParameterError</code>. If a file
/// system with the specified client request token doesn't exist,
/// <code>CreateFileSystem</code> does the following: </p>
/// <ul>
/// <li>
/// <p>Creates a new, empty Amazon FSx file system with an assigned ID, and an
/// initial lifecycle state of <code>CREATING</code>.</p>
/// </li>
/// <li>
/// <p>Returns the description of the file system.</p>
/// </li>
/// </ul>
/// <p>This operation requires a client request token in the request that Amazon FSx uses
/// to ensure idempotent creation. This means that calling the operation multiple times with
/// the same client request token has no effect. By using the idempotent operation, you can
/// retry a <code>CreateFileSystem</code> operation without the risk of creating an extra
/// file system. This approach can be useful when an initial call fails in a way that makes
/// it unclear whether a file system was created. Examples are if a transport level timeout
/// occurred, or your connection was reset. If you use the same client request token and the
/// initial call created a file system, the client receives success as long as the
/// parameters are the same.</p>
/// <note>
/// <p>The <code>CreateFileSystem</code> call returns while the file system's
/// lifecycle state is still <code>CREATING</code>. You can check the file-system
/// creation status by calling the <a>DescribeFileSystems</a> operation,
/// which returns the file system state along with other information.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFileSystem {
    _private: (),
}
impl CreateFileSystem {
    /// Creates a new builder-style object to manufacture [`CreateFileSystemInput`](crate::input::CreateFileSystemInput)
    pub fn builder() -> crate::input::create_file_system_input::Builder {
        crate::input::create_file_system_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFileSystem {
    type Output = std::result::Result<
        crate::output::CreateFileSystemOutput,
        crate::error::CreateFileSystemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_file_system_error(response)
        } else {
            crate::operation_deser::parse_create_file_system_response(response)
        }
    }
}

/// <p>Creates a new Amazon FSx for Lustre or Amazon FSx for Windows File Server file system
/// from an existing Amazon FSx backup.</p>
/// <p>If a file system with the specified client request token exists and the parameters
/// match, this operation returns the description of the file system. If a client
/// request token specified by the file system exists and the parameters don't match,
/// this call returns <code>IncompatibleParameterError</code>. If a file system with the
/// specified client request token doesn't exist, this operation does the following:</p>
/// <ul>
/// <li>
/// <p>Creates a new Amazon FSx file system from backup with an assigned ID, and
/// an initial lifecycle state of <code>CREATING</code>.</p>
/// </li>
/// <li>
/// <p>Returns the description of the file system.</p>
/// </li>
/// </ul>
/// <p>Parameters like Active Directory, default share name, automatic backup, and backup
/// settings default to the parameters of the file system that was backed up, unless
/// overridden. You can explicitly supply other settings.</p>
/// <p>By using the idempotent operation, you can retry a
/// <code>CreateFileSystemFromBackup</code> call without the risk of creating an extra
/// file system. This approach can be useful when an initial call fails in a way that makes
/// it unclear whether a file system was created. Examples are if a transport level timeout
/// occurred, or your connection was reset. If you use the same client request token and the
/// initial call created a file system, the client receives success as long as the
/// parameters are the same.</p>
/// <note>
/// <p>The <code>CreateFileSystemFromBackup</code> call returns while the file
/// system's lifecycle state is still <code>CREATING</code>. You can check the
/// file-system creation status by calling the <a>DescribeFileSystems</a>
/// operation, which returns the file system state along with other
/// information.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFileSystemFromBackup {
    _private: (),
}
impl CreateFileSystemFromBackup {
    /// Creates a new builder-style object to manufacture [`CreateFileSystemFromBackupInput`](crate::input::CreateFileSystemFromBackupInput)
    pub fn builder() -> crate::input::create_file_system_from_backup_input::Builder {
        crate::input::create_file_system_from_backup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFileSystemFromBackup {
    type Output = std::result::Result<
        crate::output::CreateFileSystemFromBackupOutput,
        crate::error::CreateFileSystemFromBackupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_file_system_from_backup_error(response)
        } else {
            crate::operation_deser::parse_create_file_system_from_backup_response(response)
        }
    }
}

/// <p>Creates a storage virtual machine (SVM) for an Amazon FSx for ONTAP file system.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStorageVirtualMachine {
    _private: (),
}
impl CreateStorageVirtualMachine {
    /// Creates a new builder-style object to manufacture [`CreateStorageVirtualMachineInput`](crate::input::CreateStorageVirtualMachineInput)
    pub fn builder() -> crate::input::create_storage_virtual_machine_input::Builder {
        crate::input::create_storage_virtual_machine_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStorageVirtualMachine {
    type Output = std::result::Result<
        crate::output::CreateStorageVirtualMachineOutput,
        crate::error::CreateStorageVirtualMachineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_storage_virtual_machine_error(response)
        } else {
            crate::operation_deser::parse_create_storage_virtual_machine_response(response)
        }
    }
}

/// <p>Creates an Amazon FSx for NetApp ONTAP storage volume.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateVolume {
    _private: (),
}
impl CreateVolume {
    /// Creates a new builder-style object to manufacture [`CreateVolumeInput`](crate::input::CreateVolumeInput)
    pub fn builder() -> crate::input::create_volume_input::Builder {
        crate::input::create_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateVolume {
    type Output =
        std::result::Result<crate::output::CreateVolumeOutput, crate::error::CreateVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_volume_error(response)
        } else {
            crate::operation_deser::parse_create_volume_response(response)
        }
    }
}

/// <p>Creates a new Amazon FSx for NetApp ONTAP volume from an
/// existing Amazon FSx volume backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateVolumeFromBackup {
    _private: (),
}
impl CreateVolumeFromBackup {
    /// Creates a new builder-style object to manufacture [`CreateVolumeFromBackupInput`](crate::input::CreateVolumeFromBackupInput)
    pub fn builder() -> crate::input::create_volume_from_backup_input::Builder {
        crate::input::create_volume_from_backup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateVolumeFromBackup {
    type Output = std::result::Result<
        crate::output::CreateVolumeFromBackupOutput,
        crate::error::CreateVolumeFromBackupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_volume_from_backup_error(response)
        } else {
            crate::operation_deser::parse_create_volume_from_backup_response(response)
        }
    }
}

/// <p>Deletes an Amazon FSx backup, deleting its contents. After deletion, the backup no longer exists, and its data is gone.</p>
/// <p>The <code>DeleteBackup</code> call returns instantly. The backup will not show up
/// in later <code>DescribeBackups</code> calls.</p>
/// <important>
/// <p>The data in a deleted backup is also deleted and can't be recovered by any
/// means.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBackup {
    _private: (),
}
impl DeleteBackup {
    /// Creates a new builder-style object to manufacture [`DeleteBackupInput`](crate::input::DeleteBackupInput)
    pub fn builder() -> crate::input::delete_backup_input::Builder {
        crate::input::delete_backup_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBackup {
    type Output =
        std::result::Result<crate::output::DeleteBackupOutput, crate::error::DeleteBackupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_backup_error(response)
        } else {
            crate::operation_deser::parse_delete_backup_response(response)
        }
    }
}

/// <p>Deletes a file system, deleting its contents. After deletion, the file system no
/// longer exists, and its data is gone. Any existing automatic backups will also be
/// deleted.</p>
/// <p>To delete an Amazon FSx for NetApp ONTAP file system, first delete all the volumes
/// and SVMs on the file system. Then provide a <code>FileSystemId</code> value to the
/// <code>DeleFileSystem</code> operation.</p>
/// <p>By default, when you delete an Amazon FSx for Windows File Server file system, a
/// final backup is created upon deletion. This final backup is not subject to the file
/// system's retention policy, and must be manually deleted.</p>
/// <p>The <code>DeleteFileSystem</code> action returns while the file system has the
/// <code>DELETING</code> status. You can check the file system deletion status by
/// calling the <a>DescribeFileSystems</a> action, which returns a list of file
/// systems in your account. If you pass the file system ID for a deleted file system, the
/// <a>DescribeFileSystems</a> returns a <code>FileSystemNotFound</code>
/// error.</p>
/// <note>
/// <p>Deleting an Amazon FSx for Lustre file system will fail with a 400 BadRequest if
/// a data repository task is in a <code>PENDING</code> or <code>EXECUTING</code>
/// state.</p>
/// </note>
/// <important>
/// <p>The data in a deleted file system is also deleted and can't be recovered by
/// any means.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFileSystem {
    _private: (),
}
impl DeleteFileSystem {
    /// Creates a new builder-style object to manufacture [`DeleteFileSystemInput`](crate::input::DeleteFileSystemInput)
    pub fn builder() -> crate::input::delete_file_system_input::Builder {
        crate::input::delete_file_system_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFileSystem {
    type Output = std::result::Result<
        crate::output::DeleteFileSystemOutput,
        crate::error::DeleteFileSystemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_file_system_error(response)
        } else {
            crate::operation_deser::parse_delete_file_system_response(response)
        }
    }
}

/// <p>Deletes an existing Amazon FSx for ONTAP storage virtual machine (SVM). Prior
/// to deleting an SVM, you must delete all non-root volumes in the SVM, otherwise the operation will fail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStorageVirtualMachine {
    _private: (),
}
impl DeleteStorageVirtualMachine {
    /// Creates a new builder-style object to manufacture [`DeleteStorageVirtualMachineInput`](crate::input::DeleteStorageVirtualMachineInput)
    pub fn builder() -> crate::input::delete_storage_virtual_machine_input::Builder {
        crate::input::delete_storage_virtual_machine_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStorageVirtualMachine {
    type Output = std::result::Result<
        crate::output::DeleteStorageVirtualMachineOutput,
        crate::error::DeleteStorageVirtualMachineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_storage_virtual_machine_error(response)
        } else {
            crate::operation_deser::parse_delete_storage_virtual_machine_response(response)
        }
    }
}

/// <p>Deletes an Amazon FSx for NetApp ONTAP volume. When deleting a volume,
/// you have the option of creating a final backup. If you create a final backup, you have the option to
/// apply Tags to the backup. You need to have <code>fsx:TagResource</code>
/// permission in order to apply tags to the backup.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteVolume {
    _private: (),
}
impl DeleteVolume {
    /// Creates a new builder-style object to manufacture [`DeleteVolumeInput`](crate::input::DeleteVolumeInput)
    pub fn builder() -> crate::input::delete_volume_input::Builder {
        crate::input::delete_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteVolume {
    type Output =
        std::result::Result<crate::output::DeleteVolumeOutput, crate::error::DeleteVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_volume_error(response)
        } else {
            crate::operation_deser::parse_delete_volume_response(response)
        }
    }
}

/// <p>Returns the description of specific Amazon FSx backups, if
/// a <code>BackupIds</code> value is provided for that backup. Otherwise, it returns all
/// backups owned by your Amazon Web Services account  in the Amazon Web Services Region
/// of the endpoint that you're calling.</p>
/// <p>When retrieving all backups, you can optionally specify the <code>MaxResults</code>
/// parameter to limit the number of backups in a response. If more backups remain, Amazon
/// FSx returns a <code>NextToken</code> value in the response. In this case, send a later
/// request with the <code>NextToken</code> request parameter set to the value of
/// <code>NextToken</code> from the last response.</p>
/// <p>This action is used in an iterative process to retrieve a list of your backups.
/// <code>DescribeBackups</code> is called first without a <code>NextToken</code>value.
/// Then the action continues to be called with the <code>NextToken</code> parameter set to
/// the value of the last <code>NextToken</code> value until a response has no
/// <code>NextToken</code>.</p>
/// <p>When using this action, keep the following in mind:</p>
/// <ul>
/// <li>
/// <p>The implementation might return fewer than <code>MaxResults</code>
/// backup descriptions while still including a <code>NextToken</code>
/// value.</p>
/// </li>
/// <li>
/// <p>The order of backups returned in the response of one
/// <code>DescribeBackups</code> call and the order of backups returned across
/// the responses of a multi-call iteration is unspecified.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeBackups {
    _private: (),
}
impl DescribeBackups {
    /// Creates a new builder-style object to manufacture [`DescribeBackupsInput`](crate::input::DescribeBackupsInput)
    pub fn builder() -> crate::input::describe_backups_input::Builder {
        crate::input::describe_backups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeBackups {
    type Output = std::result::Result<
        crate::output::DescribeBackupsOutput,
        crate::error::DescribeBackupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_backups_error(response)
        } else {
            crate::operation_deser::parse_describe_backups_response(response)
        }
    }
}

/// <p>Returns the description of specific Amazon FSx for Lustre data repository tasks, if
/// one or more <code>TaskIds</code> values are provided in the request, or if filters are used in the request.
/// You can use filters to narrow the response to include just tasks for specific file systems,
/// or tasks in a specific lifecycle state. Otherwise, it returns all data repository tasks owned
/// by your Amazon Web Services account in the Amazon Web Services Region of the endpoint that you're calling.</p>
/// <p>When retrieving all tasks, you can paginate the response by using  the optional <code>MaxResults</code>
/// parameter to limit the number of tasks returned in a response. If more tasks remain, Amazon
/// FSx returns a <code>NextToken</code> value in the response. In this case, send a later
/// request with the <code>NextToken</code> request parameter set to the value of
/// <code>NextToken</code> from the last response.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDataRepositoryTasks {
    _private: (),
}
impl DescribeDataRepositoryTasks {
    /// Creates a new builder-style object to manufacture [`DescribeDataRepositoryTasksInput`](crate::input::DescribeDataRepositoryTasksInput)
    pub fn builder() -> crate::input::describe_data_repository_tasks_input::Builder {
        crate::input::describe_data_repository_tasks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDataRepositoryTasks {
    type Output = std::result::Result<
        crate::output::DescribeDataRepositoryTasksOutput,
        crate::error::DescribeDataRepositoryTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_data_repository_tasks_error(response)
        } else {
            crate::operation_deser::parse_describe_data_repository_tasks_response(response)
        }
    }
}

/// <p>Returns the DNS aliases that are associated with the specified Amazon FSx for Windows File Server file system. A history of
/// all DNS aliases that have been associated with and disassociated from the file system is available in the list of <a>AdministrativeAction</a>
/// provided in the <a>DescribeFileSystems</a> operation response.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFileSystemAliases {
    _private: (),
}
impl DescribeFileSystemAliases {
    /// Creates a new builder-style object to manufacture [`DescribeFileSystemAliasesInput`](crate::input::DescribeFileSystemAliasesInput)
    pub fn builder() -> crate::input::describe_file_system_aliases_input::Builder {
        crate::input::describe_file_system_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFileSystemAliases {
    type Output = std::result::Result<
        crate::output::DescribeFileSystemAliasesOutput,
        crate::error::DescribeFileSystemAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_file_system_aliases_error(response)
        } else {
            crate::operation_deser::parse_describe_file_system_aliases_response(response)
        }
    }
}

/// <p>Returns the description of specific Amazon FSx file systems, if a
/// <code>FileSystemIds</code> value is provided for that file system. Otherwise, it
/// returns descriptions of all file systems owned by your Amazon Web Services account in
/// the Amazon Web Services Region of the endpoint that you're calling.</p>
/// <p>When retrieving all file system descriptions, you can optionally specify the
/// <code>MaxResults</code> parameter to limit the number of descriptions in a response.
/// If more file system descriptions remain, Amazon FSx returns a <code>NextToken</code>
/// value in the response. In this case, send a later request with the
/// <code>NextToken</code> request parameter set to the value of <code>NextToken</code>
/// from the last response.</p>
/// <p>This action is used in an iterative process to retrieve a list of your file system
/// descriptions. <code>DescribeFileSystems</code> is called first without a
/// <code>NextToken</code>value. Then the action continues to be called with the
/// <code>NextToken</code> parameter set to the value of the last <code>NextToken</code>
/// value until a response has no <code>NextToken</code>.</p>
/// <p>When using this action, keep the following in mind:</p>
/// <ul>
/// <li>
/// <p>The implementation might return fewer than <code>MaxResults</code> file
/// system descriptions while still including a <code>NextToken</code>
/// value.</p>
/// </li>
/// <li>
/// <p>The order of file systems returned in the response of one
/// <code>DescribeFileSystems</code> call and the order of file systems returned
/// across the responses of a multicall iteration is unspecified.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFileSystems {
    _private: (),
}
impl DescribeFileSystems {
    /// Creates a new builder-style object to manufacture [`DescribeFileSystemsInput`](crate::input::DescribeFileSystemsInput)
    pub fn builder() -> crate::input::describe_file_systems_input::Builder {
        crate::input::describe_file_systems_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFileSystems {
    type Output = std::result::Result<
        crate::output::DescribeFileSystemsOutput,
        crate::error::DescribeFileSystemsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_file_systems_error(response)
        } else {
            crate::operation_deser::parse_describe_file_systems_response(response)
        }
    }
}

/// <p>Describes one or more Amazon FSx for NetApp ONTAP storage virtual machines (SVMs).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStorageVirtualMachines {
    _private: (),
}
impl DescribeStorageVirtualMachines {
    /// Creates a new builder-style object to manufacture [`DescribeStorageVirtualMachinesInput`](crate::input::DescribeStorageVirtualMachinesInput)
    pub fn builder() -> crate::input::describe_storage_virtual_machines_input::Builder {
        crate::input::describe_storage_virtual_machines_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStorageVirtualMachines {
    type Output = std::result::Result<
        crate::output::DescribeStorageVirtualMachinesOutput,
        crate::error::DescribeStorageVirtualMachinesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_storage_virtual_machines_error(response)
        } else {
            crate::operation_deser::parse_describe_storage_virtual_machines_response(response)
        }
    }
}

/// <p>Describes one or more Amazon FSx for NetApp ONTAP volumes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeVolumes {
    _private: (),
}
impl DescribeVolumes {
    /// Creates a new builder-style object to manufacture [`DescribeVolumesInput`](crate::input::DescribeVolumesInput)
    pub fn builder() -> crate::input::describe_volumes_input::Builder {
        crate::input::describe_volumes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeVolumes {
    type Output = std::result::Result<
        crate::output::DescribeVolumesOutput,
        crate::error::DescribeVolumesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_volumes_error(response)
        } else {
            crate::operation_deser::parse_describe_volumes_response(response)
        }
    }
}

/// <p>Use this action to disassociate, or remove, one or more Domain Name Service (DNS) aliases
/// from an Amazon FSx for Windows File Server file system. If you attempt to disassociate a DNS alias that is not
/// associated with the file system, Amazon FSx responds with a 400 Bad Request. For more information, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a>.</p>
/// <p>The system generated response showing the DNS aliases that
/// Amazon FSx is attempting to disassociate from the file system.
/// Use the  API
/// operation to monitor the status of the aliases Amazon FSx is
/// disassociating with the file system.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateFileSystemAliases {
    _private: (),
}
impl DisassociateFileSystemAliases {
    /// Creates a new builder-style object to manufacture [`DisassociateFileSystemAliasesInput`](crate::input::DisassociateFileSystemAliasesInput)
    pub fn builder() -> crate::input::disassociate_file_system_aliases_input::Builder {
        crate::input::disassociate_file_system_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateFileSystemAliases {
    type Output = std::result::Result<
        crate::output::DisassociateFileSystemAliasesOutput,
        crate::error::DisassociateFileSystemAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_file_system_aliases_error(response)
        } else {
            crate::operation_deser::parse_disassociate_file_system_aliases_response(response)
        }
    }
}

/// <p>Lists tags for an Amazon FSx file systems and backups in the case of Amazon FSx for
/// Windows File Server.</p>
/// <p>When retrieving all tags, you can optionally specify the <code>MaxResults</code>
/// parameter to limit the number of tags in a response. If more tags remain, Amazon FSx
/// returns a <code>NextToken</code> value in the response. In this case, send a later
/// request with the <code>NextToken</code> request parameter set to the value of
/// <code>NextToken</code> from the last response.</p>
/// <p>This action is used in an iterative process to retrieve a list of your tags.
/// <code>ListTagsForResource</code> is called first without a
/// <code>NextToken</code>value. Then the action continues to be called with the
/// <code>NextToken</code> parameter set to the value of the last <code>NextToken</code>
/// value until a response has no <code>NextToken</code>.</p>
/// <p>When using this action, keep the following in mind:</p>
/// <ul>
/// <li>
/// <p>The implementation might return fewer than <code>MaxResults</code> file
/// system descriptions while still including a <code>NextToken</code>
/// value.</p>
/// </li>
/// <li>
/// <p>The order of tags returned in the response of one
/// <code>ListTagsForResource</code> call and the order of tags returned across
/// the responses of a multi-call iteration is unspecified.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Tags an Amazon FSx resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>This action removes a tag from an Amazon FSx resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Use this operation to update the configuration of an existing Amazon FSx file system.
/// You can update multiple properties in a single request.</p>
/// <p>For Amazon FSx for Windows File Server file systems, you can update the following
/// properties:</p>
/// <ul>
/// <li>
/// <p>AuditLogConfiguration</p>
/// </li>
/// <li>
/// <p>AutomaticBackupRetentionDays</p>
/// </li>
/// <li>
/// <p>DailyAutomaticBackupStartTime</p>
/// </li>
/// <li>
/// <p>SelfManagedActiveDirectoryConfiguration</p>
/// </li>
/// <li>
/// <p>StorageCapacity</p>
/// </li>
/// <li>
/// <p>ThroughputCapacity</p>
/// </li>
/// <li>
/// <p>WeeklyMaintenanceStartTime</p>
/// </li>
/// </ul>
/// <p>For Amazon FSx for Lustre file systems, you can update the following
/// properties:</p>
/// <ul>
/// <li>
/// <p>AutoImportPolicy</p>
/// </li>
/// <li>
/// <p>AutomaticBackupRetentionDays</p>
/// </li>
/// <li>
/// <p>DailyAutomaticBackupStartTime</p>
/// </li>
/// <li>
/// <p>DataCompressionType</p>
/// </li>
/// <li>
/// <p>StorageCapacity</p>
/// </li>
/// <li>
/// <p>WeeklyMaintenanceStartTime</p>
/// </li>
/// </ul>
/// <p>For Amazon FSx for NetApp ONTAP file systems, you can update the following
/// properties:</p>
/// <ul>
/// <li>
/// <p>AutomaticBackupRetentionDays</p>
/// </li>
/// <li>
/// <p>DailyAutomaticBackupStartTime</p>
/// </li>
/// <li>
/// <p>FsxAdminPassword</p>
/// </li>
/// <li>
/// <p>WeeklyMaintenanceStartTime</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFileSystem {
    _private: (),
}
impl UpdateFileSystem {
    /// Creates a new builder-style object to manufacture [`UpdateFileSystemInput`](crate::input::UpdateFileSystemInput)
    pub fn builder() -> crate::input::update_file_system_input::Builder {
        crate::input::update_file_system_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFileSystem {
    type Output = std::result::Result<
        crate::output::UpdateFileSystemOutput,
        crate::error::UpdateFileSystemError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_file_system_error(response)
        } else {
            crate::operation_deser::parse_update_file_system_response(response)
        }
    }
}

/// <p>Updates an Amazon FSx for ONTAP storage virtual machine (SVM).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStorageVirtualMachine {
    _private: (),
}
impl UpdateStorageVirtualMachine {
    /// Creates a new builder-style object to manufacture [`UpdateStorageVirtualMachineInput`](crate::input::UpdateStorageVirtualMachineInput)
    pub fn builder() -> crate::input::update_storage_virtual_machine_input::Builder {
        crate::input::update_storage_virtual_machine_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStorageVirtualMachine {
    type Output = std::result::Result<
        crate::output::UpdateStorageVirtualMachineOutput,
        crate::error::UpdateStorageVirtualMachineError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_storage_virtual_machine_error(response)
        } else {
            crate::operation_deser::parse_update_storage_virtual_machine_response(response)
        }
    }
}

/// <p>Updates an Amazon FSx for NetApp ONTAP volume's configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateVolume {
    _private: (),
}
impl UpdateVolume {
    /// Creates a new builder-style object to manufacture [`UpdateVolumeInput`](crate::input::UpdateVolumeInput)
    pub fn builder() -> crate::input::update_volume_input::Builder {
        crate::input::update_volume_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateVolume {
    type Output =
        std::result::Result<crate::output::UpdateVolumeOutput, crate::error::UpdateVolumeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_volume_error(response)
        } else {
            crate::operation_deser::parse_update_volume_response(response)
        }
    }
}
