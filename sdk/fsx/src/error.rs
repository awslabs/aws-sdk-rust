// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateVolumeErrorKind = UpdateVolumeError;
/// Error type for the `UpdateVolumeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVolumeError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>A volume configuration is required for this operation.</p>
    MissingVolumeConfiguration(crate::error::MissingVolumeConfiguration),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVolumeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::MissingVolumeConfiguration(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateVolumeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingVolumeConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateVolumeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVolumeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVolumeError {
    /// Creates the `UpdateVolumeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateVolumeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::MissingVolumeConfiguration(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateVolumeError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateVolumeError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `UpdateVolumeError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateVolumeError::MissingVolumeConfiguration`.
    pub fn is_missing_volume_configuration(&self) -> bool {
        matches!(self, Self::MissingVolumeConfiguration(_))
    }
    /// Returns `true` if the error kind is `UpdateVolumeError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for UpdateVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::MissingVolumeConfiguration(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VolumeNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl VolumeNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for VolumeNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VolumeNotFound")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for VolumeNotFound {}
impl aws_http::request_id::RequestId for crate::error::VolumeNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for VolumeNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl VolumeNotFound {
    /// Creates a new builder-style object to manufacture [`VolumeNotFound`](crate::error::VolumeNotFound).
    pub fn builder() -> crate::error::volume_not_found::Builder {
        crate::error::volume_not_found::Builder::default()
    }
}

/// See [`VolumeNotFound`](crate::error::VolumeNotFound).
pub mod volume_not_found {

    /// A builder for [`VolumeNotFound`](crate::error::VolumeNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`VolumeNotFound`](crate::error::VolumeNotFound).
        pub fn build(self) -> crate::error::VolumeNotFound {
            crate::error::VolumeNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A volume configuration is required for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissingVolumeConfiguration {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MissingVolumeConfiguration {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingVolumeConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingVolumeConfiguration")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MissingVolumeConfiguration {}
impl aws_http::request_id::RequestId for crate::error::MissingVolumeConfiguration {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MissingVolumeConfiguration {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl MissingVolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`MissingVolumeConfiguration`](crate::error::MissingVolumeConfiguration).
    pub fn builder() -> crate::error::missing_volume_configuration::Builder {
        crate::error::missing_volume_configuration::Builder::default()
    }
}

/// See [`MissingVolumeConfiguration`](crate::error::MissingVolumeConfiguration).
pub mod missing_volume_configuration {

    /// A builder for [`MissingVolumeConfiguration`](crate::error::MissingVolumeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MissingVolumeConfiguration`](crate::error::MissingVolumeConfiguration).
        pub fn build(self) -> crate::error::MissingVolumeConfiguration {
            crate::error::MissingVolumeConfiguration {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A generic error indicating a server-side failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerError {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InternalServerError {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
impl aws_http::request_id::RequestId for crate::error::InternalServerError {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InternalServerError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError).
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// See [`InternalServerError`](crate::error::InternalServerError).
pub mod internal_server_error {

    /// A builder for [`InternalServerError`](crate::error::InternalServerError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError).
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncompatibleParameterError {
    /// <p>A parameter that is incompatible with the earlier request.</p>
    #[doc(hidden)]
    pub parameter: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IncompatibleParameterError {
    /// <p>A parameter that is incompatible with the earlier request.</p>
    pub fn parameter(&self) -> std::option::Option<&str> {
        self.parameter.as_deref()
    }
}
impl IncompatibleParameterError {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncompatibleParameterError")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleParameterError {}
impl aws_http::request_id::RequestId for crate::error::IncompatibleParameterError {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IncompatibleParameterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IncompatibleParameterError {
    /// Creates a new builder-style object to manufacture [`IncompatibleParameterError`](crate::error::IncompatibleParameterError).
    pub fn builder() -> crate::error::incompatible_parameter_error::Builder {
        crate::error::incompatible_parameter_error::Builder::default()
    }
}

/// See [`IncompatibleParameterError`](crate::error::IncompatibleParameterError).
pub mod incompatible_parameter_error {

    /// A builder for [`IncompatibleParameterError`](crate::error::IncompatibleParameterError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A parameter that is incompatible with the earlier request.</p>
        pub fn parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter = Some(input.into());
            self
        }
        /// <p>A parameter that is incompatible with the earlier request.</p>
        pub fn set_parameter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameter = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleParameterError`](crate::error::IncompatibleParameterError).
        pub fn build(self) -> crate::error::IncompatibleParameterError {
            crate::error::IncompatibleParameterError {
                parameter: self.parameter,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A generic error indicating a failure with a client request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BadRequest {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BadRequest {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequest")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BadRequest {}
impl aws_http::request_id::RequestId for crate::error::BadRequest {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BadRequest {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BadRequest {
    /// Creates a new builder-style object to manufacture [`BadRequest`](crate::error::BadRequest).
    pub fn builder() -> crate::error::bad_request::Builder {
        crate::error::bad_request::Builder::default()
    }
}

/// See [`BadRequest`](crate::error::BadRequest).
pub mod bad_request {

    /// A builder for [`BadRequest`](crate::error::BadRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BadRequest`](crate::error::BadRequest).
        pub fn build(self) -> crate::error::BadRequest {
            crate::error::BadRequest {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateStorageVirtualMachineErrorKind = UpdateStorageVirtualMachineError;
/// Error type for the `UpdateStorageVirtualMachineError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStorageVirtualMachineError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
    StorageVirtualMachineNotFound(crate::error::StorageVirtualMachineNotFound),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateStorageVirtualMachineError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateStorageVirtualMachineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::StorageVirtualMachineNotFound(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateStorageVirtualMachineError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageVirtualMachineNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateStorageVirtualMachineError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateStorageVirtualMachineError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStorageVirtualMachineError {
    /// Creates the `UpdateStorageVirtualMachineError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateStorageVirtualMachineError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::StorageVirtualMachineNotFound(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateStorageVirtualMachineError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateStorageVirtualMachineError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `UpdateStorageVirtualMachineError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateStorageVirtualMachineError::StorageVirtualMachineNotFound`.
    pub fn is_storage_virtual_machine_not_found(&self) -> bool {
        matches!(self, Self::StorageVirtualMachineNotFound(_))
    }
    /// Returns `true` if the error kind is `UpdateStorageVirtualMachineError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for UpdateStorageVirtualMachineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::StorageVirtualMachineNotFound(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested operation is not supported for this resource or API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedOperation {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedOperation {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperation")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperation {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedOperation {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UnsupportedOperation {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnsupportedOperation {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperation`](crate::error::UnsupportedOperation).
    pub fn builder() -> crate::error::unsupported_operation::Builder {
        crate::error::unsupported_operation::Builder::default()
    }
}

/// See [`UnsupportedOperation`](crate::error::UnsupportedOperation).
pub mod unsupported_operation {

    /// A builder for [`UnsupportedOperation`](crate::error::UnsupportedOperation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperation`](crate::error::UnsupportedOperation).
        pub fn build(self) -> crate::error::UnsupportedOperation {
            crate::error::UnsupportedOperation {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageVirtualMachineNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StorageVirtualMachineNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageVirtualMachineNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageVirtualMachineNotFound")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StorageVirtualMachineNotFound {}
impl aws_http::request_id::RequestId for crate::error::StorageVirtualMachineNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StorageVirtualMachineNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl StorageVirtualMachineNotFound {
    /// Creates a new builder-style object to manufacture [`StorageVirtualMachineNotFound`](crate::error::StorageVirtualMachineNotFound).
    pub fn builder() -> crate::error::storage_virtual_machine_not_found::Builder {
        crate::error::storage_virtual_machine_not_found::Builder::default()
    }
}

/// See [`StorageVirtualMachineNotFound`](crate::error::StorageVirtualMachineNotFound).
pub mod storage_virtual_machine_not_found {

    /// A builder for [`StorageVirtualMachineNotFound`](crate::error::StorageVirtualMachineNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StorageVirtualMachineNotFound`](crate::error::StorageVirtualMachineNotFound).
        pub fn build(self) -> crate::error::StorageVirtualMachineNotFound {
            crate::error::StorageVirtualMachineNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateSnapshotErrorKind = UpdateSnapshotError;
/// Error type for the `UpdateSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSnapshotError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx snapshots were found based on the supplied parameters.</p>
    SnapshotNotFound(crate::error::SnapshotNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::SnapshotNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSnapshotError {
    /// Creates the `UpdateSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::SnapshotNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateSnapshotError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateSnapshotError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateSnapshotError::SnapshotNotFound`.
    pub fn is_snapshot_not_found(&self) -> bool {
        matches!(self, Self::SnapshotNotFound(_))
    }
}
impl std::error::Error for UpdateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::SnapshotNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>No Amazon FSx snapshots were found based on the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotNotFound")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotNotFound {}
impl aws_http::request_id::RequestId for crate::error::SnapshotNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SnapshotNotFound {
    /// Creates a new builder-style object to manufacture [`SnapshotNotFound`](crate::error::SnapshotNotFound).
    pub fn builder() -> crate::error::snapshot_not_found::Builder {
        crate::error::snapshot_not_found::Builder::default()
    }
}

/// See [`SnapshotNotFound`](crate::error::SnapshotNotFound).
pub mod snapshot_not_found {

    /// A builder for [`SnapshotNotFound`](crate::error::SnapshotNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotNotFound`](crate::error::SnapshotNotFound).
        pub fn build(self) -> crate::error::SnapshotNotFound {
            crate::error::SnapshotNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFileSystemErrorKind = UpdateFileSystemError;
/// Error type for the `UpdateFileSystemError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFileSystemError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>One or more network settings specified in the request are invalid.</p>
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    /// <p>A file system configuration is required for this operation.</p>
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFileSystemError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            Self::MissingFileSystemConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateFileSystemError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNetworkSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingFileSystemConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFileSystemError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFileSystemError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFileSystemError {
    /// Creates the `UpdateFileSystemError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFileSystemError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidNetworkSettings(e) => e.meta(),
            Self::MissingFileSystemConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::InvalidNetworkSettings`.
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(self, Self::InvalidNetworkSettings(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::MissingFileSystemConfiguration`.
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(self, Self::MissingFileSystemConfiguration(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `UpdateFileSystemError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for UpdateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidNetworkSettings(_inner) => Some(_inner),
            Self::MissingFileSystemConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceLimitExceeded {
    /// <p>Enumeration of the service limit that was exceeded. </p>
    #[doc(hidden)]
    pub limit: std::option::Option<crate::model::ServiceLimit>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ServiceLimitExceeded {
    /// <p>Enumeration of the service limit that was exceeded. </p>
    pub fn limit(&self) -> std::option::Option<&crate::model::ServiceLimit> {
        self.limit.as_ref()
    }
}
impl ServiceLimitExceeded {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceLimitExceeded")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceLimitExceeded {}
impl aws_http::request_id::RequestId for crate::error::ServiceLimitExceeded {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ServiceLimitExceeded {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ServiceLimitExceeded {
    /// Creates a new builder-style object to manufacture [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded).
    pub fn builder() -> crate::error::service_limit_exceeded::Builder {
        crate::error::service_limit_exceeded::Builder::default()
    }
}

/// See [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded).
pub mod service_limit_exceeded {

    /// A builder for [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<crate::model::ServiceLimit>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Enumeration of the service limit that was exceeded. </p>
        pub fn limit(mut self, input: crate::model::ServiceLimit) -> Self {
            self.limit = Some(input);
            self
        }
        /// <p>Enumeration of the service limit that was exceeded. </p>
        pub fn set_limit(mut self, input: std::option::Option<crate::model::ServiceLimit>) -> Self {
            self.limit = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded).
        pub fn build(self) -> crate::error::ServiceLimitExceeded {
            crate::error::ServiceLimitExceeded {
                limit: self.limit,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A file system configuration is required for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissingFileSystemConfiguration {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MissingFileSystemConfiguration {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingFileSystemConfiguration")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MissingFileSystemConfiguration {}
impl aws_http::request_id::RequestId for crate::error::MissingFileSystemConfiguration {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MissingFileSystemConfiguration {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl MissingFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration).
    pub fn builder() -> crate::error::missing_file_system_configuration::Builder {
        crate::error::missing_file_system_configuration::Builder::default()
    }
}

/// See [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration).
pub mod missing_file_system_configuration {

    /// A builder for [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration).
        pub fn build(self) -> crate::error::MissingFileSystemConfiguration {
            crate::error::MissingFileSystemConfiguration {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>One or more network settings specified in the request are invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNetworkSettings {
    /// <p>Error message explaining what's wrong with network settings.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The subnet ID that is either invalid or not part of the VPC specified.</p>
    #[doc(hidden)]
    pub invalid_subnet_id: std::option::Option<std::string::String>,
    /// <p>The security group ID is either invalid or not part of the VPC specified.</p>
    #[doc(hidden)]
    pub invalid_security_group_id: std::option::Option<std::string::String>,
    /// <p>The route table ID is either invalid or not part of the VPC specified.</p>
    #[doc(hidden)]
    pub invalid_route_table_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidNetworkSettings {
    /// <p>The subnet ID that is either invalid or not part of the VPC specified.</p>
    pub fn invalid_subnet_id(&self) -> std::option::Option<&str> {
        self.invalid_subnet_id.as_deref()
    }
    /// <p>The security group ID is either invalid or not part of the VPC specified.</p>
    pub fn invalid_security_group_id(&self) -> std::option::Option<&str> {
        self.invalid_security_group_id.as_deref()
    }
    /// <p>The route table ID is either invalid or not part of the VPC specified.</p>
    pub fn invalid_route_table_id(&self) -> std::option::Option<&str> {
        self.invalid_route_table_id.as_deref()
    }
}
impl InvalidNetworkSettings {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNetworkSettings")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNetworkSettings {}
impl aws_http::request_id::RequestId for crate::error::InvalidNetworkSettings {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidNetworkSettings {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidNetworkSettings {
    /// Creates a new builder-style object to manufacture [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings).
    pub fn builder() -> crate::error::invalid_network_settings::Builder {
        crate::error::invalid_network_settings::Builder::default()
    }
}

/// See [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings).
pub mod invalid_network_settings {

    /// A builder for [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) invalid_subnet_id: std::option::Option<std::string::String>,
        pub(crate) invalid_security_group_id: std::option::Option<std::string::String>,
        pub(crate) invalid_route_table_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Error message explaining what's wrong with network settings.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message explaining what's wrong with network settings.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The subnet ID that is either invalid or not part of the VPC specified.</p>
        pub fn invalid_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_subnet_id = Some(input.into());
            self
        }
        /// <p>The subnet ID that is either invalid or not part of the VPC specified.</p>
        pub fn set_invalid_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_subnet_id = input;
            self
        }
        /// <p>The security group ID is either invalid or not part of the VPC specified.</p>
        pub fn invalid_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_security_group_id = Some(input.into());
            self
        }
        /// <p>The security group ID is either invalid or not part of the VPC specified.</p>
        pub fn set_invalid_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_security_group_id = input;
            self
        }
        /// <p>The route table ID is either invalid or not part of the VPC specified.</p>
        pub fn invalid_route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_route_table_id = Some(input.into());
            self
        }
        /// <p>The route table ID is either invalid or not part of the VPC specified.</p>
        pub fn set_invalid_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_route_table_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings).
        pub fn build(self) -> crate::error::InvalidNetworkSettings {
            crate::error::InvalidNetworkSettings {
                message: self.message,
                invalid_subnet_id: self.invalid_subnet_id,
                invalid_security_group_id: self.invalid_security_group_id,
                invalid_route_table_id: self.invalid_route_table_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileSystemNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileSystemNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileSystemNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileSystemNotFound")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileSystemNotFound {}
impl aws_http::request_id::RequestId for crate::error::FileSystemNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileSystemNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl FileSystemNotFound {
    /// Creates a new builder-style object to manufacture [`FileSystemNotFound`](crate::error::FileSystemNotFound).
    pub fn builder() -> crate::error::file_system_not_found::Builder {
        crate::error::file_system_not_found::Builder::default()
    }
}

/// See [`FileSystemNotFound`](crate::error::FileSystemNotFound).
pub mod file_system_not_found {

    /// A builder for [`FileSystemNotFound`](crate::error::FileSystemNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemNotFound`](crate::error::FileSystemNotFound).
        pub fn build(self) -> crate::error::FileSystemNotFound {
            crate::error::FileSystemNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateFileCacheErrorKind = UpdateFileCacheError;
/// Error type for the `UpdateFileCacheError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFileCacheError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No caches were found based upon supplied parameters.</p>
    FileCacheNotFound(crate::error::FileCacheNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>A cache configuration is required for this operation.</p>
    MissingFileCacheConfiguration(crate::error::MissingFileCacheConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFileCacheError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateFileCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileCacheNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::MissingFileCacheConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateFileCacheError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileCacheNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingFileCacheConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateFileCacheError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFileCacheError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFileCacheError {
    /// Creates the `UpdateFileCacheError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateFileCacheError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileCacheNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::MissingFileCacheConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::FileCacheNotFound`.
    pub fn is_file_cache_not_found(&self) -> bool {
        matches!(self, Self::FileCacheNotFound(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::MissingFileCacheConfiguration`.
    pub fn is_missing_file_cache_configuration(&self) -> bool {
        matches!(self, Self::MissingFileCacheConfiguration(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `UpdateFileCacheError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for UpdateFileCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileCacheNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::MissingFileCacheConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A cache configuration is required for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MissingFileCacheConfiguration {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MissingFileCacheConfiguration {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingFileCacheConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingFileCacheConfiguration")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MissingFileCacheConfiguration {}
impl aws_http::request_id::RequestId for crate::error::MissingFileCacheConfiguration {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MissingFileCacheConfiguration {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl MissingFileCacheConfiguration {
    /// Creates a new builder-style object to manufacture [`MissingFileCacheConfiguration`](crate::error::MissingFileCacheConfiguration).
    pub fn builder() -> crate::error::missing_file_cache_configuration::Builder {
        crate::error::missing_file_cache_configuration::Builder::default()
    }
}

/// See [`MissingFileCacheConfiguration`](crate::error::MissingFileCacheConfiguration).
pub mod missing_file_cache_configuration {

    /// A builder for [`MissingFileCacheConfiguration`](crate::error::MissingFileCacheConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MissingFileCacheConfiguration`](crate::error::MissingFileCacheConfiguration).
        pub fn build(self) -> crate::error::MissingFileCacheConfiguration {
            crate::error::MissingFileCacheConfiguration {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>No caches were found based upon supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileCacheNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileCacheNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileCacheNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileCacheNotFound")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileCacheNotFound {}
impl aws_http::request_id::RequestId for crate::error::FileCacheNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileCacheNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl FileCacheNotFound {
    /// Creates a new builder-style object to manufacture [`FileCacheNotFound`](crate::error::FileCacheNotFound).
    pub fn builder() -> crate::error::file_cache_not_found::Builder {
        crate::error::file_cache_not_found::Builder::default()
    }
}

/// See [`FileCacheNotFound`](crate::error::FileCacheNotFound).
pub mod file_cache_not_found {

    /// A builder for [`FileCacheNotFound`](crate::error::FileCacheNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileCacheNotFound`](crate::error::FileCacheNotFound).
        pub fn build(self) -> crate::error::FileCacheNotFound {
            crate::error::FileCacheNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDataRepositoryAssociationErrorKind = UpdateDataRepositoryAssociationError;
/// Error type for the `UpdateDataRepositoryAssociationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataRepositoryAssociationError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No data repository associations were found based upon the supplied parameters.</p>
    DataRepositoryAssociationNotFound(crate::error::DataRepositoryAssociationNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDataRepositoryAssociationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDataRepositoryAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryAssociationNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateDataRepositoryAssociationError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryAssociationNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDataRepositoryAssociationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDataRepositoryAssociationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataRepositoryAssociationError {
    /// Creates the `UpdateDataRepositoryAssociationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDataRepositoryAssociationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryAssociationNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDataRepositoryAssociationError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UpdateDataRepositoryAssociationError::DataRepositoryAssociationNotFound`.
    pub fn is_data_repository_association_not_found(&self) -> bool {
        matches!(self, Self::DataRepositoryAssociationNotFound(_))
    }
    /// Returns `true` if the error kind is `UpdateDataRepositoryAssociationError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `UpdateDataRepositoryAssociationError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UpdateDataRepositoryAssociationError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for UpdateDataRepositoryAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryAssociationNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>No data repository associations were found based upon the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataRepositoryAssociationNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DataRepositoryAssociationNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryAssociationNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryAssociationNotFound")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryAssociationNotFound {}
impl aws_http::request_id::RequestId for crate::error::DataRepositoryAssociationNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DataRepositoryAssociationNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DataRepositoryAssociationNotFound {
    /// Creates a new builder-style object to manufacture [`DataRepositoryAssociationNotFound`](crate::error::DataRepositoryAssociationNotFound).
    pub fn builder() -> crate::error::data_repository_association_not_found::Builder {
        crate::error::data_repository_association_not_found::Builder::default()
    }
}

/// See [`DataRepositoryAssociationNotFound`](crate::error::DataRepositoryAssociationNotFound).
pub mod data_repository_association_not_found {

    /// A builder for [`DataRepositoryAssociationNotFound`](crate::error::DataRepositoryAssociationNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryAssociationNotFound`](crate::error::DataRepositoryAssociationNotFound).
        pub fn build(self) -> crate::error::DataRepositoryAssociationNotFound {
            crate::error::DataRepositoryAssociationNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The resource specified for the tagging operation is not a resource type owned by Amazon FSx. Use the API of the relevant service to perform the operation. </p>
    NotServiceResourceError(crate::error::NotServiceResourceError),
    /// <p>The resource specified does not support tagging. </p>
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    /// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::NotServiceResourceError(_inner) => _inner.fmt(f),
            Self::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            Self::ResourceNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NotServiceResourceError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceDoesNotSupportTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::NotServiceResourceError(e) => e.meta(),
            Self::ResourceDoesNotSupportTagging(e) => e.meta(),
            Self::ResourceNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::NotServiceResourceError`.
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(self, Self::NotServiceResourceError(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ResourceDoesNotSupportTagging`.
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(self, Self::ResourceDoesNotSupportTagging(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ResourceNotFound`.
    pub fn is_resource_not_found(&self) -> bool {
        matches!(self, Self::ResourceNotFound(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::NotServiceResourceError(_inner) => Some(_inner),
            Self::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            Self::ResourceNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFound {
    /// <p>The resource ARN of the resource that can't be found.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceNotFound {
    /// <p>The resource ARN of the resource that can't be found.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ResourceNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFound")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFound {}
impl aws_http::request_id::RequestId for crate::error::ResourceNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceNotFound {
    /// Creates a new builder-style object to manufacture [`ResourceNotFound`](crate::error::ResourceNotFound).
    pub fn builder() -> crate::error::resource_not_found::Builder {
        crate::error::resource_not_found::Builder::default()
    }
}

/// See [`ResourceNotFound`](crate::error::ResourceNotFound).
pub mod resource_not_found {

    /// A builder for [`ResourceNotFound`](crate::error::ResourceNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The resource ARN of the resource that can't be found.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource ARN of the resource that can't be found.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFound`](crate::error::ResourceNotFound).
        pub fn build(self) -> crate::error::ResourceNotFound {
            crate::error::ResourceNotFound {
                resource_arn: self.resource_arn,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource specified does not support tagging. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceDoesNotSupportTagging {
    /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support tagging.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceDoesNotSupportTagging {
    /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support tagging.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ResourceDoesNotSupportTagging {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDoesNotSupportTagging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceDoesNotSupportTagging")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDoesNotSupportTagging {}
impl aws_http::request_id::RequestId for crate::error::ResourceDoesNotSupportTagging {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceDoesNotSupportTagging {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceDoesNotSupportTagging {
    /// Creates a new builder-style object to manufacture [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging).
    pub fn builder() -> crate::error::resource_does_not_support_tagging::Builder {
        crate::error::resource_does_not_support_tagging::Builder::default()
    }
}

/// See [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging).
pub mod resource_does_not_support_tagging {

    /// A builder for [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support tagging.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support tagging.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging).
        pub fn build(self) -> crate::error::ResourceDoesNotSupportTagging {
            crate::error::ResourceDoesNotSupportTagging {
                resource_arn: self.resource_arn,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The resource specified for the tagging operation is not a resource type owned by Amazon FSx. Use the API of the relevant service to perform the operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotServiceResourceError {
    /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NotServiceResourceError {
    /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl NotServiceResourceError {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotServiceResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotServiceResourceError")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NotServiceResourceError {}
impl aws_http::request_id::RequestId for crate::error::NotServiceResourceError {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NotServiceResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl NotServiceResourceError {
    /// Creates a new builder-style object to manufacture [`NotServiceResourceError`](crate::error::NotServiceResourceError).
    pub fn builder() -> crate::error::not_service_resource_error::Builder {
        crate::error::not_service_resource_error::Builder::default()
    }
}

/// See [`NotServiceResourceError`](crate::error::NotServiceResourceError).
pub mod not_service_resource_error {

    /// A builder for [`NotServiceResourceError`](crate::error::NotServiceResourceError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NotServiceResourceError`](crate::error::NotServiceResourceError).
        pub fn build(self) -> crate::error::NotServiceResourceError {
            crate::error::NotServiceResourceError {
                resource_arn: self.resource_arn,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The resource specified for the tagging operation is not a resource type owned by Amazon FSx. Use the API of the relevant service to perform the operation. </p>
    NotServiceResourceError(crate::error::NotServiceResourceError),
    /// <p>The resource specified does not support tagging. </p>
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    /// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::NotServiceResourceError(_inner) => _inner.fmt(f),
            Self::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            Self::ResourceNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NotServiceResourceError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceDoesNotSupportTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::NotServiceResourceError(e) => e.meta(),
            Self::ResourceDoesNotSupportTagging(e) => e.meta(),
            Self::ResourceNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::NotServiceResourceError`.
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(self, Self::NotServiceResourceError(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ResourceDoesNotSupportTagging`.
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(self, Self::ResourceDoesNotSupportTagging(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ResourceNotFound`.
    pub fn is_resource_not_found(&self) -> bool {
        matches!(self, Self::ResourceNotFound(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::NotServiceResourceError(_inner) => Some(_inner),
            Self::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            Self::ResourceNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreVolumeFromSnapshotErrorKind = RestoreVolumeFromSnapshotError;
/// Error type for the `RestoreVolumeFromSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreVolumeFromSnapshotError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreVolumeFromSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreVolumeFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreVolumeFromSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreVolumeFromSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreVolumeFromSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreVolumeFromSnapshotError {
    /// Creates the `RestoreVolumeFromSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreVolumeFromSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreVolumeFromSnapshotError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `RestoreVolumeFromSnapshotError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `RestoreVolumeFromSnapshotError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for RestoreVolumeFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ReleaseFileSystemNfsV3LocksErrorKind = ReleaseFileSystemNfsV3LocksError;
/// Error type for the `ReleaseFileSystemNfsV3LocksError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReleaseFileSystemNfsV3LocksError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ReleaseFileSystemNfsV3LocksError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ReleaseFileSystemNfsV3LocksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReleaseFileSystemNfsV3LocksError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ReleaseFileSystemNfsV3LocksError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ReleaseFileSystemNfsV3LocksError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReleaseFileSystemNfsV3LocksError {
    /// Creates the `ReleaseFileSystemNfsV3LocksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ReleaseFileSystemNfsV3LocksError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ReleaseFileSystemNfsV3LocksError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `ReleaseFileSystemNfsV3LocksError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `ReleaseFileSystemNfsV3LocksError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `ReleaseFileSystemNfsV3LocksError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `ReleaseFileSystemNfsV3LocksError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for ReleaseFileSystemNfsV3LocksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The resource specified for the tagging operation is not a resource type owned by Amazon FSx. Use the API of the relevant service to perform the operation. </p>
    NotServiceResourceError(crate::error::NotServiceResourceError),
    /// <p>The resource specified does not support tagging. </p>
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    /// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::NotServiceResourceError(_inner) => _inner.fmt(f),
            Self::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            Self::ResourceNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NotServiceResourceError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceDoesNotSupportTagging(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::NotServiceResourceError(e) => e.meta(),
            Self::ResourceDoesNotSupportTagging(e) => e.meta(),
            Self::ResourceNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::NotServiceResourceError`.
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(self, Self::NotServiceResourceError(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ResourceDoesNotSupportTagging`.
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(self, Self::ResourceDoesNotSupportTagging(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ResourceNotFound`.
    pub fn is_resource_not_found(&self) -> bool {
        matches!(self, Self::ResourceNotFound(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::NotServiceResourceError(_inner) => Some(_inner),
            Self::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            Self::ResourceNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisassociateFileSystemAliasesErrorKind = DisassociateFileSystemAliasesError;
/// Error type for the `DisassociateFileSystemAliasesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFileSystemAliasesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DisassociateFileSystemAliasesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisassociateFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DisassociateFileSystemAliasesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DisassociateFileSystemAliasesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DisassociateFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFileSystemAliasesError {
    /// Creates the `DisassociateFileSystemAliasesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisassociateFileSystemAliasesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisassociateFileSystemAliasesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DisassociateFileSystemAliasesError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DisassociateFileSystemAliasesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DisassociateFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeVolumesErrorKind = DescribeVolumesError;
/// Error type for the `DescribeVolumesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVolumesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeVolumesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeVolumesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeVolumesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeVolumesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeVolumesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVolumesError {
    /// Creates the `DescribeVolumesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeVolumesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeVolumesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeVolumesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeVolumesError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for DescribeVolumesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeStorageVirtualMachinesErrorKind = DescribeStorageVirtualMachinesError;
/// Error type for the `DescribeStorageVirtualMachinesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStorageVirtualMachinesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
    StorageVirtualMachineNotFound(crate::error::StorageVirtualMachineNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeStorageVirtualMachinesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeStorageVirtualMachinesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::StorageVirtualMachineNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeStorageVirtualMachinesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageVirtualMachineNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeStorageVirtualMachinesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeStorageVirtualMachinesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStorageVirtualMachinesError {
    /// Creates the `DescribeStorageVirtualMachinesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeStorageVirtualMachinesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::StorageVirtualMachineNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeStorageVirtualMachinesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeStorageVirtualMachinesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeStorageVirtualMachinesError::StorageVirtualMachineNotFound`.
    pub fn is_storage_virtual_machine_not_found(&self) -> bool {
        matches!(self, Self::StorageVirtualMachineNotFound(_))
    }
}
impl std::error::Error for DescribeStorageVirtualMachinesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::StorageVirtualMachineNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeSnapshotsErrorKind = DescribeSnapshotsError;
/// Error type for the `DescribeSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotsError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx snapshots were found based on the supplied parameters.</p>
    SnapshotNotFound(crate::error::SnapshotNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::SnapshotNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotsError {
    /// Creates the `DescribeSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::SnapshotNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeSnapshotsError::SnapshotNotFound`.
    pub fn is_snapshot_not_found(&self) -> bool {
        matches!(self, Self::SnapshotNotFound(_))
    }
}
impl std::error::Error for DescribeSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::SnapshotNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeFileSystemsErrorKind = DescribeFileSystemsError;
/// Error type for the `DescribeFileSystemsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileSystemsError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeFileSystemsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeFileSystemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeFileSystemsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeFileSystemsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFileSystemsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileSystemsError {
    /// Creates the `DescribeFileSystemsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeFileSystemsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeFileSystemsError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeFileSystemsError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeFileSystemsError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DescribeFileSystemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeFileSystemAliasesErrorKind = DescribeFileSystemAliasesError;
/// Error type for the `DescribeFileSystemAliasesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileSystemAliasesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeFileSystemAliasesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeFileSystemAliasesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeFileSystemAliasesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileSystemAliasesError {
    /// Creates the `DescribeFileSystemAliasesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeFileSystemAliasesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeFileSystemAliasesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeFileSystemAliasesError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeFileSystemAliasesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DescribeFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeFileCachesErrorKind = DescribeFileCachesError;
/// Error type for the `DescribeFileCachesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileCachesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No caches were found based upon supplied parameters.</p>
    FileCacheNotFound(crate::error::FileCacheNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeFileCachesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeFileCachesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileCacheNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeFileCachesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileCacheNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeFileCachesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeFileCachesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileCachesError {
    /// Creates the `DescribeFileCachesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeFileCachesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileCacheNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeFileCachesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeFileCachesError::FileCacheNotFound`.
    pub fn is_file_cache_not_found(&self) -> bool {
        matches!(self, Self::FileCacheNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeFileCachesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DescribeFileCachesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileCacheNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDataRepositoryTasksErrorKind = DescribeDataRepositoryTasksError;
/// Error type for the `DescribeDataRepositoryTasksError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataRepositoryTasksError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The data repository task or tasks you specified could not be found.</p>
    DataRepositoryTaskNotFound(crate::error::DataRepositoryTaskNotFound),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDataRepositoryTasksError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDataRepositoryTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryTaskNotFound(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDataRepositoryTasksError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryTaskNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDataRepositoryTasksError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDataRepositoryTasksError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataRepositoryTasksError {
    /// Creates the `DescribeDataRepositoryTasksError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDataRepositoryTasksError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryTaskNotFound(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryTasksError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryTasksError::DataRepositoryTaskNotFound`.
    pub fn is_data_repository_task_not_found(&self) -> bool {
        matches!(self, Self::DataRepositoryTaskNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryTasksError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryTasksError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DescribeDataRepositoryTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryTaskNotFound(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The data repository task or tasks you specified could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataRepositoryTaskNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DataRepositoryTaskNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskNotFound")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskNotFound {}
impl aws_http::request_id::RequestId for crate::error::DataRepositoryTaskNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DataRepositoryTaskNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DataRepositoryTaskNotFound {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound).
    pub fn builder() -> crate::error::data_repository_task_not_found::Builder {
        crate::error::data_repository_task_not_found::Builder::default()
    }
}

/// See [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound).
pub mod data_repository_task_not_found {

    /// A builder for [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound).
        pub fn build(self) -> crate::error::DataRepositoryTaskNotFound {
            crate::error::DataRepositoryTaskNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDataRepositoryAssociationsErrorKind = DescribeDataRepositoryAssociationsError;
/// Error type for the `DescribeDataRepositoryAssociationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataRepositoryAssociationsError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No data repository associations were found based upon the supplied parameters.</p>
    DataRepositoryAssociationNotFound(crate::error::DataRepositoryAssociationNotFound),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>You have filtered the response to a data repository type that is not supported.</p>
    InvalidDataRepositoryType(crate::error::InvalidDataRepositoryType),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDataRepositoryAssociationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDataRepositoryAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryAssociationNotFound(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidDataRepositoryType(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDataRepositoryAssociationsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryAssociationNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDataRepositoryType(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDataRepositoryAssociationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDataRepositoryAssociationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataRepositoryAssociationsError {
    /// Creates the `DescribeDataRepositoryAssociationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDataRepositoryAssociationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryAssociationNotFound(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidDataRepositoryType(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryAssociationsError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryAssociationsError::DataRepositoryAssociationNotFound`.
    pub fn is_data_repository_association_not_found(&self) -> bool {
        matches!(self, Self::DataRepositoryAssociationNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryAssociationsError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryAssociationsError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeDataRepositoryAssociationsError::InvalidDataRepositoryType`.
    pub fn is_invalid_data_repository_type(&self) -> bool {
        matches!(self, Self::InvalidDataRepositoryType(_))
    }
}
impl std::error::Error for DescribeDataRepositoryAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryAssociationNotFound(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidDataRepositoryType(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have filtered the response to a data repository type that is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDataRepositoryType {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDataRepositoryType {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDataRepositoryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDataRepositoryType")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDataRepositoryType {}
impl aws_http::request_id::RequestId for crate::error::InvalidDataRepositoryType {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDataRepositoryType {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDataRepositoryType {
    /// Creates a new builder-style object to manufacture [`InvalidDataRepositoryType`](crate::error::InvalidDataRepositoryType).
    pub fn builder() -> crate::error::invalid_data_repository_type::Builder {
        crate::error::invalid_data_repository_type::Builder::default()
    }
}

/// See [`InvalidDataRepositoryType`](crate::error::InvalidDataRepositoryType).
pub mod invalid_data_repository_type {

    /// A builder for [`InvalidDataRepositoryType`](crate::error::InvalidDataRepositoryType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDataRepositoryType`](crate::error::InvalidDataRepositoryType).
        pub fn build(self) -> crate::error::InvalidDataRepositoryType {
            crate::error::InvalidDataRepositoryType {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeBackupsErrorKind = DescribeBackupsError;
/// Error type for the `DescribeBackupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBackupsError {
    /// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
    BackupNotFound(crate::error::BackupNotFound),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeBackupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BackupNotFound(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeBackupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BackupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeBackupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeBackupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBackupsError {
    /// Creates the `DescribeBackupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeBackupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BackupNotFound(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeBackupsError::BackupNotFound`.
    pub fn is_backup_not_found(&self) -> bool {
        matches!(self, Self::BackupNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeBackupsError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DescribeBackupsError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DescribeBackupsError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DescribeBackupsError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for DescribeBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BackupNotFound(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BackupNotFound {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BackupNotFound {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupNotFound")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BackupNotFound {}
impl aws_http::request_id::RequestId for crate::error::BackupNotFound {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BackupNotFound {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BackupNotFound {
    /// Creates a new builder-style object to manufacture [`BackupNotFound`](crate::error::BackupNotFound).
    pub fn builder() -> crate::error::backup_not_found::Builder {
        crate::error::backup_not_found::Builder::default()
    }
}

/// See [`BackupNotFound`](crate::error::BackupNotFound).
pub mod backup_not_found {

    /// A builder for [`BackupNotFound`](crate::error::BackupNotFound).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BackupNotFound`](crate::error::BackupNotFound).
        pub fn build(self) -> crate::error::BackupNotFound {
            crate::error::BackupNotFound {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteVolumeErrorKind = DeleteVolumeError;
/// Error type for the `DeleteVolumeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVolumeError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVolumeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteVolumeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteVolumeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVolumeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVolumeError {
    /// Creates the `DeleteVolumeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteVolumeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteVolumeError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteVolumeError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteVolumeError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteVolumeError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for DeleteVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteStorageVirtualMachineErrorKind = DeleteStorageVirtualMachineError;
/// Error type for the `DeleteStorageVirtualMachineError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStorageVirtualMachineError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
    StorageVirtualMachineNotFound(crate::error::StorageVirtualMachineNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteStorageVirtualMachineError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteStorageVirtualMachineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::StorageVirtualMachineNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteStorageVirtualMachineError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageVirtualMachineNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteStorageVirtualMachineError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteStorageVirtualMachineError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStorageVirtualMachineError {
    /// Creates the `DeleteStorageVirtualMachineError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteStorageVirtualMachineError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::StorageVirtualMachineNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteStorageVirtualMachineError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteStorageVirtualMachineError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteStorageVirtualMachineError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteStorageVirtualMachineError::StorageVirtualMachineNotFound`.
    pub fn is_storage_virtual_machine_not_found(&self) -> bool {
        matches!(self, Self::StorageVirtualMachineNotFound(_))
    }
}
impl std::error::Error for DeleteStorageVirtualMachineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::StorageVirtualMachineNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteSnapshotErrorKind = DeleteSnapshotError;
/// Error type for the `DeleteSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>No Amazon FSx snapshots were found based on the supplied parameters.</p>
    SnapshotNotFound(crate::error::SnapshotNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::SnapshotNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotError {
    /// Creates the `DeleteSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::SnapshotNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteSnapshotError::SnapshotNotFound`.
    pub fn is_snapshot_not_found(&self) -> bool {
        matches!(self, Self::SnapshotNotFound(_))
    }
}
impl std::error::Error for DeleteSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::SnapshotNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFileSystemErrorKind = DeleteFileSystemError;
/// Error type for the `DeleteFileSystemError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileSystemError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFileSystemError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFileSystemError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFileSystemError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFileSystemError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileSystemError {
    /// Creates the `DeleteFileSystemError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFileSystemError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFileSystemError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteFileSystemError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `DeleteFileSystemError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteFileSystemError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteFileSystemError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for DeleteFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFileCacheErrorKind = DeleteFileCacheError;
/// Error type for the `DeleteFileCacheError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileCacheError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No caches were found based upon supplied parameters.</p>
    FileCacheNotFound(crate::error::FileCacheNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFileCacheError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFileCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileCacheNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFileCacheError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileCacheNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFileCacheError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFileCacheError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileCacheError {
    /// Creates the `DeleteFileCacheError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFileCacheError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileCacheNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFileCacheError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteFileCacheError::FileCacheNotFound`.
    pub fn is_file_cache_not_found(&self) -> bool {
        matches!(self, Self::FileCacheNotFound(_))
    }
    /// Returns `true` if the error kind is `DeleteFileCacheError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteFileCacheError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteFileCacheError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for DeleteFileCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileCacheNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDataRepositoryAssociationErrorKind = DeleteDataRepositoryAssociationError;
/// Error type for the `DeleteDataRepositoryAssociationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDataRepositoryAssociationError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No data repository associations were found based upon the supplied parameters.</p>
    DataRepositoryAssociationNotFound(crate::error::DataRepositoryAssociationNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDataRepositoryAssociationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDataRepositoryAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryAssociationNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteDataRepositoryAssociationError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryAssociationNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDataRepositoryAssociationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDataRepositoryAssociationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDataRepositoryAssociationError {
    /// Creates the `DeleteDataRepositoryAssociationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDataRepositoryAssociationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryAssociationNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDataRepositoryAssociationError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteDataRepositoryAssociationError::DataRepositoryAssociationNotFound`.
    pub fn is_data_repository_association_not_found(&self) -> bool {
        matches!(self, Self::DataRepositoryAssociationNotFound(_))
    }
    /// Returns `true` if the error kind is `DeleteDataRepositoryAssociationError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteDataRepositoryAssociationError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `DeleteDataRepositoryAssociationError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for DeleteDataRepositoryAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryAssociationNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteBackupErrorKind = DeleteBackupError;
/// Error type for the `DeleteBackupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupError {
    /// <p>You can't delete a backup while it's being copied.</p>
    BackupBeingCopied(crate::error::BackupBeingCopied),
    /// <p>Another backup is already under way. Wait for completion before initiating additional backups of this file system.</p>
    BackupInProgress(crate::error::BackupInProgress),
    /// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
    BackupNotFound(crate::error::BackupNotFound),
    /// <p>You can't delete a backup while it's being used to restore a file system.</p>
    BackupRestoring(crate::error::BackupRestoring),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteBackupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BackupBeingCopied(_inner) => _inner.fmt(f),
            Self::BackupInProgress(_inner) => _inner.fmt(f),
            Self::BackupNotFound(_inner) => _inner.fmt(f),
            Self::BackupRestoring(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteBackupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BackupBeingCopied(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BackupInProgress(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BackupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BackupRestoring(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteBackupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteBackupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupError {
    /// Creates the `DeleteBackupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteBackupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BackupBeingCopied(e) => e.meta(),
            Self::BackupInProgress(e) => e.meta(),
            Self::BackupNotFound(e) => e.meta(),
            Self::BackupRestoring(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteBackupError::BackupBeingCopied`.
    pub fn is_backup_being_copied(&self) -> bool {
        matches!(self, Self::BackupBeingCopied(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::BackupInProgress`.
    pub fn is_backup_in_progress(&self) -> bool {
        matches!(self, Self::BackupInProgress(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::BackupNotFound`.
    pub fn is_backup_not_found(&self) -> bool {
        matches!(self, Self::BackupNotFound(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::BackupRestoring`.
    pub fn is_backup_restoring(&self) -> bool {
        matches!(self, Self::BackupRestoring(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `DeleteBackupError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for DeleteBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BackupBeingCopied(_inner) => Some(_inner),
            Self::BackupInProgress(_inner) => Some(_inner),
            Self::BackupNotFound(_inner) => Some(_inner),
            Self::BackupRestoring(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You can't delete a backup while it's being used to restore a file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BackupRestoring {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of a file system being restored from the backup.</p>
    #[doc(hidden)]
    pub file_system_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BackupRestoring {
    /// <p>The ID of a file system being restored from the backup.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
}
impl BackupRestoring {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupRestoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupRestoring")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BackupRestoring {}
impl aws_http::request_id::RequestId for crate::error::BackupRestoring {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BackupRestoring {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BackupRestoring {
    /// Creates a new builder-style object to manufacture [`BackupRestoring`](crate::error::BackupRestoring).
    pub fn builder() -> crate::error::backup_restoring::Builder {
        crate::error::backup_restoring::Builder::default()
    }
}

/// See [`BackupRestoring`](crate::error::BackupRestoring).
pub mod backup_restoring {

    /// A builder for [`BackupRestoring`](crate::error::BackupRestoring).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of a file system being restored from the backup.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The ID of a file system being restored from the backup.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BackupRestoring`](crate::error::BackupRestoring).
        pub fn build(self) -> crate::error::BackupRestoring {
            crate::error::BackupRestoring {
                message: self.message,
                file_system_id: self.file_system_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Another backup is already under way. Wait for completion before initiating additional backups of this file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BackupInProgress {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BackupInProgress {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupInProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupInProgress")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BackupInProgress {}
impl aws_http::request_id::RequestId for crate::error::BackupInProgress {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BackupInProgress {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BackupInProgress {
    /// Creates a new builder-style object to manufacture [`BackupInProgress`](crate::error::BackupInProgress).
    pub fn builder() -> crate::error::backup_in_progress::Builder {
        crate::error::backup_in_progress::Builder::default()
    }
}

/// See [`BackupInProgress`](crate::error::BackupInProgress).
pub mod backup_in_progress {

    /// A builder for [`BackupInProgress`](crate::error::BackupInProgress).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BackupInProgress`](crate::error::BackupInProgress).
        pub fn build(self) -> crate::error::BackupInProgress {
            crate::error::BackupInProgress {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>You can't delete a backup while it's being copied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BackupBeingCopied {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    #[doc(hidden)]
    pub backup_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BackupBeingCopied {
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub fn backup_id(&self) -> std::option::Option<&str> {
        self.backup_id.as_deref()
    }
}
impl BackupBeingCopied {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupBeingCopied {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupBeingCopied")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BackupBeingCopied {}
impl aws_http::request_id::RequestId for crate::error::BackupBeingCopied {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BackupBeingCopied {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BackupBeingCopied {
    /// Creates a new builder-style object to manufacture [`BackupBeingCopied`](crate::error::BackupBeingCopied).
    pub fn builder() -> crate::error::backup_being_copied::Builder {
        crate::error::backup_being_copied::Builder::default()
    }
}

/// See [`BackupBeingCopied`](crate::error::BackupBeingCopied).
pub mod backup_being_copied {

    /// A builder for [`BackupBeingCopied`](crate::error::BackupBeingCopied).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) backup_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BackupBeingCopied`](crate::error::BackupBeingCopied).
        pub fn build(self) -> crate::error::BackupBeingCopied {
            crate::error::BackupBeingCopied {
                message: self.message,
                backup_id: self.backup_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateVolumeFromBackupErrorKind = CreateVolumeFromBackupError;
/// Error type for the `CreateVolumeFromBackupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVolumeFromBackupError {
    /// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
    BackupNotFound(crate::error::BackupNotFound),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>A volume configuration is required for this operation.</p>
    MissingVolumeConfiguration(crate::error::MissingVolumeConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
    StorageVirtualMachineNotFound(crate::error::StorageVirtualMachineNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVolumeFromBackupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateVolumeFromBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BackupNotFound(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::MissingVolumeConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::StorageVirtualMachineNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateVolumeFromBackupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BackupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingVolumeConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageVirtualMachineNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateVolumeFromBackupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVolumeFromBackupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVolumeFromBackupError {
    /// Creates the `CreateVolumeFromBackupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateVolumeFromBackupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BackupNotFound(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::MissingVolumeConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::StorageVirtualMachineNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::BackupNotFound`.
    pub fn is_backup_not_found(&self) -> bool {
        matches!(self, Self::BackupNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::MissingVolumeConfiguration`.
    pub fn is_missing_volume_configuration(&self) -> bool {
        matches!(self, Self::MissingVolumeConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeFromBackupError::StorageVirtualMachineNotFound`.
    pub fn is_storage_virtual_machine_not_found(&self) -> bool {
        matches!(self, Self::StorageVirtualMachineNotFound(_))
    }
}
impl std::error::Error for CreateVolumeFromBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BackupNotFound(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::MissingVolumeConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::StorageVirtualMachineNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateVolumeErrorKind = CreateVolumeError;
/// Error type for the `CreateVolumeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVolumeError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>A volume configuration is required for this operation.</p>
    MissingVolumeConfiguration(crate::error::MissingVolumeConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>No FSx for ONTAP SVMs were found based upon the supplied parameters.</p>
    StorageVirtualMachineNotFound(crate::error::StorageVirtualMachineNotFound),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVolumeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateVolumeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::MissingVolumeConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::StorageVirtualMachineNotFound(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateVolumeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingVolumeConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageVirtualMachineNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateVolumeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateVolumeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVolumeError {
    /// Creates the `CreateVolumeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateVolumeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::MissingVolumeConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::StorageVirtualMachineNotFound(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateVolumeError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::MissingVolumeConfiguration`.
    pub fn is_missing_volume_configuration(&self) -> bool {
        matches!(self, Self::MissingVolumeConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::StorageVirtualMachineNotFound`.
    pub fn is_storage_virtual_machine_not_found(&self) -> bool {
        matches!(self, Self::StorageVirtualMachineNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateVolumeError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateVolumeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::MissingVolumeConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::StorageVirtualMachineNotFound(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateStorageVirtualMachineErrorKind = CreateStorageVirtualMachineError;
/// Error type for the `CreateStorageVirtualMachineError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStorageVirtualMachineError {
    /// <p>An Active Directory error.</p>
    ActiveDirectoryError(crate::error::ActiveDirectoryError),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateStorageVirtualMachineError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateStorageVirtualMachineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ActiveDirectoryError(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateStorageVirtualMachineError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ActiveDirectoryError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateStorageVirtualMachineError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateStorageVirtualMachineError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStorageVirtualMachineError {
    /// Creates the `CreateStorageVirtualMachineError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateStorageVirtualMachineError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ActiveDirectoryError(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::ActiveDirectoryError`.
    pub fn is_active_directory_error(&self) -> bool {
        matches!(self, Self::ActiveDirectoryError(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateStorageVirtualMachineError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateStorageVirtualMachineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ActiveDirectoryError(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An Active Directory error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActiveDirectoryError {
    /// <p>The directory ID of the directory that an error pertains to.</p>
    #[doc(hidden)]
    pub active_directory_id: std::option::Option<std::string::String>,
    /// <p>The type of Active Directory error.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ActiveDirectoryErrorType>,
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ActiveDirectoryError {
    /// <p>The directory ID of the directory that an error pertains to.</p>
    pub fn active_directory_id(&self) -> std::option::Option<&str> {
        self.active_directory_id.as_deref()
    }
    /// <p>The type of Active Directory error.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ActiveDirectoryErrorType> {
        self.r#type.as_ref()
    }
}
impl ActiveDirectoryError {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ActiveDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ActiveDirectoryError")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ActiveDirectoryError {}
impl aws_http::request_id::RequestId for crate::error::ActiveDirectoryError {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ActiveDirectoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ActiveDirectoryError {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryError`](crate::error::ActiveDirectoryError).
    pub fn builder() -> crate::error::active_directory_error::Builder {
        crate::error::active_directory_error::Builder::default()
    }
}

/// See [`ActiveDirectoryError`](crate::error::ActiveDirectoryError).
pub mod active_directory_error {

    /// A builder for [`ActiveDirectoryError`](crate::error::ActiveDirectoryError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ActiveDirectoryErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The directory ID of the directory that an error pertains to.</p>
        pub fn active_directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_id = Some(input.into());
            self
        }
        /// <p>The directory ID of the directory that an error pertains to.</p>
        pub fn set_active_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_id = input;
            self
        }
        /// <p>The type of Active Directory error.</p>
        pub fn r#type(mut self, input: crate::model::ActiveDirectoryErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of Active Directory error.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ActiveDirectoryErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryError`](crate::error::ActiveDirectoryError).
        pub fn build(self) -> crate::error::ActiveDirectoryError {
            crate::error::ActiveDirectoryError {
                active_directory_id: self.active_directory_id,
                r#type: self.r#type,
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateSnapshotErrorKind = CreateSnapshotError;
/// Error type for the `CreateSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotError {
    /// Creates the `CreateSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateSnapshotError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for CreateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFileSystemFromBackupErrorKind = CreateFileSystemFromBackupError;
/// Error type for the `CreateFileSystemFromBackupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFileSystemFromBackupError {
    /// <p>An Active Directory error.</p>
    ActiveDirectoryError(crate::error::ActiveDirectoryError),
    /// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
    BackupNotFound(crate::error::BackupNotFound),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>One or more network settings specified in the request are invalid.</p>
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    /// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
    InvalidPerUnitStorageThroughput(crate::error::InvalidPerUnitStorageThroughput),
    /// <p>A file system configuration is required for this operation.</p>
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFileSystemFromBackupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFileSystemFromBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ActiveDirectoryError(_inner) => _inner.fmt(f),
            Self::BackupNotFound(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            Self::InvalidPerUnitStorageThroughput(_inner) => _inner.fmt(f),
            Self::MissingFileSystemConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateFileSystemFromBackupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ActiveDirectoryError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BackupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNetworkSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPerUnitStorageThroughput(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingFileSystemConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFileSystemFromBackupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFileSystemFromBackupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFileSystemFromBackupError {
    /// Creates the `CreateFileSystemFromBackupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFileSystemFromBackupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ActiveDirectoryError(e) => e.meta(),
            Self::BackupNotFound(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidNetworkSettings(e) => e.meta(),
            Self::InvalidPerUnitStorageThroughput(e) => e.meta(),
            Self::MissingFileSystemConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::ActiveDirectoryError`.
    pub fn is_active_directory_error(&self) -> bool {
        matches!(self, Self::ActiveDirectoryError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::BackupNotFound`.
    pub fn is_backup_not_found(&self) -> bool {
        matches!(self, Self::BackupNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::InvalidNetworkSettings`.
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(self, Self::InvalidNetworkSettings(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::InvalidPerUnitStorageThroughput`.
    pub fn is_invalid_per_unit_storage_throughput(&self) -> bool {
        matches!(self, Self::InvalidPerUnitStorageThroughput(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::MissingFileSystemConfiguration`.
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(self, Self::MissingFileSystemConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemFromBackupError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for CreateFileSystemFromBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ActiveDirectoryError(_inner) => Some(_inner),
            Self::BackupNotFound(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidNetworkSettings(_inner) => Some(_inner),
            Self::InvalidPerUnitStorageThroughput(_inner) => Some(_inner),
            Self::MissingFileSystemConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPerUnitStorageThroughput {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPerUnitStorageThroughput {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPerUnitStorageThroughput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPerUnitStorageThroughput")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPerUnitStorageThroughput {}
impl aws_http::request_id::RequestId for crate::error::InvalidPerUnitStorageThroughput {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPerUnitStorageThroughput {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidPerUnitStorageThroughput {
    /// Creates a new builder-style object to manufacture [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput).
    pub fn builder() -> crate::error::invalid_per_unit_storage_throughput::Builder {
        crate::error::invalid_per_unit_storage_throughput::Builder::default()
    }
}

/// See [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput).
pub mod invalid_per_unit_storage_throughput {

    /// A builder for [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput).
        pub fn build(self) -> crate::error::InvalidPerUnitStorageThroughput {
            crate::error::InvalidPerUnitStorageThroughput {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFileSystemErrorKind = CreateFileSystemError;
/// Error type for the `CreateFileSystemError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFileSystemError {
    /// <p>An Active Directory error.</p>
    ActiveDirectoryError(crate::error::ActiveDirectoryError),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The path provided for data repository export isn't valid.</p>
    InvalidExportPath(crate::error::InvalidExportPath),
    /// <p>The path provided for data repository import isn't valid.</p>
    InvalidImportPath(crate::error::InvalidImportPath),
    /// <p>One or more network settings specified in the request are invalid.</p>
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    /// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
    InvalidPerUnitStorageThroughput(crate::error::InvalidPerUnitStorageThroughput),
    /// <p>A file system configuration is required for this operation.</p>
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFileSystemError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ActiveDirectoryError(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidExportPath(_inner) => _inner.fmt(f),
            Self::InvalidImportPath(_inner) => _inner.fmt(f),
            Self::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            Self::InvalidPerUnitStorageThroughput(_inner) => _inner.fmt(f),
            Self::MissingFileSystemConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateFileSystemError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ActiveDirectoryError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidExportPath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidImportPath(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNetworkSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPerUnitStorageThroughput(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingFileSystemConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFileSystemError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFileSystemError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFileSystemError {
    /// Creates the `CreateFileSystemError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFileSystemError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ActiveDirectoryError(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidExportPath(e) => e.meta(),
            Self::InvalidImportPath(e) => e.meta(),
            Self::InvalidNetworkSettings(e) => e.meta(),
            Self::InvalidPerUnitStorageThroughput(e) => e.meta(),
            Self::MissingFileSystemConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::ActiveDirectoryError`.
    pub fn is_active_directory_error(&self) -> bool {
        matches!(self, Self::ActiveDirectoryError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::InvalidExportPath`.
    pub fn is_invalid_export_path(&self) -> bool {
        matches!(self, Self::InvalidExportPath(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::InvalidImportPath`.
    pub fn is_invalid_import_path(&self) -> bool {
        matches!(self, Self::InvalidImportPath(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::InvalidNetworkSettings`.
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(self, Self::InvalidNetworkSettings(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::InvalidPerUnitStorageThroughput`.
    pub fn is_invalid_per_unit_storage_throughput(&self) -> bool {
        matches!(self, Self::InvalidPerUnitStorageThroughput(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::MissingFileSystemConfiguration`.
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(self, Self::MissingFileSystemConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateFileSystemError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for CreateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ActiveDirectoryError(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidExportPath(_inner) => Some(_inner),
            Self::InvalidImportPath(_inner) => Some(_inner),
            Self::InvalidNetworkSettings(_inner) => Some(_inner),
            Self::InvalidPerUnitStorageThroughput(_inner) => Some(_inner),
            Self::MissingFileSystemConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The path provided for data repository import isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidImportPath {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidImportPath {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImportPath")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImportPath {}
impl aws_http::request_id::RequestId for crate::error::InvalidImportPath {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidImportPath {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidImportPath {
    /// Creates a new builder-style object to manufacture [`InvalidImportPath`](crate::error::InvalidImportPath).
    pub fn builder() -> crate::error::invalid_import_path::Builder {
        crate::error::invalid_import_path::Builder::default()
    }
}

/// See [`InvalidImportPath`](crate::error::InvalidImportPath).
pub mod invalid_import_path {

    /// A builder for [`InvalidImportPath`](crate::error::InvalidImportPath).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImportPath`](crate::error::InvalidImportPath).
        pub fn build(self) -> crate::error::InvalidImportPath {
            crate::error::InvalidImportPath {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The path provided for data repository export isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidExportPath {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidExportPath {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportPath")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportPath {}
impl aws_http::request_id::RequestId for crate::error::InvalidExportPath {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidExportPath {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidExportPath {
    /// Creates a new builder-style object to manufacture [`InvalidExportPath`](crate::error::InvalidExportPath).
    pub fn builder() -> crate::error::invalid_export_path::Builder {
        crate::error::invalid_export_path::Builder::default()
    }
}

/// See [`InvalidExportPath`](crate::error::InvalidExportPath).
pub mod invalid_export_path {

    /// A builder for [`InvalidExportPath`](crate::error::InvalidExportPath).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportPath`](crate::error::InvalidExportPath).
        pub fn build(self) -> crate::error::InvalidExportPath {
            crate::error::InvalidExportPath {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateFileCacheErrorKind = CreateFileCacheError;
/// Error type for the `CreateFileCacheError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFileCacheError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>One or more network settings specified in the request are invalid.</p>
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    /// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
    InvalidPerUnitStorageThroughput(crate::error::InvalidPerUnitStorageThroughput),
    /// <p>A cache configuration is required for this operation.</p>
    MissingFileCacheConfiguration(crate::error::MissingFileCacheConfiguration),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFileCacheError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateFileCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            Self::InvalidPerUnitStorageThroughput(_inner) => _inner.fmt(f),
            Self::MissingFileCacheConfiguration(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateFileCacheError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNetworkSettings(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPerUnitStorageThroughput(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MissingFileCacheConfiguration(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateFileCacheError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFileCacheError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFileCacheError {
    /// Creates the `CreateFileCacheError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateFileCacheError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidNetworkSettings(e) => e.meta(),
            Self::InvalidPerUnitStorageThroughput(e) => e.meta(),
            Self::MissingFileCacheConfiguration(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::InvalidNetworkSettings`.
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(self, Self::InvalidNetworkSettings(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::InvalidPerUnitStorageThroughput`.
    pub fn is_invalid_per_unit_storage_throughput(&self) -> bool {
        matches!(self, Self::InvalidPerUnitStorageThroughput(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::MissingFileCacheConfiguration`.
    pub fn is_missing_file_cache_configuration(&self) -> bool {
        matches!(self, Self::MissingFileCacheConfiguration(_))
    }
    /// Returns `true` if the error kind is `CreateFileCacheError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
}
impl std::error::Error for CreateFileCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidNetworkSettings(_inner) => Some(_inner),
            Self::InvalidPerUnitStorageThroughput(_inner) => Some(_inner),
            Self::MissingFileCacheConfiguration(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDataRepositoryTaskErrorKind = CreateDataRepositoryTaskError;
/// Error type for the `CreateDataRepositoryTaskError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataRepositoryTaskError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>An existing data repository task is currently executing on the file system. Wait until the existing task has completed, then create the new task.</p>
    DataRepositoryTaskExecuting(crate::error::DataRepositoryTaskExecuting),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDataRepositoryTaskError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDataRepositoryTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryTaskExecuting(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDataRepositoryTaskError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryTaskExecuting(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDataRepositoryTaskError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDataRepositoryTaskError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataRepositoryTaskError {
    /// Creates the `CreateDataRepositoryTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDataRepositoryTaskError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryTaskExecuting(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::DataRepositoryTaskExecuting`.
    pub fn is_data_repository_task_executing(&self) -> bool {
        matches!(self, Self::DataRepositoryTaskExecuting(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryTaskError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateDataRepositoryTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryTaskExecuting(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An existing data repository task is currently executing on the file system. Wait until the existing task has completed, then create the new task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataRepositoryTaskExecuting {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DataRepositoryTaskExecuting {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskExecuting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskExecuting")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskExecuting {}
impl aws_http::request_id::RequestId for crate::error::DataRepositoryTaskExecuting {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DataRepositoryTaskExecuting {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DataRepositoryTaskExecuting {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting).
    pub fn builder() -> crate::error::data_repository_task_executing::Builder {
        crate::error::data_repository_task_executing::Builder::default()
    }
}

/// See [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting).
pub mod data_repository_task_executing {

    /// A builder for [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting).
        pub fn build(self) -> crate::error::DataRepositoryTaskExecuting {
            crate::error::DataRepositoryTaskExecuting {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDataRepositoryAssociationErrorKind = CreateDataRepositoryAssociationError;
/// Error type for the `CreateDataRepositoryAssociationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataRepositoryAssociationError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDataRepositoryAssociationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDataRepositoryAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateDataRepositoryAssociationError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDataRepositoryAssociationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDataRepositoryAssociationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataRepositoryAssociationError {
    /// Creates the `CreateDataRepositoryAssociationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDataRepositoryAssociationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateDataRepositoryAssociationError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateDataRepositoryAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateBackupErrorKind = CreateBackupError;
/// Error type for the `CreateBackupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupError {
    /// <p>Another backup is already under way. Wait for completion before initiating additional backups of this file system.</p>
    BackupInProgress(crate::error::BackupInProgress),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// <p>No Amazon FSx volumes were found based upon the supplied parameters.</p>
    VolumeNotFound(crate::error::VolumeNotFound),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateBackupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BackupInProgress(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::VolumeNotFound(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateBackupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BackupInProgress(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::VolumeNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateBackupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateBackupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupError {
    /// Creates the `CreateBackupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateBackupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BackupInProgress(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::VolumeNotFound(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateBackupError::BackupInProgress`.
    pub fn is_backup_in_progress(&self) -> bool {
        matches!(self, Self::BackupInProgress(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
    /// Returns `true` if the error kind is `CreateBackupError::VolumeNotFound`.
    pub fn is_volume_not_found(&self) -> bool {
        matches!(self, Self::VolumeNotFound(_))
    }
}
impl std::error::Error for CreateBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BackupInProgress(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::VolumeNotFound(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyBackupErrorKind = CopyBackupError;
/// Error type for the `CopyBackupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyBackupError {
    /// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
    BackupNotFound(crate::error::BackupNotFound),
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The error returned when a second request is received with the same client request token but different parameters settings. A client request token should always uniquely identify a single request.</p>
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    /// <p>Amazon FSx doesn't support Multi-AZ Windows File Server copy backup in the destination Region, so the copied backup can't be restored.</p>
    IncompatibleRegionForMultiAz(crate::error::IncompatibleRegionForMultiAz),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The Key Management Service (KMS) key of the destination backup is not valid.</p>
    InvalidDestinationKmsKey(crate::error::InvalidDestinationKmsKey),
    /// <p>The Region provided for <code>SourceRegion</code> is not valid or is in a different Amazon Web Services partition.</p>
    InvalidRegion(crate::error::InvalidRegion),
    /// <p>The Key Management Service (KMS) key of the source backup is not valid.</p>
    InvalidSourceKmsKey(crate::error::InvalidSourceKmsKey),
    /// <p>An error indicating that a particular service limit was exceeded. You can increase some service limits by contacting Amazon Web Services Support.</p>
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// <p>The request was rejected because the lifecycle status of the source backup isn't <code>AVAILABLE</code>.</p>
    SourceBackupUnavailable(crate::error::SourceBackupUnavailable),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyBackupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BackupNotFound(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::IncompatibleParameterError(_inner) => _inner.fmt(f),
            Self::IncompatibleRegionForMultiAz(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::InvalidDestinationKmsKey(_inner) => _inner.fmt(f),
            Self::InvalidRegion(_inner) => _inner.fmt(f),
            Self::InvalidSourceKmsKey(_inner) => _inner.fmt(f),
            Self::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            Self::SourceBackupUnavailable(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyBackupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BackupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleParameterError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncompatibleRegionForMultiAz(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDestinationKmsKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRegion(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSourceKmsKey(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ServiceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceBackupUnavailable(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyBackupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyBackupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyBackupError {
    /// Creates the `CopyBackupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyBackupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BackupNotFound(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::IncompatibleParameterError(e) => e.meta(),
            Self::IncompatibleRegionForMultiAz(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::InvalidDestinationKmsKey(e) => e.meta(),
            Self::InvalidRegion(e) => e.meta(),
            Self::InvalidSourceKmsKey(e) => e.meta(),
            Self::ServiceLimitExceeded(e) => e.meta(),
            Self::SourceBackupUnavailable(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyBackupError::BackupNotFound`.
    pub fn is_backup_not_found(&self) -> bool {
        matches!(self, Self::BackupNotFound(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::IncompatibleParameterError`.
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(self, Self::IncompatibleParameterError(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::IncompatibleRegionForMultiAz`.
    pub fn is_incompatible_region_for_multi_az(&self) -> bool {
        matches!(self, Self::IncompatibleRegionForMultiAz(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::InvalidDestinationKmsKey`.
    pub fn is_invalid_destination_kms_key(&self) -> bool {
        matches!(self, Self::InvalidDestinationKmsKey(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::InvalidRegion`.
    pub fn is_invalid_region(&self) -> bool {
        matches!(self, Self::InvalidRegion(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::InvalidSourceKmsKey`.
    pub fn is_invalid_source_kms_key(&self) -> bool {
        matches!(self, Self::InvalidSourceKmsKey(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::ServiceLimitExceeded`.
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(self, Self::ServiceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::SourceBackupUnavailable`.
    pub fn is_source_backup_unavailable(&self) -> bool {
        matches!(self, Self::SourceBackupUnavailable(_))
    }
    /// Returns `true` if the error kind is `CopyBackupError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CopyBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BackupNotFound(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::IncompatibleParameterError(_inner) => Some(_inner),
            Self::IncompatibleRegionForMultiAz(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::InvalidDestinationKmsKey(_inner) => Some(_inner),
            Self::InvalidRegion(_inner) => Some(_inner),
            Self::InvalidSourceKmsKey(_inner) => Some(_inner),
            Self::ServiceLimitExceeded(_inner) => Some(_inner),
            Self::SourceBackupUnavailable(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The request was rejected because the lifecycle status of the source backup isn't <code>AVAILABLE</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceBackupUnavailable {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    #[doc(hidden)]
    pub backup_id: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SourceBackupUnavailable {
    /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
    pub fn backup_id(&self) -> std::option::Option<&str> {
        self.backup_id.as_deref()
    }
}
impl SourceBackupUnavailable {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceBackupUnavailable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceBackupUnavailable")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SourceBackupUnavailable {}
impl aws_http::request_id::RequestId for crate::error::SourceBackupUnavailable {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SourceBackupUnavailable {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl SourceBackupUnavailable {
    /// Creates a new builder-style object to manufacture [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable).
    pub fn builder() -> crate::error::source_backup_unavailable::Builder {
        crate::error::source_backup_unavailable::Builder::default()
    }
}

/// See [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable).
pub mod source_backup_unavailable {

    /// A builder for [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) backup_id: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        /// <p>The ID of the source backup. Specifies the backup that you are copying.</p>
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable).
        pub fn build(self) -> crate::error::SourceBackupUnavailable {
            crate::error::SourceBackupUnavailable {
                message: self.message,
                backup_id: self.backup_id,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The Key Management Service (KMS) key of the source backup is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSourceKmsKey {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSourceKmsKey {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSourceKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSourceKmsKey")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSourceKmsKey {}
impl aws_http::request_id::RequestId for crate::error::InvalidSourceKmsKey {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSourceKmsKey {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSourceKmsKey {
    /// Creates a new builder-style object to manufacture [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey).
    pub fn builder() -> crate::error::invalid_source_kms_key::Builder {
        crate::error::invalid_source_kms_key::Builder::default()
    }
}

/// See [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey).
pub mod invalid_source_kms_key {

    /// A builder for [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey).
        pub fn build(self) -> crate::error::InvalidSourceKmsKey {
            crate::error::InvalidSourceKmsKey {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The Region provided for <code>SourceRegion</code> is not valid or is in a different Amazon Web Services partition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRegion {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRegion {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRegion")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRegion {}
impl aws_http::request_id::RequestId for crate::error::InvalidRegion {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRegion {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRegion {
    /// Creates a new builder-style object to manufacture [`InvalidRegion`](crate::error::InvalidRegion).
    pub fn builder() -> crate::error::invalid_region::Builder {
        crate::error::invalid_region::Builder::default()
    }
}

/// See [`InvalidRegion`](crate::error::InvalidRegion).
pub mod invalid_region {

    /// A builder for [`InvalidRegion`](crate::error::InvalidRegion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRegion`](crate::error::InvalidRegion).
        pub fn build(self) -> crate::error::InvalidRegion {
            crate::error::InvalidRegion {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The Key Management Service (KMS) key of the destination backup is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDestinationKmsKey {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDestinationKmsKey {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDestinationKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDestinationKmsKey")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDestinationKmsKey {}
impl aws_http::request_id::RequestId for crate::error::InvalidDestinationKmsKey {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDestinationKmsKey {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDestinationKmsKey {
    /// Creates a new builder-style object to manufacture [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey).
    pub fn builder() -> crate::error::invalid_destination_kms_key::Builder {
        crate::error::invalid_destination_kms_key::Builder::default()
    }
}

/// See [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey).
pub mod invalid_destination_kms_key {

    /// A builder for [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey).
        pub fn build(self) -> crate::error::InvalidDestinationKmsKey {
            crate::error::InvalidDestinationKmsKey {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>Amazon FSx doesn't support Multi-AZ Windows File Server copy backup in the destination Region, so the copied backup can't be restored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IncompatibleRegionForMultiAz {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IncompatibleRegionForMultiAz {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleRegionForMultiAz {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IncompatibleRegionForMultiAz [IncompatibleRegionForMultiAZ]"
        )?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleRegionForMultiAz {}
impl aws_http::request_id::RequestId for crate::error::IncompatibleRegionForMultiAz {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IncompatibleRegionForMultiAz {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IncompatibleRegionForMultiAz {
    /// Creates a new builder-style object to manufacture [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz).
    pub fn builder() -> crate::error::incompatible_region_for_multi_az::Builder {
        crate::error::incompatible_region_for_multi_az::Builder::default()
    }
}

/// See [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz).
pub mod incompatible_region_for_multi_az {

    /// A builder for [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz).
        pub fn build(self) -> crate::error::IncompatibleRegionForMultiAz {
            crate::error::IncompatibleRegionForMultiAz {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CancelDataRepositoryTaskErrorKind = CancelDataRepositoryTaskError;
/// Error type for the `CancelDataRepositoryTaskError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDataRepositoryTaskError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The data repository task could not be canceled because the task has already ended.</p>
    DataRepositoryTaskEnded(crate::error::DataRepositoryTaskEnded),
    /// <p>The data repository task or tasks you specified could not be found.</p>
    DataRepositoryTaskNotFound(crate::error::DataRepositoryTaskNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>The requested operation is not supported for this resource or API.</p>
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CancelDataRepositoryTaskError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CancelDataRepositoryTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::DataRepositoryTaskEnded(_inner) => _inner.fmt(f),
            Self::DataRepositoryTaskNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::UnsupportedOperation(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CancelDataRepositoryTaskError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryTaskEnded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DataRepositoryTaskNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedOperation(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CancelDataRepositoryTaskError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CancelDataRepositoryTaskError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDataRepositoryTaskError {
    /// Creates the `CancelDataRepositoryTaskError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CancelDataRepositoryTaskError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::DataRepositoryTaskEnded(e) => e.meta(),
            Self::DataRepositoryTaskNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::UnsupportedOperation(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CancelDataRepositoryTaskError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CancelDataRepositoryTaskError::DataRepositoryTaskEnded`.
    pub fn is_data_repository_task_ended(&self) -> bool {
        matches!(self, Self::DataRepositoryTaskEnded(_))
    }
    /// Returns `true` if the error kind is `CancelDataRepositoryTaskError::DataRepositoryTaskNotFound`.
    pub fn is_data_repository_task_not_found(&self) -> bool {
        matches!(self, Self::DataRepositoryTaskNotFound(_))
    }
    /// Returns `true` if the error kind is `CancelDataRepositoryTaskError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CancelDataRepositoryTaskError::UnsupportedOperation`.
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(self, Self::UnsupportedOperation(_))
    }
}
impl std::error::Error for CancelDataRepositoryTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::DataRepositoryTaskEnded(_inner) => Some(_inner),
            Self::DataRepositoryTaskNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::UnsupportedOperation(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The data repository task could not be canceled because the task has already ended.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataRepositoryTaskEnded {
    /// <p>A detailed error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DataRepositoryTaskEnded {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskEnded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskEnded")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskEnded {}
impl aws_http::request_id::RequestId for crate::error::DataRepositoryTaskEnded {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DataRepositoryTaskEnded {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DataRepositoryTaskEnded {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded).
    pub fn builder() -> crate::error::data_repository_task_ended::Builder {
        crate::error::data_repository_task_ended::Builder::default()
    }
}

/// See [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded).
pub mod data_repository_task_ended {

    /// A builder for [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A detailed error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded).
        pub fn build(self) -> crate::error::DataRepositoryTaskEnded {
            crate::error::DataRepositoryTaskEnded {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AssociateFileSystemAliasesErrorKind = AssociateFileSystemAliasesError;
/// Error type for the `AssociateFileSystemAliasesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateFileSystemAliasesError {
    /// <p>A generic error indicating a failure with a client request.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>A generic error indicating a server-side failure.</p>
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociateFileSystemAliasesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AssociateFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociateFileSystemAliasesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociateFileSystemAliasesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AssociateFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateFileSystemAliasesError {
    /// Creates the `AssociateFileSystemAliasesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AssociateFileSystemAliasesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateFileSystemAliasesError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `AssociateFileSystemAliasesError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `AssociateFileSystemAliasesError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl std::error::Error for AssociateFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
