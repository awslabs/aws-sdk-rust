// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateFileSystemAliasesError {
    pub kind: AssociateFileSystemAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateFileSystemAliasesErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateFileSystemAliasesErrorKind::BadRequest(_inner) => _inner.fmt(f),
            AssociateFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            AssociateFileSystemAliasesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            AssociateFileSystemAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        AssociateFileSystemAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateFileSystemAliasesError {
    pub fn new(kind: AssociateFileSystemAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateFileSystemAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateFileSystemAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFileSystemAliasesErrorKind::BadRequest(_)
        )
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFileSystemAliasesErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateFileSystemAliasesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for AssociateFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateFileSystemAliasesErrorKind::BadRequest(_inner) => Some(_inner),
            AssociateFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            AssociateFileSystemAliasesErrorKind::InternalServerError(_inner) => Some(_inner),
            AssociateFileSystemAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelDataRepositoryTaskError {
    pub kind: CancelDataRepositoryTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelDataRepositoryTaskErrorKind {
    BadRequest(crate::error::BadRequest),
    DataRepositoryTaskEnded(crate::error::DataRepositoryTaskEnded),
    DataRepositoryTaskNotFound(crate::error::DataRepositoryTaskNotFound),
    InternalServerError(crate::error::InternalServerError),
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelDataRepositoryTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelDataRepositoryTaskErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskEnded(_inner) => _inner.fmt(f),
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskNotFound(_inner) => _inner.fmt(f),
            CancelDataRepositoryTaskErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CancelDataRepositoryTaskErrorKind::UnsupportedOperation(_inner) => _inner.fmt(f),
            CancelDataRepositoryTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelDataRepositoryTaskError {
    fn code(&self) -> Option<&str> {
        CancelDataRepositoryTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelDataRepositoryTaskError {
    pub fn new(kind: CancelDataRepositoryTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelDataRepositoryTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelDataRepositoryTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, CancelDataRepositoryTaskErrorKind::BadRequest(_))
    }
    pub fn is_data_repository_task_ended(&self) -> bool {
        matches!(
            &self.kind,
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskEnded(_)
        )
    }
    pub fn is_data_repository_task_not_found(&self) -> bool {
        matches!(
            &self.kind,
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelDataRepositoryTaskErrorKind::InternalServerError(_)
        )
    }
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(
            &self.kind,
            CancelDataRepositoryTaskErrorKind::UnsupportedOperation(_)
        )
    }
}
impl std::error::Error for CancelDataRepositoryTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelDataRepositoryTaskErrorKind::BadRequest(_inner) => Some(_inner),
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskEnded(_inner) => Some(_inner),
            CancelDataRepositoryTaskErrorKind::DataRepositoryTaskNotFound(_inner) => Some(_inner),
            CancelDataRepositoryTaskErrorKind::InternalServerError(_inner) => Some(_inner),
            CancelDataRepositoryTaskErrorKind::UnsupportedOperation(_inner) => Some(_inner),
            CancelDataRepositoryTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopyBackupError {
    pub kind: CopyBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyBackupErrorKind {
    BackupNotFound(crate::error::BackupNotFound),
    BadRequest(crate::error::BadRequest),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    IncompatibleRegionForMultiAz(crate::error::IncompatibleRegionForMultiAz),
    InternalServerError(crate::error::InternalServerError),
    InvalidDestinationKmsKey(crate::error::InvalidDestinationKmsKey),
    InvalidRegion(crate::error::InvalidRegion),
    InvalidSourceKmsKey(crate::error::InvalidSourceKmsKey),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    SourceBackupUnavailable(crate::error::SourceBackupUnavailable),
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopyBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopyBackupErrorKind::BackupNotFound(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::IncompatibleRegionForMultiAz(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::InvalidDestinationKmsKey(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::InvalidRegion(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::InvalidSourceKmsKey(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::SourceBackupUnavailable(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::UnsupportedOperation(_inner) => _inner.fmt(f),
            CopyBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopyBackupError {
    fn code(&self) -> Option<&str> {
        CopyBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyBackupError {
    pub fn new(kind: CopyBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopyBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopyBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_backup_not_found(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::BackupNotFound(_))
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::BadRequest(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CopyBackupErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_incompatible_region_for_multi_az(&self) -> bool {
        matches!(
            &self.kind,
            CopyBackupErrorKind::IncompatibleRegionForMultiAz(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::InternalServerError(_))
    }
    pub fn is_invalid_destination_kms_key(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::InvalidDestinationKmsKey(_))
    }
    pub fn is_invalid_region(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::InvalidRegion(_))
    }
    pub fn is_invalid_source_kms_key(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::InvalidSourceKmsKey(_))
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::ServiceLimitExceeded(_))
    }
    pub fn is_source_backup_unavailable(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::SourceBackupUnavailable(_))
    }
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(&self.kind, CopyBackupErrorKind::UnsupportedOperation(_))
    }
}
impl std::error::Error for CopyBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopyBackupErrorKind::BackupNotFound(_inner) => Some(_inner),
            CopyBackupErrorKind::BadRequest(_inner) => Some(_inner),
            CopyBackupErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            CopyBackupErrorKind::IncompatibleRegionForMultiAz(_inner) => Some(_inner),
            CopyBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            CopyBackupErrorKind::InvalidDestinationKmsKey(_inner) => Some(_inner),
            CopyBackupErrorKind::InvalidRegion(_inner) => Some(_inner),
            CopyBackupErrorKind::InvalidSourceKmsKey(_inner) => Some(_inner),
            CopyBackupErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            CopyBackupErrorKind::SourceBackupUnavailable(_inner) => Some(_inner),
            CopyBackupErrorKind::UnsupportedOperation(_inner) => Some(_inner),
            CopyBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBackupError {
    pub kind: CreateBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupErrorKind {
    BackupInProgress(crate::error::BackupInProgress),
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBackupErrorKind::BackupInProgress(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::UnsupportedOperation(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBackupError {
    fn code(&self) -> Option<&str> {
        CreateBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupError {
    pub fn new(kind: CreateBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_backup_in_progress(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::BackupInProgress(_))
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::BadRequest(_))
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::FileSystemNotFound(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateBackupErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::InternalServerError(_))
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::ServiceLimitExceeded(_))
    }
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(&self.kind, CreateBackupErrorKind::UnsupportedOperation(_))
    }
}
impl std::error::Error for CreateBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBackupErrorKind::BackupInProgress(_inner) => Some(_inner),
            CreateBackupErrorKind::BadRequest(_inner) => Some(_inner),
            CreateBackupErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            CreateBackupErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            CreateBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateBackupErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            CreateBackupErrorKind::UnsupportedOperation(_inner) => Some(_inner),
            CreateBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDataRepositoryTaskError {
    pub kind: CreateDataRepositoryTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataRepositoryTaskErrorKind {
    BadRequest(crate::error::BadRequest),
    DataRepositoryTaskExecuting(crate::error::DataRepositoryTaskExecuting),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDataRepositoryTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDataRepositoryTaskErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::DataRepositoryTaskExecuting(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::UnsupportedOperation(_inner) => _inner.fmt(f),
            CreateDataRepositoryTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDataRepositoryTaskError {
    fn code(&self) -> Option<&str> {
        CreateDataRepositoryTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataRepositoryTaskError {
    pub fn new(kind: CreateDataRepositoryTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDataRepositoryTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDataRepositoryTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, CreateDataRepositoryTaskErrorKind::BadRequest(_))
    }
    pub fn is_data_repository_task_executing(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::DataRepositoryTaskExecuting(_)
        )
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::InternalServerError(_)
        )
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::ServiceLimitExceeded(_)
        )
    }
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataRepositoryTaskErrorKind::UnsupportedOperation(_)
        )
    }
}
impl std::error::Error for CreateDataRepositoryTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDataRepositoryTaskErrorKind::BadRequest(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::DataRepositoryTaskExecuting(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::UnsupportedOperation(_inner) => Some(_inner),
            CreateDataRepositoryTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFileSystemError {
    pub kind: CreateFileSystemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFileSystemErrorKind {
    ActiveDirectoryError(crate::error::ActiveDirectoryError),
    BadRequest(crate::error::BadRequest),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    InvalidExportPath(crate::error::InvalidExportPath),
    InvalidImportPath(crate::error::InvalidImportPath),
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    InvalidPerUnitStorageThroughput(crate::error::InvalidPerUnitStorageThroughput),
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFileSystemErrorKind::ActiveDirectoryError(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::InvalidExportPath(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::InvalidImportPath(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::InvalidPerUnitStorageThroughput(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::MissingFileSystemConfiguration(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            CreateFileSystemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFileSystemError {
    fn code(&self) -> Option<&str> {
        CreateFileSystemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFileSystemError {
    pub fn new(kind: CreateFileSystemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFileSystemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFileSystemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_active_directory_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::ActiveDirectoryError(_)
        )
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, CreateFileSystemErrorKind::BadRequest(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_export_path(&self) -> bool {
        matches!(&self.kind, CreateFileSystemErrorKind::InvalidExportPath(_))
    }
    pub fn is_invalid_import_path(&self) -> bool {
        matches!(&self.kind, CreateFileSystemErrorKind::InvalidImportPath(_))
    }
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::InvalidNetworkSettings(_)
        )
    }
    pub fn is_invalid_per_unit_storage_throughput(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::InvalidPerUnitStorageThroughput(_)
        )
    }
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::MissingFileSystemConfiguration(_)
        )
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemErrorKind::ServiceLimitExceeded(_)
        )
    }
}
impl std::error::Error for CreateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFileSystemErrorKind::ActiveDirectoryError(_inner) => Some(_inner),
            CreateFileSystemErrorKind::BadRequest(_inner) => Some(_inner),
            CreateFileSystemErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            CreateFileSystemErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateFileSystemErrorKind::InvalidExportPath(_inner) => Some(_inner),
            CreateFileSystemErrorKind::InvalidImportPath(_inner) => Some(_inner),
            CreateFileSystemErrorKind::InvalidNetworkSettings(_inner) => Some(_inner),
            CreateFileSystemErrorKind::InvalidPerUnitStorageThroughput(_inner) => Some(_inner),
            CreateFileSystemErrorKind::MissingFileSystemConfiguration(_inner) => Some(_inner),
            CreateFileSystemErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            CreateFileSystemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFileSystemFromBackupError {
    pub kind: CreateFileSystemFromBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFileSystemFromBackupErrorKind {
    ActiveDirectoryError(crate::error::ActiveDirectoryError),
    BackupNotFound(crate::error::BackupNotFound),
    BadRequest(crate::error::BadRequest),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    InvalidNetworkSettings(crate::error::InvalidNetworkSettings),
    InvalidPerUnitStorageThroughput(crate::error::InvalidPerUnitStorageThroughput),
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFileSystemFromBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFileSystemFromBackupErrorKind::ActiveDirectoryError(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::BackupNotFound(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::BadRequest(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::IncompatibleParameterError(_inner) => {
                _inner.fmt(f)
            }
            CreateFileSystemFromBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::InvalidNetworkSettings(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::InvalidPerUnitStorageThroughput(_inner) => {
                _inner.fmt(f)
            }
            CreateFileSystemFromBackupErrorKind::MissingFileSystemConfiguration(_inner) => {
                _inner.fmt(f)
            }
            CreateFileSystemFromBackupErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            CreateFileSystemFromBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFileSystemFromBackupError {
    fn code(&self) -> Option<&str> {
        CreateFileSystemFromBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFileSystemFromBackupError {
    pub fn new(kind: CreateFileSystemFromBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFileSystemFromBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFileSystemFromBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_active_directory_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::ActiveDirectoryError(_)
        )
    }
    pub fn is_backup_not_found(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::BackupNotFound(_)
        )
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::BadRequest(_)
        )
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::InternalServerError(_)
        )
    }
    pub fn is_invalid_network_settings(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::InvalidNetworkSettings(_)
        )
    }
    pub fn is_invalid_per_unit_storage_throughput(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::InvalidPerUnitStorageThroughput(_)
        )
    }
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::MissingFileSystemConfiguration(_)
        )
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateFileSystemFromBackupErrorKind::ServiceLimitExceeded(_)
        )
    }
}
impl std::error::Error for CreateFileSystemFromBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFileSystemFromBackupErrorKind::ActiveDirectoryError(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::BackupNotFound(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::BadRequest(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::InvalidNetworkSettings(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::InvalidPerUnitStorageThroughput(_inner) => {
                Some(_inner)
            }
            CreateFileSystemFromBackupErrorKind::MissingFileSystemConfiguration(_inner) => {
                Some(_inner)
            }
            CreateFileSystemFromBackupErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            CreateFileSystemFromBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupError {
    pub kind: DeleteBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupErrorKind {
    BackupBeingCopied(crate::error::BackupBeingCopied),
    BackupInProgress(crate::error::BackupInProgress),
    BackupNotFound(crate::error::BackupNotFound),
    BackupRestoring(crate::error::BackupRestoring),
    BadRequest(crate::error::BadRequest),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupErrorKind::BackupBeingCopied(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::BackupInProgress(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::BackupNotFound(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::BackupRestoring(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupError {
    fn code(&self) -> Option<&str> {
        DeleteBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupError {
    pub fn new(kind: DeleteBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_backup_being_copied(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::BackupBeingCopied(_))
    }
    pub fn is_backup_in_progress(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::BackupInProgress(_))
    }
    pub fn is_backup_not_found(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::BackupNotFound(_))
    }
    pub fn is_backup_restoring(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::BackupRestoring(_))
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::BadRequest(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBackupErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DeleteBackupErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for DeleteBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupErrorKind::BackupBeingCopied(_inner) => Some(_inner),
            DeleteBackupErrorKind::BackupInProgress(_inner) => Some(_inner),
            DeleteBackupErrorKind::BackupNotFound(_inner) => Some(_inner),
            DeleteBackupErrorKind::BackupRestoring(_inner) => Some(_inner),
            DeleteBackupErrorKind::BadRequest(_inner) => Some(_inner),
            DeleteBackupErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            DeleteBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFileSystemError {
    pub kind: DeleteFileSystemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileSystemErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFileSystemErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DeleteFileSystemErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DeleteFileSystemErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            DeleteFileSystemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteFileSystemErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            DeleteFileSystemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFileSystemError {
    fn code(&self) -> Option<&str> {
        DeleteFileSystemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileSystemError {
    pub fn new(kind: DeleteFileSystemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFileSystemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFileSystemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, DeleteFileSystemErrorKind::BadRequest(_))
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(&self.kind, DeleteFileSystemErrorKind::FileSystemNotFound(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileSystemErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileSystemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileSystemErrorKind::ServiceLimitExceeded(_)
        )
    }
}
impl std::error::Error for DeleteFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFileSystemErrorKind::BadRequest(_inner) => Some(_inner),
            DeleteFileSystemErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DeleteFileSystemErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            DeleteFileSystemErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteFileSystemErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            DeleteFileSystemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBackupsError {
    pub kind: DescribeBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBackupsErrorKind {
    BackupNotFound(crate::error::BackupNotFound),
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBackupsErrorKind::BackupNotFound(_inner) => _inner.fmt(f),
            DescribeBackupsErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DescribeBackupsErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DescribeBackupsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBackupsError {
    fn code(&self) -> Option<&str> {
        DescribeBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBackupsError {
    pub fn new(kind: DescribeBackupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_backup_not_found(&self) -> bool {
        matches!(&self.kind, DescribeBackupsErrorKind::BackupNotFound(_))
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, DescribeBackupsErrorKind::BadRequest(_))
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(&self.kind, DescribeBackupsErrorKind::FileSystemNotFound(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, DescribeBackupsErrorKind::InternalServerError(_))
    }
}
impl std::error::Error for DescribeBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBackupsErrorKind::BackupNotFound(_inner) => Some(_inner),
            DescribeBackupsErrorKind::BadRequest(_inner) => Some(_inner),
            DescribeBackupsErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DescribeBackupsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDataRepositoryTasksError {
    pub kind: DescribeDataRepositoryTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDataRepositoryTasksErrorKind {
    BadRequest(crate::error::BadRequest),
    DataRepositoryTaskNotFound(crate::error::DataRepositoryTaskNotFound),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDataRepositoryTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDataRepositoryTasksErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DescribeDataRepositoryTasksErrorKind::DataRepositoryTaskNotFound(_inner) => {
                _inner.fmt(f)
            }
            DescribeDataRepositoryTasksErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DescribeDataRepositoryTasksErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeDataRepositoryTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDataRepositoryTasksError {
    fn code(&self) -> Option<&str> {
        DescribeDataRepositoryTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDataRepositoryTasksError {
    pub fn new(kind: DescribeDataRepositoryTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDataRepositoryTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDataRepositoryTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataRepositoryTasksErrorKind::BadRequest(_)
        )
    }
    pub fn is_data_repository_task_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataRepositoryTasksErrorKind::DataRepositoryTaskNotFound(_)
        )
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataRepositoryTasksErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDataRepositoryTasksErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeDataRepositoryTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDataRepositoryTasksErrorKind::BadRequest(_inner) => Some(_inner),
            DescribeDataRepositoryTasksErrorKind::DataRepositoryTaskNotFound(_inner) => {
                Some(_inner)
            }
            DescribeDataRepositoryTasksErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DescribeDataRepositoryTasksErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeDataRepositoryTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFileSystemAliasesError {
    pub kind: DescribeFileSystemAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileSystemAliasesErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFileSystemAliasesErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DescribeFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DescribeFileSystemAliasesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeFileSystemAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        DescribeFileSystemAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileSystemAliasesError {
    pub fn new(kind: DescribeFileSystemAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFileSystemAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFileSystemAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemAliasesErrorKind::BadRequest(_)
        )
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemAliasesErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemAliasesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFileSystemAliasesErrorKind::BadRequest(_inner) => Some(_inner),
            DescribeFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DescribeFileSystemAliasesErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeFileSystemAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeFileSystemsError {
    pub kind: DescribeFileSystemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeFileSystemsErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeFileSystemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeFileSystemsErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DescribeFileSystemsErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DescribeFileSystemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeFileSystemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeFileSystemsError {
    fn code(&self) -> Option<&str> {
        DescribeFileSystemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeFileSystemsError {
    pub fn new(kind: DescribeFileSystemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeFileSystemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeFileSystemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, DescribeFileSystemsErrorKind::BadRequest(_))
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemsErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeFileSystemsErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DescribeFileSystemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeFileSystemsErrorKind::BadRequest(_inner) => Some(_inner),
            DescribeFileSystemsErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DescribeFileSystemsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeFileSystemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateFileSystemAliasesError {
    pub kind: DisassociateFileSystemAliasesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateFileSystemAliasesErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    InternalServerError(crate::error::InternalServerError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateFileSystemAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateFileSystemAliasesErrorKind::BadRequest(_inner) => _inner.fmt(f),
            DisassociateFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            DisassociateFileSystemAliasesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DisassociateFileSystemAliasesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateFileSystemAliasesError {
    fn code(&self) -> Option<&str> {
        DisassociateFileSystemAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateFileSystemAliasesError {
    pub fn new(kind: DisassociateFileSystemAliasesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateFileSystemAliasesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateFileSystemAliasesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFileSystemAliasesErrorKind::BadRequest(_)
        )
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFileSystemAliasesErrorKind::FileSystemNotFound(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateFileSystemAliasesErrorKind::InternalServerError(_)
        )
    }
}
impl std::error::Error for DisassociateFileSystemAliasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateFileSystemAliasesErrorKind::BadRequest(_inner) => Some(_inner),
            DisassociateFileSystemAliasesErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            DisassociateFileSystemAliasesErrorKind::InternalServerError(_inner) => Some(_inner),
            DisassociateFileSystemAliasesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequest(crate::error::BadRequest),
    InternalServerError(crate::error::InternalServerError),
    NotServiceResourceError(crate::error::NotServiceResourceError),
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequest(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotServiceResourceError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFound(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::BadRequest(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerError(_)
        )
    }
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotServiceResourceError(_)
        )
    }
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceDoesNotSupportTagging(_)
        )
    }
    pub fn is_resource_not_found(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFound(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequest(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotServiceResourceError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFound(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequest(crate::error::BadRequest),
    InternalServerError(crate::error::InternalServerError),
    NotServiceResourceError(crate::error::NotServiceResourceError),
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequest(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotServiceResourceError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFound(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequest(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerError(_))
    }
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotServiceResourceError(_))
    }
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceDoesNotSupportTagging(_)
        )
    }
    pub fn is_resource_not_found(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ResourceNotFound(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequest(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            TagResourceErrorKind::NotServiceResourceError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFound(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequest(crate::error::BadRequest),
    InternalServerError(crate::error::InternalServerError),
    NotServiceResourceError(crate::error::NotServiceResourceError),
    ResourceDoesNotSupportTagging(crate::error::ResourceDoesNotSupportTagging),
    ResourceNotFound(crate::error::ResourceNotFound),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequest(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotServiceResourceError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFound(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequest(_))
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerError(_))
    }
    pub fn is_not_service_resource_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::NotServiceResourceError(_)
        )
    }
    pub fn is_resource_does_not_support_tagging(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceDoesNotSupportTagging(_)
        )
    }
    pub fn is_resource_not_found(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ResourceNotFound(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequest(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::NotServiceResourceError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceDoesNotSupportTagging(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFound(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFileSystemError {
    pub kind: UpdateFileSystemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFileSystemErrorKind {
    BadRequest(crate::error::BadRequest),
    FileSystemNotFound(crate::error::FileSystemNotFound),
    IncompatibleParameterError(crate::error::IncompatibleParameterError),
    InternalServerError(crate::error::InternalServerError),
    MissingFileSystemConfiguration(crate::error::MissingFileSystemConfiguration),
    ServiceLimitExceeded(crate::error::ServiceLimitExceeded),
    UnsupportedOperation(crate::error::UnsupportedOperation),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFileSystemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFileSystemErrorKind::BadRequest(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::FileSystemNotFound(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::IncompatibleParameterError(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::MissingFileSystemConfiguration(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::ServiceLimitExceeded(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::UnsupportedOperation(_inner) => _inner.fmt(f),
            UpdateFileSystemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFileSystemError {
    fn code(&self) -> Option<&str> {
        UpdateFileSystemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFileSystemError {
    pub fn new(kind: UpdateFileSystemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFileSystemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFileSystemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request(&self) -> bool {
        matches!(&self.kind, UpdateFileSystemErrorKind::BadRequest(_))
    }
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(&self.kind, UpdateFileSystemErrorKind::FileSystemNotFound(_))
    }
    pub fn is_incompatible_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemErrorKind::IncompatibleParameterError(_)
        )
    }
    pub fn is_internal_server_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemErrorKind::InternalServerError(_)
        )
    }
    pub fn is_missing_file_system_configuration(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemErrorKind::MissingFileSystemConfiguration(_)
        )
    }
    pub fn is_service_limit_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemErrorKind::ServiceLimitExceeded(_)
        )
    }
    pub fn is_unsupported_operation(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFileSystemErrorKind::UnsupportedOperation(_)
        )
    }
}
impl std::error::Error for UpdateFileSystemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFileSystemErrorKind::BadRequest(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::FileSystemNotFound(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::IncompatibleParameterError(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::MissingFileSystemConfiguration(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::ServiceLimitExceeded(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::UnsupportedOperation(_inner) => Some(_inner),
            UpdateFileSystemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The requested operation is not supported for this resource or API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperation {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperation");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperation {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperation")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperation {}
/// See [`UnsupportedOperation`](crate::error::UnsupportedOperation)
pub mod unsupported_operation {
    /// A builder for [`UnsupportedOperation`](crate::error::UnsupportedOperation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperation`](crate::error::UnsupportedOperation)
        pub fn build(self) -> crate::error::UnsupportedOperation {
            crate::error::UnsupportedOperation {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperation {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperation`](crate::error::UnsupportedOperation)
    pub fn builder() -> crate::error::unsupported_operation::Builder {
        crate::error::unsupported_operation::Builder::default()
    }
}

/// <p>An error indicating that a particular service limit was exceeded. You can increase
/// some service limits by contacting AWS Support.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceLimitExceeded {
    /// <p>Enumeration of the service limit that was exceeded. </p>
    pub limit: std::option::Option<crate::model::ServiceLimit>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceLimitExceeded");
        formatter.field("limit", &self.limit);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceLimitExceeded")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceLimitExceeded {}
/// See [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded)
pub mod service_limit_exceeded {
    /// A builder for [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) limit: std::option::Option<crate::model::ServiceLimit>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Enumeration of the service limit that was exceeded. </p>
        pub fn limit(mut self, input: crate::model::ServiceLimit) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<crate::model::ServiceLimit>) -> Self {
            self.limit = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded)
        pub fn build(self) -> crate::error::ServiceLimitExceeded {
            crate::error::ServiceLimitExceeded {
                limit: self.limit,
                message: self.message,
            }
        }
    }
}
impl ServiceLimitExceeded {
    /// Creates a new builder-style object to manufacture [`ServiceLimitExceeded`](crate::error::ServiceLimitExceeded)
    pub fn builder() -> crate::error::service_limit_exceeded::Builder {
        crate::error::service_limit_exceeded::Builder::default()
    }
}

/// <p>A file system configuration is required for this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MissingFileSystemConfiguration {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MissingFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MissingFileSystemConfiguration");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MissingFileSystemConfiguration {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MissingFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MissingFileSystemConfiguration")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for MissingFileSystemConfiguration {}
/// See [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration)
pub mod missing_file_system_configuration {
    /// A builder for [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration)
        pub fn build(self) -> crate::error::MissingFileSystemConfiguration {
            crate::error::MissingFileSystemConfiguration {
                message: self.message,
            }
        }
    }
}
impl MissingFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`MissingFileSystemConfiguration`](crate::error::MissingFileSystemConfiguration)
    pub fn builder() -> crate::error::missing_file_system_configuration::Builder {
        crate::error::missing_file_system_configuration::Builder::default()
    }
}

/// <p>A generic error indicating a server-side failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>The error returned when a second request is received with the same client request
/// token but different parameters settings. A client request token should always uniquely
/// identify a single request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncompatibleParameterError {
    /// <p>A parameter that is incompatible with the earlier request.</p>
    pub parameter: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncompatibleParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncompatibleParameterError");
        formatter.field("parameter", &self.parameter);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncompatibleParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncompatibleParameterError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleParameterError {}
/// See [`IncompatibleParameterError`](crate::error::IncompatibleParameterError)
pub mod incompatible_parameter_error {
    /// A builder for [`IncompatibleParameterError`](crate::error::IncompatibleParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A parameter that is incompatible with the earlier request.</p>
        pub fn parameter(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter = Some(input.into());
            self
        }
        pub fn set_parameter(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameter = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleParameterError`](crate::error::IncompatibleParameterError)
        pub fn build(self) -> crate::error::IncompatibleParameterError {
            crate::error::IncompatibleParameterError {
                parameter: self.parameter,
                message: self.message,
            }
        }
    }
}
impl IncompatibleParameterError {
    /// Creates a new builder-style object to manufacture [`IncompatibleParameterError`](crate::error::IncompatibleParameterError)
    pub fn builder() -> crate::error::incompatible_parameter_error::Builder {
        crate::error::incompatible_parameter_error::Builder::default()
    }
}

/// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemNotFound {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileSystemNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileSystemNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileSystemNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileSystemNotFound")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileSystemNotFound {}
/// See [`FileSystemNotFound`](crate::error::FileSystemNotFound)
pub mod file_system_not_found {
    /// A builder for [`FileSystemNotFound`](crate::error::FileSystemNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemNotFound`](crate::error::FileSystemNotFound)
        pub fn build(self) -> crate::error::FileSystemNotFound {
            crate::error::FileSystemNotFound {
                message: self.message,
            }
        }
    }
}
impl FileSystemNotFound {
    /// Creates a new builder-style object to manufacture [`FileSystemNotFound`](crate::error::FileSystemNotFound)
    pub fn builder() -> crate::error::file_system_not_found::Builder {
        crate::error::file_system_not_found::Builder::default()
    }
}

/// <p>A generic error indicating a failure with a client request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequest {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequest");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequest {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequest")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequest {}
/// See [`BadRequest`](crate::error::BadRequest)
pub mod bad_request {
    /// A builder for [`BadRequest`](crate::error::BadRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequest`](crate::error::BadRequest)
        pub fn build(self) -> crate::error::BadRequest {
            crate::error::BadRequest {
                message: self.message,
            }
        }
    }
}
impl BadRequest {
    /// Creates a new builder-style object to manufacture [`BadRequest`](crate::error::BadRequest)
    pub fn builder() -> crate::error::bad_request::Builder {
        crate::error::bad_request::Builder::default()
    }
}

/// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFound {
    /// <p>The resource ARN of the resource that can't be found.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFound");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFound")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFound {}
/// See [`ResourceNotFound`](crate::error::ResourceNotFound)
pub mod resource_not_found {
    /// A builder for [`ResourceNotFound`](crate::error::ResourceNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource ARN of the resource that can't be found.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFound`](crate::error::ResourceNotFound)
        pub fn build(self) -> crate::error::ResourceNotFound {
            crate::error::ResourceNotFound {
                resource_arn: self.resource_arn,
                message: self.message,
            }
        }
    }
}
impl ResourceNotFound {
    /// Creates a new builder-style object to manufacture [`ResourceNotFound`](crate::error::ResourceNotFound)
    pub fn builder() -> crate::error::resource_not_found::Builder {
        crate::error::resource_not_found::Builder::default()
    }
}

/// <p>The resource specified does not support tagging. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDoesNotSupportTagging {
    /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support
    /// tagging.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceDoesNotSupportTagging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDoesNotSupportTagging");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceDoesNotSupportTagging {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceDoesNotSupportTagging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceDoesNotSupportTagging")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceDoesNotSupportTagging {}
/// See [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging)
pub mod resource_does_not_support_tagging {
    /// A builder for [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support
        /// tagging.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging)
        pub fn build(self) -> crate::error::ResourceDoesNotSupportTagging {
            crate::error::ResourceDoesNotSupportTagging {
                resource_arn: self.resource_arn,
                message: self.message,
            }
        }
    }
}
impl ResourceDoesNotSupportTagging {
    /// Creates a new builder-style object to manufacture [`ResourceDoesNotSupportTagging`](crate::error::ResourceDoesNotSupportTagging)
    pub fn builder() -> crate::error::resource_does_not_support_tagging::Builder {
        crate::error::resource_does_not_support_tagging::Builder::default()
    }
}

/// <p>The resource specified for the tagging operation is not a resource type owned by
/// Amazon FSx. Use the API of the relevant service to perform the operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotServiceResourceError {
    /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotServiceResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotServiceResourceError");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotServiceResourceError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotServiceResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotServiceResourceError")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotServiceResourceError {}
/// See [`NotServiceResourceError`](crate::error::NotServiceResourceError)
pub mod not_service_resource_error {
    /// A builder for [`NotServiceResourceError`](crate::error::NotServiceResourceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotServiceResourceError`](crate::error::NotServiceResourceError)
        pub fn build(self) -> crate::error::NotServiceResourceError {
            crate::error::NotServiceResourceError {
                resource_arn: self.resource_arn,
                message: self.message,
            }
        }
    }
}
impl NotServiceResourceError {
    /// Creates a new builder-style object to manufacture [`NotServiceResourceError`](crate::error::NotServiceResourceError)
    pub fn builder() -> crate::error::not_service_resource_error::Builder {
        crate::error::not_service_resource_error::Builder::default()
    }
}

/// <p>The data repository task or tasks you specified could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskNotFound {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataRepositoryTaskNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DataRepositoryTaskNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskNotFound")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskNotFound {}
/// See [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound)
pub mod data_repository_task_not_found {
    /// A builder for [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound)
        pub fn build(self) -> crate::error::DataRepositoryTaskNotFound {
            crate::error::DataRepositoryTaskNotFound {
                message: self.message,
            }
        }
    }
}
impl DataRepositoryTaskNotFound {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskNotFound`](crate::error::DataRepositoryTaskNotFound)
    pub fn builder() -> crate::error::data_repository_task_not_found::Builder {
        crate::error::data_repository_task_not_found::Builder::default()
    }
}

/// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupNotFound {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupNotFound");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupNotFound {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupNotFound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupNotFound")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupNotFound {}
/// See [`BackupNotFound`](crate::error::BackupNotFound)
pub mod backup_not_found {
    /// A builder for [`BackupNotFound`](crate::error::BackupNotFound)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupNotFound`](crate::error::BackupNotFound)
        pub fn build(self) -> crate::error::BackupNotFound {
            crate::error::BackupNotFound {
                message: self.message,
            }
        }
    }
}
impl BackupNotFound {
    /// Creates a new builder-style object to manufacture [`BackupNotFound`](crate::error::BackupNotFound)
    pub fn builder() -> crate::error::backup_not_found::Builder {
        crate::error::backup_not_found::Builder::default()
    }
}

/// <p>You can't delete a backup while it's being used to restore a file
/// system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupRestoring {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of a file system being restored from the backup.</p>
    pub file_system_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupRestoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupRestoring");
        formatter.field("message", &self.message);
        formatter.field("file_system_id", &self.file_system_id);
        formatter.finish()
    }
}
impl BackupRestoring {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupRestoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupRestoring")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupRestoring {}
/// See [`BackupRestoring`](crate::error::BackupRestoring)
pub mod backup_restoring {
    /// A builder for [`BackupRestoring`](crate::error::BackupRestoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of a file system being restored from the backup.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupRestoring`](crate::error::BackupRestoring)
        pub fn build(self) -> crate::error::BackupRestoring {
            crate::error::BackupRestoring {
                message: self.message,
                file_system_id: self.file_system_id,
            }
        }
    }
}
impl BackupRestoring {
    /// Creates a new builder-style object to manufacture [`BackupRestoring`](crate::error::BackupRestoring)
    pub fn builder() -> crate::error::backup_restoring::Builder {
        crate::error::backup_restoring::Builder::default()
    }
}

/// <p>Another backup is already under way. Wait for completion before initiating
/// additional backups of this file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupInProgress {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupInProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupInProgress");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupInProgress {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupInProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupInProgress")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupInProgress {}
/// See [`BackupInProgress`](crate::error::BackupInProgress)
pub mod backup_in_progress {
    /// A builder for [`BackupInProgress`](crate::error::BackupInProgress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupInProgress`](crate::error::BackupInProgress)
        pub fn build(self) -> crate::error::BackupInProgress {
            crate::error::BackupInProgress {
                message: self.message,
            }
        }
    }
}
impl BackupInProgress {
    /// Creates a new builder-style object to manufacture [`BackupInProgress`](crate::error::BackupInProgress)
    pub fn builder() -> crate::error::backup_in_progress::Builder {
        crate::error::backup_in_progress::Builder::default()
    }
}

/// <p>You can't delete a backup while it's being copied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupBeingCopied {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    pub backup_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupBeingCopied {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupBeingCopied");
        formatter.field("message", &self.message);
        formatter.field("backup_id", &self.backup_id);
        formatter.finish()
    }
}
impl BackupBeingCopied {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupBeingCopied {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupBeingCopied")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupBeingCopied {}
/// See [`BackupBeingCopied`](crate::error::BackupBeingCopied)
pub mod backup_being_copied {
    /// A builder for [`BackupBeingCopied`](crate::error::BackupBeingCopied)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) backup_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupBeingCopied`](crate::error::BackupBeingCopied)
        pub fn build(self) -> crate::error::BackupBeingCopied {
            crate::error::BackupBeingCopied {
                message: self.message,
                backup_id: self.backup_id,
            }
        }
    }
}
impl BackupBeingCopied {
    /// Creates a new builder-style object to manufacture [`BackupBeingCopied`](crate::error::BackupBeingCopied)
    pub fn builder() -> crate::error::backup_being_copied::Builder {
        crate::error::backup_being_copied::Builder::default()
    }
}

/// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPerUnitStorageThroughput {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPerUnitStorageThroughput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPerUnitStorageThroughput");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPerUnitStorageThroughput {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPerUnitStorageThroughput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPerUnitStorageThroughput")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPerUnitStorageThroughput {}
/// See [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput)
pub mod invalid_per_unit_storage_throughput {
    /// A builder for [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput)
        pub fn build(self) -> crate::error::InvalidPerUnitStorageThroughput {
            crate::error::InvalidPerUnitStorageThroughput {
                message: self.message,
            }
        }
    }
}
impl InvalidPerUnitStorageThroughput {
    /// Creates a new builder-style object to manufacture [`InvalidPerUnitStorageThroughput`](crate::error::InvalidPerUnitStorageThroughput)
    pub fn builder() -> crate::error::invalid_per_unit_storage_throughput::Builder {
        crate::error::invalid_per_unit_storage_throughput::Builder::default()
    }
}

/// <p>One or more network settings specified in the request are invalid.
/// <code>InvalidVpcId</code> means that the ID passed for the virtual private cloud
/// (VPC) is invalid. <code>InvalidSubnetIds</code> returns the list of IDs for subnets that
/// are either invalid or not part of the VPC specified.
/// <code>InvalidSecurityGroupIds</code> returns the list of IDs for security groups
/// that are either invalid or not part of the VPC specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNetworkSettings {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID for a subnet. A <i>subnet</i> is a range of IP addresses in
    /// your virtual private cloud (VPC). For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html">VPC and Subnets</a> in the
    /// <i>Amazon VPC User Guide.</i>
    /// </p>
    pub invalid_subnet_id: std::option::Option<std::string::String>,
    /// <p>The ID of your Amazon EC2 security group. This ID is used to control network access
    /// to the endpoint that Amazon FSx creates on your behalf in each subnet. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Amazon EC2 Security
    /// Groups for Linux Instances</a> in the <i>Amazon EC2 User
    /// Guide</i>.</p>
    pub invalid_security_group_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNetworkSettings");
        formatter.field("message", &self.message);
        formatter.field("invalid_subnet_id", &self.invalid_subnet_id);
        formatter.field("invalid_security_group_id", &self.invalid_security_group_id);
        formatter.finish()
    }
}
impl InvalidNetworkSettings {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNetworkSettings")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNetworkSettings {}
/// See [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings)
pub mod invalid_network_settings {
    /// A builder for [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) invalid_subnet_id: std::option::Option<std::string::String>,
        pub(crate) invalid_security_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID for a subnet. A <i>subnet</i> is a range of IP addresses in
        /// your virtual private cloud (VPC). For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html">VPC and Subnets</a> in the
        /// <i>Amazon VPC User Guide.</i>
        /// </p>
        pub fn invalid_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_subnet_id = Some(input.into());
            self
        }
        pub fn set_invalid_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_subnet_id = input;
            self
        }
        /// <p>The ID of your Amazon EC2 security group. This ID is used to control network access
        /// to the endpoint that Amazon FSx creates on your behalf in each subnet. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Amazon EC2 Security
        /// Groups for Linux Instances</a> in the <i>Amazon EC2 User
        /// Guide</i>.</p>
        pub fn invalid_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.invalid_security_group_id = Some(input.into());
            self
        }
        pub fn set_invalid_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invalid_security_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings)
        pub fn build(self) -> crate::error::InvalidNetworkSettings {
            crate::error::InvalidNetworkSettings {
                message: self.message,
                invalid_subnet_id: self.invalid_subnet_id,
                invalid_security_group_id: self.invalid_security_group_id,
            }
        }
    }
}
impl InvalidNetworkSettings {
    /// Creates a new builder-style object to manufacture [`InvalidNetworkSettings`](crate::error::InvalidNetworkSettings)
    pub fn builder() -> crate::error::invalid_network_settings::Builder {
        crate::error::invalid_network_settings::Builder::default()
    }
}

/// <p>An Active Directory error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryError {
    /// <p>The directory ID of the directory that an error pertains to.</p>
    pub active_directory_id: std::option::Option<std::string::String>,
    /// <p>The type of Active Directory error.</p>
    pub r#type: std::option::Option<crate::model::ActiveDirectoryErrorType>,
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActiveDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryError");
        formatter.field("active_directory_id", &self.active_directory_id);
        formatter.field("r#type", &self.r#type);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ActiveDirectoryError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ActiveDirectoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ActiveDirectoryError")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for ActiveDirectoryError {}
/// See [`ActiveDirectoryError`](crate::error::ActiveDirectoryError)
pub mod active_directory_error {
    /// A builder for [`ActiveDirectoryError`](crate::error::ActiveDirectoryError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ActiveDirectoryErrorType>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The directory ID of the directory that an error pertains to.</p>
        pub fn active_directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_id = Some(input.into());
            self
        }
        pub fn set_active_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_id = input;
            self
        }
        /// <p>The type of Active Directory error.</p>
        pub fn r#type(mut self, input: crate::model::ActiveDirectoryErrorType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ActiveDirectoryErrorType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryError`](crate::error::ActiveDirectoryError)
        pub fn build(self) -> crate::error::ActiveDirectoryError {
            crate::error::ActiveDirectoryError {
                active_directory_id: self.active_directory_id,
                r#type: self.r#type,
                message: self.message,
            }
        }
    }
}
impl ActiveDirectoryError {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryError`](crate::error::ActiveDirectoryError)
    pub fn builder() -> crate::error::active_directory_error::Builder {
        crate::error::active_directory_error::Builder::default()
    }
}

/// <p>The path provided for data repository import isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidImportPath {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidImportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImportPath");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidImportPath {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidImportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImportPath")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidImportPath {}
/// See [`InvalidImportPath`](crate::error::InvalidImportPath)
pub mod invalid_import_path {
    /// A builder for [`InvalidImportPath`](crate::error::InvalidImportPath)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidImportPath`](crate::error::InvalidImportPath)
        pub fn build(self) -> crate::error::InvalidImportPath {
            crate::error::InvalidImportPath {
                message: self.message,
            }
        }
    }
}
impl InvalidImportPath {
    /// Creates a new builder-style object to manufacture [`InvalidImportPath`](crate::error::InvalidImportPath)
    pub fn builder() -> crate::error::invalid_import_path::Builder {
        crate::error::invalid_import_path::Builder::default()
    }
}

/// <p>The path provided for data repository export isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportPath {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportPath");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportPath {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportPath")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportPath {}
/// See [`InvalidExportPath`](crate::error::InvalidExportPath)
pub mod invalid_export_path {
    /// A builder for [`InvalidExportPath`](crate::error::InvalidExportPath)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportPath`](crate::error::InvalidExportPath)
        pub fn build(self) -> crate::error::InvalidExportPath {
            crate::error::InvalidExportPath {
                message: self.message,
            }
        }
    }
}
impl InvalidExportPath {
    /// Creates a new builder-style object to manufacture [`InvalidExportPath`](crate::error::InvalidExportPath)
    pub fn builder() -> crate::error::invalid_export_path::Builder {
        crate::error::invalid_export_path::Builder::default()
    }
}

/// <p>An existing data repository task is currently executing on the file system.  
/// Wait until the existing task has completed, then create the new task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskExecuting {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataRepositoryTaskExecuting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskExecuting");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DataRepositoryTaskExecuting {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskExecuting {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskExecuting")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskExecuting {}
/// See [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting)
pub mod data_repository_task_executing {
    /// A builder for [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting)
        pub fn build(self) -> crate::error::DataRepositoryTaskExecuting {
            crate::error::DataRepositoryTaskExecuting {
                message: self.message,
            }
        }
    }
}
impl DataRepositoryTaskExecuting {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskExecuting`](crate::error::DataRepositoryTaskExecuting)
    pub fn builder() -> crate::error::data_repository_task_executing::Builder {
        crate::error::data_repository_task_executing::Builder::default()
    }
}

/// <p>The request was rejected because the lifecycle status of the
/// source backup is not <code>AVAILABLE</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceBackupUnavailable {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    pub backup_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceBackupUnavailable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceBackupUnavailable");
        formatter.field("message", &self.message);
        formatter.field("backup_id", &self.backup_id);
        formatter.finish()
    }
}
impl SourceBackupUnavailable {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceBackupUnavailable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceBackupUnavailable")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceBackupUnavailable {}
/// See [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable)
pub mod source_backup_unavailable {
    /// A builder for [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) backup_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable)
        pub fn build(self) -> crate::error::SourceBackupUnavailable {
            crate::error::SourceBackupUnavailable {
                message: self.message,
                backup_id: self.backup_id,
            }
        }
    }
}
impl SourceBackupUnavailable {
    /// Creates a new builder-style object to manufacture [`SourceBackupUnavailable`](crate::error::SourceBackupUnavailable)
    pub fn builder() -> crate::error::source_backup_unavailable::Builder {
        crate::error::source_backup_unavailable::Builder::default()
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the source backup
/// is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSourceKmsKey {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSourceKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSourceKmsKey");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSourceKmsKey {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSourceKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSourceKmsKey")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSourceKmsKey {}
/// See [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey)
pub mod invalid_source_kms_key {
    /// A builder for [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey)
        pub fn build(self) -> crate::error::InvalidSourceKmsKey {
            crate::error::InvalidSourceKmsKey {
                message: self.message,
            }
        }
    }
}
impl InvalidSourceKmsKey {
    /// Creates a new builder-style object to manufacture [`InvalidSourceKmsKey`](crate::error::InvalidSourceKmsKey)
    pub fn builder() -> crate::error::invalid_source_kms_key::Builder {
        crate::error::invalid_source_kms_key::Builder::default()
    }
}

/// <p>The Region provided for <code>Source Region</code> is invalid or
/// is in a different AWS partition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRegion {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRegion");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRegion {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRegion")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRegion {}
/// See [`InvalidRegion`](crate::error::InvalidRegion)
pub mod invalid_region {
    /// A builder for [`InvalidRegion`](crate::error::InvalidRegion)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRegion`](crate::error::InvalidRegion)
        pub fn build(self) -> crate::error::InvalidRegion {
            crate::error::InvalidRegion {
                message: self.message,
            }
        }
    }
}
impl InvalidRegion {
    /// Creates a new builder-style object to manufacture [`InvalidRegion`](crate::error::InvalidRegion)
    pub fn builder() -> crate::error::invalid_region::Builder {
        crate::error::invalid_region::Builder::default()
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the destination
/// backup is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDestinationKmsKey {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDestinationKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDestinationKmsKey");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDestinationKmsKey {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDestinationKmsKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDestinationKmsKey")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDestinationKmsKey {}
/// See [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey)
pub mod invalid_destination_kms_key {
    /// A builder for [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey)
        pub fn build(self) -> crate::error::InvalidDestinationKmsKey {
            crate::error::InvalidDestinationKmsKey {
                message: self.message,
            }
        }
    }
}
impl InvalidDestinationKmsKey {
    /// Creates a new builder-style object to manufacture [`InvalidDestinationKmsKey`](crate::error::InvalidDestinationKmsKey)
    pub fn builder() -> crate::error::invalid_destination_kms_key::Builder {
        crate::error::invalid_destination_kms_key::Builder::default()
    }
}

/// <p>Amazon FSx doesn't support Multi-AZ Windows File Server
/// copy backup in the destination Region, so the copied backup
/// can't be restored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IncompatibleRegionForMultiAz {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IncompatibleRegionForMultiAz {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IncompatibleRegionForMultiAz");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncompatibleRegionForMultiAz {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IncompatibleRegionForMultiAz {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IncompatibleRegionForMultiAz [IncompatibleRegionForMultiAZ]"
        )?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for IncompatibleRegionForMultiAz {}
/// See [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz)
pub mod incompatible_region_for_multi_az {
    /// A builder for [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz)
        pub fn build(self) -> crate::error::IncompatibleRegionForMultiAz {
            crate::error::IncompatibleRegionForMultiAz {
                message: self.message,
            }
        }
    }
}
impl IncompatibleRegionForMultiAz {
    /// Creates a new builder-style object to manufacture [`IncompatibleRegionForMultiAz`](crate::error::IncompatibleRegionForMultiAz)
    pub fn builder() -> crate::error::incompatible_region_for_multi_az::Builder {
        crate::error::incompatible_region_for_multi_az::Builder::default()
    }
}

/// <p>The data repository task could not be canceled because the task has already ended.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskEnded {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataRepositoryTaskEnded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskEnded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DataRepositoryTaskEnded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataRepositoryTaskEnded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataRepositoryTaskEnded")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for DataRepositoryTaskEnded {}
/// See [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded)
pub mod data_repository_task_ended {
    /// A builder for [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded)
        pub fn build(self) -> crate::error::DataRepositoryTaskEnded {
            crate::error::DataRepositoryTaskEnded {
                message: self.message,
            }
        }
    }
}
impl DataRepositoryTaskEnded {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskEnded`](crate::error::DataRepositoryTaskEnded)
    pub fn builder() -> crate::error::data_repository_task_ended::Builder {
        crate::error::data_repository_task_ended::Builder::default()
    }
}
