// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The types of limits on your service utilization. Limits include file system count,
/// total throughput capacity, total storage, and total user-initiated backups. These limits
/// apply for a specific account in a specific AWS Region. You can increase some of them by
/// contacting AWS Support. </p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceLimit {
    FileSystemCount,
    TotalInProgressCopyBackups,
    TotalStorage,
    TotalThroughputCapacity,
    TotalUserInitiatedBackups,
    TotalUserTags,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ServiceLimit {
    fn from(s: &str) -> Self {
        match s {
            "FILE_SYSTEM_COUNT" => ServiceLimit::FileSystemCount,
            "TOTAL_IN_PROGRESS_COPY_BACKUPS" => ServiceLimit::TotalInProgressCopyBackups,
            "TOTAL_STORAGE" => ServiceLimit::TotalStorage,
            "TOTAL_THROUGHPUT_CAPACITY" => ServiceLimit::TotalThroughputCapacity,
            "TOTAL_USER_INITIATED_BACKUPS" => ServiceLimit::TotalUserInitiatedBackups,
            "TOTAL_USER_TAGS" => ServiceLimit::TotalUserTags,
            other => ServiceLimit::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ServiceLimit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceLimit::from(s))
    }
}
impl ServiceLimit {
    pub fn as_str(&self) -> &str {
        match self {
            ServiceLimit::FileSystemCount => "FILE_SYSTEM_COUNT",
            ServiceLimit::TotalInProgressCopyBackups => "TOTAL_IN_PROGRESS_COPY_BACKUPS",
            ServiceLimit::TotalStorage => "TOTAL_STORAGE",
            ServiceLimit::TotalThroughputCapacity => "TOTAL_THROUGHPUT_CAPACITY",
            ServiceLimit::TotalUserInitiatedBackups => "TOTAL_USER_INITIATED_BACKUPS",
            ServiceLimit::TotalUserTags => "TOTAL_USER_TAGS",
            ServiceLimit::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "FILE_SYSTEM_COUNT",
            "TOTAL_IN_PROGRESS_COPY_BACKUPS",
            "TOTAL_STORAGE",
            "TOTAL_THROUGHPUT_CAPACITY",
            "TOTAL_USER_INITIATED_BACKUPS",
            "TOTAL_USER_TAGS",
        ]
    }
}
impl AsRef<str> for ServiceLimit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A description of a specific Amazon FSx file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystem {
    /// <p>The AWS account that created the file system. If the file system was created by an AWS
    /// Identity and Access Management (IAM) user, the AWS account to which the IAM user belongs
    /// is the owner.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z),
    /// also known as Unix time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The system-generated, unique 17-digit ID of the file system.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The type of Amazon FSx file system, either <code>LUSTRE</code> or <code>WINDOWS</code>.</p>
    pub file_system_type: std::option::Option<crate::model::FileSystemType>,
    /// <p>The lifecycle status of the file system, following are the possible values and what they mean:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AVAILABLE</code> - The file system is in a healthy state, and is reachable and available for use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - Amazon FSx is creating the new file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - Amazon FSx is deleting an existing file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - An existing file system has experienced an unrecoverable failure.
    /// When creating a new file system, Amazon FSx was unable to create the file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MISCONFIGURED</code> indicates that the file system is in a failed but recoverable state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> indicates that the file system is undergoing a customer initiated update.</p>
    /// </li>
    /// </ul>
    pub lifecycle: std::option::Option<crate::model::FileSystemLifecycle>,
    /// <p>A structure providing details of any failures that occur when creating the file system
    /// has failed.</p>
    pub failure_details: std::option::Option<crate::model::FileSystemFailureDetails>,
    /// <p>The storage capacity of the file system in gibibytes (GiB).</p>
    pub storage_capacity: std::option::Option<i32>,
    /// <p>The storage type of the file system.
    /// Valid values are <code>SSD</code> and <code>HDD</code>.
    /// If set to <code>SSD</code>, the file system uses solid state drive storage.
    /// If set to <code>HDD</code>, the file system uses hard disk drive storage.
    /// </p>
    pub storage_type: std::option::Option<crate::model::StorageType>,
    /// <p>The ID of the primary VPC for the file system.</p>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>Specifies the IDs of the subnets that the file system is accessible from. For Windows <code>MULTI_AZ_1</code>
    /// file system deployment type, there are two subnet IDs, one for the preferred file server
    /// and one for the standby file server. The preferred file server subnet identified in the  
    /// <code>PreferredSubnetID</code> property. All other file systems have only one subnet ID.</p>
    /// <p>For Lustre file systems, and Single-AZ Windows file systems, this is the ID of
    /// the subnet that contains the endpoint for the file system. For <code>MULTI_AZ_1</code> Windows file systems,
    /// the endpoint for the file system is available in the <code>PreferredSubnetID</code>.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IDs of the elastic network interface from which a specific file system is
    /// accessible. The elastic network interface is automatically created in the same VPC that
    /// the Amazon FSx file system was created in. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html">Elastic Network
    /// Interfaces</a> in the <i>Amazon EC2 User Guide.</i>
    /// </p>
    /// <p>For an Amazon FSx for Windows File Server file system, you can have one network
    /// interface ID. For an Amazon FSx for Lustre file system, you can have more than
    /// one.</p>
    pub network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The DNS name for the file system.</p>
    pub dns_name: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    /// for Amazon FSx for Windows File Server file systems and persistent Amazon FSx for Lustre file
    /// systems at rest. In either case, if not specified, the Amazon FSx managed key
    /// is used. The scratch Amazon FSx for Lustre file systems are always encrypted at rest using
    /// Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    /// in the <i>AWS Key Management Service API Reference</i>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the file system resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags to associate with the file system. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html">Tagging Your
    /// Amazon EC2 Resources</a> in the <i>Amazon EC2 User
    /// Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The configuration for this Microsoft Windows file system.</p>
    pub windows_configuration: std::option::Option<crate::model::WindowsFileSystemConfiguration>,
    /// <p>The configuration for the Amazon FSx for Lustre file system.</p>
    pub lustre_configuration: std::option::Option<crate::model::LustreFileSystemConfiguration>,
    /// <p>A list of administrative actions for the file system that are in process or waiting to be processed.
    /// Administrative actions describe changes to the Windows file system that you have initiated using the <code>UpdateFileSystem</code> action.
    /// </p>
    pub administrative_actions:
        std::option::Option<std::vec::Vec<crate::model::AdministrativeAction>>,
}
impl std::fmt::Debug for FileSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystem");
        formatter.field("owner_id", &self.owner_id);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("file_system_type", &self.file_system_type);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("storage_capacity", &self.storage_capacity);
        formatter.field("storage_type", &self.storage_type);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("network_interface_ids", &self.network_interface_ids);
        formatter.field("dns_name", &self.dns_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.field("windows_configuration", &self.windows_configuration);
        formatter.field("lustre_configuration", &self.lustre_configuration);
        formatter.field("administrative_actions", &self.administrative_actions);
        formatter.finish()
    }
}
/// See [`FileSystem`](crate::model::FileSystem)
pub mod file_system {
    /// A builder for [`FileSystem`](crate::model::FileSystem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) file_system_type: std::option::Option<crate::model::FileSystemType>,
        pub(crate) lifecycle: std::option::Option<crate::model::FileSystemLifecycle>,
        pub(crate) failure_details: std::option::Option<crate::model::FileSystemFailureDetails>,
        pub(crate) storage_capacity: std::option::Option<i32>,
        pub(crate) storage_type: std::option::Option<crate::model::StorageType>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) network_interface_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) dns_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) windows_configuration:
            std::option::Option<crate::model::WindowsFileSystemConfiguration>,
        pub(crate) lustre_configuration:
            std::option::Option<crate::model::LustreFileSystemConfiguration>,
        pub(crate) administrative_actions:
            std::option::Option<std::vec::Vec<crate::model::AdministrativeAction>>,
    }
    impl Builder {
        /// <p>The AWS account that created the file system. If the file system was created by an AWS
        /// Identity and Access Management (IAM) user, the AWS account to which the IAM user belongs
        /// is the owner.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z),
        /// also known as Unix time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The system-generated, unique 17-digit ID of the file system.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The type of Amazon FSx file system, either <code>LUSTRE</code> or <code>WINDOWS</code>.</p>
        pub fn file_system_type(mut self, input: crate::model::FileSystemType) -> Self {
            self.file_system_type = Some(input);
            self
        }
        pub fn set_file_system_type(
            mut self,
            input: std::option::Option<crate::model::FileSystemType>,
        ) -> Self {
            self.file_system_type = input;
            self
        }
        /// <p>The lifecycle status of the file system, following are the possible values and what they mean:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AVAILABLE</code> - The file system is in a healthy state, and is reachable and available for use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - Amazon FSx is creating the new file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - Amazon FSx is deleting an existing file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - An existing file system has experienced an unrecoverable failure.
        /// When creating a new file system, Amazon FSx was unable to create the file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MISCONFIGURED</code> indicates that the file system is in a failed but recoverable state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> indicates that the file system is undergoing a customer initiated update.</p>
        /// </li>
        /// </ul>
        pub fn lifecycle(mut self, input: crate::model::FileSystemLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::FileSystemLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>A structure providing details of any failures that occur when creating the file system
        /// has failed.</p>
        pub fn failure_details(mut self, input: crate::model::FileSystemFailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::FileSystemFailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>The storage capacity of the file system in gibibytes (GiB).</p>
        pub fn storage_capacity(mut self, input: i32) -> Self {
            self.storage_capacity = Some(input);
            self
        }
        pub fn set_storage_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.storage_capacity = input;
            self
        }
        /// <p>The storage type of the file system.
        /// Valid values are <code>SSD</code> and <code>HDD</code>.
        /// If set to <code>SSD</code>, the file system uses solid state drive storage.
        /// If set to <code>HDD</code>, the file system uses hard disk drive storage.
        /// </p>
        pub fn storage_type(mut self, input: crate::model::StorageType) -> Self {
            self.storage_type = Some(input);
            self
        }
        pub fn set_storage_type(
            mut self,
            input: std::option::Option<crate::model::StorageType>,
        ) -> Self {
            self.storage_type = input;
            self
        }
        /// <p>The ID of the primary VPC for the file system.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        pub fn network_interface_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.network_interface_ids.unwrap_or_default();
            v.push(input.into());
            self.network_interface_ids = Some(v);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_interface_ids = input;
            self
        }
        /// <p>The DNS name for the file system.</p>
        pub fn dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dns_name = Some(input.into());
            self
        }
        pub fn set_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dns_name = input;
            self
        }
        /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
        /// for Amazon FSx for Windows File Server file systems and persistent Amazon FSx for Lustre file
        /// systems at rest. In either case, if not specified, the Amazon FSx managed key
        /// is used. The scratch Amazon FSx for Lustre file systems are always encrypted at rest using
        /// Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
        /// in the <i>AWS Key Management Service API Reference</i>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the file system resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The configuration for this Microsoft Windows file system.</p>
        pub fn windows_configuration(
            mut self,
            input: crate::model::WindowsFileSystemConfiguration,
        ) -> Self {
            self.windows_configuration = Some(input);
            self
        }
        pub fn set_windows_configuration(
            mut self,
            input: std::option::Option<crate::model::WindowsFileSystemConfiguration>,
        ) -> Self {
            self.windows_configuration = input;
            self
        }
        /// <p>The configuration for the Amazon FSx for Lustre file system.</p>
        pub fn lustre_configuration(
            mut self,
            input: crate::model::LustreFileSystemConfiguration,
        ) -> Self {
            self.lustre_configuration = Some(input);
            self
        }
        pub fn set_lustre_configuration(
            mut self,
            input: std::option::Option<crate::model::LustreFileSystemConfiguration>,
        ) -> Self {
            self.lustre_configuration = input;
            self
        }
        pub fn administrative_actions(
            mut self,
            input: impl Into<crate::model::AdministrativeAction>,
        ) -> Self {
            let mut v = self.administrative_actions.unwrap_or_default();
            v.push(input.into());
            self.administrative_actions = Some(v);
            self
        }
        pub fn set_administrative_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AdministrativeAction>>,
        ) -> Self {
            self.administrative_actions = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystem`](crate::model::FileSystem)
        pub fn build(self) -> crate::model::FileSystem {
            crate::model::FileSystem {
                owner_id: self.owner_id,
                creation_time: self.creation_time,
                file_system_id: self.file_system_id,
                file_system_type: self.file_system_type,
                lifecycle: self.lifecycle,
                failure_details: self.failure_details,
                storage_capacity: self.storage_capacity,
                storage_type: self.storage_type,
                vpc_id: self.vpc_id,
                subnet_ids: self.subnet_ids,
                network_interface_ids: self.network_interface_ids,
                dns_name: self.dns_name,
                kms_key_id: self.kms_key_id,
                resource_arn: self.resource_arn,
                tags: self.tags,
                windows_configuration: self.windows_configuration,
                lustre_configuration: self.lustre_configuration,
                administrative_actions: self.administrative_actions,
            }
        }
    }
}
impl FileSystem {
    /// Creates a new builder-style object to manufacture [`FileSystem`](crate::model::FileSystem)
    pub fn builder() -> crate::model::file_system::Builder {
        crate::model::file_system::Builder::default()
    }
}

/// <p>Describes a specific Amazon FSx administrative action for the current Windows or
/// Lustre file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdministrativeAction {
    /// <p>Describes the type of administrative action, as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
    /// Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
    /// task to increase a file system's storage capacity completes successfully, a
    /// <code>STORAGE_OPTIMIZATION</code> task starts.
    /// </p>
    /// <ul>
    /// <li>
    /// <p>For Windows, storage optimization is the process of migrating the file system data
    /// to the new, larger disks.</p>
    /// </li>
    /// <li>
    /// <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
    /// newly added file servers.</p>
    /// </li>
    /// </ul>
    /// <p>You can track the storage optimization progress using the
    /// <code>ProgressPercent</code> property. When
    /// <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
    /// <code>FILE_SYSTEM_UPDATE</code> action status changes to
    /// <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
    /// storage capacity</a> in the <i>Amazon FSx for Windows File Server
    /// User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
    /// and throughput capacity</a> in the <i>Amazon FSx for Lustre User
    /// Guide</i>. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
    /// For more information, see
    /// .</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
    /// For more information, see .</p>
    /// </li>
    /// </ul>
    pub administrative_action_type: std::option::Option<crate::model::AdministrativeActionType>,
    /// <p>Provides the percent complete of a <code>STORAGE_OPTIMIZATION</code> administrative action.
    /// Does not apply to any other administrative action type.</p>
    pub progress_percent: std::option::Option<i32>,
    /// <p>Time that the administrative action request was received.</p>
    pub request_time: std::option::Option<smithy_types::Instant>,
    /// <p>Describes the status of the administrative action, as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - Amazon FSx failed to process the administrative action successfully.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_PROGRESS</code> - Amazon FSx is processing the administrative action.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - Amazon FSx is waiting to process the administrative action.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>COMPLETED</code> - Amazon FSx has finished processing the administrative task.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATED_OPTIMIZING</code> - For a storage capacity increase update, Amazon FSx has
    /// updated the file system with the new storage capacity, and is now performing the
    /// storage optimization process. For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
    /// storage capacity</a> in the <i>Amazon FSx for Windows File Server
    /// User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
    /// and throughput capacity</a> in the <i>Amazon FSx for Lustre User
    /// Guide</i>.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::Status>,
    /// <p>Describes the target value for the administration action,  
    /// provided in the <code>UpdateFileSystem</code> operation.  
    /// Returned for <code>FILE_SYSTEM_UPDATE</code> administrative actions.
    /// </p>
    pub target_file_system_values: std::option::Option<crate::model::FileSystem>,
    /// <p>Provides information about a failed administrative action.</p>
    pub failure_details: std::option::Option<crate::model::AdministrativeActionFailureDetails>,
}
impl std::fmt::Debug for AdministrativeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdministrativeAction");
        formatter.field(
            "administrative_action_type",
            &self.administrative_action_type,
        );
        formatter.field("progress_percent", &self.progress_percent);
        formatter.field("request_time", &self.request_time);
        formatter.field("status", &self.status);
        formatter.field("target_file_system_values", &self.target_file_system_values);
        formatter.field("failure_details", &self.failure_details);
        formatter.finish()
    }
}
/// See [`AdministrativeAction`](crate::model::AdministrativeAction)
pub mod administrative_action {
    /// A builder for [`AdministrativeAction`](crate::model::AdministrativeAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) administrative_action_type:
            std::option::Option<crate::model::AdministrativeActionType>,
        pub(crate) progress_percent: std::option::Option<i32>,
        pub(crate) request_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) target_file_system_values: std::option::Option<crate::model::FileSystem>,
        pub(crate) failure_details:
            std::option::Option<crate::model::AdministrativeActionFailureDetails>,
    }
    impl Builder {
        /// <p>Describes the type of administrative action, as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
        /// Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
        /// task to increase a file system's storage capacity completes successfully, a
        /// <code>STORAGE_OPTIMIZATION</code> task starts.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>For Windows, storage optimization is the process of migrating the file system data
        /// to the new, larger disks.</p>
        /// </li>
        /// <li>
        /// <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
        /// newly added file servers.</p>
        /// </li>
        /// </ul>
        /// <p>You can track the storage optimization progress using the
        /// <code>ProgressPercent</code> property. When
        /// <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
        /// <code>FILE_SYSTEM_UPDATE</code> action status changes to
        /// <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
        /// storage capacity</a> in the <i>Amazon FSx for Windows File Server
        /// User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
        /// and throughput capacity</a> in the <i>Amazon FSx for Lustre User
        /// Guide</i>. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
        /// For more information, see
        /// .</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
        /// For more information, see .</p>
        /// </li>
        /// </ul>
        pub fn administrative_action_type(
            mut self,
            input: crate::model::AdministrativeActionType,
        ) -> Self {
            self.administrative_action_type = Some(input);
            self
        }
        pub fn set_administrative_action_type(
            mut self,
            input: std::option::Option<crate::model::AdministrativeActionType>,
        ) -> Self {
            self.administrative_action_type = input;
            self
        }
        /// <p>Provides the percent complete of a <code>STORAGE_OPTIMIZATION</code> administrative action.
        /// Does not apply to any other administrative action type.</p>
        pub fn progress_percent(mut self, input: i32) -> Self {
            self.progress_percent = Some(input);
            self
        }
        pub fn set_progress_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.progress_percent = input;
            self
        }
        /// <p>Time that the administrative action request was received.</p>
        pub fn request_time(mut self, input: smithy_types::Instant) -> Self {
            self.request_time = Some(input);
            self
        }
        pub fn set_request_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.request_time = input;
            self
        }
        /// <p>Describes the status of the administrative action, as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - Amazon FSx failed to process the administrative action successfully.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_PROGRESS</code> - Amazon FSx is processing the administrative action.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - Amazon FSx is waiting to process the administrative action.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>COMPLETED</code> - Amazon FSx has finished processing the administrative task.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATED_OPTIMIZING</code> - For a storage capacity increase update, Amazon FSx has
        /// updated the file system with the new storage capacity, and is now performing the
        /// storage optimization process. For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
        /// storage capacity</a> in the <i>Amazon FSx for Windows File Server
        /// User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
        /// and throughput capacity</a> in the <i>Amazon FSx for Lustre User
        /// Guide</i>.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>Describes the target value for the administration action,  
        /// provided in the <code>UpdateFileSystem</code> operation.  
        /// Returned for <code>FILE_SYSTEM_UPDATE</code> administrative actions.
        /// </p>
        pub fn target_file_system_values(mut self, input: crate::model::FileSystem) -> Self {
            self.target_file_system_values = Some(input);
            self
        }
        pub fn set_target_file_system_values(
            mut self,
            input: std::option::Option<crate::model::FileSystem>,
        ) -> Self {
            self.target_file_system_values = input;
            self
        }
        /// <p>Provides information about a failed administrative action.</p>
        pub fn failure_details(
            mut self,
            input: crate::model::AdministrativeActionFailureDetails,
        ) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::AdministrativeActionFailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// Consumes the builder and constructs a [`AdministrativeAction`](crate::model::AdministrativeAction)
        pub fn build(self) -> crate::model::AdministrativeAction {
            crate::model::AdministrativeAction {
                administrative_action_type: self.administrative_action_type,
                progress_percent: self.progress_percent,
                request_time: self.request_time,
                status: self.status,
                target_file_system_values: self.target_file_system_values,
                failure_details: self.failure_details,
            }
        }
    }
}
impl AdministrativeAction {
    /// Creates a new builder-style object to manufacture [`AdministrativeAction`](crate::model::AdministrativeAction)
    pub fn builder() -> crate::model::administrative_action::Builder {
        crate::model::administrative_action::Builder::default()
    }
}

/// <p>Provides information about a failed administrative action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdministrativeActionFailureDetails {
    /// <p>Error message providing details about the failed administrative action.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AdministrativeActionFailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdministrativeActionFailureDetails");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`AdministrativeActionFailureDetails`](crate::model::AdministrativeActionFailureDetails)
pub mod administrative_action_failure_details {
    /// A builder for [`AdministrativeActionFailureDetails`](crate::model::AdministrativeActionFailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error message providing details about the failed administrative action.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AdministrativeActionFailureDetails`](crate::model::AdministrativeActionFailureDetails)
        pub fn build(self) -> crate::model::AdministrativeActionFailureDetails {
            crate::model::AdministrativeActionFailureDetails {
                message: self.message,
            }
        }
    }
}
impl AdministrativeActionFailureDetails {
    /// Creates a new builder-style object to manufacture [`AdministrativeActionFailureDetails`](crate::model::AdministrativeActionFailureDetails)
    pub fn builder() -> crate::model::administrative_action_failure_details::Builder {
        crate::model::administrative_action_failure_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    Completed,
    Failed,
    InProgress,
    Pending,
    UpdatedOptimizing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => Status::Completed,
            "FAILED" => Status::Failed,
            "IN_PROGRESS" => Status::InProgress,
            "PENDING" => Status::Pending,
            "UPDATED_OPTIMIZING" => Status::UpdatedOptimizing,
            other => Status::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    pub fn as_str(&self) -> &str {
        match self {
            Status::Completed => "COMPLETED",
            Status::Failed => "FAILED",
            Status::InProgress => "IN_PROGRESS",
            Status::Pending => "PENDING",
            Status::UpdatedOptimizing => "UPDATED_OPTIMIZING",
            Status::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "IN_PROGRESS",
            "PENDING",
            "UPDATED_OPTIMIZING",
        ]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the type of administrative action, as follows:</p>
/// <ul>
/// <li>
/// <p>
/// <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
/// Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
/// </li>
/// <li>
/// <p>
/// <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
/// task to increase a file system's storage capacity completes successfully, a
/// <code>STORAGE_OPTIMIZATION</code> task starts.
/// </p>
/// <ul>
/// <li>
/// <p>For Windows, storage optimization is the process of migrating the file system data
/// to the new, larger disks.</p>
/// </li>
/// <li>
/// <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
/// newly added file servers.</p>
/// </li>
/// </ul>
/// <p>You can track the storage optimization progress using the
/// <code>ProgressPercent</code> property. When
/// <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
/// <code>FILE_SYSTEM_UPDATE</code> action status changes to
/// <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
/// storage capacity</a> in the <i>Amazon FSx for Windows File Server
/// User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
/// and throughput capacity</a> in the <i>Amazon FSx for Lustre User
/// Guide</i>. </p>
/// </li>
/// <li>
/// <p>
/// <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
/// For more information, see
/// .</p>
/// </li>
/// <li>
/// <p>
/// <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
/// For more information, see .</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AdministrativeActionType {
    FileSystemAliasAssociation,
    FileSystemAliasDisassociation,
    FileSystemUpdate,
    StorageOptimization,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AdministrativeActionType {
    fn from(s: &str) -> Self {
        match s {
            "FILE_SYSTEM_ALIAS_ASSOCIATION" => AdministrativeActionType::FileSystemAliasAssociation,
            "FILE_SYSTEM_ALIAS_DISASSOCIATION" => {
                AdministrativeActionType::FileSystemAliasDisassociation
            }
            "FILE_SYSTEM_UPDATE" => AdministrativeActionType::FileSystemUpdate,
            "STORAGE_OPTIMIZATION" => AdministrativeActionType::StorageOptimization,
            other => AdministrativeActionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AdministrativeActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AdministrativeActionType::from(s))
    }
}
impl AdministrativeActionType {
    pub fn as_str(&self) -> &str {
        match self {
            AdministrativeActionType::FileSystemAliasAssociation => "FILE_SYSTEM_ALIAS_ASSOCIATION",
            AdministrativeActionType::FileSystemAliasDisassociation => {
                "FILE_SYSTEM_ALIAS_DISASSOCIATION"
            }
            AdministrativeActionType::FileSystemUpdate => "FILE_SYSTEM_UPDATE",
            AdministrativeActionType::StorageOptimization => "STORAGE_OPTIMIZATION",
            AdministrativeActionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "FILE_SYSTEM_ALIAS_ASSOCIATION",
            "FILE_SYSTEM_ALIAS_DISASSOCIATION",
            "FILE_SYSTEM_UPDATE",
            "STORAGE_OPTIMIZATION",
        ]
    }
}
impl AsRef<str> for AdministrativeActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for the Amazon FSx for Lustre file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LustreFileSystemConfiguration {
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>The data repository configuration object for Lustre file systems returned in the response of
    /// the <code>CreateFileSystem</code> operation.</p>
    pub data_repository_configuration:
        std::option::Option<crate::model::DataRepositoryConfiguration>,
    /// <p>The deployment type of the FSX for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage
    /// and shorter-term processing of data.</p>
    /// <p>
    /// <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
    /// types are best suited for when you need temporary storage and shorter-term processing of data.
    /// The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
    /// throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>The <code>PERSISTENT_1</code> deployment type is used for longer-term storage
    /// and workloads and encryption of data in transit. To learn more about deployment types, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
    /// FSx for Lustre Deployment Options</a>. (Default = <code>SCRATCH_1</code>)</p>
    pub deployment_type: std::option::Option<crate::model::LustreDeploymentType>,
    /// <p> Per unit storage throughput represents the megabytes per second of read or write
    /// throughput per 1 tebibyte of storage provisioned. File system throughput capacity is
    /// equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is
    /// only valid for <code>PERSISTENT_1</code> deployment types. </p>
    /// <p>Valid values for SSD storage: 50, 100, 200. Valid values for HDD storage: 12, 40. </p>
    pub per_unit_storage_throughput: std::option::Option<i32>,
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>".
    /// For <code>SCRATCH_2</code> and <code>PERSISTENT_1</code> deployment types, this
    /// value is a string that is unique within an AWS Region.
    /// </p>
    pub mount_name: std::option::Option<std::string::String>,
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
    /// If it's set to true, all tags on the file system are
    /// copied to all automatic backups and any user-initiated backups where the user
    /// doesn't specify any tags. If this value is true, and you specify one or more tags,
    /// only the specified tags are copied to backups. If you specify one or more tags when
    /// creating a user-initiated backup, no tags are copied from the file system,
    /// regardless of this value. (Default = false)</p>
    pub copy_tags_to_backups: std::option::Option<bool>,
    /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
    /// HDD storage devices. This parameter is required when storage type is HDD. Set to
    /// <code>READ</code>, improve the performance for frequently accessed files and allows 20%
    /// of the total storage capacity of the file system to be cached.  </p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    pub drive_cache_type: std::option::Option<crate::model::DriveCacheType>,
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code>
    /// can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - Data compression is turned off for
    /// the file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LZ4</code> - Data compression is turned on with the LZ4
    /// algorithm.</p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub data_compression_type: std::option::Option<crate::model::DataCompressionType>,
}
impl std::fmt::Debug for LustreFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LustreFileSystemConfiguration");
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field(
            "data_repository_configuration",
            &self.data_repository_configuration,
        );
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field(
            "per_unit_storage_throughput",
            &self.per_unit_storage_throughput,
        );
        formatter.field("mount_name", &self.mount_name);
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("copy_tags_to_backups", &self.copy_tags_to_backups);
        formatter.field("drive_cache_type", &self.drive_cache_type);
        formatter.field("data_compression_type", &self.data_compression_type);
        formatter.finish()
    }
}
/// See [`LustreFileSystemConfiguration`](crate::model::LustreFileSystemConfiguration)
pub mod lustre_file_system_configuration {
    /// A builder for [`LustreFileSystemConfiguration`](crate::model::LustreFileSystemConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) data_repository_configuration:
            std::option::Option<crate::model::DataRepositoryConfiguration>,
        pub(crate) deployment_type: std::option::Option<crate::model::LustreDeploymentType>,
        pub(crate) per_unit_storage_throughput: std::option::Option<i32>,
        pub(crate) mount_name: std::option::Option<std::string::String>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) copy_tags_to_backups: std::option::Option<bool>,
        pub(crate) drive_cache_type: std::option::Option<crate::model::DriveCacheType>,
        pub(crate) data_compression_type: std::option::Option<crate::model::DataCompressionType>,
    }
    impl Builder {
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>The data repository configuration object for Lustre file systems returned in the response of
        /// the <code>CreateFileSystem</code> operation.</p>
        pub fn data_repository_configuration(
            mut self,
            input: crate::model::DataRepositoryConfiguration,
        ) -> Self {
            self.data_repository_configuration = Some(input);
            self
        }
        pub fn set_data_repository_configuration(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryConfiguration>,
        ) -> Self {
            self.data_repository_configuration = input;
            self
        }
        /// <p>The deployment type of the FSX for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage
        /// and shorter-term processing of data.</p>
        /// <p>
        /// <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
        /// types are best suited for when you need temporary storage and shorter-term processing of data.
        /// The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
        /// throughput capacity than <code>SCRATCH_1</code>.</p>
        /// <p>The <code>PERSISTENT_1</code> deployment type is used for longer-term storage
        /// and workloads and encryption of data in transit. To learn more about deployment types, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
        /// FSx for Lustre Deployment Options</a>. (Default = <code>SCRATCH_1</code>)</p>
        pub fn deployment_type(mut self, input: crate::model::LustreDeploymentType) -> Self {
            self.deployment_type = Some(input);
            self
        }
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<crate::model::LustreDeploymentType>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p> Per unit storage throughput represents the megabytes per second of read or write
        /// throughput per 1 tebibyte of storage provisioned. File system throughput capacity is
        /// equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is
        /// only valid for <code>PERSISTENT_1</code> deployment types. </p>
        /// <p>Valid values for SSD storage: 50, 100, 200. Valid values for HDD storage: 12, 40. </p>
        pub fn per_unit_storage_throughput(mut self, input: i32) -> Self {
            self.per_unit_storage_throughput = Some(input);
            self
        }
        pub fn set_per_unit_storage_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.per_unit_storage_throughput = input;
            self
        }
        /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
        /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>".
        /// For <code>SCRATCH_2</code> and <code>PERSISTENT_1</code> deployment types, this
        /// value is a string that is unique within an AWS Region.
        /// </p>
        pub fn mount_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.mount_name = Some(input.into());
            self
        }
        pub fn set_mount_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mount_name = input;
            self
        }
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
        /// If it's set to true, all tags on the file system are
        /// copied to all automatic backups and any user-initiated backups where the user
        /// doesn't specify any tags. If this value is true, and you specify one or more tags,
        /// only the specified tags are copied to backups. If you specify one or more tags when
        /// creating a user-initiated backup, no tags are copied from the file system,
        /// regardless of this value. (Default = false)</p>
        pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
            self.copy_tags_to_backups = Some(input);
            self
        }
        pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_backups = input;
            self
        }
        /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
        /// HDD storage devices. This parameter is required when storage type is HDD. Set to
        /// <code>READ</code>, improve the performance for frequently accessed files and allows 20%
        /// of the total storage capacity of the file system to be cached.  </p>
        /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
        pub fn drive_cache_type(mut self, input: crate::model::DriveCacheType) -> Self {
            self.drive_cache_type = Some(input);
            self
        }
        pub fn set_drive_cache_type(
            mut self,
            input: std::option::Option<crate::model::DriveCacheType>,
        ) -> Self {
            self.drive_cache_type = input;
            self
        }
        /// <p>The data compression configuration for the file system. <code>DataCompressionType</code>
        /// can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - Data compression is turned off for
        /// the file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LZ4</code> - Data compression is turned on with the LZ4
        /// algorithm.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        pub fn data_compression_type(mut self, input: crate::model::DataCompressionType) -> Self {
            self.data_compression_type = Some(input);
            self
        }
        pub fn set_data_compression_type(
            mut self,
            input: std::option::Option<crate::model::DataCompressionType>,
        ) -> Self {
            self.data_compression_type = input;
            self
        }
        /// Consumes the builder and constructs a [`LustreFileSystemConfiguration`](crate::model::LustreFileSystemConfiguration)
        pub fn build(self) -> crate::model::LustreFileSystemConfiguration {
            crate::model::LustreFileSystemConfiguration {
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                data_repository_configuration: self.data_repository_configuration,
                deployment_type: self.deployment_type,
                per_unit_storage_throughput: self.per_unit_storage_throughput,
                mount_name: self.mount_name,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                copy_tags_to_backups: self.copy_tags_to_backups,
                drive_cache_type: self.drive_cache_type,
                data_compression_type: self.data_compression_type,
            }
        }
    }
}
impl LustreFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`LustreFileSystemConfiguration`](crate::model::LustreFileSystemConfiguration)
    pub fn builder() -> crate::model::lustre_file_system_configuration::Builder {
        crate::model::lustre_file_system_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataCompressionType {
    Lz4,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataCompressionType {
    fn from(s: &str) -> Self {
        match s {
            "LZ4" => DataCompressionType::Lz4,
            "NONE" => DataCompressionType::None,
            other => DataCompressionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataCompressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataCompressionType::from(s))
    }
}
impl DataCompressionType {
    pub fn as_str(&self) -> &str {
        match self {
            DataCompressionType::Lz4 => "LZ4",
            DataCompressionType::None => "NONE",
            DataCompressionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LZ4", "NONE"]
    }
}
impl AsRef<str> for DataCompressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DriveCacheType {
    None,
    Read,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DriveCacheType {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => DriveCacheType::None,
            "READ" => DriveCacheType::Read,
            other => DriveCacheType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DriveCacheType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DriveCacheType::from(s))
    }
}
impl DriveCacheType {
    pub fn as_str(&self) -> &str {
        match self {
            DriveCacheType::None => "NONE",
            DriveCacheType::Read => "READ",
            DriveCacheType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["NONE", "READ"]
    }
}
impl AsRef<str> for DriveCacheType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LustreDeploymentType {
    Persistent1,
    Scratch1,
    Scratch2,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LustreDeploymentType {
    fn from(s: &str) -> Self {
        match s {
            "PERSISTENT_1" => LustreDeploymentType::Persistent1,
            "SCRATCH_1" => LustreDeploymentType::Scratch1,
            "SCRATCH_2" => LustreDeploymentType::Scratch2,
            other => LustreDeploymentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LustreDeploymentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LustreDeploymentType::from(s))
    }
}
impl LustreDeploymentType {
    pub fn as_str(&self) -> &str {
        match self {
            LustreDeploymentType::Persistent1 => "PERSISTENT_1",
            LustreDeploymentType::Scratch1 => "SCRATCH_1",
            LustreDeploymentType::Scratch2 => "SCRATCH_2",
            LustreDeploymentType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PERSISTENT_1", "SCRATCH_1", "SCRATCH_2"]
    }
}
impl AsRef<str> for LustreDeploymentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The data repository configuration object for Lustre file systems returned in the response of
/// the <code>CreateFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryConfiguration {
    /// <p>Describes the state of the file system's S3 durable data repository, if it is configured with an S3 repository.
    /// The lifecycle can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The data repository configuration between
    /// the FSx file system and the linked S3 data repository is being created.
    /// The data repository is unavailable.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AVAILABLE</code> - The data repository is available for use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MISCONFIGURED</code> - Amazon FSx cannot automatically import updates from the S3 bucket
    /// until the data repository configuration is corrected. For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/troubleshooting.html#troubleshooting-misconfigured-data-repository">Troubleshooting a Misconfigured linked S3 bucket</a>.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The data repository is undergoing a customer initiated update and availability may be impacted.</p>
    /// </li>
    /// </ul>
    pub lifecycle: std::option::Option<crate::model::DataRepositoryLifecycle>,
    /// <p>The import path to the Amazon S3 bucket (and optional prefix) that you're using
    /// as the data repository for your FSx for Lustre file system, for example
    /// <code>s3://import-bucket/optional-prefix</code>. If a prefix is specified after the
    /// Amazon S3 bucket name, only object keys with that prefix are loaded into the file
    /// system.</p>
    pub import_path: std::option::Option<std::string::String>,
    /// <p>The export path to the Amazon S3 bucket (and prefix) that you are using to store new and
    /// changed Lustre file system files in S3.</p>
    pub export_path: std::option::Option<std::string::String>,
    /// <p>For files imported from a data repository, this value determines the stripe count and
    /// maximum amount of data per file (in MiB) stored on a single physical disk. The maximum
    /// number of disks that a single file can be striped across is limited by the total number
    /// of disks that make up the file system.</p>
    /// <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
    /// GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
    pub imported_file_chunk_size: std::option::Option<i32>,
    /// <p>Describes the file system's linked S3 data repository's <code>AutoImportPolicy</code>.
    /// The AutoImportPolicy configures how Amazon FSx keeps your file and directory listings up to date
    /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    /// file and directory listings from the linked S3 bucket
    /// when the file system is created. FSx does not update file and directory
    /// listings for any new or changed objects after choosing this option.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    /// directory listings of any new objects added to the linked S3 bucket that
    /// do not currently exist in the FSx file system. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    /// file and directory listings of any new objects added to the S3 bucket and any
    /// existing objects that are changed in the S3 bucket after you choose this option.
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    pub auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
    /// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
    /// set to <code>MISCONFIGURED</code>.</p>
    pub failure_details: std::option::Option<crate::model::DataRepositoryFailureDetails>,
}
impl std::fmt::Debug for DataRepositoryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryConfiguration");
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("import_path", &self.import_path);
        formatter.field("export_path", &self.export_path);
        formatter.field("imported_file_chunk_size", &self.imported_file_chunk_size);
        formatter.field("auto_import_policy", &self.auto_import_policy);
        formatter.field("failure_details", &self.failure_details);
        formatter.finish()
    }
}
/// See [`DataRepositoryConfiguration`](crate::model::DataRepositoryConfiguration)
pub mod data_repository_configuration {
    /// A builder for [`DataRepositoryConfiguration`](crate::model::DataRepositoryConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lifecycle: std::option::Option<crate::model::DataRepositoryLifecycle>,
        pub(crate) import_path: std::option::Option<std::string::String>,
        pub(crate) export_path: std::option::Option<std::string::String>,
        pub(crate) imported_file_chunk_size: std::option::Option<i32>,
        pub(crate) auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
        pub(crate) failure_details: std::option::Option<crate::model::DataRepositoryFailureDetails>,
    }
    impl Builder {
        /// <p>Describes the state of the file system's S3 durable data repository, if it is configured with an S3 repository.
        /// The lifecycle can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The data repository configuration between
        /// the FSx file system and the linked S3 data repository is being created.
        /// The data repository is unavailable.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AVAILABLE</code> - The data repository is available for use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MISCONFIGURED</code> - Amazon FSx cannot automatically import updates from the S3 bucket
        /// until the data repository configuration is corrected. For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/troubleshooting.html#troubleshooting-misconfigured-data-repository">Troubleshooting a Misconfigured linked S3 bucket</a>.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The data repository is undergoing a customer initiated update and availability may be impacted.</p>
        /// </li>
        /// </ul>
        pub fn lifecycle(mut self, input: crate::model::DataRepositoryLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>The import path to the Amazon S3 bucket (and optional prefix) that you're using
        /// as the data repository for your FSx for Lustre file system, for example
        /// <code>s3://import-bucket/optional-prefix</code>. If a prefix is specified after the
        /// Amazon S3 bucket name, only object keys with that prefix are loaded into the file
        /// system.</p>
        pub fn import_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_path = Some(input.into());
            self
        }
        pub fn set_import_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.import_path = input;
            self
        }
        /// <p>The export path to the Amazon S3 bucket (and prefix) that you are using to store new and
        /// changed Lustre file system files in S3.</p>
        pub fn export_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.export_path = Some(input.into());
            self
        }
        pub fn set_export_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.export_path = input;
            self
        }
        /// <p>For files imported from a data repository, this value determines the stripe count and
        /// maximum amount of data per file (in MiB) stored on a single physical disk. The maximum
        /// number of disks that a single file can be striped across is limited by the total number
        /// of disks that make up the file system.</p>
        /// <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
        /// GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
        pub fn imported_file_chunk_size(mut self, input: i32) -> Self {
            self.imported_file_chunk_size = Some(input);
            self
        }
        pub fn set_imported_file_chunk_size(mut self, input: std::option::Option<i32>) -> Self {
            self.imported_file_chunk_size = input;
            self
        }
        /// <p>Describes the file system's linked S3 data repository's <code>AutoImportPolicy</code>.
        /// The AutoImportPolicy configures how Amazon FSx keeps your file and directory listings up to date
        /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        /// file and directory listings from the linked S3 bucket
        /// when the file system is created. FSx does not update file and directory
        /// listings for any new or changed objects after choosing this option.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        /// directory listings of any new objects added to the linked S3 bucket that
        /// do not currently exist in the FSx file system. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        /// file and directory listings of any new objects added to the S3 bucket and any
        /// existing objects that are changed in the S3 bucket after you choose this option.
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        pub fn auto_import_policy(mut self, input: crate::model::AutoImportPolicyType) -> Self {
            self.auto_import_policy = Some(input);
            self
        }
        pub fn set_auto_import_policy(
            mut self,
            input: std::option::Option<crate::model::AutoImportPolicyType>,
        ) -> Self {
            self.auto_import_policy = input;
            self
        }
        /// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
        /// set to <code>MISCONFIGURED</code>.</p>
        pub fn failure_details(
            mut self,
            input: crate::model::DataRepositoryFailureDetails,
        ) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryFailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryConfiguration`](crate::model::DataRepositoryConfiguration)
        pub fn build(self) -> crate::model::DataRepositoryConfiguration {
            crate::model::DataRepositoryConfiguration {
                lifecycle: self.lifecycle,
                import_path: self.import_path,
                export_path: self.export_path,
                imported_file_chunk_size: self.imported_file_chunk_size,
                auto_import_policy: self.auto_import_policy,
                failure_details: self.failure_details,
            }
        }
    }
}
impl DataRepositoryConfiguration {
    /// Creates a new builder-style object to manufacture [`DataRepositoryConfiguration`](crate::model::DataRepositoryConfiguration)
    pub fn builder() -> crate::model::data_repository_configuration::Builder {
        crate::model::data_repository_configuration::Builder::default()
    }
}

/// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
/// set to <code>MISCONFIGURED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryFailureDetails {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataRepositoryFailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryFailureDetails");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DataRepositoryFailureDetails`](crate::model::DataRepositoryFailureDetails)
pub mod data_repository_failure_details {
    /// A builder for [`DataRepositoryFailureDetails`](crate::model::DataRepositoryFailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryFailureDetails`](crate::model::DataRepositoryFailureDetails)
        pub fn build(self) -> crate::model::DataRepositoryFailureDetails {
            crate::model::DataRepositoryFailureDetails {
                message: self.message,
            }
        }
    }
}
impl DataRepositoryFailureDetails {
    /// Creates a new builder-style object to manufacture [`DataRepositoryFailureDetails`](crate::model::DataRepositoryFailureDetails)
    pub fn builder() -> crate::model::data_repository_failure_details::Builder {
        crate::model::data_repository_failure_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutoImportPolicyType {
    New,
    NewChanged,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AutoImportPolicyType {
    fn from(s: &str) -> Self {
        match s {
            "NEW" => AutoImportPolicyType::New,
            "NEW_CHANGED" => AutoImportPolicyType::NewChanged,
            "NONE" => AutoImportPolicyType::None,
            other => AutoImportPolicyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AutoImportPolicyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutoImportPolicyType::from(s))
    }
}
impl AutoImportPolicyType {
    pub fn as_str(&self) -> &str {
        match self {
            AutoImportPolicyType::New => "NEW",
            AutoImportPolicyType::NewChanged => "NEW_CHANGED",
            AutoImportPolicyType::None => "NONE",
            AutoImportPolicyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["NEW", "NEW_CHANGED", "NONE"]
    }
}
impl AsRef<str> for AutoImportPolicyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataRepositoryLifecycle {
    Available,
    Creating,
    Deleting,
    Misconfigured,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataRepositoryLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => DataRepositoryLifecycle::Available,
            "CREATING" => DataRepositoryLifecycle::Creating,
            "DELETING" => DataRepositoryLifecycle::Deleting,
            "MISCONFIGURED" => DataRepositoryLifecycle::Misconfigured,
            "UPDATING" => DataRepositoryLifecycle::Updating,
            other => DataRepositoryLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataRepositoryLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataRepositoryLifecycle::from(s))
    }
}
impl DataRepositoryLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            DataRepositoryLifecycle::Available => "AVAILABLE",
            DataRepositoryLifecycle::Creating => "CREATING",
            DataRepositoryLifecycle::Deleting => "DELETING",
            DataRepositoryLifecycle::Misconfigured => "MISCONFIGURED",
            DataRepositoryLifecycle::Updating => "UPDATING",
            DataRepositoryLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CREATING",
            "DELETING",
            "MISCONFIGURED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for DataRepositoryLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for this Microsoft Windows file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WindowsFileSystemConfiguration {
    /// <p>The ID for an existing AWS Managed Microsoft Active Directory instance that the file system is joined to.</p>
    pub active_directory_id: std::option::Option<std::string::String>,
    /// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
    /// which the Windows File Server instance is joined.</p>
    pub self_managed_active_directory_configuration:
        std::option::Option<crate::model::SelfManagedActiveDirectoryAttributes>,
    /// <p>Specifies the file system deployment type, valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MULTI_AZ_1</code> - Specifies a high availability file system that is configured for Multi-AZ
    /// redundancy to tolerate temporary Availability Zone (AZ) unavailability, and supports SSD and HDD storage.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SINGLE_AZ_1</code> - (Default) Specifies a file system that is configured for single AZ redundancy,
    /// only supports SSD storage.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SINGLE_AZ_2</code> - Latest generation Single AZ file system.
    /// Specifies a file system that is configured for single AZ redundancy and supports SSD and HDD storage.</p>
    /// </li>
    /// </ul>
    /// <p>For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">Single-AZ and Multi-AZ File Systems</a>.</p>
    pub deployment_type: std::option::Option<crate::model::WindowsDeploymentType>,
    /// <p>For <code>MULTI_AZ_1</code> deployment types, use this endpoint when performing administrative tasks on the file system using
    /// Amazon FSx Remote PowerShell.</p>
    /// <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this is the DNS name of the file system.</p>
    /// <p>This endpoint is temporarily unavailable when the file system is undergoing maintenance.</p>
    pub remote_administration_endpoint: std::option::Option<std::string::String>,
    /// <p>For <code>MULTI_AZ_1</code> deployment types, it specifies the ID of the subnet where the preferred file server is located.
    /// Must be one of the two subnet IDs specified in <code>SubnetIds</code> property.
    /// Amazon FSx serves traffic from this subnet except in the event of a failover to the secondary file server.</p>
    /// <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this value is the same as that for <code>SubnetIDs</code>.
    /// For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html#single-multi-az-resources">Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
    pub preferred_subnet_id: std::option::Option<std::string::String>,
    /// <p>For <code>MULTI_AZ_1</code> deployment types, the IP address of the primary, or preferred, file server.</p>
    /// <p>Use this IP address when mounting the file system on Linux SMB clients or Windows SMB clients that
    /// are not joined to a Microsoft Active Directory.
    /// Applicable for all Windows file system deployment types.
    /// This IP address is temporarily unavailable
    /// when the file system is undergoing maintenance. For Linux and Windows
    /// SMB clients that are joined to an Active Directory, use the file system's DNSName instead. For more information
    /// on mapping and mounting file shares, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/accessing-file-shares.html">Accessing File Shares</a>.</p>
    pub preferred_file_server_ip: std::option::Option<std::string::String>,
    /// <p>The throughput of the Amazon FSx file system, measured in megabytes per
    /// second.</p>
    pub throughput_capacity: std::option::Option<i32>,
    /// <p>The list of maintenance operations in progress for this file system.</p>
    pub maintenance_operations_in_progress:
        std::option::Option<std::vec::Vec<crate::model::FileSystemMaintenanceOperation>>,
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>The preferred time to take daily automatic backups, in the UTC time zone.</p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables automatic
    /// backups. You can retain automatic backups for a maximum of 90 days.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
    /// This value defaults to false. If it's set to true, all tags on the file system are
    /// copied to all automatic backups and any user-initiated backups where the user
    /// doesn't specify any tags. If this value is true, and you specify one or more tags,
    /// only the specified tags are copied to backups. If you specify one or more tags when
    /// creating a user-initiated backup, no tags are copied from the file system,
    /// regardless of this value.</p>
    pub copy_tags_to_backups: std::option::Option<bool>,
    /// <p>An array of one or more DNS aliases that are currently associated with the Amazon FSx file system.
    /// Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
    /// You can associate up to 50 aliases with a file system at any time.
    /// You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
    /// You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
    /// You only need to specify the alias name in the request payload. For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>.</p>
    pub aliases: std::option::Option<std::vec::Vec<crate::model::Alias>>,
    /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
    /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
    /// file system.</p>
    pub audit_log_configuration: std::option::Option<crate::model::WindowsAuditLogConfiguration>,
}
impl std::fmt::Debug for WindowsFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WindowsFileSystemConfiguration");
        formatter.field("active_directory_id", &self.active_directory_id);
        formatter.field(
            "self_managed_active_directory_configuration",
            &self.self_managed_active_directory_configuration,
        );
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field(
            "remote_administration_endpoint",
            &self.remote_administration_endpoint,
        );
        formatter.field("preferred_subnet_id", &self.preferred_subnet_id);
        formatter.field("preferred_file_server_ip", &self.preferred_file_server_ip);
        formatter.field("throughput_capacity", &self.throughput_capacity);
        formatter.field(
            "maintenance_operations_in_progress",
            &self.maintenance_operations_in_progress,
        );
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("copy_tags_to_backups", &self.copy_tags_to_backups);
        formatter.field("aliases", &self.aliases);
        formatter.field("audit_log_configuration", &self.audit_log_configuration);
        formatter.finish()
    }
}
/// See [`WindowsFileSystemConfiguration`](crate::model::WindowsFileSystemConfiguration)
pub mod windows_file_system_configuration {
    /// A builder for [`WindowsFileSystemConfiguration`](crate::model::WindowsFileSystemConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_id: std::option::Option<std::string::String>,
        pub(crate) self_managed_active_directory_configuration:
            std::option::Option<crate::model::SelfManagedActiveDirectoryAttributes>,
        pub(crate) deployment_type: std::option::Option<crate::model::WindowsDeploymentType>,
        pub(crate) remote_administration_endpoint: std::option::Option<std::string::String>,
        pub(crate) preferred_subnet_id: std::option::Option<std::string::String>,
        pub(crate) preferred_file_server_ip: std::option::Option<std::string::String>,
        pub(crate) throughput_capacity: std::option::Option<i32>,
        pub(crate) maintenance_operations_in_progress:
            std::option::Option<std::vec::Vec<crate::model::FileSystemMaintenanceOperation>>,
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) copy_tags_to_backups: std::option::Option<bool>,
        pub(crate) aliases: std::option::Option<std::vec::Vec<crate::model::Alias>>,
        pub(crate) audit_log_configuration:
            std::option::Option<crate::model::WindowsAuditLogConfiguration>,
    }
    impl Builder {
        /// <p>The ID for an existing AWS Managed Microsoft Active Directory instance that the file system is joined to.</p>
        pub fn active_directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_id = Some(input.into());
            self
        }
        pub fn set_active_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_id = input;
            self
        }
        /// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
        /// which the Windows File Server instance is joined.</p>
        pub fn self_managed_active_directory_configuration(
            mut self,
            input: crate::model::SelfManagedActiveDirectoryAttributes,
        ) -> Self {
            self.self_managed_active_directory_configuration = Some(input);
            self
        }
        pub fn set_self_managed_active_directory_configuration(
            mut self,
            input: std::option::Option<crate::model::SelfManagedActiveDirectoryAttributes>,
        ) -> Self {
            self.self_managed_active_directory_configuration = input;
            self
        }
        /// <p>Specifies the file system deployment type, valid values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MULTI_AZ_1</code> - Specifies a high availability file system that is configured for Multi-AZ
        /// redundancy to tolerate temporary Availability Zone (AZ) unavailability, and supports SSD and HDD storage.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SINGLE_AZ_1</code> - (Default) Specifies a file system that is configured for single AZ redundancy,
        /// only supports SSD storage.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SINGLE_AZ_2</code> - Latest generation Single AZ file system.
        /// Specifies a file system that is configured for single AZ redundancy and supports SSD and HDD storage.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">Single-AZ and Multi-AZ File Systems</a>.</p>
        pub fn deployment_type(mut self, input: crate::model::WindowsDeploymentType) -> Self {
            self.deployment_type = Some(input);
            self
        }
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<crate::model::WindowsDeploymentType>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p>For <code>MULTI_AZ_1</code> deployment types, use this endpoint when performing administrative tasks on the file system using
        /// Amazon FSx Remote PowerShell.</p>
        /// <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this is the DNS name of the file system.</p>
        /// <p>This endpoint is temporarily unavailable when the file system is undergoing maintenance.</p>
        pub fn remote_administration_endpoint(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.remote_administration_endpoint = Some(input.into());
            self
        }
        pub fn set_remote_administration_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.remote_administration_endpoint = input;
            self
        }
        /// <p>For <code>MULTI_AZ_1</code> deployment types, it specifies the ID of the subnet where the preferred file server is located.
        /// Must be one of the two subnet IDs specified in <code>SubnetIds</code> property.
        /// Amazon FSx serves traffic from this subnet except in the event of a failover to the secondary file server.</p>
        /// <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this value is the same as that for <code>SubnetIDs</code>.
        /// For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html#single-multi-az-resources">Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
        pub fn preferred_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_subnet_id = Some(input.into());
            self
        }
        pub fn set_preferred_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_subnet_id = input;
            self
        }
        /// <p>For <code>MULTI_AZ_1</code> deployment types, the IP address of the primary, or preferred, file server.</p>
        /// <p>Use this IP address when mounting the file system on Linux SMB clients or Windows SMB clients that
        /// are not joined to a Microsoft Active Directory.
        /// Applicable for all Windows file system deployment types.
        /// This IP address is temporarily unavailable
        /// when the file system is undergoing maintenance. For Linux and Windows
        /// SMB clients that are joined to an Active Directory, use the file system's DNSName instead. For more information
        /// on mapping and mounting file shares, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/accessing-file-shares.html">Accessing File Shares</a>.</p>
        pub fn preferred_file_server_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_file_server_ip = Some(input.into());
            self
        }
        pub fn set_preferred_file_server_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_file_server_ip = input;
            self
        }
        /// <p>The throughput of the Amazon FSx file system, measured in megabytes per
        /// second.</p>
        pub fn throughput_capacity(mut self, input: i32) -> Self {
            self.throughput_capacity = Some(input);
            self
        }
        pub fn set_throughput_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput_capacity = input;
            self
        }
        pub fn maintenance_operations_in_progress(
            mut self,
            input: impl Into<crate::model::FileSystemMaintenanceOperation>,
        ) -> Self {
            let mut v = self.maintenance_operations_in_progress.unwrap_or_default();
            v.push(input.into());
            self.maintenance_operations_in_progress = Some(v);
            self
        }
        pub fn set_maintenance_operations_in_progress(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FileSystemMaintenanceOperation>>,
        ) -> Self {
            self.maintenance_operations_in_progress = input;
            self
        }
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>The preferred time to take daily automatic backups, in the UTC time zone.</p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables automatic
        /// backups. You can retain automatic backups for a maximum of 90 days.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
        /// This value defaults to false. If it's set to true, all tags on the file system are
        /// copied to all automatic backups and any user-initiated backups where the user
        /// doesn't specify any tags. If this value is true, and you specify one or more tags,
        /// only the specified tags are copied to backups. If you specify one or more tags when
        /// creating a user-initiated backup, no tags are copied from the file system,
        /// regardless of this value.</p>
        pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
            self.copy_tags_to_backups = Some(input);
            self
        }
        pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_backups = input;
            self
        }
        pub fn aliases(mut self, input: impl Into<crate::model::Alias>) -> Self {
            let mut v = self.aliases.unwrap_or_default();
            v.push(input.into());
            self.aliases = Some(v);
            self
        }
        pub fn set_aliases(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alias>>,
        ) -> Self {
            self.aliases = input;
            self
        }
        /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
        /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
        /// file system.</p>
        pub fn audit_log_configuration(
            mut self,
            input: crate::model::WindowsAuditLogConfiguration,
        ) -> Self {
            self.audit_log_configuration = Some(input);
            self
        }
        pub fn set_audit_log_configuration(
            mut self,
            input: std::option::Option<crate::model::WindowsAuditLogConfiguration>,
        ) -> Self {
            self.audit_log_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WindowsFileSystemConfiguration`](crate::model::WindowsFileSystemConfiguration)
        pub fn build(self) -> crate::model::WindowsFileSystemConfiguration {
            crate::model::WindowsFileSystemConfiguration {
                active_directory_id: self.active_directory_id,
                self_managed_active_directory_configuration: self
                    .self_managed_active_directory_configuration,
                deployment_type: self.deployment_type,
                remote_administration_endpoint: self.remote_administration_endpoint,
                preferred_subnet_id: self.preferred_subnet_id,
                preferred_file_server_ip: self.preferred_file_server_ip,
                throughput_capacity: self.throughput_capacity,
                maintenance_operations_in_progress: self.maintenance_operations_in_progress,
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                copy_tags_to_backups: self.copy_tags_to_backups,
                aliases: self.aliases,
                audit_log_configuration: self.audit_log_configuration,
            }
        }
    }
}
impl WindowsFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`WindowsFileSystemConfiguration`](crate::model::WindowsFileSystemConfiguration)
    pub fn builder() -> crate::model::windows_file_system_configuration::Builder {
        crate::model::windows_file_system_configuration::Builder::default()
    }
}

/// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
/// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
/// file system. For more information,
/// see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/file-access-auditing.html">
/// File access auditing</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WindowsAuditLogConfiguration {
    /// <p>Sets which attempt type is logged by Amazon FSx for file and folder accesses.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SUCCESS_ONLY</code> - only successful attempts to access files
    /// or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILURE_ONLY</code> - only failed attempts to access files
    /// or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
    /// failed attempts to access files or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DISABLED</code> - access auditing of files and folders is turned off.</p>
    /// </li>
    /// </ul>
    pub file_access_audit_log_level: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
    /// <p>Sets which attempt type is logged by Amazon FSx for file share accesses.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SUCCESS_ONLY</code> - only successful attempts to access file
    /// shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILURE_ONLY</code> - only failed attempts to access file
    /// shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
    /// failed attempts to access file shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DISABLED</code> - access auditing of file shares is turned off.</p>
    /// </li>
    /// </ul>
    pub file_share_access_audit_log_level:
        std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
    /// <p>The Amazon Resource Name (ARN) for the destination of the audit logs.
    /// The destination can be any Amazon CloudWatch Logs log group ARN or
    /// Amazon Kinesis Data Firehose delivery stream ARN.</p>
    /// <p>The name of the Amazon CloudWatch Logs log group must begin with
    /// the <code>/aws/fsx</code> prefix. The name of the Amazon Kinesis Data
    /// Firehouse delivery stream must begin with the <code>aws-fsx</code> prefix.</p>
    /// <p>The destination ARN (either CloudWatch Logs log group or Kinesis
    /// Data Firehose delivery stream) must be in the same AWS partition,
    /// AWS region, and AWS account as your Amazon FSx file system.</p>
    pub audit_log_destination: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WindowsAuditLogConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WindowsAuditLogConfiguration");
        formatter.field(
            "file_access_audit_log_level",
            &self.file_access_audit_log_level,
        );
        formatter.field(
            "file_share_access_audit_log_level",
            &self.file_share_access_audit_log_level,
        );
        formatter.field("audit_log_destination", &self.audit_log_destination);
        formatter.finish()
    }
}
/// See [`WindowsAuditLogConfiguration`](crate::model::WindowsAuditLogConfiguration)
pub mod windows_audit_log_configuration {
    /// A builder for [`WindowsAuditLogConfiguration`](crate::model::WindowsAuditLogConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_access_audit_log_level:
            std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        pub(crate) file_share_access_audit_log_level:
            std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        pub(crate) audit_log_destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets which attempt type is logged by Amazon FSx for file and folder accesses.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SUCCESS_ONLY</code> - only successful attempts to access files
        /// or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILURE_ONLY</code> - only failed attempts to access files
        /// or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
        /// failed attempts to access files or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DISABLED</code> - access auditing of files and folders is turned off.</p>
        /// </li>
        /// </ul>
        pub fn file_access_audit_log_level(
            mut self,
            input: crate::model::WindowsAccessAuditLogLevel,
        ) -> Self {
            self.file_access_audit_log_level = Some(input);
            self
        }
        pub fn set_file_access_audit_log_level(
            mut self,
            input: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        ) -> Self {
            self.file_access_audit_log_level = input;
            self
        }
        /// <p>Sets which attempt type is logged by Amazon FSx for file share accesses.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SUCCESS_ONLY</code> - only successful attempts to access file
        /// shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILURE_ONLY</code> - only failed attempts to access file
        /// shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
        /// failed attempts to access file shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DISABLED</code> - access auditing of file shares is turned off.</p>
        /// </li>
        /// </ul>
        pub fn file_share_access_audit_log_level(
            mut self,
            input: crate::model::WindowsAccessAuditLogLevel,
        ) -> Self {
            self.file_share_access_audit_log_level = Some(input);
            self
        }
        pub fn set_file_share_access_audit_log_level(
            mut self,
            input: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        ) -> Self {
            self.file_share_access_audit_log_level = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the destination of the audit logs.
        /// The destination can be any Amazon CloudWatch Logs log group ARN or
        /// Amazon Kinesis Data Firehose delivery stream ARN.</p>
        /// <p>The name of the Amazon CloudWatch Logs log group must begin with
        /// the <code>/aws/fsx</code> prefix. The name of the Amazon Kinesis Data
        /// Firehouse delivery stream must begin with the <code>aws-fsx</code> prefix.</p>
        /// <p>The destination ARN (either CloudWatch Logs log group or Kinesis
        /// Data Firehose delivery stream) must be in the same AWS partition,
        /// AWS region, and AWS account as your Amazon FSx file system.</p>
        pub fn audit_log_destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.audit_log_destination = Some(input.into());
            self
        }
        pub fn set_audit_log_destination(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.audit_log_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`WindowsAuditLogConfiguration`](crate::model::WindowsAuditLogConfiguration)
        pub fn build(self) -> crate::model::WindowsAuditLogConfiguration {
            crate::model::WindowsAuditLogConfiguration {
                file_access_audit_log_level: self.file_access_audit_log_level,
                file_share_access_audit_log_level: self.file_share_access_audit_log_level,
                audit_log_destination: self.audit_log_destination,
            }
        }
    }
}
impl WindowsAuditLogConfiguration {
    /// Creates a new builder-style object to manufacture [`WindowsAuditLogConfiguration`](crate::model::WindowsAuditLogConfiguration)
    pub fn builder() -> crate::model::windows_audit_log_configuration::Builder {
        crate::model::windows_audit_log_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WindowsAccessAuditLogLevel {
    Disabled,
    FailureOnly,
    SuccessAndFailure,
    SuccessOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WindowsAccessAuditLogLevel {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => WindowsAccessAuditLogLevel::Disabled,
            "FAILURE_ONLY" => WindowsAccessAuditLogLevel::FailureOnly,
            "SUCCESS_AND_FAILURE" => WindowsAccessAuditLogLevel::SuccessAndFailure,
            "SUCCESS_ONLY" => WindowsAccessAuditLogLevel::SuccessOnly,
            other => WindowsAccessAuditLogLevel::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WindowsAccessAuditLogLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WindowsAccessAuditLogLevel::from(s))
    }
}
impl WindowsAccessAuditLogLevel {
    pub fn as_str(&self) -> &str {
        match self {
            WindowsAccessAuditLogLevel::Disabled => "DISABLED",
            WindowsAccessAuditLogLevel::FailureOnly => "FAILURE_ONLY",
            WindowsAccessAuditLogLevel::SuccessAndFailure => "SUCCESS_AND_FAILURE",
            WindowsAccessAuditLogLevel::SuccessOnly => "SUCCESS_ONLY",
            WindowsAccessAuditLogLevel::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "DISABLED",
            "FAILURE_ONLY",
            "SUCCESS_AND_FAILURE",
            "SUCCESS_ONLY",
        ]
    }
}
impl AsRef<str> for WindowsAccessAuditLogLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A DNS alias that is associated with the file system. You can use a DNS alias to access a file system using
/// user-defined DNS names, in addition to the default DNS name
/// that Amazon FSx assigns to the file system. For more information, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>
/// in the <i>FSx for Windows File Server User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Alias {
    /// <p>The name of the DNS alias. The alias name has to meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
    /// </li>
    /// <li>
    /// <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
    /// </li>
    /// <li>
    /// <p>Cannot start or end with a hyphen.</p>
    /// </li>
    /// <li>
    /// <p>Can start with a numeric.</p>
    /// </li>
    /// </ul>
    /// <p>For DNS names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    /// as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Describes the state of the DNS alias.</p>
    /// <ul>
    /// <li>
    /// <p>AVAILABLE - The DNS alias is associated with an Amazon FSx file system.</p>
    /// </li>
    /// <li>
    /// <p>CREATING - Amazon FSx is creating the DNS alias and associating it with the file system.</p>
    /// </li>
    /// <li>
    /// <p>CREATE_FAILED - Amazon FSx was unable to associate the DNS alias with the file system.</p>
    /// </li>
    /// <li>
    /// <p>DELETING - Amazon FSx is disassociating the DNS alias from the file system and deleting it.</p>
    /// </li>
    /// <li>
    /// <p>DELETE_FAILED - Amazon FSx was unable to disassocate the DNS alias from the file system.</p>
    /// </li>
    /// </ul>
    pub lifecycle: std::option::Option<crate::model::AliasLifecycle>,
}
impl std::fmt::Debug for Alias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Alias");
        formatter.field("name", &self.name);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.finish()
    }
}
/// See [`Alias`](crate::model::Alias)
pub mod alias {
    /// A builder for [`Alias`](crate::model::Alias)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::AliasLifecycle>,
    }
    impl Builder {
        /// <p>The name of the DNS alias. The alias name has to meet the following requirements:</p>
        /// <ul>
        /// <li>
        /// <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
        /// </li>
        /// <li>
        /// <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
        /// </li>
        /// <li>
        /// <p>Cannot start or end with a hyphen.</p>
        /// </li>
        /// <li>
        /// <p>Can start with a numeric.</p>
        /// </li>
        /// </ul>
        /// <p>For DNS names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
        /// as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Describes the state of the DNS alias.</p>
        /// <ul>
        /// <li>
        /// <p>AVAILABLE - The DNS alias is associated with an Amazon FSx file system.</p>
        /// </li>
        /// <li>
        /// <p>CREATING - Amazon FSx is creating the DNS alias and associating it with the file system.</p>
        /// </li>
        /// <li>
        /// <p>CREATE_FAILED - Amazon FSx was unable to associate the DNS alias with the file system.</p>
        /// </li>
        /// <li>
        /// <p>DELETING - Amazon FSx is disassociating the DNS alias from the file system and deleting it.</p>
        /// </li>
        /// <li>
        /// <p>DELETE_FAILED - Amazon FSx was unable to disassocate the DNS alias from the file system.</p>
        /// </li>
        /// </ul>
        pub fn lifecycle(mut self, input: crate::model::AliasLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::AliasLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// Consumes the builder and constructs a [`Alias`](crate::model::Alias)
        pub fn build(self) -> crate::model::Alias {
            crate::model::Alias {
                name: self.name,
                lifecycle: self.lifecycle,
            }
        }
    }
}
impl Alias {
    /// Creates a new builder-style object to manufacture [`Alias`](crate::model::Alias)
    pub fn builder() -> crate::model::alias::Builder {
        crate::model::alias::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AliasLifecycle {
    Available,
    CreateFailed,
    Creating,
    DeleteFailed,
    Deleting,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AliasLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => AliasLifecycle::Available,
            "CREATE_FAILED" => AliasLifecycle::CreateFailed,
            "CREATING" => AliasLifecycle::Creating,
            "DELETE_FAILED" => AliasLifecycle::DeleteFailed,
            "DELETING" => AliasLifecycle::Deleting,
            other => AliasLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AliasLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AliasLifecycle::from(s))
    }
}
impl AliasLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            AliasLifecycle::Available => "AVAILABLE",
            AliasLifecycle::CreateFailed => "CREATE_FAILED",
            AliasLifecycle::Creating => "CREATING",
            AliasLifecycle::DeleteFailed => "DELETE_FAILED",
            AliasLifecycle::Deleting => "DELETING",
            AliasLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CREATE_FAILED",
            "CREATING",
            "DELETE_FAILED",
            "DELETING",
        ]
    }
}
impl AsRef<str> for AliasLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An enumeration specifying the currently ongoing maintenance operation.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemMaintenanceOperation {
    BackingUp,
    Patching,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemMaintenanceOperation {
    fn from(s: &str) -> Self {
        match s {
            "BACKING_UP" => FileSystemMaintenanceOperation::BackingUp,
            "PATCHING" => FileSystemMaintenanceOperation::Patching,
            other => FileSystemMaintenanceOperation::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemMaintenanceOperation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemMaintenanceOperation::from(s))
    }
}
impl FileSystemMaintenanceOperation {
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemMaintenanceOperation::BackingUp => "BACKING_UP",
            FileSystemMaintenanceOperation::Patching => "PATCHING",
            FileSystemMaintenanceOperation::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["BACKING_UP", "PATCHING"]
    }
}
impl AsRef<str> for FileSystemMaintenanceOperation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WindowsDeploymentType {
    MultiAz1,
    SingleAz1,
    SingleAz2,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WindowsDeploymentType {
    fn from(s: &str) -> Self {
        match s {
            "MULTI_AZ_1" => WindowsDeploymentType::MultiAz1,
            "SINGLE_AZ_1" => WindowsDeploymentType::SingleAz1,
            "SINGLE_AZ_2" => WindowsDeploymentType::SingleAz2,
            other => WindowsDeploymentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WindowsDeploymentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WindowsDeploymentType::from(s))
    }
}
impl WindowsDeploymentType {
    pub fn as_str(&self) -> &str {
        match self {
            WindowsDeploymentType::MultiAz1 => "MULTI_AZ_1",
            WindowsDeploymentType::SingleAz1 => "SINGLE_AZ_1",
            WindowsDeploymentType::SingleAz2 => "SINGLE_AZ_2",
            WindowsDeploymentType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["MULTI_AZ_1", "SINGLE_AZ_1", "SINGLE_AZ_2"]
    }
}
impl AsRef<str> for WindowsDeploymentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
/// which the Windows File Server instance is joined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SelfManagedActiveDirectoryAttributes {
    /// <p>The fully qualified domain name of the self-managed AD directory.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The fully qualified distinguished name of the organizational unit within the
    /// self-managed AD directory to which the Windows File Server instance is joined.</p>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    /// <p>The name of the domain group whose members have administrative privileges for the FSx
    /// file system.</p>
    pub file_system_administrators_group: std::option::Option<std::string::String>,
    /// <p>The user name for the service account on your self-managed AD domain that FSx uses to
    /// join to your AD domain.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    /// self-managed AD directory.</p>
    pub dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SelfManagedActiveDirectoryAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SelfManagedActiveDirectoryAttributes");
        formatter.field("domain_name", &self.domain_name);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.field(
            "file_system_administrators_group",
            &self.file_system_administrators_group,
        );
        formatter.field("user_name", &self.user_name);
        formatter.field("dns_ips", &self.dns_ips);
        formatter.finish()
    }
}
/// See [`SelfManagedActiveDirectoryAttributes`](crate::model::SelfManagedActiveDirectoryAttributes)
pub mod self_managed_active_directory_attributes {
    /// A builder for [`SelfManagedActiveDirectoryAttributes`](crate::model::SelfManagedActiveDirectoryAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
        pub(crate) file_system_administrators_group: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The fully qualified domain name of the self-managed AD directory.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The fully qualified distinguished name of the organizational unit within the
        /// self-managed AD directory to which the Windows File Server instance is joined.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// <p>The name of the domain group whose members have administrative privileges for the FSx
        /// file system.</p>
        pub fn file_system_administrators_group(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.file_system_administrators_group = Some(input.into());
            self
        }
        pub fn set_file_system_administrators_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_administrators_group = input;
            self
        }
        /// <p>The user name for the service account on your self-managed AD domain that FSx uses to
        /// join to your AD domain.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        pub fn dns_ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ips.unwrap_or_default();
            v.push(input.into());
            self.dns_ips = Some(v);
            self
        }
        pub fn set_dns_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ips = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManagedActiveDirectoryAttributes`](crate::model::SelfManagedActiveDirectoryAttributes)
        pub fn build(self) -> crate::model::SelfManagedActiveDirectoryAttributes {
            crate::model::SelfManagedActiveDirectoryAttributes {
                domain_name: self.domain_name,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
                file_system_administrators_group: self.file_system_administrators_group,
                user_name: self.user_name,
                dns_ips: self.dns_ips,
            }
        }
    }
}
impl SelfManagedActiveDirectoryAttributes {
    /// Creates a new builder-style object to manufacture [`SelfManagedActiveDirectoryAttributes`](crate::model::SelfManagedActiveDirectoryAttributes)
    pub fn builder() -> crate::model::self_managed_active_directory_attributes::Builder {
        crate::model::self_managed_active_directory_attributes::Builder::default()
    }
}

/// <p>Specifies a key-value pair for a resource tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>A value that specifies the <code>TagKey</code>, the name of the tag. Tag keys must
    /// be unique for the resource to which they are attached.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A value that specifies the <code>TagValue</code>, the value assigned to the
    /// corresponding tag key. Tag values can be null and don't have to be unique in a tag set.
    /// For example, you can have a key-value pair in a tag set of <code>finances : April</code>
    /// and also of <code>payroll : April</code>.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A value that specifies the <code>TagKey</code>, the name of the tag. Tag keys must
        /// be unique for the resource to which they are attached.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A value that specifies the <code>TagValue</code>, the value assigned to the
        /// corresponding tag key. Tag values can be null and don't have to be unique in a tag set.
        /// For example, you can have a key-value pair in a tag set of <code>finances : April</code>
        /// and also of <code>payroll : April</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The storage type for your Amazon FSx file system.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StorageType {
    Hdd,
    Ssd,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StorageType {
    fn from(s: &str) -> Self {
        match s {
            "HDD" => StorageType::Hdd,
            "SSD" => StorageType::Ssd,
            other => StorageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StorageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StorageType::from(s))
    }
}
impl StorageType {
    pub fn as_str(&self) -> &str {
        match self {
            StorageType::Hdd => "HDD",
            StorageType::Ssd => "SSD",
            StorageType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["HDD", "SSD"]
    }
}
impl AsRef<str> for StorageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure providing details of any failures that occur when creating the file system
/// has failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileSystemFailureDetails {
    /// <p>A message describing any failures that occurred during file system creation.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileSystemFailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileSystemFailureDetails");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`FileSystemFailureDetails`](crate::model::FileSystemFailureDetails)
pub mod file_system_failure_details {
    /// A builder for [`FileSystemFailureDetails`](crate::model::FileSystemFailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing any failures that occurred during file system creation.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileSystemFailureDetails`](crate::model::FileSystemFailureDetails)
        pub fn build(self) -> crate::model::FileSystemFailureDetails {
            crate::model::FileSystemFailureDetails {
                message: self.message,
            }
        }
    }
}
impl FileSystemFailureDetails {
    /// Creates a new builder-style object to manufacture [`FileSystemFailureDetails`](crate::model::FileSystemFailureDetails)
    pub fn builder() -> crate::model::file_system_failure_details::Builder {
        crate::model::file_system_failure_details::Builder::default()
    }
}

/// <p>The lifecycle status of the file system.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemLifecycle {
    Available,
    Creating,
    Deleting,
    Failed,
    Misconfigured,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => FileSystemLifecycle::Available,
            "CREATING" => FileSystemLifecycle::Creating,
            "DELETING" => FileSystemLifecycle::Deleting,
            "FAILED" => FileSystemLifecycle::Failed,
            "MISCONFIGURED" => FileSystemLifecycle::Misconfigured,
            "UPDATING" => FileSystemLifecycle::Updating,
            other => FileSystemLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemLifecycle::from(s))
    }
}
impl FileSystemLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemLifecycle::Available => "AVAILABLE",
            FileSystemLifecycle::Creating => "CREATING",
            FileSystemLifecycle::Deleting => "DELETING",
            FileSystemLifecycle::Failed => "FAILED",
            FileSystemLifecycle::Misconfigured => "MISCONFIGURED",
            FileSystemLifecycle::Updating => "UPDATING",
            FileSystemLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "CREATING",
            "DELETING",
            "FAILED",
            "MISCONFIGURED",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for FileSystemLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The type of file system.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FileSystemType {
    Lustre,
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FileSystemType {
    fn from(s: &str) -> Self {
        match s {
            "LUSTRE" => FileSystemType::Lustre,
            "WINDOWS" => FileSystemType::Windows,
            other => FileSystemType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FileSystemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FileSystemType::from(s))
    }
}
impl FileSystemType {
    pub fn as_str(&self) -> &str {
        match self {
            FileSystemType::Lustre => "LUSTRE",
            FileSystemType::Windows => "WINDOWS",
            FileSystemType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LUSTRE", "WINDOWS"]
    }
}
impl AsRef<str> for FileSystemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration object for Amazon FSx for Lustre file systems used in the
/// <code>UpdateFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFileSystemLustreConfiguration {
    /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
    /// Use this property to choose how Amazon FSx keeps your file and directory listing up to date
    /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
    /// have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    /// file and directory listings from the linked S3 bucket
    /// when the file system is created. FSx does not update the file and directory
    /// listing for any new or changed objects after choosing this option.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    /// directory listings of any new objects added to the linked S3 bucket that
    /// do not currently exist in the FSx file system. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    /// file and directory listings of any new objects added to the S3 bucket and any
    /// existing objects that are changed in the S3 bucket after you choose this option.
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    pub auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
    /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
    /// can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - Data compression is turned off for
    /// the file system.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LZ4</code> - Data compression is turned on with the LZ4
    /// algorithm.</p>
    /// </li>
    /// </ul>
    /// <p>If you don't use <code>DataCompressionType</code>, the file system retains
    /// its current data compression configuration.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub data_compression_type: std::option::Option<crate::model::DataCompressionType>,
}
impl std::fmt::Debug for UpdateFileSystemLustreConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFileSystemLustreConfiguration");
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("auto_import_policy", &self.auto_import_policy);
        formatter.field("data_compression_type", &self.data_compression_type);
        formatter.finish()
    }
}
/// See [`UpdateFileSystemLustreConfiguration`](crate::model::UpdateFileSystemLustreConfiguration)
pub mod update_file_system_lustre_configuration {
    /// A builder for [`UpdateFileSystemLustreConfiguration`](crate::model::UpdateFileSystemLustreConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
        pub(crate) data_compression_type: std::option::Option<crate::model::DataCompressionType>,
    }
    impl Builder {
        /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
        /// Use this property to choose how Amazon FSx keeps your file and directory listing up to date
        /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
        /// have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        /// file and directory listings from the linked S3 bucket
        /// when the file system is created. FSx does not update the file and directory
        /// listing for any new or changed objects after choosing this option.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        /// directory listings of any new objects added to the linked S3 bucket that
        /// do not currently exist in the FSx file system. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        /// file and directory listings of any new objects added to the S3 bucket and any
        /// existing objects that are changed in the S3 bucket after you choose this option.
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        pub fn auto_import_policy(mut self, input: crate::model::AutoImportPolicyType) -> Self {
            self.auto_import_policy = Some(input);
            self
        }
        pub fn set_auto_import_policy(
            mut self,
            input: std::option::Option<crate::model::AutoImportPolicyType>,
        ) -> Self {
            self.auto_import_policy = input;
            self
        }
        /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
        /// can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - Data compression is turned off for
        /// the file system.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LZ4</code> - Data compression is turned on with the LZ4
        /// algorithm.</p>
        /// </li>
        /// </ul>
        /// <p>If you don't use <code>DataCompressionType</code>, the file system retains
        /// its current data compression configuration.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        pub fn data_compression_type(mut self, input: crate::model::DataCompressionType) -> Self {
            self.data_compression_type = Some(input);
            self
        }
        pub fn set_data_compression_type(
            mut self,
            input: std::option::Option<crate::model::DataCompressionType>,
        ) -> Self {
            self.data_compression_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFileSystemLustreConfiguration`](crate::model::UpdateFileSystemLustreConfiguration)
        pub fn build(self) -> crate::model::UpdateFileSystemLustreConfiguration {
            crate::model::UpdateFileSystemLustreConfiguration {
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                auto_import_policy: self.auto_import_policy,
                data_compression_type: self.data_compression_type,
            }
        }
    }
}
impl UpdateFileSystemLustreConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateFileSystemLustreConfiguration`](crate::model::UpdateFileSystemLustreConfiguration)
    pub fn builder() -> crate::model::update_file_system_lustre_configuration::Builder {
        crate::model::update_file_system_lustre_configuration::Builder::default()
    }
}

/// <p>Updates the configuration for an existing Amazon FSx for Windows
/// File Server file system. Amazon FSx only overwrites existing properties with non-null values
/// provided in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateFileSystemWindowsConfiguration {
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone. Where d is the weekday number, from 1 through 7, with 1 = Monday and 7 = Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>The preferred time to start the daily automatic backup, in the UTC time zone, for example, <code>02:00</code>
    /// </p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic daily backups. Setting this to zero (0) disables automatic daily
    /// backups. You can retain automatic daily backups for a maximum of 90 days. For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#automatic-backups">Working with Automatic Daily Backups</a>.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>Sets the target value for a file system's throughput capacity, in MB/s, that you are updating the file system to. Valid values are
    /// 8, 16, 32, 64, 128, 256, 512, 1024, 2048. You cannot make a throughput capacity update request if there is an existing throughput capacity update request in progress. For more information,
    /// see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-throughput-capacity.html">Managing Throughput Capacity</a>.</p>
    pub throughput_capacity: std::option::Option<i32>,
    /// <p>The configuration Amazon FSx uses to join the Windows File Server instance to the
    /// self-managed Microsoft AD directory. You cannot make a self-managed Microsoft AD update request if there is an existing self-managed Microsoft AD update request in progress.</p>
    pub self_managed_active_directory_configuration:
        std::option::Option<crate::model::SelfManagedActiveDirectoryConfigurationUpdates>,
    /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
    /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
    /// file system..</p>
    pub audit_log_configuration:
        std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
}
impl std::fmt::Debug for UpdateFileSystemWindowsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateFileSystemWindowsConfiguration");
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("throughput_capacity", &self.throughput_capacity);
        formatter.field(
            "self_managed_active_directory_configuration",
            &self.self_managed_active_directory_configuration,
        );
        formatter.field("audit_log_configuration", &self.audit_log_configuration);
        formatter.finish()
    }
}
/// See [`UpdateFileSystemWindowsConfiguration`](crate::model::UpdateFileSystemWindowsConfiguration)
pub mod update_file_system_windows_configuration {
    /// A builder for [`UpdateFileSystemWindowsConfiguration`](crate::model::UpdateFileSystemWindowsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) throughput_capacity: std::option::Option<i32>,
        pub(crate) self_managed_active_directory_configuration:
            std::option::Option<crate::model::SelfManagedActiveDirectoryConfigurationUpdates>,
        pub(crate) audit_log_configuration:
            std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
    }
    impl Builder {
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone. Where d is the weekday number, from 1 through 7, with 1 = Monday and 7 = Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>The preferred time to start the daily automatic backup, in the UTC time zone, for example, <code>02:00</code>
        /// </p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic daily backups. Setting this to zero (0) disables automatic daily
        /// backups. You can retain automatic daily backups for a maximum of 90 days. For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#automatic-backups">Working with Automatic Daily Backups</a>.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p>Sets the target value for a file system's throughput capacity, in MB/s, that you are updating the file system to. Valid values are
        /// 8, 16, 32, 64, 128, 256, 512, 1024, 2048. You cannot make a throughput capacity update request if there is an existing throughput capacity update request in progress. For more information,
        /// see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-throughput-capacity.html">Managing Throughput Capacity</a>.</p>
        pub fn throughput_capacity(mut self, input: i32) -> Self {
            self.throughput_capacity = Some(input);
            self
        }
        pub fn set_throughput_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput_capacity = input;
            self
        }
        /// <p>The configuration Amazon FSx uses to join the Windows File Server instance to the
        /// self-managed Microsoft AD directory. You cannot make a self-managed Microsoft AD update request if there is an existing self-managed Microsoft AD update request in progress.</p>
        pub fn self_managed_active_directory_configuration(
            mut self,
            input: crate::model::SelfManagedActiveDirectoryConfigurationUpdates,
        ) -> Self {
            self.self_managed_active_directory_configuration = Some(input);
            self
        }
        pub fn set_self_managed_active_directory_configuration(
            mut self,
            input: std::option::Option<
                crate::model::SelfManagedActiveDirectoryConfigurationUpdates,
            >,
        ) -> Self {
            self.self_managed_active_directory_configuration = input;
            self
        }
        /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
        /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
        /// file system..</p>
        pub fn audit_log_configuration(
            mut self,
            input: crate::model::WindowsAuditLogCreateConfiguration,
        ) -> Self {
            self.audit_log_configuration = Some(input);
            self
        }
        pub fn set_audit_log_configuration(
            mut self,
            input: std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
        ) -> Self {
            self.audit_log_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFileSystemWindowsConfiguration`](crate::model::UpdateFileSystemWindowsConfiguration)
        pub fn build(self) -> crate::model::UpdateFileSystemWindowsConfiguration {
            crate::model::UpdateFileSystemWindowsConfiguration {
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                throughput_capacity: self.throughput_capacity,
                self_managed_active_directory_configuration: self
                    .self_managed_active_directory_configuration,
                audit_log_configuration: self.audit_log_configuration,
            }
        }
    }
}
impl UpdateFileSystemWindowsConfiguration {
    /// Creates a new builder-style object to manufacture [`UpdateFileSystemWindowsConfiguration`](crate::model::UpdateFileSystemWindowsConfiguration)
    pub fn builder() -> crate::model::update_file_system_windows_configuration::Builder {
        crate::model::update_file_system_windows_configuration::Builder::default()
    }
}

/// <p>The Windows file access auditing configuration used when creating
/// or updating an Amazon FSx for Windows File Server file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WindowsAuditLogCreateConfiguration {
    /// <p>Sets which attempt type is logged by Amazon FSx for file and folder accesses.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SUCCESS_ONLY</code> - only successful attempts to access files
    /// or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILURE_ONLY</code> - only failed attempts to access files
    /// or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
    /// failed attempts to access files or folders are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DISABLED</code> - access auditing of files and folders is turned off.</p>
    /// </li>
    /// </ul>
    pub file_access_audit_log_level: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
    /// <p>Sets which attempt type is logged by Amazon FSx for file share accesses.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SUCCESS_ONLY</code> - only successful attempts to access file
    /// shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILURE_ONLY</code> - only failed attempts to access file
    /// shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
    /// failed attempts to access file shares are logged.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DISABLED</code> - access auditing of file shares is turned off.</p>
    /// </li>
    /// </ul>
    pub file_share_access_audit_log_level:
        std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
    /// <p>The Amazon Resource Name (ARN) that specifies the destination of the audit logs.</p>
    /// <p>The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis
    /// Data Firehose delivery stream ARN, with the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>The destination ARN that you provide (either CloudWatch Logs log group
    /// or Kinesis Data Firehose delivery stream) must be in the same AWS partition,
    /// AWS region, and AWS account as your Amazon FSx file system.</p>
    /// </li>
    /// <li>
    /// <p>The name of the Amazon CloudWatch Logs log group must begin with
    /// the <code>/aws/fsx</code> prefix. The name of the Amazon Kinesis Data
    /// Firehouse delivery stream must begin with the <code>aws-fsx</code> prefix.</p>
    /// </li>
    /// <li>
    /// <p>If you do not provide a destination in <code>AuditLogDestination</code>,
    /// Amazon FSx will create and use a log stream in the CloudWatch Logs
    /// <code>/aws/fsx/windows</code> log group.</p>
    /// </li>
    /// <li>
    /// <p>If <code>AuditLogDestination</code> is provided and the resource does not
    /// exist, the request will fail with a <code>BadRequest</code> error.</p>
    /// </li>
    /// <li>
    /// <p>If <code>FileAccessAuditLogLevel</code> and <code>FileShareAccessAuditLogLevel</code>
    /// are both set to <code>DISABLED</code>, you cannot specify a destination in
    /// <code>AuditLogDestination</code>.</p>
    /// </li>
    /// </ul>
    pub audit_log_destination: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WindowsAuditLogCreateConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WindowsAuditLogCreateConfiguration");
        formatter.field(
            "file_access_audit_log_level",
            &self.file_access_audit_log_level,
        );
        formatter.field(
            "file_share_access_audit_log_level",
            &self.file_share_access_audit_log_level,
        );
        formatter.field("audit_log_destination", &self.audit_log_destination);
        formatter.finish()
    }
}
/// See [`WindowsAuditLogCreateConfiguration`](crate::model::WindowsAuditLogCreateConfiguration)
pub mod windows_audit_log_create_configuration {
    /// A builder for [`WindowsAuditLogCreateConfiguration`](crate::model::WindowsAuditLogCreateConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_access_audit_log_level:
            std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        pub(crate) file_share_access_audit_log_level:
            std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        pub(crate) audit_log_destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets which attempt type is logged by Amazon FSx for file and folder accesses.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SUCCESS_ONLY</code> - only successful attempts to access files
        /// or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILURE_ONLY</code> - only failed attempts to access files
        /// or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
        /// failed attempts to access files or folders are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DISABLED</code> - access auditing of files and folders is turned off.</p>
        /// </li>
        /// </ul>
        pub fn file_access_audit_log_level(
            mut self,
            input: crate::model::WindowsAccessAuditLogLevel,
        ) -> Self {
            self.file_access_audit_log_level = Some(input);
            self
        }
        pub fn set_file_access_audit_log_level(
            mut self,
            input: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        ) -> Self {
            self.file_access_audit_log_level = input;
            self
        }
        /// <p>Sets which attempt type is logged by Amazon FSx for file share accesses.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SUCCESS_ONLY</code> - only successful attempts to access file
        /// shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILURE_ONLY</code> - only failed attempts to access file
        /// shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCESS_AND_FAILURE</code> - both successful attempts and
        /// failed attempts to access file shares are logged.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DISABLED</code> - access auditing of file shares is turned off.</p>
        /// </li>
        /// </ul>
        pub fn file_share_access_audit_log_level(
            mut self,
            input: crate::model::WindowsAccessAuditLogLevel,
        ) -> Self {
            self.file_share_access_audit_log_level = Some(input);
            self
        }
        pub fn set_file_share_access_audit_log_level(
            mut self,
            input: std::option::Option<crate::model::WindowsAccessAuditLogLevel>,
        ) -> Self {
            self.file_share_access_audit_log_level = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that specifies the destination of the audit logs.</p>
        /// <p>The destination can be any Amazon CloudWatch Logs log group ARN or Amazon Kinesis
        /// Data Firehose delivery stream ARN, with the following requirements:</p>
        /// <ul>
        /// <li>
        /// <p>The destination ARN that you provide (either CloudWatch Logs log group
        /// or Kinesis Data Firehose delivery stream) must be in the same AWS partition,
        /// AWS region, and AWS account as your Amazon FSx file system.</p>
        /// </li>
        /// <li>
        /// <p>The name of the Amazon CloudWatch Logs log group must begin with
        /// the <code>/aws/fsx</code> prefix. The name of the Amazon Kinesis Data
        /// Firehouse delivery stream must begin with the <code>aws-fsx</code> prefix.</p>
        /// </li>
        /// <li>
        /// <p>If you do not provide a destination in <code>AuditLogDestination</code>,
        /// Amazon FSx will create and use a log stream in the CloudWatch Logs
        /// <code>/aws/fsx/windows</code> log group.</p>
        /// </li>
        /// <li>
        /// <p>If <code>AuditLogDestination</code> is provided and the resource does not
        /// exist, the request will fail with a <code>BadRequest</code> error.</p>
        /// </li>
        /// <li>
        /// <p>If <code>FileAccessAuditLogLevel</code> and <code>FileShareAccessAuditLogLevel</code>
        /// are both set to <code>DISABLED</code>, you cannot specify a destination in
        /// <code>AuditLogDestination</code>.</p>
        /// </li>
        /// </ul>
        pub fn audit_log_destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.audit_log_destination = Some(input.into());
            self
        }
        pub fn set_audit_log_destination(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.audit_log_destination = input;
            self
        }
        /// Consumes the builder and constructs a [`WindowsAuditLogCreateConfiguration`](crate::model::WindowsAuditLogCreateConfiguration)
        pub fn build(self) -> crate::model::WindowsAuditLogCreateConfiguration {
            crate::model::WindowsAuditLogCreateConfiguration {
                file_access_audit_log_level: self.file_access_audit_log_level,
                file_share_access_audit_log_level: self.file_share_access_audit_log_level,
                audit_log_destination: self.audit_log_destination,
            }
        }
    }
}
impl WindowsAuditLogCreateConfiguration {
    /// Creates a new builder-style object to manufacture [`WindowsAuditLogCreateConfiguration`](crate::model::WindowsAuditLogCreateConfiguration)
    pub fn builder() -> crate::model::windows_audit_log_create_configuration::Builder {
        crate::model::windows_audit_log_create_configuration::Builder::default()
    }
}

/// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to a
/// self-managed Microsoft Active Directory (AD) directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SelfManagedActiveDirectoryConfigurationUpdates {
    /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to
    /// your AD domain. This account must have the permission to join
    /// computers to the domain in the organizational unit provided in
    /// <code>OrganizationalUnitDistinguishedName</code>.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The password for the service account on your self-managed AD domain that Amazon FSx will use to join to
    /// your AD domain.</p>
    pub password: std::option::Option<std::string::String>,
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    /// self-managed AD directory.</p>
    pub dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SelfManagedActiveDirectoryConfigurationUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SelfManagedActiveDirectoryConfigurationUpdates");
        formatter.field("user_name", &self.user_name);
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.field("dns_ips", &self.dns_ips);
        formatter.finish()
    }
}
/// See [`SelfManagedActiveDirectoryConfigurationUpdates`](crate::model::SelfManagedActiveDirectoryConfigurationUpdates)
pub mod self_managed_active_directory_configuration_updates {
    /// A builder for [`SelfManagedActiveDirectoryConfigurationUpdates`](crate::model::SelfManagedActiveDirectoryConfigurationUpdates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to
        /// your AD domain. This account must have the permission to join
        /// computers to the domain in the organizational unit provided in
        /// <code>OrganizationalUnitDistinguishedName</code>.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The password for the service account on your self-managed AD domain that Amazon FSx will use to join to
        /// your AD domain.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        pub fn dns_ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ips.unwrap_or_default();
            v.push(input.into());
            self.dns_ips = Some(v);
            self
        }
        pub fn set_dns_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ips = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManagedActiveDirectoryConfigurationUpdates`](crate::model::SelfManagedActiveDirectoryConfigurationUpdates)
        pub fn build(self) -> crate::model::SelfManagedActiveDirectoryConfigurationUpdates {
            crate::model::SelfManagedActiveDirectoryConfigurationUpdates {
                user_name: self.user_name,
                password: self.password,
                dns_ips: self.dns_ips,
            }
        }
    }
}
impl SelfManagedActiveDirectoryConfigurationUpdates {
    /// Creates a new builder-style object to manufacture [`SelfManagedActiveDirectoryConfigurationUpdates`](crate::model::SelfManagedActiveDirectoryConfigurationUpdates)
    pub fn builder() -> crate::model::self_managed_active_directory_configuration_updates::Builder {
        crate::model::self_managed_active_directory_configuration_updates::Builder::default()
    }
}

/// <p>A description of the data repository task. You use data repository tasks
/// to perform bulk transfer operations between your Amazon FSx file system and its linked data
/// repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTask {
    /// <p>The system-generated, unique 17-digit ID of the data repository task.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The lifecycle status of the data repository task, as follows:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - Amazon FSx has not started the task.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
    /// The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CANCELING</code> - FSx is in process of canceling the task.</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>You cannot delete an FSx for Lustre file system if there are data
    /// repository tasks for the file system in the <code>PENDING</code> or <code>EXECUTING</code> states.
    /// Please retry when the data repository task is finished (with a status of <code>CANCELED</code>, <code>SUCCEEDED</code>, or <code>FAILED</code>).
    /// You can use the DescribeDataRepositoryTask action to monitor the task status. Contact the FSx team if you need to delete your file system immediately.</p>
    /// </note>
    pub lifecycle: std::option::Option<crate::model::DataRepositoryTaskLifecycle>,
    /// <p>The type of data repository task; EXPORT_TO_REPOSITORY is the only type currently supported.</p>
    pub r#type: std::option::Option<crate::model::DataRepositoryTaskType>,
    /// <p>The time that the resource was created, in seconds (since 1970-01-01T00:00:00Z),
    /// also known as Unix time.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that Amazon FSx began processing the task.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time that Amazon FSx completed processing the task, populated after the task is complete.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
    /// resources. We require an ARN when you need to specify a resource unambiguously across
    /// all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
    /// and AWS Service Namespaces</a> in the <i>AWS General
    /// Reference</i>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>An array of paths on the Amazon FSx for Lustre file system that specify the data for the data repository task to process.
    /// For example, in an EXPORT_TO_REPOSITORY task, the paths specify which data to export to the linked data repository.</p>
    /// <p>(Default) If <code>Paths</code> is not specified, Amazon FSx uses the file system root directory.</p>
    pub paths: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Failure message describing why the task failed, it is populated only when <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
    pub failure_details: std::option::Option<crate::model::DataRepositoryTaskFailureDetails>,
    /// <p>Provides the status of the number of files that the task has processed successfully and failed to process.</p>
    pub status: std::option::Option<crate::model::DataRepositoryTaskStatus>,
    /// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
    /// FSx delivers the report to the file system's linked data repository in Amazon S3,
    /// using the path specified in the report <code>Path</code> parameter.
    /// You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
    pub report: std::option::Option<crate::model::CompletionReport>,
}
impl std::fmt::Debug for DataRepositoryTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTask");
        formatter.field("task_id", &self.task_id);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("r#type", &self.r#type);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("paths", &self.paths);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("status", &self.status);
        formatter.field("report", &self.report);
        formatter.finish()
    }
}
/// See [`DataRepositoryTask`](crate::model::DataRepositoryTask)
pub mod data_repository_task {
    /// A builder for [`DataRepositoryTask`](crate::model::DataRepositoryTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::DataRepositoryTaskLifecycle>,
        pub(crate) r#type: std::option::Option<crate::model::DataRepositoryTaskType>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) paths: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) failure_details:
            std::option::Option<crate::model::DataRepositoryTaskFailureDetails>,
        pub(crate) status: std::option::Option<crate::model::DataRepositoryTaskStatus>,
        pub(crate) report: std::option::Option<crate::model::CompletionReport>,
    }
    impl Builder {
        /// <p>The system-generated, unique 17-digit ID of the data repository task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The lifecycle status of the data repository task, as follows:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - Amazon FSx has not started the task.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
        /// The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CANCELING</code> - FSx is in process of canceling the task.</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>You cannot delete an FSx for Lustre file system if there are data
        /// repository tasks for the file system in the <code>PENDING</code> or <code>EXECUTING</code> states.
        /// Please retry when the data repository task is finished (with a status of <code>CANCELED</code>, <code>SUCCEEDED</code>, or <code>FAILED</code>).
        /// You can use the DescribeDataRepositoryTask action to monitor the task status. Contact the FSx team if you need to delete your file system immediately.</p>
        /// </note>
        pub fn lifecycle(mut self, input: crate::model::DataRepositoryTaskLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryTaskLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>The type of data repository task; EXPORT_TO_REPOSITORY is the only type currently supported.</p>
        pub fn r#type(mut self, input: crate::model::DataRepositoryTaskType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryTaskType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The time that the resource was created, in seconds (since 1970-01-01T00:00:00Z),
        /// also known as Unix time.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time that Amazon FSx began processing the task.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time that Amazon FSx completed processing the task, populated after the task is complete.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
        /// resources. We require an ARN when you need to specify a resource unambiguously across
        /// all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
        /// and AWS Service Namespaces</a> in the <i>AWS General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        pub fn paths(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.paths.unwrap_or_default();
            v.push(input.into());
            self.paths = Some(v);
            self
        }
        pub fn set_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.paths = input;
            self
        }
        /// <p>Failure message describing why the task failed, it is populated only when <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
        pub fn failure_details(
            mut self,
            input: crate::model::DataRepositoryTaskFailureDetails,
        ) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryTaskFailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>Provides the status of the number of files that the task has processed successfully and failed to process.</p>
        pub fn status(mut self, input: crate::model::DataRepositoryTaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryTaskStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
        /// FSx delivers the report to the file system's linked data repository in Amazon S3,
        /// using the path specified in the report <code>Path</code> parameter.
        /// You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
        pub fn report(mut self, input: crate::model::CompletionReport) -> Self {
            self.report = Some(input);
            self
        }
        pub fn set_report(
            mut self,
            input: std::option::Option<crate::model::CompletionReport>,
        ) -> Self {
            self.report = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTask`](crate::model::DataRepositoryTask)
        pub fn build(self) -> crate::model::DataRepositoryTask {
            crate::model::DataRepositoryTask {
                task_id: self.task_id,
                lifecycle: self.lifecycle,
                r#type: self.r#type,
                creation_time: self.creation_time,
                start_time: self.start_time,
                end_time: self.end_time,
                resource_arn: self.resource_arn,
                tags: self.tags,
                file_system_id: self.file_system_id,
                paths: self.paths,
                failure_details: self.failure_details,
                status: self.status,
                report: self.report,
            }
        }
    }
}
impl DataRepositoryTask {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTask`](crate::model::DataRepositoryTask)
    pub fn builder() -> crate::model::data_repository_task::Builder {
        crate::model::data_repository_task::Builder::default()
    }
}

/// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
/// FSx delivers the report to the file system's linked data repository in Amazon S3,
/// using the path specified in the report <code>Path</code> parameter.
/// You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompletionReport {
    /// <p>Set <code>Enabled</code> to <code>True</code> to generate a <code>CompletionReport</code> when the task completes.
    /// If set to <code>true</code>, then you need to provide a report <code>Scope</code>, <code>Path</code>, and <code>Format</code>.
    /// Set <code>Enabled</code> to <code>False</code> if you do not want a <code>CompletionReport</code> generated when the task completes.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the location of the report on the file system's linked S3 data repository. An absolute path that defines where the completion report will be stored in the destination location.
    /// The <code>Path</code> you provide must be located within the file system’s ExportPath.
    /// An example <code>Path</code> value is "s3://myBucket/myExportPath/optionalPrefix". The report provides the following information for each file in the report:
    /// FilePath, FileStatus, and ErrorCode. To learn more about a file system's <code>ExportPath</code>, see .
    /// </p>
    pub path: std::option::Option<std::string::String>,
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the format of the <code>CompletionReport</code>. <code>REPORT_CSV_20191124</code> is the only format currently supported.
    /// When <code>Format</code> is set to <code>REPORT_CSV_20191124</code>, the <code>CompletionReport</code> is provided in CSV format, and is delivered to
    /// <code>{path}/task-{id}/failures.csv</code>.
    /// </p>
    pub format: std::option::Option<crate::model::ReportFormat>,
    /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the scope of the <code>CompletionReport</code>; <code>FAILED_FILES_ONLY</code> is the only scope currently supported.
    /// When <code>Scope</code> is set to <code>FAILED_FILES_ONLY</code>, the <code>CompletionReport</code> only contains information about files that the data repository task failed to process.</p>
    pub scope: std::option::Option<crate::model::ReportScope>,
}
impl std::fmt::Debug for CompletionReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CompletionReport");
        formatter.field("enabled", &self.enabled);
        formatter.field("path", &self.path);
        formatter.field("format", &self.format);
        formatter.field("scope", &self.scope);
        formatter.finish()
    }
}
/// See [`CompletionReport`](crate::model::CompletionReport)
pub mod completion_report {
    /// A builder for [`CompletionReport`](crate::model::CompletionReport)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) path: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::ReportFormat>,
        pub(crate) scope: std::option::Option<crate::model::ReportScope>,
    }
    impl Builder {
        /// <p>Set <code>Enabled</code> to <code>True</code> to generate a <code>CompletionReport</code> when the task completes.
        /// If set to <code>true</code>, then you need to provide a report <code>Scope</code>, <code>Path</code>, and <code>Format</code>.
        /// Set <code>Enabled</code> to <code>False</code> if you do not want a <code>CompletionReport</code> generated when the task completes.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the location of the report on the file system's linked S3 data repository. An absolute path that defines where the completion report will be stored in the destination location.
        /// The <code>Path</code> you provide must be located within the file system’s ExportPath.
        /// An example <code>Path</code> value is "s3://myBucket/myExportPath/optionalPrefix". The report provides the following information for each file in the report:
        /// FilePath, FileStatus, and ErrorCode. To learn more about a file system's <code>ExportPath</code>, see .
        /// </p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input;
            self
        }
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the format of the <code>CompletionReport</code>. <code>REPORT_CSV_20191124</code> is the only format currently supported.
        /// When <code>Format</code> is set to <code>REPORT_CSV_20191124</code>, the <code>CompletionReport</code> is provided in CSV format, and is delivered to
        /// <code>{path}/task-{id}/failures.csv</code>.
        /// </p>
        pub fn format(mut self, input: crate::model::ReportFormat) -> Self {
            self.format = Some(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::ReportFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the scope of the <code>CompletionReport</code>; <code>FAILED_FILES_ONLY</code> is the only scope currently supported.
        /// When <code>Scope</code> is set to <code>FAILED_FILES_ONLY</code>, the <code>CompletionReport</code> only contains information about files that the data repository task failed to process.</p>
        pub fn scope(mut self, input: crate::model::ReportScope) -> Self {
            self.scope = Some(input);
            self
        }
        pub fn set_scope(mut self, input: std::option::Option<crate::model::ReportScope>) -> Self {
            self.scope = input;
            self
        }
        /// Consumes the builder and constructs a [`CompletionReport`](crate::model::CompletionReport)
        pub fn build(self) -> crate::model::CompletionReport {
            crate::model::CompletionReport {
                enabled: self.enabled,
                path: self.path,
                format: self.format,
                scope: self.scope,
            }
        }
    }
}
impl CompletionReport {
    /// Creates a new builder-style object to manufacture [`CompletionReport`](crate::model::CompletionReport)
    pub fn builder() -> crate::model::completion_report::Builder {
        crate::model::completion_report::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportScope {
    FailedFilesOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReportScope {
    fn from(s: &str) -> Self {
        match s {
            "FAILED_FILES_ONLY" => ReportScope::FailedFilesOnly,
            other => ReportScope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReportScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportScope::from(s))
    }
}
impl ReportScope {
    pub fn as_str(&self) -> &str {
        match self {
            ReportScope::FailedFilesOnly => "FAILED_FILES_ONLY",
            ReportScope::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FAILED_FILES_ONLY"]
    }
}
impl AsRef<str> for ReportScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReportFormat {
    ReportCsv20191124,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReportFormat {
    fn from(s: &str) -> Self {
        match s {
            "REPORT_CSV_20191124" => ReportFormat::ReportCsv20191124,
            other => ReportFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReportFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReportFormat::from(s))
    }
}
impl ReportFormat {
    pub fn as_str(&self) -> &str {
        match self {
            ReportFormat::ReportCsv20191124 => "REPORT_CSV_20191124",
            ReportFormat::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["REPORT_CSV_20191124"]
    }
}
impl AsRef<str> for ReportFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the task status showing a running total of the total number of files to be processed,
/// the number successfully processed, and the number of files the task failed to process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskStatus {
    /// <p>The total number of files that the task will process. While a task is executing, the sum of
    /// <code>SucceededCount</code> plus <code>FailedCount</code> may not equal <code>TotalCount</code>. When the task is complete,
    /// <code>TotalCount</code> equals the sum of <code>SucceededCount</code> plus <code>FailedCount</code>.</p>
    pub total_count: std::option::Option<i64>,
    /// <p>A running total of the number of files that the task has successfully processed.</p>
    pub succeeded_count: std::option::Option<i64>,
    /// <p>A running total of the number of files that the task failed to process.</p>
    pub failed_count: std::option::Option<i64>,
    /// <p>The time at which the task status was last updated.</p>
    pub last_updated_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DataRepositoryTaskStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskStatus");
        formatter.field("total_count", &self.total_count);
        formatter.field("succeeded_count", &self.succeeded_count);
        formatter.field("failed_count", &self.failed_count);
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.finish()
    }
}
/// See [`DataRepositoryTaskStatus`](crate::model::DataRepositoryTaskStatus)
pub mod data_repository_task_status {
    /// A builder for [`DataRepositoryTaskStatus`](crate::model::DataRepositoryTaskStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_count: std::option::Option<i64>,
        pub(crate) succeeded_count: std::option::Option<i64>,
        pub(crate) failed_count: std::option::Option<i64>,
        pub(crate) last_updated_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The total number of files that the task will process. While a task is executing, the sum of
        /// <code>SucceededCount</code> plus <code>FailedCount</code> may not equal <code>TotalCount</code>. When the task is complete,
        /// <code>TotalCount</code> equals the sum of <code>SucceededCount</code> plus <code>FailedCount</code>.</p>
        pub fn total_count(mut self, input: i64) -> Self {
            self.total_count = Some(input);
            self
        }
        pub fn set_total_count(mut self, input: std::option::Option<i64>) -> Self {
            self.total_count = input;
            self
        }
        /// <p>A running total of the number of files that the task has successfully processed.</p>
        pub fn succeeded_count(mut self, input: i64) -> Self {
            self.succeeded_count = Some(input);
            self
        }
        pub fn set_succeeded_count(mut self, input: std::option::Option<i64>) -> Self {
            self.succeeded_count = input;
            self
        }
        /// <p>A running total of the number of files that the task failed to process.</p>
        pub fn failed_count(mut self, input: i64) -> Self {
            self.failed_count = Some(input);
            self
        }
        pub fn set_failed_count(mut self, input: std::option::Option<i64>) -> Self {
            self.failed_count = input;
            self
        }
        /// <p>The time at which the task status was last updated.</p>
        pub fn last_updated_time(mut self, input: smithy_types::Instant) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskStatus`](crate::model::DataRepositoryTaskStatus)
        pub fn build(self) -> crate::model::DataRepositoryTaskStatus {
            crate::model::DataRepositoryTaskStatus {
                total_count: self.total_count,
                succeeded_count: self.succeeded_count,
                failed_count: self.failed_count,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl DataRepositoryTaskStatus {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskStatus`](crate::model::DataRepositoryTaskStatus)
    pub fn builder() -> crate::model::data_repository_task_status::Builder {
        crate::model::data_repository_task_status::Builder::default()
    }
}

/// <p>Provides information about why a data repository task failed. Only populated when the task <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskFailureDetails {
    /// <p>A detailed error message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataRepositoryTaskFailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskFailureDetails");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`DataRepositoryTaskFailureDetails`](crate::model::DataRepositoryTaskFailureDetails)
pub mod data_repository_task_failure_details {
    /// A builder for [`DataRepositoryTaskFailureDetails`](crate::model::DataRepositoryTaskFailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A detailed error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskFailureDetails`](crate::model::DataRepositoryTaskFailureDetails)
        pub fn build(self) -> crate::model::DataRepositoryTaskFailureDetails {
            crate::model::DataRepositoryTaskFailureDetails {
                message: self.message,
            }
        }
    }
}
impl DataRepositoryTaskFailureDetails {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskFailureDetails`](crate::model::DataRepositoryTaskFailureDetails)
    pub fn builder() -> crate::model::data_repository_task_failure_details::Builder {
        crate::model::data_repository_task_failure_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataRepositoryTaskType {
    Export,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataRepositoryTaskType {
    fn from(s: &str) -> Self {
        match s {
            "EXPORT_TO_REPOSITORY" => DataRepositoryTaskType::Export,
            other => DataRepositoryTaskType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataRepositoryTaskType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataRepositoryTaskType::from(s))
    }
}
impl DataRepositoryTaskType {
    pub fn as_str(&self) -> &str {
        match self {
            DataRepositoryTaskType::Export => "EXPORT_TO_REPOSITORY",
            DataRepositoryTaskType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EXPORT_TO_REPOSITORY"]
    }
}
impl AsRef<str> for DataRepositoryTaskType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataRepositoryTaskLifecycle {
    Canceled,
    Canceling,
    Executing,
    Failed,
    Pending,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataRepositoryTaskLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => DataRepositoryTaskLifecycle::Canceled,
            "CANCELING" => DataRepositoryTaskLifecycle::Canceling,
            "EXECUTING" => DataRepositoryTaskLifecycle::Executing,
            "FAILED" => DataRepositoryTaskLifecycle::Failed,
            "PENDING" => DataRepositoryTaskLifecycle::Pending,
            "SUCCEEDED" => DataRepositoryTaskLifecycle::Succeeded,
            other => DataRepositoryTaskLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataRepositoryTaskLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataRepositoryTaskLifecycle::from(s))
    }
}
impl DataRepositoryTaskLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            DataRepositoryTaskLifecycle::Canceled => "CANCELED",
            DataRepositoryTaskLifecycle::Canceling => "CANCELING",
            DataRepositoryTaskLifecycle::Executing => "EXECUTING",
            DataRepositoryTaskLifecycle::Failed => "FAILED",
            DataRepositoryTaskLifecycle::Pending => "PENDING",
            DataRepositoryTaskLifecycle::Succeeded => "SUCCEEDED",
            DataRepositoryTaskLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "CANCELING",
            "EXECUTING",
            "FAILED",
            "PENDING",
            "SUCCEEDED",
        ]
    }
}
impl AsRef<str> for DataRepositoryTaskLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>(Optional) An array of filter objects you can use to filter the response of data repository tasks you will see in the the response.
/// You can filter the tasks returned in the response by one or more file system IDs, task lifecycles, and by task type.
/// A filter object consists of a filter <code>Name</code>, and one or more <code>Values</code> for the filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataRepositoryTaskFilter {
    /// <p>Name of the task property to use in filtering the tasks returned in the response.</p>
    /// <ul>
    /// <li>
    /// <p>Use <code>file-system-id</code> to retrieve data repository tasks for specific file systems.</p>
    /// </li>
    /// <li>
    /// <p>Use <code>task-lifecycle</code> to retrieve data repository tasks with one or more specific lifecycle states,
    /// as follows: CANCELED, EXECUTING, FAILED, PENDING, and SUCCEEDED.</p>
    /// </li>
    /// </ul>
    pub name: std::option::Option<crate::model::DataRepositoryTaskFilterName>,
    /// <p>Use Values to include the specific file system IDs and task
    /// lifecycle states for the filters you are using.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DataRepositoryTaskFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataRepositoryTaskFilter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`DataRepositoryTaskFilter`](crate::model::DataRepositoryTaskFilter)
pub mod data_repository_task_filter {
    /// A builder for [`DataRepositoryTaskFilter`](crate::model::DataRepositoryTaskFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::DataRepositoryTaskFilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Name of the task property to use in filtering the tasks returned in the response.</p>
        /// <ul>
        /// <li>
        /// <p>Use <code>file-system-id</code> to retrieve data repository tasks for specific file systems.</p>
        /// </li>
        /// <li>
        /// <p>Use <code>task-lifecycle</code> to retrieve data repository tasks with one or more specific lifecycle states,
        /// as follows: CANCELED, EXECUTING, FAILED, PENDING, and SUCCEEDED.</p>
        /// </li>
        /// </ul>
        pub fn name(mut self, input: crate::model::DataRepositoryTaskFilterName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(
            mut self,
            input: std::option::Option<crate::model::DataRepositoryTaskFilterName>,
        ) -> Self {
            self.name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`DataRepositoryTaskFilter`](crate::model::DataRepositoryTaskFilter)
        pub fn build(self) -> crate::model::DataRepositoryTaskFilter {
            crate::model::DataRepositoryTaskFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl DataRepositoryTaskFilter {
    /// Creates a new builder-style object to manufacture [`DataRepositoryTaskFilter`](crate::model::DataRepositoryTaskFilter)
    pub fn builder() -> crate::model::data_repository_task_filter::Builder {
        crate::model::data_repository_task_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataRepositoryTaskFilterName {
    FileSystemId,
    TaskLifecycle,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DataRepositoryTaskFilterName {
    fn from(s: &str) -> Self {
        match s {
            "file-system-id" => DataRepositoryTaskFilterName::FileSystemId,
            "task-lifecycle" => DataRepositoryTaskFilterName::TaskLifecycle,
            other => DataRepositoryTaskFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DataRepositoryTaskFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataRepositoryTaskFilterName::from(s))
    }
}
impl DataRepositoryTaskFilterName {
    pub fn as_str(&self) -> &str {
        match self {
            DataRepositoryTaskFilterName::FileSystemId => "file-system-id",
            DataRepositoryTaskFilterName::TaskLifecycle => "task-lifecycle",
            DataRepositoryTaskFilterName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["file-system-id", "task-lifecycle"]
    }
}
impl AsRef<str> for DataRepositoryTaskFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A backup of an Amazon FSx file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Backup {
    /// <p>The ID of the backup.</p>
    pub backup_id: std::option::Option<std::string::String>,
    /// <p>The lifecycle status of the backup.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AVAILABLE</code> - The backup is fully available.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - Amazon FSx is creating the backup.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is transferring the backup to S3.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>COPYING</code> - Amazon FSx is copying the backup.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
    /// </li>
    /// </ul>
    pub lifecycle: std::option::Option<crate::model::BackupLifecycle>,
    /// <p>Details explaining any failures that occur when creating a backup.</p>
    pub failure_details: std::option::Option<crate::model::BackupFailureDetails>,
    /// <p>The type of the file system backup.</p>
    pub r#type: std::option::Option<crate::model::BackupType>,
    /// <p>The current percent of progress of an asynchronous task.</p>
    pub progress_percent: std::option::Option<i32>,
    /// <p>The time when a particular backup was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the
    /// backup of the Amazon FSx file system's data at rest.
    /// </p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the backup resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Tags associated with a particular file system.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Metadata of the file system associated with the backup. This metadata is persisted
    /// even if the file system is deleted.</p>
    pub file_system: std::option::Option<crate::model::FileSystem>,
    /// <p>The configuration of the self-managed Microsoft Active Directory (AD) to which the Windows File Server instance is joined.</p>
    pub directory_information: std::option::Option<crate::model::ActiveDirectoryBackupAttributes>,
    /// <p>An AWS account ID. This ID is a 12-digit number that you use to construct Amazon
    /// Resource Names (ARNs) for resources.</p>
    pub owner_id: std::option::Option<std::string::String>,
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    pub source_backup_id: std::option::Option<std::string::String>,
    /// <p>The source Region of the backup. Specifies the Region from where this backup
    /// is copied.</p>
    pub source_backup_region: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Backup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Backup");
        formatter.field("backup_id", &self.backup_id);
        formatter.field("lifecycle", &self.lifecycle);
        formatter.field("failure_details", &self.failure_details);
        formatter.field("r#type", &self.r#type);
        formatter.field("progress_percent", &self.progress_percent);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.field("file_system", &self.file_system);
        formatter.field("directory_information", &self.directory_information);
        formatter.field("owner_id", &self.owner_id);
        formatter.field("source_backup_id", &self.source_backup_id);
        formatter.field("source_backup_region", &self.source_backup_region);
        formatter.finish()
    }
}
/// See [`Backup`](crate::model::Backup)
pub mod backup {
    /// A builder for [`Backup`](crate::model::Backup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_id: std::option::Option<std::string::String>,
        pub(crate) lifecycle: std::option::Option<crate::model::BackupLifecycle>,
        pub(crate) failure_details: std::option::Option<crate::model::BackupFailureDetails>,
        pub(crate) r#type: std::option::Option<crate::model::BackupType>,
        pub(crate) progress_percent: std::option::Option<i32>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) file_system: std::option::Option<crate::model::FileSystem>,
        pub(crate) directory_information:
            std::option::Option<crate::model::ActiveDirectoryBackupAttributes>,
        pub(crate) owner_id: std::option::Option<std::string::String>,
        pub(crate) source_backup_id: std::option::Option<std::string::String>,
        pub(crate) source_backup_region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the backup.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// <p>The lifecycle status of the backup.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AVAILABLE</code> - The backup is fully available.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - Amazon FSx is creating the backup.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is transferring the backup to S3.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>COPYING</code> - Amazon FSx is copying the backup.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
        /// </li>
        /// </ul>
        pub fn lifecycle(mut self, input: crate::model::BackupLifecycle) -> Self {
            self.lifecycle = Some(input);
            self
        }
        pub fn set_lifecycle(
            mut self,
            input: std::option::Option<crate::model::BackupLifecycle>,
        ) -> Self {
            self.lifecycle = input;
            self
        }
        /// <p>Details explaining any failures that occur when creating a backup.</p>
        pub fn failure_details(mut self, input: crate::model::BackupFailureDetails) -> Self {
            self.failure_details = Some(input);
            self
        }
        pub fn set_failure_details(
            mut self,
            input: std::option::Option<crate::model::BackupFailureDetails>,
        ) -> Self {
            self.failure_details = input;
            self
        }
        /// <p>The type of the file system backup.</p>
        pub fn r#type(mut self, input: crate::model::BackupType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::BackupType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The current percent of progress of an asynchronous task.</p>
        pub fn progress_percent(mut self, input: i32) -> Self {
            self.progress_percent = Some(input);
            self
        }
        pub fn set_progress_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.progress_percent = input;
            self
        }
        /// <p>The time when a particular backup was created.</p>
        pub fn creation_time(mut self, input: smithy_types::Instant) -> Self {
            self.creation_time = Some(input);
            self
        }
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the
        /// backup of the Amazon FSx file system's data at rest.
        /// </p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the backup resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Metadata of the file system associated with the backup. This metadata is persisted
        /// even if the file system is deleted.</p>
        pub fn file_system(mut self, input: crate::model::FileSystem) -> Self {
            self.file_system = Some(input);
            self
        }
        pub fn set_file_system(
            mut self,
            input: std::option::Option<crate::model::FileSystem>,
        ) -> Self {
            self.file_system = input;
            self
        }
        /// <p>The configuration of the self-managed Microsoft Active Directory (AD) to which the Windows File Server instance is joined.</p>
        pub fn directory_information(
            mut self,
            input: crate::model::ActiveDirectoryBackupAttributes,
        ) -> Self {
            self.directory_information = Some(input);
            self
        }
        pub fn set_directory_information(
            mut self,
            input: std::option::Option<crate::model::ActiveDirectoryBackupAttributes>,
        ) -> Self {
            self.directory_information = input;
            self
        }
        /// <p>An AWS account ID. This ID is a 12-digit number that you use to construct Amazon
        /// Resource Names (ARNs) for resources.</p>
        pub fn owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_id = Some(input.into());
            self
        }
        pub fn set_owner_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_id = input;
            self
        }
        /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
        pub fn source_backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_backup_id = Some(input.into());
            self
        }
        pub fn set_source_backup_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_backup_id = input;
            self
        }
        /// <p>The source Region of the backup. Specifies the Region from where this backup
        /// is copied.</p>
        pub fn source_backup_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_backup_region = Some(input.into());
            self
        }
        pub fn set_source_backup_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_backup_region = input;
            self
        }
        /// Consumes the builder and constructs a [`Backup`](crate::model::Backup)
        pub fn build(self) -> crate::model::Backup {
            crate::model::Backup {
                backup_id: self.backup_id,
                lifecycle: self.lifecycle,
                failure_details: self.failure_details,
                r#type: self.r#type,
                progress_percent: self.progress_percent,
                creation_time: self.creation_time,
                kms_key_id: self.kms_key_id,
                resource_arn: self.resource_arn,
                tags: self.tags,
                file_system: self.file_system,
                directory_information: self.directory_information,
                owner_id: self.owner_id,
                source_backup_id: self.source_backup_id,
                source_backup_region: self.source_backup_region,
            }
        }
    }
}
impl Backup {
    /// Creates a new builder-style object to manufacture [`Backup`](crate::model::Backup)
    pub fn builder() -> crate::model::backup::Builder {
        crate::model::backup::Builder::default()
    }
}

/// <p>The Microsoft AD attributes of the Amazon FSx for Windows File Server file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryBackupAttributes {
    /// <p>The fully qualified domain name of the self-managed AD directory.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS Managed Microsoft Active Directory instance to which the file system is joined.</p>
    pub active_directory_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
    /// resources. We require an ARN when you need to specify a resource unambiguously across
    /// all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
    /// and AWS Service Namespaces</a> in the <i>AWS General
    /// Reference</i>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActiveDirectoryBackupAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryBackupAttributes");
        formatter.field("domain_name", &self.domain_name);
        formatter.field("active_directory_id", &self.active_directory_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}
/// See [`ActiveDirectoryBackupAttributes`](crate::model::ActiveDirectoryBackupAttributes)
pub mod active_directory_backup_attributes {
    /// A builder for [`ActiveDirectoryBackupAttributes`](crate::model::ActiveDirectoryBackupAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) active_directory_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The fully qualified domain name of the self-managed AD directory.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The ID of the AWS Managed Microsoft Active Directory instance to which the file system is joined.</p>
        pub fn active_directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_id = Some(input.into());
            self
        }
        pub fn set_active_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
        /// resources. We require an ARN when you need to specify a resource unambiguously across
        /// all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
        /// and AWS Service Namespaces</a> in the <i>AWS General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryBackupAttributes`](crate::model::ActiveDirectoryBackupAttributes)
        pub fn build(self) -> crate::model::ActiveDirectoryBackupAttributes {
            crate::model::ActiveDirectoryBackupAttributes {
                domain_name: self.domain_name,
                active_directory_id: self.active_directory_id,
                resource_arn: self.resource_arn,
            }
        }
    }
}
impl ActiveDirectoryBackupAttributes {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryBackupAttributes`](crate::model::ActiveDirectoryBackupAttributes)
    pub fn builder() -> crate::model::active_directory_backup_attributes::Builder {
        crate::model::active_directory_backup_attributes::Builder::default()
    }
}

/// <p>The type of the backup.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackupType {
    Automatic,
    AwsBackup,
    UserInitiated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BackupType {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATIC" => BackupType::Automatic,
            "AWS_BACKUP" => BackupType::AwsBackup,
            "USER_INITIATED" => BackupType::UserInitiated,
            other => BackupType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BackupType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BackupType::from(s))
    }
}
impl BackupType {
    pub fn as_str(&self) -> &str {
        match self {
            BackupType::Automatic => "AUTOMATIC",
            BackupType::AwsBackup => "AWS_BACKUP",
            BackupType::UserInitiated => "USER_INITIATED",
            BackupType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AUTOMATIC", "AWS_BACKUP", "USER_INITIATED"]
    }
}
impl AsRef<str> for BackupType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>If backup creation fails, this structure contains the details of that
/// failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupFailureDetails {
    /// <p>A message describing the backup creation failure.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupFailureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupFailureDetails");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BackupFailureDetails`](crate::model::BackupFailureDetails)
pub mod backup_failure_details {
    /// A builder for [`BackupFailureDetails`](crate::model::BackupFailureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A message describing the backup creation failure.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BackupFailureDetails`](crate::model::BackupFailureDetails)
        pub fn build(self) -> crate::model::BackupFailureDetails {
            crate::model::BackupFailureDetails {
                message: self.message,
            }
        }
    }
}
impl BackupFailureDetails {
    /// Creates a new builder-style object to manufacture [`BackupFailureDetails`](crate::model::BackupFailureDetails)
    pub fn builder() -> crate::model::backup_failure_details::Builder {
        crate::model::backup_failure_details::Builder::default()
    }
}

/// <p>The lifecycle status of the backup.</p>
/// <ul>
/// <li>
/// <p>
/// <code>AVAILABLE</code> - The backup is fully available.</p>
/// </li>
/// <li>
/// <p>
/// <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
/// </li>
/// <li>
/// <p>
/// <code>CREATING</code> - Amazon FSx is creating the new user-intiated backup</p>
/// </li>
/// <li>
/// <p>
/// <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is backing up the file system.</p>
/// </li>
/// <li>
/// <p>
/// <code>COPYING</code> - Amazon FSx is copying the backup.</p>
/// </li>
/// <li>
/// <p>
/// <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
/// </li>
/// <li>
/// <p>
/// <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackupLifecycle {
    Available,
    Copying,
    Creating,
    Deleted,
    Failed,
    Pending,
    Transferring,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BackupLifecycle {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => BackupLifecycle::Available,
            "COPYING" => BackupLifecycle::Copying,
            "CREATING" => BackupLifecycle::Creating,
            "DELETED" => BackupLifecycle::Deleted,
            "FAILED" => BackupLifecycle::Failed,
            "PENDING" => BackupLifecycle::Pending,
            "TRANSFERRING" => BackupLifecycle::Transferring,
            other => BackupLifecycle::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BackupLifecycle {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BackupLifecycle::from(s))
    }
}
impl BackupLifecycle {
    pub fn as_str(&self) -> &str {
        match self {
            BackupLifecycle::Available => "AVAILABLE",
            BackupLifecycle::Copying => "COPYING",
            BackupLifecycle::Creating => "CREATING",
            BackupLifecycle::Deleted => "DELETED",
            BackupLifecycle::Failed => "FAILED",
            BackupLifecycle::Pending => "PENDING",
            BackupLifecycle::Transferring => "TRANSFERRING",
            BackupLifecycle::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "COPYING",
            "CREATING",
            "DELETED",
            "FAILED",
            "PENDING",
            "TRANSFERRING",
        ]
    }
}
impl AsRef<str> for BackupLifecycle {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter used to restrict the results of describe calls. You can use multiple
/// filters to return results that meet all applied filter requirements.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>The name for this filter.</p>
    pub name: std::option::Option<crate::model::FilterName>,
    /// <p>The values of the filter. These are all the values for any of the applied
    /// filters.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::FilterName>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name for this filter.</p>
        pub fn name(mut self, input: crate::model::FilterName) -> Self {
            self.name = Some(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<crate::model::FilterName>) -> Self {
            self.name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>The name for a filter.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterName {
    BackupType,
    FileSystemId,
    FileSystemType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FilterName {
    fn from(s: &str) -> Self {
        match s {
            "backup-type" => FilterName::BackupType,
            "file-system-id" => FilterName::FileSystemId,
            "file-system-type" => FilterName::FileSystemType,
            other => FilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterName::from(s))
    }
}
impl FilterName {
    pub fn as_str(&self) -> &str {
        match self {
            FilterName::BackupType => "backup-type",
            FilterName::FileSystemId => "file-system-id",
            FilterName::FileSystemType => "file-system-type",
            FilterName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["backup-type", "file-system-id", "file-system-type"]
    }
}
impl AsRef<str> for FilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The response object for the Amazon FSx for Lustre file system being deleted in the
/// <code>DeleteFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFileSystemLustreResponse {
    /// <p>The ID of the final backup for this file system.</p>
    pub final_backup_id: std::option::Option<std::string::String>,
    /// <p>The set of tags applied to the final backup.</p>
    pub final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for DeleteFileSystemLustreResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFileSystemLustreResponse");
        formatter.field("final_backup_id", &self.final_backup_id);
        formatter.field("final_backup_tags", &self.final_backup_tags);
        formatter.finish()
    }
}
/// See [`DeleteFileSystemLustreResponse`](crate::model::DeleteFileSystemLustreResponse)
pub mod delete_file_system_lustre_response {
    /// A builder for [`DeleteFileSystemLustreResponse`](crate::model::DeleteFileSystemLustreResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) final_backup_id: std::option::Option<std::string::String>,
        pub(crate) final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the final backup for this file system.</p>
        pub fn final_backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.final_backup_id = Some(input.into());
            self
        }
        pub fn set_final_backup_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.final_backup_id = input;
            self
        }
        pub fn final_backup_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.final_backup_tags.unwrap_or_default();
            v.push(input.into());
            self.final_backup_tags = Some(v);
            self
        }
        pub fn set_final_backup_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.final_backup_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFileSystemLustreResponse`](crate::model::DeleteFileSystemLustreResponse)
        pub fn build(self) -> crate::model::DeleteFileSystemLustreResponse {
            crate::model::DeleteFileSystemLustreResponse {
                final_backup_id: self.final_backup_id,
                final_backup_tags: self.final_backup_tags,
            }
        }
    }
}
impl DeleteFileSystemLustreResponse {
    /// Creates a new builder-style object to manufacture [`DeleteFileSystemLustreResponse`](crate::model::DeleteFileSystemLustreResponse)
    pub fn builder() -> crate::model::delete_file_system_lustre_response::Builder {
        crate::model::delete_file_system_lustre_response::Builder::default()
    }
}

/// <p>The response object for the Microsoft Windows file system used in the
/// <code>DeleteFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFileSystemWindowsResponse {
    /// <p>The ID of the final backup for this file system.</p>
    pub final_backup_id: std::option::Option<std::string::String>,
    /// <p>The set of tags applied to the final backup.</p>
    pub final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for DeleteFileSystemWindowsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFileSystemWindowsResponse");
        formatter.field("final_backup_id", &self.final_backup_id);
        formatter.field("final_backup_tags", &self.final_backup_tags);
        formatter.finish()
    }
}
/// See [`DeleteFileSystemWindowsResponse`](crate::model::DeleteFileSystemWindowsResponse)
pub mod delete_file_system_windows_response {
    /// A builder for [`DeleteFileSystemWindowsResponse`](crate::model::DeleteFileSystemWindowsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) final_backup_id: std::option::Option<std::string::String>,
        pub(crate) final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the final backup for this file system.</p>
        pub fn final_backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.final_backup_id = Some(input.into());
            self
        }
        pub fn set_final_backup_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.final_backup_id = input;
            self
        }
        pub fn final_backup_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.final_backup_tags.unwrap_or_default();
            v.push(input.into());
            self.final_backup_tags = Some(v);
            self
        }
        pub fn set_final_backup_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.final_backup_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFileSystemWindowsResponse`](crate::model::DeleteFileSystemWindowsResponse)
        pub fn build(self) -> crate::model::DeleteFileSystemWindowsResponse {
            crate::model::DeleteFileSystemWindowsResponse {
                final_backup_id: self.final_backup_id,
                final_backup_tags: self.final_backup_tags,
            }
        }
    }
}
impl DeleteFileSystemWindowsResponse {
    /// Creates a new builder-style object to manufacture [`DeleteFileSystemWindowsResponse`](crate::model::DeleteFileSystemWindowsResponse)
    pub fn builder() -> crate::model::delete_file_system_windows_response::Builder {
        crate::model::delete_file_system_windows_response::Builder::default()
    }
}

/// <p>The configuration object for the Amazon FSx for Lustre file system being deleted in the
/// <code>DeleteFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFileSystemLustreConfiguration {
    /// <p>Set <code>SkipFinalBackup</code> to false if you want to take a final backup of the file
    /// system you are deleting. By default, Amazon FSx will not take a final backup on your behalf when the
    /// <code>DeleteFileSystem</code> operation is invoked. (Default = true)</p>
    pub skip_final_backup: std::option::Option<bool>,
    /// <p>Use if <code>SkipFinalBackup</code> is set to <code>false</code>,
    /// and you want to apply an array of tags to the final backup. If you have set the file system property
    /// <code>CopyTagsToBackups</code> to true, and
    /// you specify one or more <code>FinalBackupTags</code> when deleting a file system, Amazon FSx will not copy any existing file system tags to the backup.</p>
    pub final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for DeleteFileSystemLustreConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFileSystemLustreConfiguration");
        formatter.field("skip_final_backup", &self.skip_final_backup);
        formatter.field("final_backup_tags", &self.final_backup_tags);
        formatter.finish()
    }
}
/// See [`DeleteFileSystemLustreConfiguration`](crate::model::DeleteFileSystemLustreConfiguration)
pub mod delete_file_system_lustre_configuration {
    /// A builder for [`DeleteFileSystemLustreConfiguration`](crate::model::DeleteFileSystemLustreConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) skip_final_backup: std::option::Option<bool>,
        pub(crate) final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>Set <code>SkipFinalBackup</code> to false if you want to take a final backup of the file
        /// system you are deleting. By default, Amazon FSx will not take a final backup on your behalf when the
        /// <code>DeleteFileSystem</code> operation is invoked. (Default = true)</p>
        pub fn skip_final_backup(mut self, input: bool) -> Self {
            self.skip_final_backup = Some(input);
            self
        }
        pub fn set_skip_final_backup(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_final_backup = input;
            self
        }
        pub fn final_backup_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.final_backup_tags.unwrap_or_default();
            v.push(input.into());
            self.final_backup_tags = Some(v);
            self
        }
        pub fn set_final_backup_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.final_backup_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFileSystemLustreConfiguration`](crate::model::DeleteFileSystemLustreConfiguration)
        pub fn build(self) -> crate::model::DeleteFileSystemLustreConfiguration {
            crate::model::DeleteFileSystemLustreConfiguration {
                skip_final_backup: self.skip_final_backup,
                final_backup_tags: self.final_backup_tags,
            }
        }
    }
}
impl DeleteFileSystemLustreConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteFileSystemLustreConfiguration`](crate::model::DeleteFileSystemLustreConfiguration)
    pub fn builder() -> crate::model::delete_file_system_lustre_configuration::Builder {
        crate::model::delete_file_system_lustre_configuration::Builder::default()
    }
}

/// <p>The configuration object for the Microsoft Windows file system used in the
/// <code>DeleteFileSystem</code> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteFileSystemWindowsConfiguration {
    /// <p>By default, Amazon FSx for Windows takes a final backup on your behalf when the
    /// <code>DeleteFileSystem</code> operation is invoked. Doing this helps protect you
    /// from data loss, and we highly recommend taking the final backup. If you want to skip
    /// this backup, use this flag to do so.</p>
    pub skip_final_backup: std::option::Option<bool>,
    /// <p>A set of tags for your final backup.</p>
    pub final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for DeleteFileSystemWindowsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteFileSystemWindowsConfiguration");
        formatter.field("skip_final_backup", &self.skip_final_backup);
        formatter.field("final_backup_tags", &self.final_backup_tags);
        formatter.finish()
    }
}
/// See [`DeleteFileSystemWindowsConfiguration`](crate::model::DeleteFileSystemWindowsConfiguration)
pub mod delete_file_system_windows_configuration {
    /// A builder for [`DeleteFileSystemWindowsConfiguration`](crate::model::DeleteFileSystemWindowsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) skip_final_backup: std::option::Option<bool>,
        pub(crate) final_backup_tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>By default, Amazon FSx for Windows takes a final backup on your behalf when the
        /// <code>DeleteFileSystem</code> operation is invoked. Doing this helps protect you
        /// from data loss, and we highly recommend taking the final backup. If you want to skip
        /// this backup, use this flag to do so.</p>
        pub fn skip_final_backup(mut self, input: bool) -> Self {
            self.skip_final_backup = Some(input);
            self
        }
        pub fn set_skip_final_backup(mut self, input: std::option::Option<bool>) -> Self {
            self.skip_final_backup = input;
            self
        }
        pub fn final_backup_tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.final_backup_tags.unwrap_or_default();
            v.push(input.into());
            self.final_backup_tags = Some(v);
            self
        }
        pub fn set_final_backup_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.final_backup_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFileSystemWindowsConfiguration`](crate::model::DeleteFileSystemWindowsConfiguration)
        pub fn build(self) -> crate::model::DeleteFileSystemWindowsConfiguration {
            crate::model::DeleteFileSystemWindowsConfiguration {
                skip_final_backup: self.skip_final_backup,
                final_backup_tags: self.final_backup_tags,
            }
        }
    }
}
impl DeleteFileSystemWindowsConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteFileSystemWindowsConfiguration`](crate::model::DeleteFileSystemWindowsConfiguration)
    pub fn builder() -> crate::model::delete_file_system_windows_configuration::Builder {
        crate::model::delete_file_system_windows_configuration::Builder::default()
    }
}

/// <p>The type of error relating to Microsoft Active Directory. NOT_FOUND means that no
/// directory was found by specifying the given directory. INCOMPATIBLE_MODE means that the
/// directory specified is not a Microsoft AD directory. WRONG_VPC means that the specified
/// directory isn't accessible from the specified VPC. WRONG_STAGE means that the
/// specified directory isn't currently in the ACTIVE state.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ActiveDirectoryErrorType {
    DomainNotFound,
    IncompatibleDomainMode,
    InvalidDomainStage,
    WrongVpc,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ActiveDirectoryErrorType {
    fn from(s: &str) -> Self {
        match s {
            "DOMAIN_NOT_FOUND" => ActiveDirectoryErrorType::DomainNotFound,
            "INCOMPATIBLE_DOMAIN_MODE" => ActiveDirectoryErrorType::IncompatibleDomainMode,
            "INVALID_DOMAIN_STAGE" => ActiveDirectoryErrorType::InvalidDomainStage,
            "WRONG_VPC" => ActiveDirectoryErrorType::WrongVpc,
            other => ActiveDirectoryErrorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ActiveDirectoryErrorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ActiveDirectoryErrorType::from(s))
    }
}
impl ActiveDirectoryErrorType {
    pub fn as_str(&self) -> &str {
        match self {
            ActiveDirectoryErrorType::DomainNotFound => "DOMAIN_NOT_FOUND",
            ActiveDirectoryErrorType::IncompatibleDomainMode => "INCOMPATIBLE_DOMAIN_MODE",
            ActiveDirectoryErrorType::InvalidDomainStage => "INVALID_DOMAIN_STAGE",
            ActiveDirectoryErrorType::WrongVpc => "WRONG_VPC",
            ActiveDirectoryErrorType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "DOMAIN_NOT_FOUND",
            "INCOMPATIBLE_DOMAIN_MODE",
            "INVALID_DOMAIN_STAGE",
            "WRONG_VPC",
        ]
    }
}
impl AsRef<str> for ActiveDirectoryErrorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Lustre configuration for the file system being created.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFileSystemLustreConfiguration {
    /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>(Optional) The path to the Amazon S3 bucket (including the optional prefix) that
    /// you're using as the data repository for your Amazon FSx for Lustre file system.
    /// The root of your FSx for Lustre file system will
    /// be mapped to the root of the Amazon S3 bucket you select. An
    /// example is <code>s3://import-bucket/optional-prefix</code>. If you specify a prefix
    /// after the Amazon S3 bucket name, only object keys with that prefix are loaded into the
    /// file system.</p>
    pub import_path: std::option::Option<std::string::String>,
    /// <p>(Optional) The path in Amazon S3 where the root of your Amazon FSx file system is exported.
    /// The path must use the same Amazon S3 bucket as specified in ImportPath. You can provide an optional prefix to which
    /// new and changed data is to be exported from your Amazon FSx for Lustre file system. If
    /// an <code>ExportPath</code> value is not provided, Amazon FSx sets a default export path,
    /// <code>s3://import-bucket/FSxLustre[creation-timestamp]</code>. The timestamp is in
    /// UTC format, for example
    /// <code>s3://import-bucket/FSxLustre20181105T222312Z</code>.</p>
    /// <p>The Amazon S3 export bucket must be the same as the import bucket specified by
    /// <code>ImportPath</code>. If you only specify a bucket name, such as
    /// <code>s3://import-bucket</code>, you get a 1:1 mapping of file system objects to S3
    /// bucket objects. This mapping means that the input data in S3 is overwritten on export.
    /// If you provide a custom prefix in the export path, such as
    /// <code>s3://import-bucket/[custom-optional-prefix]</code>, Amazon FSx exports the contents of your file
    /// system to that export prefix in the Amazon S3 bucket.</p>
    pub export_path: std::option::Option<std::string::String>,
    /// <p>(Optional) For files imported from a data repository, this value determines the stripe
    /// count and maximum amount of data per file (in MiB) stored on a single physical disk. The
    /// maximum number of disks that a single file can be striped across is limited by the total
    /// number of disks that make up the file system.</p>
    /// <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
    /// GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
    pub imported_file_chunk_size: std::option::Option<i32>,
    /// <p>
    /// Choose <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
    /// types when you need temporary storage and shorter-term processing of data.
    /// The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
    /// throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>Choose <code>PERSISTENT_1</code> deployment type for longer-term storage
    /// and workloads and encryption of data in transit. To learn more about deployment types, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
    /// FSx for Lustre Deployment Options</a>.</p>
    /// <p>Encryption of data in-transit is automatically
    /// enabled when you access a <code>SCRATCH_2</code> or <code>PERSISTENT_1</code>
    /// file system from Amazon EC2 instances that <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-                 protection.html">support this feature</a>.
    /// (Default = <code>SCRATCH_1</code>)
    /// </p>
    /// <p>Encryption of data in-transit for <code>SCRATCH_2</code> and <code>PERSISTENT_1</code>
    /// deployment types is supported when accessed from supported instance types in supported AWS Regions. To learn more,
    /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/encryption-in-transit-fsxl.html">Encrypting Data in Transit</a>.</p>
    pub deployment_type: std::option::Option<crate::model::LustreDeploymentType>,
    /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
    /// Use this property to choose how Amazon FSx keeps your file and directory listings up to date
    /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
    /// have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
    /// file and directory listings from the linked S3 bucket
    /// when the file system is created. FSx does not update file and directory
    /// listings for any new or changed objects after choosing this option.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
    /// directory listings of any new objects added to the linked S3 bucket that
    /// do not currently exist in the FSx file system. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
    /// file and directory listings of any new objects added to the S3 bucket and any
    /// existing objects that are changed in the S3 bucket after you choose this option.
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
    pub auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
    /// <p>
    /// Required for the <code>PERSISTENT_1</code> deployment type, describes the amount of read and write
    /// throughput for each 1 tebibyte of storage, in MB/s/TiB.
    /// File system throughput capacity is calculated by multiplying ﬁle system storage capacity (TiB) by the PerUnitStorageThroughput
    /// (MB/s/TiB). For a 2.4 TiB ﬁle system, provisioning 50 MB/s/TiB of PerUnitStorageThroughput
    /// yields 120 MB/s of ﬁle system throughput. You pay for the amount of throughput that you
    /// provision.
    /// </p>
    /// <p>Valid values for  SSD storage: 50, 100, 200. Valid values for  HDD storage: 12, 40.</p>
    pub per_unit_storage_throughput: std::option::Option<i32>,
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
    /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
    /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. Setting this to 0 disables
    /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>(Optional) Not available to use with file systems that are linked to a data repository.
    /// A boolean flag indicating whether tags for the file system should be copied to
    /// backups. The default value is false. If it's set to true, all file system
    /// tags are copied to all automatic and user-initiated backups when the user
    /// doesn't specify any backup-specific tags. If this value is true, and you specify one or more backup tags, only
    /// the specified tags are copied to backups. If you specify one or more tags when creating a
    /// user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with backups</a>.</p>
    pub copy_tags_to_backups: std::option::Option<bool>,
    /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
    /// HDD storage devices. This parameter is required when storage type is HDD. Set to
    /// <code>READ</code>, improve the performance for frequently accessed files and allows 20%
    /// of the total storage capacity of the file system to be cached. </p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    pub drive_cache_type: std::option::Option<crate::model::DriveCacheType>,
    /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
    /// can have the following values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>NONE</code> - (Default) Data compression is turned off when
    /// the file system is created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LZ4</code> - Data compression is turned on with the LZ4
    /// algorithm.</p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub data_compression_type: std::option::Option<crate::model::DataCompressionType>,
}
impl std::fmt::Debug for CreateFileSystemLustreConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFileSystemLustreConfiguration");
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field("import_path", &self.import_path);
        formatter.field("export_path", &self.export_path);
        formatter.field("imported_file_chunk_size", &self.imported_file_chunk_size);
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("auto_import_policy", &self.auto_import_policy);
        formatter.field(
            "per_unit_storage_throughput",
            &self.per_unit_storage_throughput,
        );
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("copy_tags_to_backups", &self.copy_tags_to_backups);
        formatter.field("drive_cache_type", &self.drive_cache_type);
        formatter.field("data_compression_type", &self.data_compression_type);
        formatter.finish()
    }
}
/// See [`CreateFileSystemLustreConfiguration`](crate::model::CreateFileSystemLustreConfiguration)
pub mod create_file_system_lustre_configuration {
    /// A builder for [`CreateFileSystemLustreConfiguration`](crate::model::CreateFileSystemLustreConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) import_path: std::option::Option<std::string::String>,
        pub(crate) export_path: std::option::Option<std::string::String>,
        pub(crate) imported_file_chunk_size: std::option::Option<i32>,
        pub(crate) deployment_type: std::option::Option<crate::model::LustreDeploymentType>,
        pub(crate) auto_import_policy: std::option::Option<crate::model::AutoImportPolicyType>,
        pub(crate) per_unit_storage_throughput: std::option::Option<i32>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) copy_tags_to_backups: std::option::Option<bool>,
        pub(crate) drive_cache_type: std::option::Option<crate::model::DriveCacheType>,
        pub(crate) data_compression_type: std::option::Option<crate::model::DataCompressionType>,
    }
    impl Builder {
        /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>(Optional) The path to the Amazon S3 bucket (including the optional prefix) that
        /// you're using as the data repository for your Amazon FSx for Lustre file system.
        /// The root of your FSx for Lustre file system will
        /// be mapped to the root of the Amazon S3 bucket you select. An
        /// example is <code>s3://import-bucket/optional-prefix</code>. If you specify a prefix
        /// after the Amazon S3 bucket name, only object keys with that prefix are loaded into the
        /// file system.</p>
        pub fn import_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.import_path = Some(input.into());
            self
        }
        pub fn set_import_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.import_path = input;
            self
        }
        /// <p>(Optional) The path in Amazon S3 where the root of your Amazon FSx file system is exported.
        /// The path must use the same Amazon S3 bucket as specified in ImportPath. You can provide an optional prefix to which
        /// new and changed data is to be exported from your Amazon FSx for Lustre file system. If
        /// an <code>ExportPath</code> value is not provided, Amazon FSx sets a default export path,
        /// <code>s3://import-bucket/FSxLustre[creation-timestamp]</code>. The timestamp is in
        /// UTC format, for example
        /// <code>s3://import-bucket/FSxLustre20181105T222312Z</code>.</p>
        /// <p>The Amazon S3 export bucket must be the same as the import bucket specified by
        /// <code>ImportPath</code>. If you only specify a bucket name, such as
        /// <code>s3://import-bucket</code>, you get a 1:1 mapping of file system objects to S3
        /// bucket objects. This mapping means that the input data in S3 is overwritten on export.
        /// If you provide a custom prefix in the export path, such as
        /// <code>s3://import-bucket/[custom-optional-prefix]</code>, Amazon FSx exports the contents of your file
        /// system to that export prefix in the Amazon S3 bucket.</p>
        pub fn export_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.export_path = Some(input.into());
            self
        }
        pub fn set_export_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.export_path = input;
            self
        }
        /// <p>(Optional) For files imported from a data repository, this value determines the stripe
        /// count and maximum amount of data per file (in MiB) stored on a single physical disk. The
        /// maximum number of disks that a single file can be striped across is limited by the total
        /// number of disks that make up the file system.</p>
        /// <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
        /// GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
        pub fn imported_file_chunk_size(mut self, input: i32) -> Self {
            self.imported_file_chunk_size = Some(input);
            self
        }
        pub fn set_imported_file_chunk_size(mut self, input: std::option::Option<i32>) -> Self {
            self.imported_file_chunk_size = input;
            self
        }
        /// <p>
        /// Choose <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
        /// types when you need temporary storage and shorter-term processing of data.
        /// The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
        /// throughput capacity than <code>SCRATCH_1</code>.</p>
        /// <p>Choose <code>PERSISTENT_1</code> deployment type for longer-term storage
        /// and workloads and encryption of data in transit. To learn more about deployment types, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
        /// FSx for Lustre Deployment Options</a>.</p>
        /// <p>Encryption of data in-transit is automatically
        /// enabled when you access a <code>SCRATCH_2</code> or <code>PERSISTENT_1</code>
        /// file system from Amazon EC2 instances that <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-                 protection.html">support this feature</a>.
        /// (Default = <code>SCRATCH_1</code>)
        /// </p>
        /// <p>Encryption of data in-transit for <code>SCRATCH_2</code> and <code>PERSISTENT_1</code>
        /// deployment types is supported when accessed from supported instance types in supported AWS Regions. To learn more,
        /// <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/encryption-in-transit-fsxl.html">Encrypting Data in Transit</a>.</p>
        pub fn deployment_type(mut self, input: crate::model::LustreDeploymentType) -> Self {
            self.deployment_type = Some(input);
            self
        }
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<crate::model::LustreDeploymentType>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
        /// Use this property to choose how Amazon FSx keeps your file and directory listings up to date
        /// as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
        /// have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        /// file and directory listings from the linked S3 bucket
        /// when the file system is created. FSx does not update file and directory
        /// listings for any new or changed objects after choosing this option.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        /// directory listings of any new objects added to the linked S3 bucket that
        /// do not currently exist in the FSx file system. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        /// file and directory listings of any new objects added to the S3 bucket and any
        /// existing objects that are changed in the S3 bucket after you choose this option.
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        pub fn auto_import_policy(mut self, input: crate::model::AutoImportPolicyType) -> Self {
            self.auto_import_policy = Some(input);
            self
        }
        pub fn set_auto_import_policy(
            mut self,
            input: std::option::Option<crate::model::AutoImportPolicyType>,
        ) -> Self {
            self.auto_import_policy = input;
            self
        }
        /// <p>
        /// Required for the <code>PERSISTENT_1</code> deployment type, describes the amount of read and write
        /// throughput for each 1 tebibyte of storage, in MB/s/TiB.
        /// File system throughput capacity is calculated by multiplying ﬁle system storage capacity (TiB) by the PerUnitStorageThroughput
        /// (MB/s/TiB). For a 2.4 TiB ﬁle system, provisioning 50 MB/s/TiB of PerUnitStorageThroughput
        /// yields 120 MB/s of ﬁle system throughput. You pay for the amount of throughput that you
        /// provision.
        /// </p>
        /// <p>Valid values for  SSD storage: 50, 100, 200. Valid values for  HDD storage: 12, 40.</p>
        pub fn per_unit_storage_throughput(mut self, input: i32) -> Self {
            self.per_unit_storage_throughput = Some(input);
            self
        }
        pub fn set_per_unit_storage_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.per_unit_storage_throughput = input;
            self
        }
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        /// zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        /// hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        /// automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p>(Optional) Not available to use with file systems that are linked to a data repository.
        /// A boolean flag indicating whether tags for the file system should be copied to
        /// backups. The default value is false. If it's set to true, all file system
        /// tags are copied to all automatic and user-initiated backups when the user
        /// doesn't specify any backup-specific tags. If this value is true, and you specify one or more backup tags, only
        /// the specified tags are copied to backups. If you specify one or more tags when creating a
        /// user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with backups</a>.</p>
        pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
            self.copy_tags_to_backups = Some(input);
            self
        }
        pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_backups = input;
            self
        }
        /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
        /// HDD storage devices. This parameter is required when storage type is HDD. Set to
        /// <code>READ</code>, improve the performance for frequently accessed files and allows 20%
        /// of the total storage capacity of the file system to be cached. </p>
        /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
        pub fn drive_cache_type(mut self, input: crate::model::DriveCacheType) -> Self {
            self.drive_cache_type = Some(input);
            self
        }
        pub fn set_drive_cache_type(
            mut self,
            input: std::option::Option<crate::model::DriveCacheType>,
        ) -> Self {
            self.drive_cache_type = input;
            self
        }
        /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
        /// can have the following values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>NONE</code> - (Default) Data compression is turned off when
        /// the file system is created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LZ4</code> - Data compression is turned on with the LZ4
        /// algorithm.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        pub fn data_compression_type(mut self, input: crate::model::DataCompressionType) -> Self {
            self.data_compression_type = Some(input);
            self
        }
        pub fn set_data_compression_type(
            mut self,
            input: std::option::Option<crate::model::DataCompressionType>,
        ) -> Self {
            self.data_compression_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFileSystemLustreConfiguration`](crate::model::CreateFileSystemLustreConfiguration)
        pub fn build(self) -> crate::model::CreateFileSystemLustreConfiguration {
            crate::model::CreateFileSystemLustreConfiguration {
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                import_path: self.import_path,
                export_path: self.export_path,
                imported_file_chunk_size: self.imported_file_chunk_size,
                deployment_type: self.deployment_type,
                auto_import_policy: self.auto_import_policy,
                per_unit_storage_throughput: self.per_unit_storage_throughput,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                copy_tags_to_backups: self.copy_tags_to_backups,
                drive_cache_type: self.drive_cache_type,
                data_compression_type: self.data_compression_type,
            }
        }
    }
}
impl CreateFileSystemLustreConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateFileSystemLustreConfiguration`](crate::model::CreateFileSystemLustreConfiguration)
    pub fn builder() -> crate::model::create_file_system_lustre_configuration::Builder {
        crate::model::create_file_system_lustre_configuration::Builder::default()
    }
}

/// <p>The configuration object for the Microsoft Windows file system used in
/// <code>CreateFileSystem</code> and <code>CreateFileSystemFromBackup</code>
/// operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateFileSystemWindowsConfiguration {
    /// <p>The ID for an existing AWS Managed Microsoft Active Directory (AD) instance that the
    /// file system should join when it's created.</p>
    pub active_directory_id: std::option::Option<std::string::String>,
    /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
    /// your self-managed (including on-premises) Microsoft Active Directory (AD)
    /// directory. For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
    /// Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
    pub self_managed_active_directory_configuration:
        std::option::Option<crate::model::SelfManagedActiveDirectoryConfiguration>,
    /// <p>Specifies the file system deployment type, valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>MULTI_AZ_1</code> - Deploys a high availability file system that is configured
    /// for Multi-AZ redundancy to tolerate temporary Availability Zone (AZ) unavailability. You
    /// can only deploy a Multi-AZ file system in AWS Regions that have a minimum of three Availability Zones. Also
    /// supports HDD storage type</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SINGLE_AZ_1</code> - (Default) Choose to deploy a file system that is configured for single AZ redundancy.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SINGLE_AZ_2</code> - The latest generation Single AZ file system.
    /// Specifies a file system that is configured for single AZ redundancy and supports HDD storage type.</p>
    /// </li>
    /// </ul>
    /// <p>For more information, see
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
    /// Availability and Durability: Single-AZ and Multi-AZ File Systems</a>.</p>
    pub deployment_type: std::option::Option<crate::model::WindowsDeploymentType>,
    /// <p>Required when <code>DeploymentType</code> is set to <code>MULTI_AZ_1</code>. This specifies the subnet
    /// in which you want the preferred file server to be located. For in-AWS applications, we recommend that you launch
    /// your clients in the same Availability Zone (AZ) as your preferred file server to reduce cross-AZ
    /// data transfer costs and minimize latency. </p>
    pub preferred_subnet_id: std::option::Option<std::string::String>,
    /// <p>The throughput of an Amazon FSx file system, measured in megabytes per second, in 2 to
    /// the <i>n</i>th increments, between 2^3 (8) and 2^11 (2048).</p>
    pub throughput_capacity: std::option::Option<i32>,
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
    /// time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>The preferred time to take daily automatic backups, formatted HH:MM in the UTC time
    /// zone.</p>
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. The default is to retain backups for 7
    /// days. Setting this value to 0 disables the creation of automatic backups. The maximum
    /// retention period for backups is 90 days.</p>
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>A boolean flag indicating whether tags for the file system should be copied to
    /// backups. This value defaults to false. If it's set to true, all tags for the file
    /// system are copied to all automatic and user-initiated backups where the user
    /// doesn't specify tags. If this value is true, and you specify one or more tags, only
    /// the specified tags are copied to backups. If you specify one or more tags when creating a
    /// user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
    pub copy_tags_to_backups: std::option::Option<bool>,
    /// <p>An array of one or more DNS alias names that you want to associate with the Amazon FSx file system.
    /// Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
    /// You can associate up to 50 aliases with a file system at any time.
    /// You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
    /// You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
    /// You only need to specify the alias name in the request payload.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a> and
    /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/walkthrough05-file-system-custom-CNAME.html">Walkthrough 5: Using DNS aliases to access your file system</a>, including
    /// additional steps you must take to be able to access your file system using a DNS alias.</p>
    /// <p>An alias name has to meet the following requirements:</p>
    /// <ul>
    /// <li>
    /// <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
    /// </li>
    /// <li>
    /// <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
    /// </li>
    /// <li>
    /// <p>Cannot start or end with a hyphen.</p>
    /// </li>
    /// <li>
    /// <p>Can start with a numeric.</p>
    /// </li>
    /// </ul>
    /// <p>For DNS alias names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    /// as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    pub aliases: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
    /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
    /// file system.</p>
    pub audit_log_configuration:
        std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
}
impl std::fmt::Debug for CreateFileSystemWindowsConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateFileSystemWindowsConfiguration");
        formatter.field("active_directory_id", &self.active_directory_id);
        formatter.field(
            "self_managed_active_directory_configuration",
            &self.self_managed_active_directory_configuration,
        );
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("preferred_subnet_id", &self.preferred_subnet_id);
        formatter.field("throughput_capacity", &self.throughput_capacity);
        formatter.field(
            "weekly_maintenance_start_time",
            &self.weekly_maintenance_start_time,
        );
        formatter.field(
            "daily_automatic_backup_start_time",
            &self.daily_automatic_backup_start_time,
        );
        formatter.field(
            "automatic_backup_retention_days",
            &self.automatic_backup_retention_days,
        );
        formatter.field("copy_tags_to_backups", &self.copy_tags_to_backups);
        formatter.field("aliases", &self.aliases);
        formatter.field("audit_log_configuration", &self.audit_log_configuration);
        formatter.finish()
    }
}
/// See [`CreateFileSystemWindowsConfiguration`](crate::model::CreateFileSystemWindowsConfiguration)
pub mod create_file_system_windows_configuration {
    /// A builder for [`CreateFileSystemWindowsConfiguration`](crate::model::CreateFileSystemWindowsConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_id: std::option::Option<std::string::String>,
        pub(crate) self_managed_active_directory_configuration:
            std::option::Option<crate::model::SelfManagedActiveDirectoryConfiguration>,
        pub(crate) deployment_type: std::option::Option<crate::model::WindowsDeploymentType>,
        pub(crate) preferred_subnet_id: std::option::Option<std::string::String>,
        pub(crate) throughput_capacity: std::option::Option<i32>,
        pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
        pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
        pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
        pub(crate) copy_tags_to_backups: std::option::Option<bool>,
        pub(crate) aliases: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) audit_log_configuration:
            std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
    }
    impl Builder {
        /// <p>The ID for an existing AWS Managed Microsoft Active Directory (AD) instance that the
        /// file system should join when it's created.</p>
        pub fn active_directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_id = Some(input.into());
            self
        }
        pub fn set_active_directory_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_id = input;
            self
        }
        /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
        /// your self-managed (including on-premises) Microsoft Active Directory (AD)
        /// directory. For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
        /// Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
        pub fn self_managed_active_directory_configuration(
            mut self,
            input: crate::model::SelfManagedActiveDirectoryConfiguration,
        ) -> Self {
            self.self_managed_active_directory_configuration = Some(input);
            self
        }
        pub fn set_self_managed_active_directory_configuration(
            mut self,
            input: std::option::Option<crate::model::SelfManagedActiveDirectoryConfiguration>,
        ) -> Self {
            self.self_managed_active_directory_configuration = input;
            self
        }
        /// <p>Specifies the file system deployment type, valid values are the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>MULTI_AZ_1</code> - Deploys a high availability file system that is configured
        /// for Multi-AZ redundancy to tolerate temporary Availability Zone (AZ) unavailability. You
        /// can only deploy a Multi-AZ file system in AWS Regions that have a minimum of three Availability Zones. Also
        /// supports HDD storage type</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SINGLE_AZ_1</code> - (Default) Choose to deploy a file system that is configured for single AZ redundancy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SINGLE_AZ_2</code> - The latest generation Single AZ file system.
        /// Specifies a file system that is configured for single AZ redundancy and supports HDD storage type.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see
        /// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
        /// Availability and Durability: Single-AZ and Multi-AZ File Systems</a>.</p>
        pub fn deployment_type(mut self, input: crate::model::WindowsDeploymentType) -> Self {
            self.deployment_type = Some(input);
            self
        }
        pub fn set_deployment_type(
            mut self,
            input: std::option::Option<crate::model::WindowsDeploymentType>,
        ) -> Self {
            self.deployment_type = input;
            self
        }
        /// <p>Required when <code>DeploymentType</code> is set to <code>MULTI_AZ_1</code>. This specifies the subnet
        /// in which you want the preferred file server to be located. For in-AWS applications, we recommend that you launch
        /// your clients in the same Availability Zone (AZ) as your preferred file server to reduce cross-AZ
        /// data transfer costs and minimize latency. </p>
        pub fn preferred_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.preferred_subnet_id = Some(input.into());
            self
        }
        pub fn set_preferred_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_subnet_id = input;
            self
        }
        /// <p>The throughput of an Amazon FSx file system, measured in megabytes per second, in 2 to
        /// the <i>n</i>th increments, between 2^3 (8) and 2^11 (2048).</p>
        pub fn throughput_capacity(mut self, input: i32) -> Self {
            self.throughput_capacity = Some(input);
            self
        }
        pub fn set_throughput_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput_capacity = input;
            self
        }
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        /// time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        pub fn weekly_maintenance_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = Some(input.into());
            self
        }
        pub fn set_weekly_maintenance_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weekly_maintenance_start_time = input;
            self
        }
        /// <p>The preferred time to take daily automatic backups, formatted HH:MM in the UTC time
        /// zone.</p>
        pub fn daily_automatic_backup_start_time(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = Some(input.into());
            self
        }
        pub fn set_daily_automatic_backup_start_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_automatic_backup_start_time = input;
            self
        }
        /// <p>The number of days to retain automatic backups. The default is to retain backups for 7
        /// days. Setting this value to 0 disables the creation of automatic backups. The maximum
        /// retention period for backups is 90 days.</p>
        pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
            self.automatic_backup_retention_days = Some(input);
            self
        }
        pub fn set_automatic_backup_retention_days(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.automatic_backup_retention_days = input;
            self
        }
        /// <p>A boolean flag indicating whether tags for the file system should be copied to
        /// backups. This value defaults to false. If it's set to true, all tags for the file
        /// system are copied to all automatic and user-initiated backups where the user
        /// doesn't specify tags. If this value is true, and you specify one or more tags, only
        /// the specified tags are copied to backups. If you specify one or more tags when creating a
        /// user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
        pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
            self.copy_tags_to_backups = Some(input);
            self
        }
        pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
            self.copy_tags_to_backups = input;
            self
        }
        pub fn aliases(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.aliases.unwrap_or_default();
            v.push(input.into());
            self.aliases = Some(v);
            self
        }
        pub fn set_aliases(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.aliases = input;
            self
        }
        /// <p>The configuration that Amazon FSx for Windows File Server uses to audit and log
        /// user accesses of files, folders, and file shares on the Amazon FSx for Windows File Server
        /// file system.</p>
        pub fn audit_log_configuration(
            mut self,
            input: crate::model::WindowsAuditLogCreateConfiguration,
        ) -> Self {
            self.audit_log_configuration = Some(input);
            self
        }
        pub fn set_audit_log_configuration(
            mut self,
            input: std::option::Option<crate::model::WindowsAuditLogCreateConfiguration>,
        ) -> Self {
            self.audit_log_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFileSystemWindowsConfiguration`](crate::model::CreateFileSystemWindowsConfiguration)
        pub fn build(self) -> crate::model::CreateFileSystemWindowsConfiguration {
            crate::model::CreateFileSystemWindowsConfiguration {
                active_directory_id: self.active_directory_id,
                self_managed_active_directory_configuration: self
                    .self_managed_active_directory_configuration,
                deployment_type: self.deployment_type,
                preferred_subnet_id: self.preferred_subnet_id,
                throughput_capacity: self.throughput_capacity,
                weekly_maintenance_start_time: self.weekly_maintenance_start_time,
                daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
                automatic_backup_retention_days: self.automatic_backup_retention_days,
                copy_tags_to_backups: self.copy_tags_to_backups,
                aliases: self.aliases,
                audit_log_configuration: self.audit_log_configuration,
            }
        }
    }
}
impl CreateFileSystemWindowsConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateFileSystemWindowsConfiguration`](crate::model::CreateFileSystemWindowsConfiguration)
    pub fn builder() -> crate::model::create_file_system_windows_configuration::Builder {
        crate::model::create_file_system_windows_configuration::Builder::default()
    }
}

/// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
/// your self-managed (including on-premises) Microsoft Active Directory (AD)
/// directory. For more information, see
/// <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
/// Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SelfManagedActiveDirectoryConfiguration {
    /// <p>The fully qualified domain name of the self-managed AD directory, such as
    /// <code>corp.example.com</code>.</p>
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>(Optional) The fully qualified distinguished name of the organizational unit within
    /// your self-managed AD directory that the Windows File Server instance will join. Amazon
    /// FSx only accepts OU as the direct parent of the file system. An example is
    /// <code>OU=FSx,DC=yourdomain,DC=corp,DC=com</code>. To learn more, see <a href="https://tools.ietf.org/html/rfc2253">RFC 2253</a>. If none is provided, the
    /// FSx file system is created in the default location of your self-managed AD directory. </p>
    /// <important>
    /// <p>Only Organizational Unit (OU) objects can be the direct parent of the file system
    /// that you're creating.</p>
    /// </important>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    /// <p>(Optional) The name of the domain group whose members are granted administrative
    /// privileges for the file system. Administrative privileges include taking ownership of
    /// files and folders, setting audit controls (audit ACLs) on files and folders, and             
    /// administering the file system remotely by using the FSx Remote PowerShell.
    /// The group that you specify must already exist in your domain. If you don't provide one,
    /// your AD domain's Domain Admins group is used.</p>
    pub file_system_administrators_group: std::option::Option<std::string::String>,
    /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx
    /// will use to join to your AD domain. This account must have the permission to join
    /// computers to the domain in the organizational unit provided in
    /// <code>OrganizationalUnitDistinguishedName</code>, or in the default location of your
    /// AD domain.</p>
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The password for the service account on your self-managed AD domain that Amazon FSx
    /// will use to join to your AD domain.</p>
    pub password: std::option::Option<std::string::String>,
    /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
    /// self-managed AD directory. </p>
    pub dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SelfManagedActiveDirectoryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SelfManagedActiveDirectoryConfiguration");
        formatter.field("domain_name", &self.domain_name);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.field(
            "file_system_administrators_group",
            &self.file_system_administrators_group,
        );
        formatter.field("user_name", &self.user_name);
        formatter.field("password", &"*** Sensitive Data Redacted ***");
        formatter.field("dns_ips", &self.dns_ips);
        formatter.finish()
    }
}
/// See [`SelfManagedActiveDirectoryConfiguration`](crate::model::SelfManagedActiveDirectoryConfiguration)
pub mod self_managed_active_directory_configuration {
    /// A builder for [`SelfManagedActiveDirectoryConfiguration`](crate::model::SelfManagedActiveDirectoryConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
        pub(crate) file_system_administrators_group: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) password: std::option::Option<std::string::String>,
        pub(crate) dns_ips: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The fully qualified domain name of the self-managed AD directory, such as
        /// <code>corp.example.com</code>.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>(Optional) The fully qualified distinguished name of the organizational unit within
        /// your self-managed AD directory that the Windows File Server instance will join. Amazon
        /// FSx only accepts OU as the direct parent of the file system. An example is
        /// <code>OU=FSx,DC=yourdomain,DC=corp,DC=com</code>. To learn more, see <a href="https://tools.ietf.org/html/rfc2253">RFC 2253</a>. If none is provided, the
        /// FSx file system is created in the default location of your self-managed AD directory. </p>
        /// <important>
        /// <p>Only Organizational Unit (OU) objects can be the direct parent of the file system
        /// that you're creating.</p>
        /// </important>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// <p>(Optional) The name of the domain group whose members are granted administrative
        /// privileges for the file system. Administrative privileges include taking ownership of
        /// files and folders, setting audit controls (audit ACLs) on files and folders, and             
        /// administering the file system remotely by using the FSx Remote PowerShell.
        /// The group that you specify must already exist in your domain. If you don't provide one,
        /// your AD domain's Domain Admins group is used.</p>
        pub fn file_system_administrators_group(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.file_system_administrators_group = Some(input.into());
            self
        }
        pub fn set_file_system_administrators_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_administrators_group = input;
            self
        }
        /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx
        /// will use to join to your AD domain. This account must have the permission to join
        /// computers to the domain in the organizational unit provided in
        /// <code>OrganizationalUnitDistinguishedName</code>, or in the default location of your
        /// AD domain.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The password for the service account on your self-managed AD domain that Amazon FSx
        /// will use to join to your AD domain.</p>
        pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
            self.password = Some(input.into());
            self
        }
        pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.password = input;
            self
        }
        pub fn dns_ips(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ips.unwrap_or_default();
            v.push(input.into());
            self.dns_ips = Some(v);
            self
        }
        pub fn set_dns_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ips = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfManagedActiveDirectoryConfiguration`](crate::model::SelfManagedActiveDirectoryConfiguration)
        pub fn build(self) -> crate::model::SelfManagedActiveDirectoryConfiguration {
            crate::model::SelfManagedActiveDirectoryConfiguration {
                domain_name: self.domain_name,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
                file_system_administrators_group: self.file_system_administrators_group,
                user_name: self.user_name,
                password: self.password,
                dns_ips: self.dns_ips,
            }
        }
    }
}
impl SelfManagedActiveDirectoryConfiguration {
    /// Creates a new builder-style object to manufacture [`SelfManagedActiveDirectoryConfiguration`](crate::model::SelfManagedActiveDirectoryConfiguration)
    pub fn builder() -> crate::model::self_managed_active_directory_configuration::Builder {
        crate::model::self_managed_active_directory_configuration::Builder::default()
    }
}
