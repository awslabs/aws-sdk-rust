// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies the configuration of the ONTAP volume that you are creating.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateOntapVolumeConfiguration {
    /// <p>Specifies the location in the SVM's namespace where the volume is mounted. The <code>JunctionPath</code> must have a leading forward slash, such as <code>/vol3</code>.</p>
    #[doc(hidden)]
    pub junction_path: std::option::Option<std::string::String>,
    /// <p>Specifies the security style for the volume. If a volume's security style is not specified, it is automatically set to the root volume's security style. The security style determines the type of permissions that FSx for ONTAP uses to control data access. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/managing-volumes.html#volume-security-style">Volume security style</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>. Specify one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>UNIX</code> if the file system is managed by a UNIX administrator, the majority of users are NFS clients, and an application accessing the data uses a UNIX user as the service account. </p> </li>
    /// <li> <p> <code>NTFS</code> if the file system is managed by a Windows administrator, the majority of users are SMB clients, and an application accessing the data uses a Windows user as the service account.</p> </li>
    /// <li> <p> <code>MIXED</code> if the file system is managed by both UNIX and Windows administrators and users consist of both NFS and SMB clients.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub security_style: std::option::Option<crate::types::SecurityStyle>,
    /// <p>Specifies the size of the volume, in megabytes (MB), that you are creating.</p>
    #[doc(hidden)]
    pub size_in_megabytes: std::option::Option<i32>,
    /// <p>Set to true to enable deduplication, compression, and compaction storage efficiency features on the volume.</p>
    #[doc(hidden)]
    pub storage_efficiency_enabled: std::option::Option<bool>,
    /// <p>Specifies the ONTAP SVM in which to create the volume.</p>
    #[doc(hidden)]
    pub storage_virtual_machine_id: std::option::Option<std::string::String>,
    /// <p>Describes the data tiering policy for an ONTAP volume. When enabled, Amazon FSx for ONTAP's intelligent tiering automatically transitions a volume's data between the file system's primary storage and capacity pool storage based on your access patterns.</p>
    /// <p>Valid tiering policies are the following:</p>
    /// <ul>
    /// <li> <p> <code>SNAPSHOT_ONLY</code> - (Default value) moves cold snapshots to the capacity pool storage tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>AUTO</code> - moves cold user data and snapshots to the capacity pool storage tier based on your access patterns.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>ALL</code> - moves all user data blocks in both the active file system and Snapshot copies to the storage pool tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>NONE</code> - keeps a volume's data in the primary storage tier, preventing it from being moved to the capacity pool tier.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub tiering_policy: std::option::Option<crate::types::TieringPolicy>,
    /// <p>Specifies the type of volume you are creating. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p> </li>
    /// <li> <p> <code>DP</code> specifies a data-protection volume. A <code>DP</code> volume is read-only and can be used as the destination of a NetApp SnapMirror relationship.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types">Volume types</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    #[doc(hidden)]
    pub ontap_volume_type: std::option::Option<crate::types::InputOntapVolumeType>,
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li> <p> <code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p> </li>
    /// <li> <p> <code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p> </li>
    /// <li> <p> <code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p> </li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    #[doc(hidden)]
    pub snapshot_policy: std::option::Option<std::string::String>,
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    #[doc(hidden)]
    pub copy_tags_to_backups: std::option::Option<bool>,
}
impl CreateOntapVolumeConfiguration {
    /// <p>Specifies the location in the SVM's namespace where the volume is mounted. The <code>JunctionPath</code> must have a leading forward slash, such as <code>/vol3</code>.</p>
    pub fn junction_path(&self) -> std::option::Option<&str> {
        self.junction_path.as_deref()
    }
    /// <p>Specifies the security style for the volume. If a volume's security style is not specified, it is automatically set to the root volume's security style. The security style determines the type of permissions that FSx for ONTAP uses to control data access. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/managing-volumes.html#volume-security-style">Volume security style</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>. Specify one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>UNIX</code> if the file system is managed by a UNIX administrator, the majority of users are NFS clients, and an application accessing the data uses a UNIX user as the service account. </p> </li>
    /// <li> <p> <code>NTFS</code> if the file system is managed by a Windows administrator, the majority of users are SMB clients, and an application accessing the data uses a Windows user as the service account.</p> </li>
    /// <li> <p> <code>MIXED</code> if the file system is managed by both UNIX and Windows administrators and users consist of both NFS and SMB clients.</p> </li>
    /// </ul>
    pub fn security_style(&self) -> std::option::Option<&crate::types::SecurityStyle> {
        self.security_style.as_ref()
    }
    /// <p>Specifies the size of the volume, in megabytes (MB), that you are creating.</p>
    pub fn size_in_megabytes(&self) -> std::option::Option<i32> {
        self.size_in_megabytes
    }
    /// <p>Set to true to enable deduplication, compression, and compaction storage efficiency features on the volume.</p>
    pub fn storage_efficiency_enabled(&self) -> std::option::Option<bool> {
        self.storage_efficiency_enabled
    }
    /// <p>Specifies the ONTAP SVM in which to create the volume.</p>
    pub fn storage_virtual_machine_id(&self) -> std::option::Option<&str> {
        self.storage_virtual_machine_id.as_deref()
    }
    /// <p>Describes the data tiering policy for an ONTAP volume. When enabled, Amazon FSx for ONTAP's intelligent tiering automatically transitions a volume's data between the file system's primary storage and capacity pool storage based on your access patterns.</p>
    /// <p>Valid tiering policies are the following:</p>
    /// <ul>
    /// <li> <p> <code>SNAPSHOT_ONLY</code> - (Default value) moves cold snapshots to the capacity pool storage tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>AUTO</code> - moves cold user data and snapshots to the capacity pool storage tier based on your access patterns.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>ALL</code> - moves all user data blocks in both the active file system and Snapshot copies to the storage pool tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>NONE</code> - keeps a volume's data in the primary storage tier, preventing it from being moved to the capacity pool tier.</p> </li>
    /// </ul>
    pub fn tiering_policy(&self) -> std::option::Option<&crate::types::TieringPolicy> {
        self.tiering_policy.as_ref()
    }
    /// <p>Specifies the type of volume you are creating. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p> </li>
    /// <li> <p> <code>DP</code> specifies a data-protection volume. A <code>DP</code> volume is read-only and can be used as the destination of a NetApp SnapMirror relationship.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types">Volume types</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn ontap_volume_type(&self) -> std::option::Option<&crate::types::InputOntapVolumeType> {
        self.ontap_volume_type.as_ref()
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li> <p> <code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p> </li>
    /// <li> <p> <code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p> </li>
    /// <li> <p> <code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p> </li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn snapshot_policy(&self) -> std::option::Option<&str> {
        self.snapshot_policy.as_deref()
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn copy_tags_to_backups(&self) -> std::option::Option<bool> {
        self.copy_tags_to_backups
    }
}
impl CreateOntapVolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateOntapVolumeConfiguration`](crate::types::CreateOntapVolumeConfiguration).
    pub fn builder() -> crate::types::builders::CreateOntapVolumeConfigurationBuilder {
        crate::types::builders::CreateOntapVolumeConfigurationBuilder::default()
    }
}

/// A builder for [`CreateOntapVolumeConfiguration`](crate::types::CreateOntapVolumeConfiguration).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CreateOntapVolumeConfigurationBuilder {
    pub(crate) junction_path: std::option::Option<std::string::String>,
    pub(crate) security_style: std::option::Option<crate::types::SecurityStyle>,
    pub(crate) size_in_megabytes: std::option::Option<i32>,
    pub(crate) storage_efficiency_enabled: std::option::Option<bool>,
    pub(crate) storage_virtual_machine_id: std::option::Option<std::string::String>,
    pub(crate) tiering_policy: std::option::Option<crate::types::TieringPolicy>,
    pub(crate) ontap_volume_type: std::option::Option<crate::types::InputOntapVolumeType>,
    pub(crate) snapshot_policy: std::option::Option<std::string::String>,
    pub(crate) copy_tags_to_backups: std::option::Option<bool>,
}
impl CreateOntapVolumeConfigurationBuilder {
    /// <p>Specifies the location in the SVM's namespace where the volume is mounted. The <code>JunctionPath</code> must have a leading forward slash, such as <code>/vol3</code>.</p>
    pub fn junction_path(mut self, input: impl Into<std::string::String>) -> Self {
        self.junction_path = Some(input.into());
        self
    }
    /// <p>Specifies the location in the SVM's namespace where the volume is mounted. The <code>JunctionPath</code> must have a leading forward slash, such as <code>/vol3</code>.</p>
    pub fn set_junction_path(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.junction_path = input;
        self
    }
    /// <p>Specifies the security style for the volume. If a volume's security style is not specified, it is automatically set to the root volume's security style. The security style determines the type of permissions that FSx for ONTAP uses to control data access. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/managing-volumes.html#volume-security-style">Volume security style</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>. Specify one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>UNIX</code> if the file system is managed by a UNIX administrator, the majority of users are NFS clients, and an application accessing the data uses a UNIX user as the service account. </p> </li>
    /// <li> <p> <code>NTFS</code> if the file system is managed by a Windows administrator, the majority of users are SMB clients, and an application accessing the data uses a Windows user as the service account.</p> </li>
    /// <li> <p> <code>MIXED</code> if the file system is managed by both UNIX and Windows administrators and users consist of both NFS and SMB clients.</p> </li>
    /// </ul>
    pub fn security_style(mut self, input: crate::types::SecurityStyle) -> Self {
        self.security_style = Some(input);
        self
    }
    /// <p>Specifies the security style for the volume. If a volume's security style is not specified, it is automatically set to the root volume's security style. The security style determines the type of permissions that FSx for ONTAP uses to control data access. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/managing-volumes.html#volume-security-style">Volume security style</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>. Specify one of the following values:</p>
    /// <ul>
    /// <li> <p> <code>UNIX</code> if the file system is managed by a UNIX administrator, the majority of users are NFS clients, and an application accessing the data uses a UNIX user as the service account. </p> </li>
    /// <li> <p> <code>NTFS</code> if the file system is managed by a Windows administrator, the majority of users are SMB clients, and an application accessing the data uses a Windows user as the service account.</p> </li>
    /// <li> <p> <code>MIXED</code> if the file system is managed by both UNIX and Windows administrators and users consist of both NFS and SMB clients.</p> </li>
    /// </ul>
    pub fn set_security_style(
        mut self,
        input: std::option::Option<crate::types::SecurityStyle>,
    ) -> Self {
        self.security_style = input;
        self
    }
    /// <p>Specifies the size of the volume, in megabytes (MB), that you are creating.</p>
    pub fn size_in_megabytes(mut self, input: i32) -> Self {
        self.size_in_megabytes = Some(input);
        self
    }
    /// <p>Specifies the size of the volume, in megabytes (MB), that you are creating.</p>
    pub fn set_size_in_megabytes(mut self, input: std::option::Option<i32>) -> Self {
        self.size_in_megabytes = input;
        self
    }
    /// <p>Set to true to enable deduplication, compression, and compaction storage efficiency features on the volume.</p>
    pub fn storage_efficiency_enabled(mut self, input: bool) -> Self {
        self.storage_efficiency_enabled = Some(input);
        self
    }
    /// <p>Set to true to enable deduplication, compression, and compaction storage efficiency features on the volume.</p>
    pub fn set_storage_efficiency_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.storage_efficiency_enabled = input;
        self
    }
    /// <p>Specifies the ONTAP SVM in which to create the volume.</p>
    pub fn storage_virtual_machine_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.storage_virtual_machine_id = Some(input.into());
        self
    }
    /// <p>Specifies the ONTAP SVM in which to create the volume.</p>
    pub fn set_storage_virtual_machine_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.storage_virtual_machine_id = input;
        self
    }
    /// <p>Describes the data tiering policy for an ONTAP volume. When enabled, Amazon FSx for ONTAP's intelligent tiering automatically transitions a volume's data between the file system's primary storage and capacity pool storage based on your access patterns.</p>
    /// <p>Valid tiering policies are the following:</p>
    /// <ul>
    /// <li> <p> <code>SNAPSHOT_ONLY</code> - (Default value) moves cold snapshots to the capacity pool storage tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>AUTO</code> - moves cold user data and snapshots to the capacity pool storage tier based on your access patterns.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>ALL</code> - moves all user data blocks in both the active file system and Snapshot copies to the storage pool tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>NONE</code> - keeps a volume's data in the primary storage tier, preventing it from being moved to the capacity pool tier.</p> </li>
    /// </ul>
    pub fn tiering_policy(mut self, input: crate::types::TieringPolicy) -> Self {
        self.tiering_policy = Some(input);
        self
    }
    /// <p>Describes the data tiering policy for an ONTAP volume. When enabled, Amazon FSx for ONTAP's intelligent tiering automatically transitions a volume's data between the file system's primary storage and capacity pool storage based on your access patterns.</p>
    /// <p>Valid tiering policies are the following:</p>
    /// <ul>
    /// <li> <p> <code>SNAPSHOT_ONLY</code> - (Default value) moves cold snapshots to the capacity pool storage tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>AUTO</code> - moves cold user data and snapshots to the capacity pool storage tier based on your access patterns.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>ALL</code> - moves all user data blocks in both the active file system and Snapshot copies to the storage pool tier.</p> </li>
    /// </ul>
    /// <ul>
    /// <li> <p> <code>NONE</code> - keeps a volume's data in the primary storage tier, preventing it from being moved to the capacity pool tier.</p> </li>
    /// </ul>
    pub fn set_tiering_policy(
        mut self,
        input: std::option::Option<crate::types::TieringPolicy>,
    ) -> Self {
        self.tiering_policy = input;
        self
    }
    /// <p>Specifies the type of volume you are creating. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p> </li>
    /// <li> <p> <code>DP</code> specifies a data-protection volume. A <code>DP</code> volume is read-only and can be used as the destination of a NetApp SnapMirror relationship.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types">Volume types</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn ontap_volume_type(mut self, input: crate::types::InputOntapVolumeType) -> Self {
        self.ontap_volume_type = Some(input);
        self
    }
    /// <p>Specifies the type of volume you are creating. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p> </li>
    /// <li> <p> <code>DP</code> specifies a data-protection volume. A <code>DP</code> volume is read-only and can be used as the destination of a NetApp SnapMirror relationship.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types">Volume types</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn set_ontap_volume_type(
        mut self,
        input: std::option::Option<crate::types::InputOntapVolumeType>,
    ) -> Self {
        self.ontap_volume_type = input;
        self
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li> <p> <code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p> </li>
    /// <li> <p> <code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p> </li>
    /// <li> <p> <code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p> </li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn snapshot_policy(mut self, input: impl Into<std::string::String>) -> Self {
        self.snapshot_policy = Some(input.into());
        self
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li> <p> <code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p> </li>
    /// <li> <p> <code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p> </li>
    /// <li> <p> <code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p> </li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the <i>Amazon FSx for NetApp ONTAP User Guide</i>.</p>
    pub fn set_snapshot_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.snapshot_policy = input;
        self
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
        self.copy_tags_to_backups = Some(input);
        self
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
        self.copy_tags_to_backups = input;
        self
    }
    /// Consumes the builder and constructs a [`CreateOntapVolumeConfiguration`](crate::types::CreateOntapVolumeConfiguration).
    pub fn build(self) -> crate::types::CreateOntapVolumeConfiguration {
        crate::types::CreateOntapVolumeConfiguration {
            junction_path: self.junction_path,
            security_style: self.security_style,
            size_in_megabytes: self.size_in_megabytes,
            storage_efficiency_enabled: self.storage_efficiency_enabled,
            storage_virtual_machine_id: self.storage_virtual_machine_id,
            tiering_policy: self.tiering_policy,
            ontap_volume_type: self.ontap_volume_type,
            snapshot_policy: self.snapshot_policy,
            copy_tags_to_backups: self.copy_tags_to_backups,
        }
    }
}
