// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The configuration for the Amazon FSx for Lustre file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LustreFileSystemConfiguration {
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC time zone. Here, <code>d</code> is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    #[doc(hidden)]
    pub weekly_maintenance_start_time: std::option::Option<std::string::String>,
    /// <p>The data repository configuration object for Lustre file systems returned in the response of the <code>CreateFileSystem</code> operation.</p>
    /// <p>This data type is not supported for file systems with the <code>Persistent_2</code> deployment type. Instead, use .</p>
    #[doc(hidden)]
    pub data_repository_configuration:
        std::option::Option<crate::types::DataRepositoryConfiguration>,
    /// <p>The deployment type of the FSx for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage and shorter-term processing of data.</p>
    /// <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment types are best suited for when you need temporary storage and shorter-term processing of data. The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>The <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment type is used for longer-term storage and workloads and encryption of data in transit. <code>PERSISTENT_2</code> is built on Lustre v2.12 and offers higher <code>PerUnitStorageThroughput</code> (up to 1000 MB/s/TiB) along with a lower minimum storage capacity requirement (600 GiB). To learn more about FSx for Lustre deployment types, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html"> FSx for Lustre deployment options</a>.</p>
    /// <p>The default is <code>SCRATCH_1</code>.</p>
    #[doc(hidden)]
    pub deployment_type: std::option::Option<crate::types::LustreDeploymentType>,
    /// <p>Per unit storage throughput represents the megabytes per second of read or write throughput per 1 tebibyte of storage provisioned. File system throughput capacity is equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is only valid for <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types. </p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>For <code>PERSISTENT_1</code> SSD storage: 50, 100, 200.</p> </li>
    /// <li> <p>For <code>PERSISTENT_1</code> HDD storage: 12, 40.</p> </li>
    /// <li> <p>For <code>PERSISTENT_2</code> SSD storage: 125, 250, 500, 1000.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub per_unit_storage_throughput: std::option::Option<i32>,
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>". For <code>SCRATCH_2</code>, <code>PERSISTENT_1</code>, and <code>PERSISTENT_2</code> deployment types, this value is a string that is unique within an Amazon Web Services Region. </p>
    #[doc(hidden)]
    pub mount_name: std::option::Option<std::string::String>,
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    #[doc(hidden)]
    pub daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    /// <p>The number of days to retain automatic backups. Setting this property to <code>0</code> disables automatic backups. You can retain automatic backups for a maximum of 90 days. The default is <code>0</code>.</p>
    #[doc(hidden)]
    pub automatic_backup_retention_days: std::option::Option<i32>,
    /// <p>A boolean flag indicating whether tags on the file system are copied to backups. If it's set to true, all tags on the file system are copied to all automatic backups and any user-initiated backups where the user doesn't specify any tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the file system, regardless of this value. (Default = false)</p>
    #[doc(hidden)]
    pub copy_tags_to_backups: std::option::Option<bool>,
    /// <p>The type of drive cache used by <code>PERSISTENT_1</code> file systems that are provisioned with HDD storage devices. This parameter is required when <code>StorageType</code> is HDD. When set to <code>READ</code> the file system has an SSD storage cache that is sized to 20% of the file system's storage capacity. This improves the performance for frequently accessed files by caching up to 20% of the total storage capacity.</p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    #[doc(hidden)]
    pub drive_cache_type: std::option::Option<crate::types::DriveCacheType>,
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code> can have the following values:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Data compression is turned off for the file system.</p> </li>
    /// <li> <p> <code>LZ4</code> - Data compression is turned on with the LZ4 algorithm.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    #[doc(hidden)]
    pub data_compression_type: std::option::Option<crate::types::DataCompressionType>,
    /// <p>The Lustre logging configuration. Lustre logging writes the enabled log events for your file system to Amazon CloudWatch Logs.</p>
    #[doc(hidden)]
    pub log_configuration: std::option::Option<crate::types::LustreLogConfiguration>,
    /// <p>The Lustre root squash configuration for an Amazon FSx for Lustre file system. When enabled, root squash restricts root-level access from clients that try to access your file system as a root user.</p>
    #[doc(hidden)]
    pub root_squash_configuration: std::option::Option<crate::types::LustreRootSquashConfiguration>,
}
impl LustreFileSystemConfiguration {
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC time zone. Here, <code>d</code> is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub fn weekly_maintenance_start_time(&self) -> std::option::Option<&str> {
        self.weekly_maintenance_start_time.as_deref()
    }
    /// <p>The data repository configuration object for Lustre file systems returned in the response of the <code>CreateFileSystem</code> operation.</p>
    /// <p>This data type is not supported for file systems with the <code>Persistent_2</code> deployment type. Instead, use .</p>
    pub fn data_repository_configuration(
        &self,
    ) -> std::option::Option<&crate::types::DataRepositoryConfiguration> {
        self.data_repository_configuration.as_ref()
    }
    /// <p>The deployment type of the FSx for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage and shorter-term processing of data.</p>
    /// <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment types are best suited for when you need temporary storage and shorter-term processing of data. The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>The <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment type is used for longer-term storage and workloads and encryption of data in transit. <code>PERSISTENT_2</code> is built on Lustre v2.12 and offers higher <code>PerUnitStorageThroughput</code> (up to 1000 MB/s/TiB) along with a lower minimum storage capacity requirement (600 GiB). To learn more about FSx for Lustre deployment types, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html"> FSx for Lustre deployment options</a>.</p>
    /// <p>The default is <code>SCRATCH_1</code>.</p>
    pub fn deployment_type(&self) -> std::option::Option<&crate::types::LustreDeploymentType> {
        self.deployment_type.as_ref()
    }
    /// <p>Per unit storage throughput represents the megabytes per second of read or write throughput per 1 tebibyte of storage provisioned. File system throughput capacity is equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is only valid for <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types. </p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>For <code>PERSISTENT_1</code> SSD storage: 50, 100, 200.</p> </li>
    /// <li> <p>For <code>PERSISTENT_1</code> HDD storage: 12, 40.</p> </li>
    /// <li> <p>For <code>PERSISTENT_2</code> SSD storage: 125, 250, 500, 1000.</p> </li>
    /// </ul>
    pub fn per_unit_storage_throughput(&self) -> std::option::Option<i32> {
        self.per_unit_storage_throughput
    }
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>". For <code>SCRATCH_2</code>, <code>PERSISTENT_1</code>, and <code>PERSISTENT_2</code> deployment types, this value is a string that is unique within an Amazon Web Services Region. </p>
    pub fn mount_name(&self) -> std::option::Option<&str> {
        self.mount_name.as_deref()
    }
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub fn daily_automatic_backup_start_time(&self) -> std::option::Option<&str> {
        self.daily_automatic_backup_start_time.as_deref()
    }
    /// <p>The number of days to retain automatic backups. Setting this property to <code>0</code> disables automatic backups. You can retain automatic backups for a maximum of 90 days. The default is <code>0</code>.</p>
    pub fn automatic_backup_retention_days(&self) -> std::option::Option<i32> {
        self.automatic_backup_retention_days
    }
    /// <p>A boolean flag indicating whether tags on the file system are copied to backups. If it's set to true, all tags on the file system are copied to all automatic backups and any user-initiated backups where the user doesn't specify any tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the file system, regardless of this value. (Default = false)</p>
    pub fn copy_tags_to_backups(&self) -> std::option::Option<bool> {
        self.copy_tags_to_backups
    }
    /// <p>The type of drive cache used by <code>PERSISTENT_1</code> file systems that are provisioned with HDD storage devices. This parameter is required when <code>StorageType</code> is HDD. When set to <code>READ</code> the file system has an SSD storage cache that is sized to 20% of the file system's storage capacity. This improves the performance for frequently accessed files by caching up to 20% of the total storage capacity.</p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    pub fn drive_cache_type(&self) -> std::option::Option<&crate::types::DriveCacheType> {
        self.drive_cache_type.as_ref()
    }
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code> can have the following values:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Data compression is turned off for the file system.</p> </li>
    /// <li> <p> <code>LZ4</code> - Data compression is turned on with the LZ4 algorithm.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub fn data_compression_type(&self) -> std::option::Option<&crate::types::DataCompressionType> {
        self.data_compression_type.as_ref()
    }
    /// <p>The Lustre logging configuration. Lustre logging writes the enabled log events for your file system to Amazon CloudWatch Logs.</p>
    pub fn log_configuration(&self) -> std::option::Option<&crate::types::LustreLogConfiguration> {
        self.log_configuration.as_ref()
    }
    /// <p>The Lustre root squash configuration for an Amazon FSx for Lustre file system. When enabled, root squash restricts root-level access from clients that try to access your file system as a root user.</p>
    pub fn root_squash_configuration(
        &self,
    ) -> std::option::Option<&crate::types::LustreRootSquashConfiguration> {
        self.root_squash_configuration.as_ref()
    }
}
impl LustreFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`LustreFileSystemConfiguration`](crate::types::LustreFileSystemConfiguration).
    pub fn builder() -> crate::types::builders::LustreFileSystemConfigurationBuilder {
        crate::types::builders::LustreFileSystemConfigurationBuilder::default()
    }
}

/// A builder for [`LustreFileSystemConfiguration`](crate::types::LustreFileSystemConfiguration).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct LustreFileSystemConfigurationBuilder {
    pub(crate) weekly_maintenance_start_time: std::option::Option<std::string::String>,
    pub(crate) data_repository_configuration:
        std::option::Option<crate::types::DataRepositoryConfiguration>,
    pub(crate) deployment_type: std::option::Option<crate::types::LustreDeploymentType>,
    pub(crate) per_unit_storage_throughput: std::option::Option<i32>,
    pub(crate) mount_name: std::option::Option<std::string::String>,
    pub(crate) daily_automatic_backup_start_time: std::option::Option<std::string::String>,
    pub(crate) automatic_backup_retention_days: std::option::Option<i32>,
    pub(crate) copy_tags_to_backups: std::option::Option<bool>,
    pub(crate) drive_cache_type: std::option::Option<crate::types::DriveCacheType>,
    pub(crate) data_compression_type: std::option::Option<crate::types::DataCompressionType>,
    pub(crate) log_configuration: std::option::Option<crate::types::LustreLogConfiguration>,
    pub(crate) root_squash_configuration:
        std::option::Option<crate::types::LustreRootSquashConfiguration>,
}
impl LustreFileSystemConfigurationBuilder {
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC time zone. Here, <code>d</code> is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub fn weekly_maintenance_start_time(mut self, input: impl Into<std::string::String>) -> Self {
        self.weekly_maintenance_start_time = Some(input.into());
        self
    }
    /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC time zone. Here, <code>d</code> is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
    pub fn set_weekly_maintenance_start_time(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.weekly_maintenance_start_time = input;
        self
    }
    /// <p>The data repository configuration object for Lustre file systems returned in the response of the <code>CreateFileSystem</code> operation.</p>
    /// <p>This data type is not supported for file systems with the <code>Persistent_2</code> deployment type. Instead, use .</p>
    pub fn data_repository_configuration(
        mut self,
        input: crate::types::DataRepositoryConfiguration,
    ) -> Self {
        self.data_repository_configuration = Some(input);
        self
    }
    /// <p>The data repository configuration object for Lustre file systems returned in the response of the <code>CreateFileSystem</code> operation.</p>
    /// <p>This data type is not supported for file systems with the <code>Persistent_2</code> deployment type. Instead, use .</p>
    pub fn set_data_repository_configuration(
        mut self,
        input: std::option::Option<crate::types::DataRepositoryConfiguration>,
    ) -> Self {
        self.data_repository_configuration = input;
        self
    }
    /// <p>The deployment type of the FSx for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage and shorter-term processing of data.</p>
    /// <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment types are best suited for when you need temporary storage and shorter-term processing of data. The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>The <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment type is used for longer-term storage and workloads and encryption of data in transit. <code>PERSISTENT_2</code> is built on Lustre v2.12 and offers higher <code>PerUnitStorageThroughput</code> (up to 1000 MB/s/TiB) along with a lower minimum storage capacity requirement (600 GiB). To learn more about FSx for Lustre deployment types, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html"> FSx for Lustre deployment options</a>.</p>
    /// <p>The default is <code>SCRATCH_1</code>.</p>
    pub fn deployment_type(mut self, input: crate::types::LustreDeploymentType) -> Self {
        self.deployment_type = Some(input);
        self
    }
    /// <p>The deployment type of the FSx for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage and shorter-term processing of data.</p>
    /// <p> <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment types are best suited for when you need temporary storage and shorter-term processing of data. The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst throughput capacity than <code>SCRATCH_1</code>.</p>
    /// <p>The <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment type is used for longer-term storage and workloads and encryption of data in transit. <code>PERSISTENT_2</code> is built on Lustre v2.12 and offers higher <code>PerUnitStorageThroughput</code> (up to 1000 MB/s/TiB) along with a lower minimum storage capacity requirement (600 GiB). To learn more about FSx for Lustre deployment types, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html"> FSx for Lustre deployment options</a>.</p>
    /// <p>The default is <code>SCRATCH_1</code>.</p>
    pub fn set_deployment_type(
        mut self,
        input: std::option::Option<crate::types::LustreDeploymentType>,
    ) -> Self {
        self.deployment_type = input;
        self
    }
    /// <p>Per unit storage throughput represents the megabytes per second of read or write throughput per 1 tebibyte of storage provisioned. File system throughput capacity is equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is only valid for <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types. </p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>For <code>PERSISTENT_1</code> SSD storage: 50, 100, 200.</p> </li>
    /// <li> <p>For <code>PERSISTENT_1</code> HDD storage: 12, 40.</p> </li>
    /// <li> <p>For <code>PERSISTENT_2</code> SSD storage: 125, 250, 500, 1000.</p> </li>
    /// </ul>
    pub fn per_unit_storage_throughput(mut self, input: i32) -> Self {
        self.per_unit_storage_throughput = Some(input);
        self
    }
    /// <p>Per unit storage throughput represents the megabytes per second of read or write throughput per 1 tebibyte of storage provisioned. File system throughput capacity is equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is only valid for <code>PERSISTENT_1</code> and <code>PERSISTENT_2</code> deployment types. </p>
    /// <p>Valid values:</p>
    /// <ul>
    /// <li> <p>For <code>PERSISTENT_1</code> SSD storage: 50, 100, 200.</p> </li>
    /// <li> <p>For <code>PERSISTENT_1</code> HDD storage: 12, 40.</p> </li>
    /// <li> <p>For <code>PERSISTENT_2</code> SSD storage: 125, 250, 500, 1000.</p> </li>
    /// </ul>
    pub fn set_per_unit_storage_throughput(mut self, input: std::option::Option<i32>) -> Self {
        self.per_unit_storage_throughput = input;
        self
    }
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>". For <code>SCRATCH_2</code>, <code>PERSISTENT_1</code>, and <code>PERSISTENT_2</code> deployment types, this value is a string that is unique within an Amazon Web Services Region. </p>
    pub fn mount_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.mount_name = Some(input.into());
        self
    }
    /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
    /// <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>". For <code>SCRATCH_2</code>, <code>PERSISTENT_1</code>, and <code>PERSISTENT_2</code> deployment types, this value is a string that is unique within an Amazon Web Services Region. </p>
    pub fn set_mount_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.mount_name = input;
        self
    }
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub fn daily_automatic_backup_start_time(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.daily_automatic_backup_start_time = Some(input.into());
        self
    }
    /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
    pub fn set_daily_automatic_backup_start_time(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.daily_automatic_backup_start_time = input;
        self
    }
    /// <p>The number of days to retain automatic backups. Setting this property to <code>0</code> disables automatic backups. You can retain automatic backups for a maximum of 90 days. The default is <code>0</code>.</p>
    pub fn automatic_backup_retention_days(mut self, input: i32) -> Self {
        self.automatic_backup_retention_days = Some(input);
        self
    }
    /// <p>The number of days to retain automatic backups. Setting this property to <code>0</code> disables automatic backups. You can retain automatic backups for a maximum of 90 days. The default is <code>0</code>.</p>
    pub fn set_automatic_backup_retention_days(mut self, input: std::option::Option<i32>) -> Self {
        self.automatic_backup_retention_days = input;
        self
    }
    /// <p>A boolean flag indicating whether tags on the file system are copied to backups. If it's set to true, all tags on the file system are copied to all automatic backups and any user-initiated backups where the user doesn't specify any tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the file system, regardless of this value. (Default = false)</p>
    pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
        self.copy_tags_to_backups = Some(input);
        self
    }
    /// <p>A boolean flag indicating whether tags on the file system are copied to backups. If it's set to true, all tags on the file system are copied to all automatic backups and any user-initiated backups where the user doesn't specify any tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the file system, regardless of this value. (Default = false)</p>
    pub fn set_copy_tags_to_backups(mut self, input: std::option::Option<bool>) -> Self {
        self.copy_tags_to_backups = input;
        self
    }
    /// <p>The type of drive cache used by <code>PERSISTENT_1</code> file systems that are provisioned with HDD storage devices. This parameter is required when <code>StorageType</code> is HDD. When set to <code>READ</code> the file system has an SSD storage cache that is sized to 20% of the file system's storage capacity. This improves the performance for frequently accessed files by caching up to 20% of the total storage capacity.</p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    pub fn drive_cache_type(mut self, input: crate::types::DriveCacheType) -> Self {
        self.drive_cache_type = Some(input);
        self
    }
    /// <p>The type of drive cache used by <code>PERSISTENT_1</code> file systems that are provisioned with HDD storage devices. This parameter is required when <code>StorageType</code> is HDD. When set to <code>READ</code> the file system has an SSD storage cache that is sized to 20% of the file system's storage capacity. This improves the performance for frequently accessed files by caching up to 20% of the total storage capacity.</p>
    /// <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
    pub fn set_drive_cache_type(
        mut self,
        input: std::option::Option<crate::types::DriveCacheType>,
    ) -> Self {
        self.drive_cache_type = input;
        self
    }
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code> can have the following values:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Data compression is turned off for the file system.</p> </li>
    /// <li> <p> <code>LZ4</code> - Data compression is turned on with the LZ4 algorithm.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub fn data_compression_type(mut self, input: crate::types::DataCompressionType) -> Self {
        self.data_compression_type = Some(input);
        self
    }
    /// <p>The data compression configuration for the file system. <code>DataCompressionType</code> can have the following values:</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Data compression is turned off for the file system.</p> </li>
    /// <li> <p> <code>LZ4</code> - Data compression is turned on with the LZ4 algorithm.</p> </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
    pub fn set_data_compression_type(
        mut self,
        input: std::option::Option<crate::types::DataCompressionType>,
    ) -> Self {
        self.data_compression_type = input;
        self
    }
    /// <p>The Lustre logging configuration. Lustre logging writes the enabled log events for your file system to Amazon CloudWatch Logs.</p>
    pub fn log_configuration(mut self, input: crate::types::LustreLogConfiguration) -> Self {
        self.log_configuration = Some(input);
        self
    }
    /// <p>The Lustre logging configuration. Lustre logging writes the enabled log events for your file system to Amazon CloudWatch Logs.</p>
    pub fn set_log_configuration(
        mut self,
        input: std::option::Option<crate::types::LustreLogConfiguration>,
    ) -> Self {
        self.log_configuration = input;
        self
    }
    /// <p>The Lustre root squash configuration for an Amazon FSx for Lustre file system. When enabled, root squash restricts root-level access from clients that try to access your file system as a root user.</p>
    pub fn root_squash_configuration(
        mut self,
        input: crate::types::LustreRootSquashConfiguration,
    ) -> Self {
        self.root_squash_configuration = Some(input);
        self
    }
    /// <p>The Lustre root squash configuration for an Amazon FSx for Lustre file system. When enabled, root squash restricts root-level access from clients that try to access your file system as a root user.</p>
    pub fn set_root_squash_configuration(
        mut self,
        input: std::option::Option<crate::types::LustreRootSquashConfiguration>,
    ) -> Self {
        self.root_squash_configuration = input;
        self
    }
    /// Consumes the builder and constructs a [`LustreFileSystemConfiguration`](crate::types::LustreFileSystemConfiguration).
    pub fn build(self) -> crate::types::LustreFileSystemConfiguration {
        crate::types::LustreFileSystemConfiguration {
            weekly_maintenance_start_time: self.weekly_maintenance_start_time,
            data_repository_configuration: self.data_repository_configuration,
            deployment_type: self.deployment_type,
            per_unit_storage_throughput: self.per_unit_storage_throughput,
            mount_name: self.mount_name,
            daily_automatic_backup_start_time: self.daily_automatic_backup_start_time,
            automatic_backup_retention_days: self.automatic_backup_retention_days,
            copy_tags_to_backups: self.copy_tags_to_backups,
            drive_cache_type: self.drive_cache_type,
            data_compression_type: self.data_compression_type,
            log_configuration: self.log_configuration,
            root_squash_configuration: self.root_squash_configuration,
        }
    }
}
