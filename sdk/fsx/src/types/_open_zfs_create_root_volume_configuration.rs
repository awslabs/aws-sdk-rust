// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The configuration of an Amazon FSx for OpenZFS root volume.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OpenZfsCreateRootVolumeConfiguration {
    /// <p>Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are 4, 8, 16, 32, 64, 128, 256, 512, or 1024 KiB. The default is 128 KiB. Most workloads should use the default record size. Database workflows can benefit from a smaller record size, while streaming workflows can benefit from a larger record size. For additional guidance on setting a custom record size, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/performance.html#performance-tips-zfs"> Tips for maximizing performance</a> in the <i>Amazon FSx for OpenZFS User Guide</i>.</p>
    pub record_size_kib: ::std::option::Option<i32>,
    /// <p>Specifies the method used to compress the data on the volume. The compression type is <code>NONE</code> by default.</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Doesn't compress the data on the volume. <code>NONE</code> is the default.</p> </li>
    /// <li> <p> <code>ZSTD</code> - Compresses the data in the volume using the Zstandard (ZSTD) compression algorithm. Compared to LZ4, Z-Standard provides a better compression ratio to minimize on-disk storage utilization.</p> </li>
    /// <li> <p> <code>LZ4</code> - Compresses the data in the volume using the LZ4 compression algorithm. Compared to Z-Standard, LZ4 is less compute-intensive and delivers higher write throughput speeds.</p> </li>
    /// </ul>
    pub data_compression_type: ::std::option::Option<crate::types::OpenZfsDataCompressionType>,
    /// <p>The configuration object for mounting a file system.</p>
    pub nfs_exports: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsNfsExport>>,
    /// <p>An object specifying how much storage users or groups can use on the volume.</p>
    pub user_and_group_quotas: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsUserOrGroupQuota>>,
    /// <p>A Boolean value indicating whether tags for the volume should be copied to snapshots of the volume. This value defaults to <code>false</code>. If it's set to <code>true</code>, all tags for the volume are copied to snapshots where the user doesn't specify tags. If this value is <code>true</code> and you specify one or more tags, only the specified tags are copied to snapshots. If you specify one or more tags when creating the snapshot, no tags are copied from the volume, regardless of this value. </p>
    pub copy_tags_to_snapshots: ::std::option::Option<bool>,
    /// <p>A Boolean value indicating whether the volume is read-only. Setting this value to <code>true</code> can be useful after you have completed changes to a volume and no longer want changes to occur. </p>
    pub read_only: ::std::option::Option<bool>,
}
impl OpenZfsCreateRootVolumeConfiguration {
    /// <p>Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are 4, 8, 16, 32, 64, 128, 256, 512, or 1024 KiB. The default is 128 KiB. Most workloads should use the default record size. Database workflows can benefit from a smaller record size, while streaming workflows can benefit from a larger record size. For additional guidance on setting a custom record size, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/performance.html#performance-tips-zfs"> Tips for maximizing performance</a> in the <i>Amazon FSx for OpenZFS User Guide</i>.</p>
    pub fn record_size_kib(&self) -> ::std::option::Option<i32> {
        self.record_size_kib
    }
    /// <p>Specifies the method used to compress the data on the volume. The compression type is <code>NONE</code> by default.</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Doesn't compress the data on the volume. <code>NONE</code> is the default.</p> </li>
    /// <li> <p> <code>ZSTD</code> - Compresses the data in the volume using the Zstandard (ZSTD) compression algorithm. Compared to LZ4, Z-Standard provides a better compression ratio to minimize on-disk storage utilization.</p> </li>
    /// <li> <p> <code>LZ4</code> - Compresses the data in the volume using the LZ4 compression algorithm. Compared to Z-Standard, LZ4 is less compute-intensive and delivers higher write throughput speeds.</p> </li>
    /// </ul>
    pub fn data_compression_type(&self) -> ::std::option::Option<&crate::types::OpenZfsDataCompressionType> {
        self.data_compression_type.as_ref()
    }
    /// <p>The configuration object for mounting a file system.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.nfs_exports.is_none()`.
    pub fn nfs_exports(&self) -> &[crate::types::OpenZfsNfsExport] {
        self.nfs_exports.as_deref().unwrap_or_default()
    }
    /// <p>An object specifying how much storage users or groups can use on the volume.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.user_and_group_quotas.is_none()`.
    pub fn user_and_group_quotas(&self) -> &[crate::types::OpenZfsUserOrGroupQuota] {
        self.user_and_group_quotas.as_deref().unwrap_or_default()
    }
    /// <p>A Boolean value indicating whether tags for the volume should be copied to snapshots of the volume. This value defaults to <code>false</code>. If it's set to <code>true</code>, all tags for the volume are copied to snapshots where the user doesn't specify tags. If this value is <code>true</code> and you specify one or more tags, only the specified tags are copied to snapshots. If you specify one or more tags when creating the snapshot, no tags are copied from the volume, regardless of this value. </p>
    pub fn copy_tags_to_snapshots(&self) -> ::std::option::Option<bool> {
        self.copy_tags_to_snapshots
    }
    /// <p>A Boolean value indicating whether the volume is read-only. Setting this value to <code>true</code> can be useful after you have completed changes to a volume and no longer want changes to occur. </p>
    pub fn read_only(&self) -> ::std::option::Option<bool> {
        self.read_only
    }
}
impl OpenZfsCreateRootVolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`OpenZfsCreateRootVolumeConfiguration`](crate::types::OpenZfsCreateRootVolumeConfiguration).
    pub fn builder() -> crate::types::builders::OpenZfsCreateRootVolumeConfigurationBuilder {
        crate::types::builders::OpenZfsCreateRootVolumeConfigurationBuilder::default()
    }
}

/// A builder for [`OpenZfsCreateRootVolumeConfiguration`](crate::types::OpenZfsCreateRootVolumeConfiguration).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct OpenZfsCreateRootVolumeConfigurationBuilder {
    pub(crate) record_size_kib: ::std::option::Option<i32>,
    pub(crate) data_compression_type: ::std::option::Option<crate::types::OpenZfsDataCompressionType>,
    pub(crate) nfs_exports: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsNfsExport>>,
    pub(crate) user_and_group_quotas: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsUserOrGroupQuota>>,
    pub(crate) copy_tags_to_snapshots: ::std::option::Option<bool>,
    pub(crate) read_only: ::std::option::Option<bool>,
}
impl OpenZfsCreateRootVolumeConfigurationBuilder {
    /// <p>Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are 4, 8, 16, 32, 64, 128, 256, 512, or 1024 KiB. The default is 128 KiB. Most workloads should use the default record size. Database workflows can benefit from a smaller record size, while streaming workflows can benefit from a larger record size. For additional guidance on setting a custom record size, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/performance.html#performance-tips-zfs"> Tips for maximizing performance</a> in the <i>Amazon FSx for OpenZFS User Guide</i>.</p>
    pub fn record_size_kib(mut self, input: i32) -> Self {
        self.record_size_kib = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are 4, 8, 16, 32, 64, 128, 256, 512, or 1024 KiB. The default is 128 KiB. Most workloads should use the default record size. Database workflows can benefit from a smaller record size, while streaming workflows can benefit from a larger record size. For additional guidance on setting a custom record size, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/performance.html#performance-tips-zfs"> Tips for maximizing performance</a> in the <i>Amazon FSx for OpenZFS User Guide</i>.</p>
    pub fn set_record_size_kib(mut self, input: ::std::option::Option<i32>) -> Self {
        self.record_size_kib = input;
        self
    }
    /// <p>Specifies the record size of an OpenZFS root volume, in kibibytes (KiB). Valid values are 4, 8, 16, 32, 64, 128, 256, 512, or 1024 KiB. The default is 128 KiB. Most workloads should use the default record size. Database workflows can benefit from a smaller record size, while streaming workflows can benefit from a larger record size. For additional guidance on setting a custom record size, see <a href="https://docs.aws.amazon.com/fsx/latest/OpenZFSGuide/performance.html#performance-tips-zfs"> Tips for maximizing performance</a> in the <i>Amazon FSx for OpenZFS User Guide</i>.</p>
    pub fn get_record_size_kib(&self) -> &::std::option::Option<i32> {
        &self.record_size_kib
    }
    /// <p>Specifies the method used to compress the data on the volume. The compression type is <code>NONE</code> by default.</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Doesn't compress the data on the volume. <code>NONE</code> is the default.</p> </li>
    /// <li> <p> <code>ZSTD</code> - Compresses the data in the volume using the Zstandard (ZSTD) compression algorithm. Compared to LZ4, Z-Standard provides a better compression ratio to minimize on-disk storage utilization.</p> </li>
    /// <li> <p> <code>LZ4</code> - Compresses the data in the volume using the LZ4 compression algorithm. Compared to Z-Standard, LZ4 is less compute-intensive and delivers higher write throughput speeds.</p> </li>
    /// </ul>
    pub fn data_compression_type(mut self, input: crate::types::OpenZfsDataCompressionType) -> Self {
        self.data_compression_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the method used to compress the data on the volume. The compression type is <code>NONE</code> by default.</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Doesn't compress the data on the volume. <code>NONE</code> is the default.</p> </li>
    /// <li> <p> <code>ZSTD</code> - Compresses the data in the volume using the Zstandard (ZSTD) compression algorithm. Compared to LZ4, Z-Standard provides a better compression ratio to minimize on-disk storage utilization.</p> </li>
    /// <li> <p> <code>LZ4</code> - Compresses the data in the volume using the LZ4 compression algorithm. Compared to Z-Standard, LZ4 is less compute-intensive and delivers higher write throughput speeds.</p> </li>
    /// </ul>
    pub fn set_data_compression_type(mut self, input: ::std::option::Option<crate::types::OpenZfsDataCompressionType>) -> Self {
        self.data_compression_type = input;
        self
    }
    /// <p>Specifies the method used to compress the data on the volume. The compression type is <code>NONE</code> by default.</p>
    /// <ul>
    /// <li> <p> <code>NONE</code> - Doesn't compress the data on the volume. <code>NONE</code> is the default.</p> </li>
    /// <li> <p> <code>ZSTD</code> - Compresses the data in the volume using the Zstandard (ZSTD) compression algorithm. Compared to LZ4, Z-Standard provides a better compression ratio to minimize on-disk storage utilization.</p> </li>
    /// <li> <p> <code>LZ4</code> - Compresses the data in the volume using the LZ4 compression algorithm. Compared to Z-Standard, LZ4 is less compute-intensive and delivers higher write throughput speeds.</p> </li>
    /// </ul>
    pub fn get_data_compression_type(&self) -> &::std::option::Option<crate::types::OpenZfsDataCompressionType> {
        &self.data_compression_type
    }
    /// Appends an item to `nfs_exports`.
    ///
    /// To override the contents of this collection use [`set_nfs_exports`](Self::set_nfs_exports).
    ///
    /// <p>The configuration object for mounting a file system.</p>
    pub fn nfs_exports(mut self, input: crate::types::OpenZfsNfsExport) -> Self {
        let mut v = self.nfs_exports.unwrap_or_default();
        v.push(input);
        self.nfs_exports = ::std::option::Option::Some(v);
        self
    }
    /// <p>The configuration object for mounting a file system.</p>
    pub fn set_nfs_exports(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsNfsExport>>) -> Self {
        self.nfs_exports = input;
        self
    }
    /// <p>The configuration object for mounting a file system.</p>
    pub fn get_nfs_exports(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::OpenZfsNfsExport>> {
        &self.nfs_exports
    }
    /// Appends an item to `user_and_group_quotas`.
    ///
    /// To override the contents of this collection use [`set_user_and_group_quotas`](Self::set_user_and_group_quotas).
    ///
    /// <p>An object specifying how much storage users or groups can use on the volume.</p>
    pub fn user_and_group_quotas(mut self, input: crate::types::OpenZfsUserOrGroupQuota) -> Self {
        let mut v = self.user_and_group_quotas.unwrap_or_default();
        v.push(input);
        self.user_and_group_quotas = ::std::option::Option::Some(v);
        self
    }
    /// <p>An object specifying how much storage users or groups can use on the volume.</p>
    pub fn set_user_and_group_quotas(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::OpenZfsUserOrGroupQuota>>) -> Self {
        self.user_and_group_quotas = input;
        self
    }
    /// <p>An object specifying how much storage users or groups can use on the volume.</p>
    pub fn get_user_and_group_quotas(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::OpenZfsUserOrGroupQuota>> {
        &self.user_and_group_quotas
    }
    /// <p>A Boolean value indicating whether tags for the volume should be copied to snapshots of the volume. This value defaults to <code>false</code>. If it's set to <code>true</code>, all tags for the volume are copied to snapshots where the user doesn't specify tags. If this value is <code>true</code> and you specify one or more tags, only the specified tags are copied to snapshots. If you specify one or more tags when creating the snapshot, no tags are copied from the volume, regardless of this value. </p>
    pub fn copy_tags_to_snapshots(mut self, input: bool) -> Self {
        self.copy_tags_to_snapshots = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean value indicating whether tags for the volume should be copied to snapshots of the volume. This value defaults to <code>false</code>. If it's set to <code>true</code>, all tags for the volume are copied to snapshots where the user doesn't specify tags. If this value is <code>true</code> and you specify one or more tags, only the specified tags are copied to snapshots. If you specify one or more tags when creating the snapshot, no tags are copied from the volume, regardless of this value. </p>
    pub fn set_copy_tags_to_snapshots(mut self, input: ::std::option::Option<bool>) -> Self {
        self.copy_tags_to_snapshots = input;
        self
    }
    /// <p>A Boolean value indicating whether tags for the volume should be copied to snapshots of the volume. This value defaults to <code>false</code>. If it's set to <code>true</code>, all tags for the volume are copied to snapshots where the user doesn't specify tags. If this value is <code>true</code> and you specify one or more tags, only the specified tags are copied to snapshots. If you specify one or more tags when creating the snapshot, no tags are copied from the volume, regardless of this value. </p>
    pub fn get_copy_tags_to_snapshots(&self) -> &::std::option::Option<bool> {
        &self.copy_tags_to_snapshots
    }
    /// <p>A Boolean value indicating whether the volume is read-only. Setting this value to <code>true</code> can be useful after you have completed changes to a volume and no longer want changes to occur. </p>
    pub fn read_only(mut self, input: bool) -> Self {
        self.read_only = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean value indicating whether the volume is read-only. Setting this value to <code>true</code> can be useful after you have completed changes to a volume and no longer want changes to occur. </p>
    pub fn set_read_only(mut self, input: ::std::option::Option<bool>) -> Self {
        self.read_only = input;
        self
    }
    /// <p>A Boolean value indicating whether the volume is read-only. Setting this value to <code>true</code> can be useful after you have completed changes to a volume and no longer want changes to occur. </p>
    pub fn get_read_only(&self) -> &::std::option::Option<bool> {
        &self.read_only
    }
    /// Consumes the builder and constructs a [`OpenZfsCreateRootVolumeConfiguration`](crate::types::OpenZfsCreateRootVolumeConfiguration).
    pub fn build(self) -> crate::types::OpenZfsCreateRootVolumeConfiguration {
        crate::types::OpenZfsCreateRootVolumeConfiguration {
            record_size_kib: self.record_size_kib,
            data_compression_type: self.data_compression_type,
            nfs_exports: self.nfs_exports,
            user_and_group_quotas: self.user_and_group_quotas,
            copy_tags_to_snapshots: self.copy_tags_to_snapshots,
            read_only: self.read_only,
        }
    }
}
