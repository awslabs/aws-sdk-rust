// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The configuration of an Amazon FSx for NetApp ONTAP volume.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OntapVolumeConfiguration {
    /// <p>Specifies the FlexCache endpoint type of the volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>NONE</code> specifies that the volume doesn't have a FlexCache configuration. <code>NONE</code> is the default.</p></li>
    /// <li>
    /// <p><code>ORIGIN</code> specifies that the volume is the origin volume for a FlexCache volume.</p></li>
    /// <li>
    /// <p><code>CACHE</code> specifies that the volume is a FlexCache volume.</p></li>
    /// </ul>
    pub flex_cache_endpoint_type: ::std::option::Option<crate::types::FlexCacheEndpointType>,
    /// <p>Specifies the directory that network-attached storage (NAS) clients use to mount the volume, along with the storage virtual machine (SVM) Domain Name System (DNS) name or IP address. You can create a <code>JunctionPath</code> directly below a parent volume junction or on a directory within a volume. A <code>JunctionPath</code> for a volume named <code>vol3</code> might be <code>/vol1/vol2/vol3</code>, or <code>/vol1/dir2/vol3</code>, or even <code>/dir1/dir2/vol3</code>.</p>
    pub junction_path: ::std::option::Option<::std::string::String>,
    /// <p>The security style for the volume, which can be <code>UNIX</code>, <code>NTFS</code>, or <code>MIXED</code>.</p>
    pub security_style: ::std::option::Option<crate::types::SecurityStyle>,
    /// <p>The configured size of the volume, in megabytes (MBs).</p>
    pub size_in_megabytes: ::std::option::Option<i32>,
    /// <p>The volume's storage efficiency setting.</p>
    pub storage_efficiency_enabled: ::std::option::Option<bool>,
    /// <p>The ID of the volume's storage virtual machine.</p>
    pub storage_virtual_machine_id: ::std::option::Option<::std::string::String>,
    /// <p>A Boolean flag indicating whether this volume is the root volume for its storage virtual machine (SVM). Only one volume on an SVM can be the root volume. This value defaults to <code>false</code>. If this value is <code>true</code>, then this is the SVM root volume.</p>
    /// <p>This flag is useful when you're deleting an SVM, because you must first delete all non-root volumes. This flag, when set to <code>false</code>, helps you identify which volumes to delete before you can delete the SVM.</p>
    pub storage_virtual_machine_root: ::std::option::Option<bool>,
    /// <p>The volume's <code>TieringPolicy</code> setting.</p>
    pub tiering_policy: ::std::option::Option<crate::types::TieringPolicy>,
    /// <p>The volume's universally unique identifier (UUID).</p>
    pub uuid: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the type of volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p></li>
    /// <li>
    /// <p><code>DP</code> specifies a data-protection volume. You can protect data by replicating it to data-protection mirror copies. If a disaster occurs, you can use these data-protection mirror copies to recover data.</p></li>
    /// <li>
    /// <p><code>LS</code> specifies a load-sharing mirror volume. A load-sharing mirror reduces the network traffic to a FlexVol volume by providing additional read-only access to clients.</p></li>
    /// </ul>
    pub ontap_volume_type: ::std::option::Option<crate::types::OntapVolumeType>,
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li>
    /// <p><code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p></li>
    /// <li>
    /// <p><code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p></li>
    /// <li>
    /// <p><code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p></li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the Amazon FSx for NetApp ONTAP User Guide.</p>
    pub snapshot_policy: ::std::option::Option<::std::string::String>,
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub copy_tags_to_backups: ::std::option::Option<bool>,
    /// <p>The SnapLock configuration object for an FSx for ONTAP SnapLock volume.</p>
    pub snaplock_configuration: ::std::option::Option<crate::types::SnaplockConfiguration>,
    /// <p>Use to specify the style of an ONTAP volume. For more information about FlexVols and FlexGroups, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types.html">Volume types</a> in Amazon FSx for NetApp ONTAP User Guide.</p>
    pub volume_style: ::std::option::Option<crate::types::VolumeStyle>,
    /// <p>This structure specifies configuration options for a volume’s storage aggregate or aggregates.</p>
    pub aggregate_configuration: ::std::option::Option<crate::types::AggregateConfiguration>,
    /// <p>The configured size of the volume, in bytes.</p>
    pub size_in_bytes: ::std::option::Option<i64>,
}
impl OntapVolumeConfiguration {
    /// <p>Specifies the FlexCache endpoint type of the volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>NONE</code> specifies that the volume doesn't have a FlexCache configuration. <code>NONE</code> is the default.</p></li>
    /// <li>
    /// <p><code>ORIGIN</code> specifies that the volume is the origin volume for a FlexCache volume.</p></li>
    /// <li>
    /// <p><code>CACHE</code> specifies that the volume is a FlexCache volume.</p></li>
    /// </ul>
    pub fn flex_cache_endpoint_type(&self) -> ::std::option::Option<&crate::types::FlexCacheEndpointType> {
        self.flex_cache_endpoint_type.as_ref()
    }
    /// <p>Specifies the directory that network-attached storage (NAS) clients use to mount the volume, along with the storage virtual machine (SVM) Domain Name System (DNS) name or IP address. You can create a <code>JunctionPath</code> directly below a parent volume junction or on a directory within a volume. A <code>JunctionPath</code> for a volume named <code>vol3</code> might be <code>/vol1/vol2/vol3</code>, or <code>/vol1/dir2/vol3</code>, or even <code>/dir1/dir2/vol3</code>.</p>
    pub fn junction_path(&self) -> ::std::option::Option<&str> {
        self.junction_path.as_deref()
    }
    /// <p>The security style for the volume, which can be <code>UNIX</code>, <code>NTFS</code>, or <code>MIXED</code>.</p>
    pub fn security_style(&self) -> ::std::option::Option<&crate::types::SecurityStyle> {
        self.security_style.as_ref()
    }
    /// <p>The configured size of the volume, in megabytes (MBs).</p>
    pub fn size_in_megabytes(&self) -> ::std::option::Option<i32> {
        self.size_in_megabytes
    }
    /// <p>The volume's storage efficiency setting.</p>
    pub fn storage_efficiency_enabled(&self) -> ::std::option::Option<bool> {
        self.storage_efficiency_enabled
    }
    /// <p>The ID of the volume's storage virtual machine.</p>
    pub fn storage_virtual_machine_id(&self) -> ::std::option::Option<&str> {
        self.storage_virtual_machine_id.as_deref()
    }
    /// <p>A Boolean flag indicating whether this volume is the root volume for its storage virtual machine (SVM). Only one volume on an SVM can be the root volume. This value defaults to <code>false</code>. If this value is <code>true</code>, then this is the SVM root volume.</p>
    /// <p>This flag is useful when you're deleting an SVM, because you must first delete all non-root volumes. This flag, when set to <code>false</code>, helps you identify which volumes to delete before you can delete the SVM.</p>
    pub fn storage_virtual_machine_root(&self) -> ::std::option::Option<bool> {
        self.storage_virtual_machine_root
    }
    /// <p>The volume's <code>TieringPolicy</code> setting.</p>
    pub fn tiering_policy(&self) -> ::std::option::Option<&crate::types::TieringPolicy> {
        self.tiering_policy.as_ref()
    }
    /// <p>The volume's universally unique identifier (UUID).</p>
    pub fn uuid(&self) -> ::std::option::Option<&str> {
        self.uuid.as_deref()
    }
    /// <p>Specifies the type of volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p></li>
    /// <li>
    /// <p><code>DP</code> specifies a data-protection volume. You can protect data by replicating it to data-protection mirror copies. If a disaster occurs, you can use these data-protection mirror copies to recover data.</p></li>
    /// <li>
    /// <p><code>LS</code> specifies a load-sharing mirror volume. A load-sharing mirror reduces the network traffic to a FlexVol volume by providing additional read-only access to clients.</p></li>
    /// </ul>
    pub fn ontap_volume_type(&self) -> ::std::option::Option<&crate::types::OntapVolumeType> {
        self.ontap_volume_type.as_ref()
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li>
    /// <p><code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p></li>
    /// <li>
    /// <p><code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p></li>
    /// <li>
    /// <p><code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p></li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn snapshot_policy(&self) -> ::std::option::Option<&str> {
        self.snapshot_policy.as_deref()
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn copy_tags_to_backups(&self) -> ::std::option::Option<bool> {
        self.copy_tags_to_backups
    }
    /// <p>The SnapLock configuration object for an FSx for ONTAP SnapLock volume.</p>
    pub fn snaplock_configuration(&self) -> ::std::option::Option<&crate::types::SnaplockConfiguration> {
        self.snaplock_configuration.as_ref()
    }
    /// <p>Use to specify the style of an ONTAP volume. For more information about FlexVols and FlexGroups, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types.html">Volume types</a> in Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn volume_style(&self) -> ::std::option::Option<&crate::types::VolumeStyle> {
        self.volume_style.as_ref()
    }
    /// <p>This structure specifies configuration options for a volume’s storage aggregate or aggregates.</p>
    pub fn aggregate_configuration(&self) -> ::std::option::Option<&crate::types::AggregateConfiguration> {
        self.aggregate_configuration.as_ref()
    }
    /// <p>The configured size of the volume, in bytes.</p>
    pub fn size_in_bytes(&self) -> ::std::option::Option<i64> {
        self.size_in_bytes
    }
}
impl OntapVolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`OntapVolumeConfiguration`](crate::types::OntapVolumeConfiguration).
    pub fn builder() -> crate::types::builders::OntapVolumeConfigurationBuilder {
        crate::types::builders::OntapVolumeConfigurationBuilder::default()
    }
}

/// A builder for [`OntapVolumeConfiguration`](crate::types::OntapVolumeConfiguration).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct OntapVolumeConfigurationBuilder {
    pub(crate) flex_cache_endpoint_type: ::std::option::Option<crate::types::FlexCacheEndpointType>,
    pub(crate) junction_path: ::std::option::Option<::std::string::String>,
    pub(crate) security_style: ::std::option::Option<crate::types::SecurityStyle>,
    pub(crate) size_in_megabytes: ::std::option::Option<i32>,
    pub(crate) storage_efficiency_enabled: ::std::option::Option<bool>,
    pub(crate) storage_virtual_machine_id: ::std::option::Option<::std::string::String>,
    pub(crate) storage_virtual_machine_root: ::std::option::Option<bool>,
    pub(crate) tiering_policy: ::std::option::Option<crate::types::TieringPolicy>,
    pub(crate) uuid: ::std::option::Option<::std::string::String>,
    pub(crate) ontap_volume_type: ::std::option::Option<crate::types::OntapVolumeType>,
    pub(crate) snapshot_policy: ::std::option::Option<::std::string::String>,
    pub(crate) copy_tags_to_backups: ::std::option::Option<bool>,
    pub(crate) snaplock_configuration: ::std::option::Option<crate::types::SnaplockConfiguration>,
    pub(crate) volume_style: ::std::option::Option<crate::types::VolumeStyle>,
    pub(crate) aggregate_configuration: ::std::option::Option<crate::types::AggregateConfiguration>,
    pub(crate) size_in_bytes: ::std::option::Option<i64>,
}
impl OntapVolumeConfigurationBuilder {
    /// <p>Specifies the FlexCache endpoint type of the volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>NONE</code> specifies that the volume doesn't have a FlexCache configuration. <code>NONE</code> is the default.</p></li>
    /// <li>
    /// <p><code>ORIGIN</code> specifies that the volume is the origin volume for a FlexCache volume.</p></li>
    /// <li>
    /// <p><code>CACHE</code> specifies that the volume is a FlexCache volume.</p></li>
    /// </ul>
    pub fn flex_cache_endpoint_type(mut self, input: crate::types::FlexCacheEndpointType) -> Self {
        self.flex_cache_endpoint_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the FlexCache endpoint type of the volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>NONE</code> specifies that the volume doesn't have a FlexCache configuration. <code>NONE</code> is the default.</p></li>
    /// <li>
    /// <p><code>ORIGIN</code> specifies that the volume is the origin volume for a FlexCache volume.</p></li>
    /// <li>
    /// <p><code>CACHE</code> specifies that the volume is a FlexCache volume.</p></li>
    /// </ul>
    pub fn set_flex_cache_endpoint_type(mut self, input: ::std::option::Option<crate::types::FlexCacheEndpointType>) -> Self {
        self.flex_cache_endpoint_type = input;
        self
    }
    /// <p>Specifies the FlexCache endpoint type of the volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>NONE</code> specifies that the volume doesn't have a FlexCache configuration. <code>NONE</code> is the default.</p></li>
    /// <li>
    /// <p><code>ORIGIN</code> specifies that the volume is the origin volume for a FlexCache volume.</p></li>
    /// <li>
    /// <p><code>CACHE</code> specifies that the volume is a FlexCache volume.</p></li>
    /// </ul>
    pub fn get_flex_cache_endpoint_type(&self) -> &::std::option::Option<crate::types::FlexCacheEndpointType> {
        &self.flex_cache_endpoint_type
    }
    /// <p>Specifies the directory that network-attached storage (NAS) clients use to mount the volume, along with the storage virtual machine (SVM) Domain Name System (DNS) name or IP address. You can create a <code>JunctionPath</code> directly below a parent volume junction or on a directory within a volume. A <code>JunctionPath</code> for a volume named <code>vol3</code> might be <code>/vol1/vol2/vol3</code>, or <code>/vol1/dir2/vol3</code>, or even <code>/dir1/dir2/vol3</code>.</p>
    pub fn junction_path(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.junction_path = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the directory that network-attached storage (NAS) clients use to mount the volume, along with the storage virtual machine (SVM) Domain Name System (DNS) name or IP address. You can create a <code>JunctionPath</code> directly below a parent volume junction or on a directory within a volume. A <code>JunctionPath</code> for a volume named <code>vol3</code> might be <code>/vol1/vol2/vol3</code>, or <code>/vol1/dir2/vol3</code>, or even <code>/dir1/dir2/vol3</code>.</p>
    pub fn set_junction_path(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.junction_path = input;
        self
    }
    /// <p>Specifies the directory that network-attached storage (NAS) clients use to mount the volume, along with the storage virtual machine (SVM) Domain Name System (DNS) name or IP address. You can create a <code>JunctionPath</code> directly below a parent volume junction or on a directory within a volume. A <code>JunctionPath</code> for a volume named <code>vol3</code> might be <code>/vol1/vol2/vol3</code>, or <code>/vol1/dir2/vol3</code>, or even <code>/dir1/dir2/vol3</code>.</p>
    pub fn get_junction_path(&self) -> &::std::option::Option<::std::string::String> {
        &self.junction_path
    }
    /// <p>The security style for the volume, which can be <code>UNIX</code>, <code>NTFS</code>, or <code>MIXED</code>.</p>
    pub fn security_style(mut self, input: crate::types::SecurityStyle) -> Self {
        self.security_style = ::std::option::Option::Some(input);
        self
    }
    /// <p>The security style for the volume, which can be <code>UNIX</code>, <code>NTFS</code>, or <code>MIXED</code>.</p>
    pub fn set_security_style(mut self, input: ::std::option::Option<crate::types::SecurityStyle>) -> Self {
        self.security_style = input;
        self
    }
    /// <p>The security style for the volume, which can be <code>UNIX</code>, <code>NTFS</code>, or <code>MIXED</code>.</p>
    pub fn get_security_style(&self) -> &::std::option::Option<crate::types::SecurityStyle> {
        &self.security_style
    }
    /// <p>The configured size of the volume, in megabytes (MBs).</p>
    pub fn size_in_megabytes(mut self, input: i32) -> Self {
        self.size_in_megabytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configured size of the volume, in megabytes (MBs).</p>
    pub fn set_size_in_megabytes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.size_in_megabytes = input;
        self
    }
    /// <p>The configured size of the volume, in megabytes (MBs).</p>
    pub fn get_size_in_megabytes(&self) -> &::std::option::Option<i32> {
        &self.size_in_megabytes
    }
    /// <p>The volume's storage efficiency setting.</p>
    pub fn storage_efficiency_enabled(mut self, input: bool) -> Self {
        self.storage_efficiency_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>The volume's storage efficiency setting.</p>
    pub fn set_storage_efficiency_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.storage_efficiency_enabled = input;
        self
    }
    /// <p>The volume's storage efficiency setting.</p>
    pub fn get_storage_efficiency_enabled(&self) -> &::std::option::Option<bool> {
        &self.storage_efficiency_enabled
    }
    /// <p>The ID of the volume's storage virtual machine.</p>
    pub fn storage_virtual_machine_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.storage_virtual_machine_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the volume's storage virtual machine.</p>
    pub fn set_storage_virtual_machine_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.storage_virtual_machine_id = input;
        self
    }
    /// <p>The ID of the volume's storage virtual machine.</p>
    pub fn get_storage_virtual_machine_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.storage_virtual_machine_id
    }
    /// <p>A Boolean flag indicating whether this volume is the root volume for its storage virtual machine (SVM). Only one volume on an SVM can be the root volume. This value defaults to <code>false</code>. If this value is <code>true</code>, then this is the SVM root volume.</p>
    /// <p>This flag is useful when you're deleting an SVM, because you must first delete all non-root volumes. This flag, when set to <code>false</code>, helps you identify which volumes to delete before you can delete the SVM.</p>
    pub fn storage_virtual_machine_root(mut self, input: bool) -> Self {
        self.storage_virtual_machine_root = ::std::option::Option::Some(input);
        self
    }
    /// <p>A Boolean flag indicating whether this volume is the root volume for its storage virtual machine (SVM). Only one volume on an SVM can be the root volume. This value defaults to <code>false</code>. If this value is <code>true</code>, then this is the SVM root volume.</p>
    /// <p>This flag is useful when you're deleting an SVM, because you must first delete all non-root volumes. This flag, when set to <code>false</code>, helps you identify which volumes to delete before you can delete the SVM.</p>
    pub fn set_storage_virtual_machine_root(mut self, input: ::std::option::Option<bool>) -> Self {
        self.storage_virtual_machine_root = input;
        self
    }
    /// <p>A Boolean flag indicating whether this volume is the root volume for its storage virtual machine (SVM). Only one volume on an SVM can be the root volume. This value defaults to <code>false</code>. If this value is <code>true</code>, then this is the SVM root volume.</p>
    /// <p>This flag is useful when you're deleting an SVM, because you must first delete all non-root volumes. This flag, when set to <code>false</code>, helps you identify which volumes to delete before you can delete the SVM.</p>
    pub fn get_storage_virtual_machine_root(&self) -> &::std::option::Option<bool> {
        &self.storage_virtual_machine_root
    }
    /// <p>The volume's <code>TieringPolicy</code> setting.</p>
    pub fn tiering_policy(mut self, input: crate::types::TieringPolicy) -> Self {
        self.tiering_policy = ::std::option::Option::Some(input);
        self
    }
    /// <p>The volume's <code>TieringPolicy</code> setting.</p>
    pub fn set_tiering_policy(mut self, input: ::std::option::Option<crate::types::TieringPolicy>) -> Self {
        self.tiering_policy = input;
        self
    }
    /// <p>The volume's <code>TieringPolicy</code> setting.</p>
    pub fn get_tiering_policy(&self) -> &::std::option::Option<crate::types::TieringPolicy> {
        &self.tiering_policy
    }
    /// <p>The volume's universally unique identifier (UUID).</p>
    pub fn uuid(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.uuid = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The volume's universally unique identifier (UUID).</p>
    pub fn set_uuid(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.uuid = input;
        self
    }
    /// <p>The volume's universally unique identifier (UUID).</p>
    pub fn get_uuid(&self) -> &::std::option::Option<::std::string::String> {
        &self.uuid
    }
    /// <p>Specifies the type of volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p></li>
    /// <li>
    /// <p><code>DP</code> specifies a data-protection volume. You can protect data by replicating it to data-protection mirror copies. If a disaster occurs, you can use these data-protection mirror copies to recover data.</p></li>
    /// <li>
    /// <p><code>LS</code> specifies a load-sharing mirror volume. A load-sharing mirror reduces the network traffic to a FlexVol volume by providing additional read-only access to clients.</p></li>
    /// </ul>
    pub fn ontap_volume_type(mut self, input: crate::types::OntapVolumeType) -> Self {
        self.ontap_volume_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the type of volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p></li>
    /// <li>
    /// <p><code>DP</code> specifies a data-protection volume. You can protect data by replicating it to data-protection mirror copies. If a disaster occurs, you can use these data-protection mirror copies to recover data.</p></li>
    /// <li>
    /// <p><code>LS</code> specifies a load-sharing mirror volume. A load-sharing mirror reduces the network traffic to a FlexVol volume by providing additional read-only access to clients.</p></li>
    /// </ul>
    pub fn set_ontap_volume_type(mut self, input: ::std::option::Option<crate::types::OntapVolumeType>) -> Self {
        self.ontap_volume_type = input;
        self
    }
    /// <p>Specifies the type of volume. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p><code>RW</code> specifies a read/write volume. <code>RW</code> is the default.</p></li>
    /// <li>
    /// <p><code>DP</code> specifies a data-protection volume. You can protect data by replicating it to data-protection mirror copies. If a disaster occurs, you can use these data-protection mirror copies to recover data.</p></li>
    /// <li>
    /// <p><code>LS</code> specifies a load-sharing mirror volume. A load-sharing mirror reduces the network traffic to a FlexVol volume by providing additional read-only access to clients.</p></li>
    /// </ul>
    pub fn get_ontap_volume_type(&self) -> &::std::option::Option<crate::types::OntapVolumeType> {
        &self.ontap_volume_type
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li>
    /// <p><code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p></li>
    /// <li>
    /// <p><code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p></li>
    /// <li>
    /// <p><code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p></li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn snapshot_policy(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.snapshot_policy = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li>
    /// <p><code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p></li>
    /// <li>
    /// <p><code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p></li>
    /// <li>
    /// <p><code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p></li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn set_snapshot_policy(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.snapshot_policy = input;
        self
    }
    /// <p>Specifies the snapshot policy for the volume. There are three built-in snapshot policies:</p>
    /// <ul>
    /// <li>
    /// <p><code>default</code>: This is the default policy. A maximum of six hourly snapshots taken five minutes past the hour. A maximum of two daily snapshots taken Monday through Saturday at 10 minutes after midnight. A maximum of two weekly snapshots taken every Sunday at 15 minutes after midnight.</p></li>
    /// <li>
    /// <p><code>default-1weekly</code>: This policy is the same as the <code>default</code> policy except that it only retains one snapshot from the weekly schedule.</p></li>
    /// <li>
    /// <p><code>none</code>: This policy does not take any snapshots. This policy can be assigned to volumes to prevent automatic snapshots from being taken.</p></li>
    /// </ul>
    /// <p>You can also provide the name of a custom policy that you created with the ONTAP CLI or REST API.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/snapshots-ontap.html#snapshot-policies">Snapshot policies</a> in the Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn get_snapshot_policy(&self) -> &::std::option::Option<::std::string::String> {
        &self.snapshot_policy
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn copy_tags_to_backups(mut self, input: bool) -> Self {
        self.copy_tags_to_backups = ::std::option::Option::Some(input);
        self
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn set_copy_tags_to_backups(mut self, input: ::std::option::Option<bool>) -> Self {
        self.copy_tags_to_backups = input;
        self
    }
    /// <p>A boolean flag indicating whether tags for the volume should be copied to backups. This value defaults to false. If it's set to true, all tags for the volume are copied to all automatic and user-initiated backups where the user doesn't specify tags. If this value is true, and you specify one or more tags, only the specified tags are copied to backups. If you specify one or more tags when creating a user-initiated backup, no tags are copied from the volume, regardless of this value.</p>
    pub fn get_copy_tags_to_backups(&self) -> &::std::option::Option<bool> {
        &self.copy_tags_to_backups
    }
    /// <p>The SnapLock configuration object for an FSx for ONTAP SnapLock volume.</p>
    pub fn snaplock_configuration(mut self, input: crate::types::SnaplockConfiguration) -> Self {
        self.snaplock_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The SnapLock configuration object for an FSx for ONTAP SnapLock volume.</p>
    pub fn set_snaplock_configuration(mut self, input: ::std::option::Option<crate::types::SnaplockConfiguration>) -> Self {
        self.snaplock_configuration = input;
        self
    }
    /// <p>The SnapLock configuration object for an FSx for ONTAP SnapLock volume.</p>
    pub fn get_snaplock_configuration(&self) -> &::std::option::Option<crate::types::SnaplockConfiguration> {
        &self.snaplock_configuration
    }
    /// <p>Use to specify the style of an ONTAP volume. For more information about FlexVols and FlexGroups, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types.html">Volume types</a> in Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn volume_style(mut self, input: crate::types::VolumeStyle) -> Self {
        self.volume_style = ::std::option::Option::Some(input);
        self
    }
    /// <p>Use to specify the style of an ONTAP volume. For more information about FlexVols and FlexGroups, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types.html">Volume types</a> in Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn set_volume_style(mut self, input: ::std::option::Option<crate::types::VolumeStyle>) -> Self {
        self.volume_style = input;
        self
    }
    /// <p>Use to specify the style of an ONTAP volume. For more information about FlexVols and FlexGroups, see <a href="https://docs.aws.amazon.com/fsx/latest/ONTAPGuide/volume-types.html">Volume types</a> in Amazon FSx for NetApp ONTAP User Guide.</p>
    pub fn get_volume_style(&self) -> &::std::option::Option<crate::types::VolumeStyle> {
        &self.volume_style
    }
    /// <p>This structure specifies configuration options for a volume’s storage aggregate or aggregates.</p>
    pub fn aggregate_configuration(mut self, input: crate::types::AggregateConfiguration) -> Self {
        self.aggregate_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>This structure specifies configuration options for a volume’s storage aggregate or aggregates.</p>
    pub fn set_aggregate_configuration(mut self, input: ::std::option::Option<crate::types::AggregateConfiguration>) -> Self {
        self.aggregate_configuration = input;
        self
    }
    /// <p>This structure specifies configuration options for a volume’s storage aggregate or aggregates.</p>
    pub fn get_aggregate_configuration(&self) -> &::std::option::Option<crate::types::AggregateConfiguration> {
        &self.aggregate_configuration
    }
    /// <p>The configured size of the volume, in bytes.</p>
    pub fn size_in_bytes(mut self, input: i64) -> Self {
        self.size_in_bytes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configured size of the volume, in bytes.</p>
    pub fn set_size_in_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
        self.size_in_bytes = input;
        self
    }
    /// <p>The configured size of the volume, in bytes.</p>
    pub fn get_size_in_bytes(&self) -> &::std::option::Option<i64> {
        &self.size_in_bytes
    }
    /// Consumes the builder and constructs a [`OntapVolumeConfiguration`](crate::types::OntapVolumeConfiguration).
    pub fn build(self) -> crate::types::OntapVolumeConfiguration {
        crate::types::OntapVolumeConfiguration {
            flex_cache_endpoint_type: self.flex_cache_endpoint_type,
            junction_path: self.junction_path,
            security_style: self.security_style,
            size_in_megabytes: self.size_in_megabytes,
            storage_efficiency_enabled: self.storage_efficiency_enabled,
            storage_virtual_machine_id: self.storage_virtual_machine_id,
            storage_virtual_machine_root: self.storage_virtual_machine_root,
            tiering_policy: self.tiering_policy,
            uuid: self.uuid,
            ontap_volume_type: self.ontap_volume_type,
            snapshot_policy: self.snapshot_policy,
            copy_tags_to_backups: self.copy_tags_to_backups,
            snaplock_configuration: self.snaplock_configuration,
            volume_style: self.volume_style,
            aggregate_configuration: self.aggregate_configuration,
            size_in_bytes: self.size_in_bytes,
        }
    }
}
