// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl AcceptHandshakeInput {
    /// Consumes the builder and constructs an Operation<[`AcceptHandshake`](crate::operation::accept_handshake::AcceptHandshake)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::accept_handshake::AcceptHandshake, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::operation::accept_handshake::AcceptHandshakeInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::operation::accept_handshake::AcceptHandshakeInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSOrganizationsV20161128.AcceptHandshake"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_accept_handshake::ser_accept_handshake_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::meta::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::accept_handshake::AcceptHandshake::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("AcceptHandshake", "organizations"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `AcceptHandshake`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct AcceptHandshake;
impl AcceptHandshake {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for AcceptHandshake {
                type Output = std::result::Result<crate::operation::accept_handshake::AcceptHandshakeOutput, crate::operation::accept_handshake::AcceptHandshakeError>;
                fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
                     tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
                     if !response.status().is_success() && response.status().as_u16() != 200 {
                        crate::protocol_serde::shape_accept_handshake::de_accept_handshake_http_error(response)
                     } else {
                        crate::protocol_serde::shape_accept_handshake::de_accept_handshake_http_response(response)
                     }
                }
            }

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AcceptHandshakeErrorKind = AcceptHandshakeError;
/// Error type for the `AcceptHandshakeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptHandshakeError {
    /// <p>You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html">Access Management</a> in the <i>IAM User Guide.</i> </p>
    AccessDeniedException(crate::types::error::AccessDeniedException),
    /// <p>The operation that you attempted requires you to have the <code>iam:CreateServiceLinkedRole</code> for <code>organizations.amazonaws.com</code> permission so that Organizations can create the required service-linked role. You don't have that permission.</p>
    AccessDeniedForDependencyException(crate::types::error::AccessDeniedForDependencyException),
    /// <p>Your account isn't a member of an organization. To make this request, you must use the credentials of an account that belongs to an organization.</p>
    AwsOrganizationsNotInUseException(crate::types::error::AwsOrganizationsNotInUseException),
    /// <p>The target of the operation is currently being modified by a different request. Try again later.</p>
    ConcurrentModificationException(crate::types::error::ConcurrentModificationException),
    /// <p>The specified handshake is already in the requested state. For example, you can't accept a handshake that was already accepted.</p>
    HandshakeAlreadyInStateException(crate::types::error::HandshakeAlreadyInStateException),
    /// <p>The requested operation would violate the constraint identified in the reason code.</p> <note> 
    /// <p>Some of the reasons in the following list might not be applicable to this specific API or operation:</p> 
    /// </note> 
    /// <ul> 
    /// <li> <p>ACCOUNT_NUMBER_LIMIT_EXCEEDED: You attempted to exceed the limit on the number of accounts in an organization. Note that deleted and closed accounts still count toward your limit.</p> <important> 
    /// <p>If you get this exception immediately after creating the organization, wait one hour and try again. If after an hour it continues to fail with this error, contact <a href="https://docs.aws.amazon.com/support/home#/">Amazon Web Services Support</a>.</p> 
    /// </important> </li> 
    /// <li> <p>ALREADY_IN_AN_ORGANIZATION: The handshake request is invalid because the invited account is already a member of an organization.</p> </li> 
    /// <li> <p>HANDSHAKE_RATE_LIMIT_EXCEEDED: You attempted to exceed the number of handshakes that you can send in one day.</p> </li> 
    /// <li> <p>INVITE_DISABLED_DURING_ENABLE_ALL_FEATURES: You can't issue new invitations to join an organization while it's in the process of enabling all features. You can resume inviting accounts after you finalize the process when all accounts have agreed to the change.</p> </li> 
    /// <li> <p>ORGANIZATION_ALREADY_HAS_ALL_FEATURES: The handshake request is invalid because the organization has already enabled all features.</p> </li> 
    /// <li> <p>ORGANIZATION_IS_ALREADY_PENDING_ALL_FEATURES_MIGRATION: The handshake request is invalid because the organization has already started the process to enable all features.</p> </li> 
    /// <li> <p>ORGANIZATION_FROM_DIFFERENT_SELLER_OF_RECORD: The request failed because the account is from a different marketplace than the accounts in the organization. For example, accounts with India addresses must be associated with the AISPL marketplace. All accounts in an organization must be from the same marketplace.</p> </li> 
    /// <li> <p>ORGANIZATION_MEMBERSHIP_CHANGE_RATE_LIMIT_EXCEEDED: You attempted to change the membership of an account too quickly after its previous change.</p> </li> 
    /// <li> <p>PAYMENT_INSTRUMENT_REQUIRED: You can't complete the operation with an account that doesn't have a payment instrument, such as a credit card, associated with it.</p> </li> 
    /// </ul>
    HandshakeConstraintViolationException(crate::types::error::HandshakeConstraintViolationException),
    /// <p>We can't find a handshake with the <code>HandshakeId</code> that you specified.</p>
    HandshakeNotFoundException(crate::types::error::HandshakeNotFoundException),
    /// <p>You can't perform the operation on the handshake in its current state. For example, you can't cancel a handshake that was already accepted or accept a handshake that was already declined.</p>
    InvalidHandshakeTransitionException(crate::types::error::InvalidHandshakeTransitionException),
    /// <p>The requested operation failed because you provided invalid values for one or more of the request parameters. This exception includes a reason that contains additional information about the violated limit:</p> <note> 
    /// <p>Some of the reasons in the following list might not be applicable to this specific API or operation.</p> 
    /// </note> 
    /// <ul> 
    /// <li> <p>DUPLICATE_TAG_KEY: Tag keys must be unique among the tags attached to the same entity.</p> </li> 
    /// <li> <p>IMMUTABLE_POLICY: You specified a policy that is managed by Amazon Web Services and can't be modified.</p> </li> 
    /// <li> <p>INPUT_REQUIRED: You must include a value for all required parameters.</p> </li> 
    /// <li> <p>INVALID_EMAIL_ADDRESS_TARGET: You specified an invalid email address for the invited account owner.</p> </li> 
    /// <li> <p>INVALID_ENUM: You specified an invalid value.</p> </li> 
    /// <li> <p>INVALID_ENUM_POLICY_TYPE: You specified an invalid policy type string.</p> </li> 
    /// <li> <p>INVALID_FULL_NAME_TARGET: You specified a full name that contains invalid characters.</p> </li> 
    /// <li> <p>INVALID_LIST_MEMBER: You provided a list to a parameter that contains at least one invalid value.</p> </li> 
    /// <li> <p>INVALID_PAGINATION_TOKEN: Get the value for the <code>NextToken</code> parameter from the response to a previous call of the operation.</p> </li> 
    /// <li> <p>INVALID_PARTY_TYPE_TARGET: You specified the wrong type of entity (account, organization, or email) as a party.</p> </li> 
    /// <li> <p>INVALID_PATTERN: You provided a value that doesn't match the required pattern.</p> </li> 
    /// <li> <p>INVALID_PATTERN_TARGET_ID: You specified a policy target ID that doesn't match the required pattern.</p> </li> 
    /// <li> <p>INVALID_ROLE_NAME: You provided a role name that isn't valid. A role name can't begin with the reserved prefix <code>AWSServiceRoleFor</code>.</p> </li> 
    /// <li> <p>INVALID_SYNTAX_ORGANIZATION_ARN: You specified an invalid Amazon Resource Name (ARN) for the organization.</p> </li> 
    /// <li> <p>INVALID_SYNTAX_POLICY_ID: You specified an invalid policy ID. </p> </li> 
    /// <li> <p>INVALID_SYSTEM_TAGS_PARAMETER: You specified a tag key that is a system tag. You can’t add, edit, or delete system tag keys because they're reserved for Amazon Web Services use. System tags don’t count against your tags per resource limit.</p> </li> 
    /// <li> <p>MAX_FILTER_LIMIT_EXCEEDED: You can specify only one filter parameter for the operation.</p> </li> 
    /// <li> <p>MAX_LENGTH_EXCEEDED: You provided a string parameter that is longer than allowed.</p> </li> 
    /// <li> <p>MAX_VALUE_EXCEEDED: You provided a numeric parameter that has a larger value than allowed.</p> </li> 
    /// <li> <p>MIN_LENGTH_EXCEEDED: You provided a string parameter that is shorter than allowed.</p> </li> 
    /// <li> <p>MIN_VALUE_EXCEEDED: You provided a numeric parameter that has a smaller value than allowed.</p> </li> 
    /// <li> <p>MOVING_ACCOUNT_BETWEEN_DIFFERENT_ROOTS: You can move an account only between entities in the same root.</p> </li> 
    /// <li> <p>TARGET_NOT_SUPPORTED: You can't perform the specified operation on that target entity.</p> </li> 
    /// <li> <p>UNRECOGNIZED_SERVICE_PRINCIPAL: You specified a service principal that isn't recognized.</p> </li> 
    /// </ul>
    InvalidInputException(crate::types::error::InvalidInputException),
    /// <p>Organizations can't complete your request because of an internal service error. Try again later.</p>
    ServiceException(crate::types::error::ServiceException),
    /// <p>You have sent too many requests in too short a period of time. The quota helps protect against denial-of-service attacks. Try again later.</p> 
    /// <p>For information about quotas that affect Organizations, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_reference_limits.html">Quotas for Organizations</a>in the <i>Organizations User Guide.</i> </p>
    TooManyRequestsException(crate::types::error::TooManyRequestsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AcceptHandshakeError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AcceptHandshakeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AccessDeniedForDependencyException(_inner) =>
            _inner.fmt(f)
            ,
            Self::AwsOrganizationsNotInUseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConcurrentModificationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::HandshakeAlreadyInStateException(_inner) =>
            _inner.fmt(f)
            ,
            Self::HandshakeConstraintViolationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::HandshakeNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidHandshakeTransitionException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidInputException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ServiceException(_inner) =>
            _inner.fmt(f)
            ,
            Self::TooManyRequestsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AcceptHandshakeError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AccessDeniedForDependencyException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::AwsOrganizationsNotInUseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConcurrentModificationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::HandshakeAlreadyInStateException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::HandshakeConstraintViolationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::HandshakeNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidHandshakeTransitionException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidInputException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ServiceException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::operation::accept_handshake::AcceptHandshakeError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AcceptHandshakeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptHandshakeError {
    /// Creates the `AcceptHandshakeError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AcceptHandshakeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::AccessDeniedForDependencyException(e) => e.meta(),
            Self::AwsOrganizationsNotInUseException(e) => e.meta(),
            Self::ConcurrentModificationException(e) => e.meta(),
            Self::HandshakeAlreadyInStateException(e) => e.meta(),
            Self::HandshakeConstraintViolationException(e) => e.meta(),
            Self::HandshakeNotFoundException(e) => e.meta(),
            Self::InvalidHandshakeTransitionException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::ServiceException(e) => e.meta(),
            Self::TooManyRequestsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::AccessDeniedForDependencyException`.
    pub fn is_access_denied_for_dependency_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedForDependencyException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::AwsOrganizationsNotInUseException`.
    pub fn is_aws_organizations_not_in_use_exception(&self) -> bool {
        matches!(self, Self::AwsOrganizationsNotInUseException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(self, Self::ConcurrentModificationException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::HandshakeAlreadyInStateException`.
    pub fn is_handshake_already_in_state_exception(&self) -> bool {
        matches!(self, Self::HandshakeAlreadyInStateException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::HandshakeConstraintViolationException`.
    pub fn is_handshake_constraint_violation_exception(&self) -> bool {
        matches!(self, Self::HandshakeConstraintViolationException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::HandshakeNotFoundException`.
    pub fn is_handshake_not_found_exception(&self) -> bool {
        matches!(self, Self::HandshakeNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::InvalidHandshakeTransitionException`.
    pub fn is_invalid_handshake_transition_exception(&self) -> bool {
        matches!(self, Self::InvalidHandshakeTransitionException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::ServiceException`.
    pub fn is_service_exception(&self) -> bool {
        matches!(self, Self::ServiceException(_))
    }
    /// Returns `true` if the error kind is `AcceptHandshakeError::TooManyRequestsException`.
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(self, Self::TooManyRequestsException(_))
    }
}
impl std::error::Error for AcceptHandshakeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::AccessDeniedForDependencyException(_inner) =>
            Some(_inner)
            ,
            Self::AwsOrganizationsNotInUseException(_inner) =>
            Some(_inner)
            ,
            Self::ConcurrentModificationException(_inner) =>
            Some(_inner)
            ,
            Self::HandshakeAlreadyInStateException(_inner) =>
            Some(_inner)
            ,
            Self::HandshakeConstraintViolationException(_inner) =>
            Some(_inner)
            ,
            Self::HandshakeNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidHandshakeTransitionException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidInputException(_inner) =>
            Some(_inner)
            ,
            Self::ServiceException(_inner) =>
            Some(_inner)
            ,
            Self::TooManyRequestsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

pub use crate::operation::accept_handshake::_accept_handshake_output::AcceptHandshakeOutput;

pub use crate::operation::accept_handshake::_accept_handshake_input::AcceptHandshakeInput;

mod _accept_handshake_input;

mod _accept_handshake_output;

/// Builders
pub mod builders;

