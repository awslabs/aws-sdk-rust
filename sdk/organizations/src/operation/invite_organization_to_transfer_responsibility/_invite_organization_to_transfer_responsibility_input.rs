// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InviteOrganizationToTransferResponsibilityInput {
    /// <p>The type of responsibility you want to designate to your organization. Currently, only <code>BILLING</code> is supported.</p>
    pub r#type: ::std::option::Option<crate::types::ResponsibilityTransferType>,
    /// <p>A <code>HandshakeParty</code> object. Contains details for the account you want to invite. Currently, only <code>ACCOUNT</code> and <code>EMAIL</code> are supported.</p>
    pub target: ::std::option::Option<crate::types::HandshakeParty>,
    /// <p>Additional information that you want to include in the invitation.</p>
    pub notes: ::std::option::Option<::std::string::String>,
    /// <p>Timestamp when the recipient will begin managing the specified responsibilities.</p>
    pub start_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Name you want to assign to the transfer.</p>
    pub source_name: ::std::option::Option<::std::string::String>,
    /// <p>A list of tags that you want to attach to the transfer. For each tag in the list, you must specify both a tag key and a value. You can set the value to an empty string, but you can't set it to <code>null</code>. For more information about tagging, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_tagging.html">Tagging Organizations resources</a> in the Organizations User Guide.</p><important>
    /// <p>Any tags in the request are checked for compliance with any applicable tag policies when the request is made. The request is rejected if the tags in the request don't match the requirements of the policy at that time. Tag policy compliance is <i> <b>not</b> </i> checked again when the invitation is accepted and the tags are actually attached to the transfer. That means that if the tag policy changes between the invitation and the acceptance, then that tags could potentially be non-compliant.</p>
    /// </important> <note>
    /// <p>If any one of the tags is not valid or if you exceed the allowed number of tags for a transfer, then the entire request fails and invitations are not sent.</p>
    /// </note>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl InviteOrganizationToTransferResponsibilityInput {
    /// <p>The type of responsibility you want to designate to your organization. Currently, only <code>BILLING</code> is supported.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::ResponsibilityTransferType> {
        self.r#type.as_ref()
    }
    /// <p>A <code>HandshakeParty</code> object. Contains details for the account you want to invite. Currently, only <code>ACCOUNT</code> and <code>EMAIL</code> are supported.</p>
    pub fn target(&self) -> ::std::option::Option<&crate::types::HandshakeParty> {
        self.target.as_ref()
    }
    /// <p>Additional information that you want to include in the invitation.</p>
    pub fn notes(&self) -> ::std::option::Option<&str> {
        self.notes.as_deref()
    }
    /// <p>Timestamp when the recipient will begin managing the specified responsibilities.</p>
    pub fn start_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.start_timestamp.as_ref()
    }
    /// <p>Name you want to assign to the transfer.</p>
    pub fn source_name(&self) -> ::std::option::Option<&str> {
        self.source_name.as_deref()
    }
    /// <p>A list of tags that you want to attach to the transfer. For each tag in the list, you must specify both a tag key and a value. You can set the value to an empty string, but you can't set it to <code>null</code>. For more information about tagging, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_tagging.html">Tagging Organizations resources</a> in the Organizations User Guide.</p><important>
    /// <p>Any tags in the request are checked for compliance with any applicable tag policies when the request is made. The request is rejected if the tags in the request don't match the requirements of the policy at that time. Tag policy compliance is <i> <b>not</b> </i> checked again when the invitation is accepted and the tags are actually attached to the transfer. That means that if the tag policy changes between the invitation and the acceptance, then that tags could potentially be non-compliant.</p>
    /// </important> <note>
    /// <p>If any one of the tags is not valid or if you exceed the allowed number of tags for a transfer, then the entire request fails and invitations are not sent.</p>
    /// </note>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl ::std::fmt::Debug for InviteOrganizationToTransferResponsibilityInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InviteOrganizationToTransferResponsibilityInput");
        formatter.field("r#type", &self.r#type);
        formatter.field("target", &self.target);
        formatter.field("notes", &"*** Sensitive Data Redacted ***");
        formatter.field("start_timestamp", &self.start_timestamp);
        formatter.field("source_name", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl InviteOrganizationToTransferResponsibilityInput {
    /// Creates a new builder-style object to manufacture [`InviteOrganizationToTransferResponsibilityInput`](crate::operation::invite_organization_to_transfer_responsibility::InviteOrganizationToTransferResponsibilityInput).
    pub fn builder(
    ) -> crate::operation::invite_organization_to_transfer_responsibility::builders::InviteOrganizationToTransferResponsibilityInputBuilder {
        crate::operation::invite_organization_to_transfer_responsibility::builders::InviteOrganizationToTransferResponsibilityInputBuilder::default()
    }
}

/// A builder for [`InviteOrganizationToTransferResponsibilityInput`](crate::operation::invite_organization_to_transfer_responsibility::InviteOrganizationToTransferResponsibilityInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct InviteOrganizationToTransferResponsibilityInputBuilder {
    pub(crate) r#type: ::std::option::Option<crate::types::ResponsibilityTransferType>,
    pub(crate) target: ::std::option::Option<crate::types::HandshakeParty>,
    pub(crate) notes: ::std::option::Option<::std::string::String>,
    pub(crate) start_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) source_name: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl InviteOrganizationToTransferResponsibilityInputBuilder {
    /// <p>The type of responsibility you want to designate to your organization. Currently, only <code>BILLING</code> is supported.</p>
    /// This field is required.
    pub fn r#type(mut self, input: crate::types::ResponsibilityTransferType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of responsibility you want to designate to your organization. Currently, only <code>BILLING</code> is supported.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::ResponsibilityTransferType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of responsibility you want to designate to your organization. Currently, only <code>BILLING</code> is supported.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::ResponsibilityTransferType> {
        &self.r#type
    }
    /// <p>A <code>HandshakeParty</code> object. Contains details for the account you want to invite. Currently, only <code>ACCOUNT</code> and <code>EMAIL</code> are supported.</p>
    /// This field is required.
    pub fn target(mut self, input: crate::types::HandshakeParty) -> Self {
        self.target = ::std::option::Option::Some(input);
        self
    }
    /// <p>A <code>HandshakeParty</code> object. Contains details for the account you want to invite. Currently, only <code>ACCOUNT</code> and <code>EMAIL</code> are supported.</p>
    pub fn set_target(mut self, input: ::std::option::Option<crate::types::HandshakeParty>) -> Self {
        self.target = input;
        self
    }
    /// <p>A <code>HandshakeParty</code> object. Contains details for the account you want to invite. Currently, only <code>ACCOUNT</code> and <code>EMAIL</code> are supported.</p>
    pub fn get_target(&self) -> &::std::option::Option<crate::types::HandshakeParty> {
        &self.target
    }
    /// <p>Additional information that you want to include in the invitation.</p>
    pub fn notes(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notes = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional information that you want to include in the invitation.</p>
    pub fn set_notes(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notes = input;
        self
    }
    /// <p>Additional information that you want to include in the invitation.</p>
    pub fn get_notes(&self) -> &::std::option::Option<::std::string::String> {
        &self.notes
    }
    /// <p>Timestamp when the recipient will begin managing the specified responsibilities.</p>
    /// This field is required.
    pub fn start_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>Timestamp when the recipient will begin managing the specified responsibilities.</p>
    pub fn set_start_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_timestamp = input;
        self
    }
    /// <p>Timestamp when the recipient will begin managing the specified responsibilities.</p>
    pub fn get_start_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_timestamp
    }
    /// <p>Name you want to assign to the transfer.</p>
    /// This field is required.
    pub fn source_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.source_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Name you want to assign to the transfer.</p>
    pub fn set_source_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.source_name = input;
        self
    }
    /// <p>Name you want to assign to the transfer.</p>
    pub fn get_source_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.source_name
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags that you want to attach to the transfer. For each tag in the list, you must specify both a tag key and a value. You can set the value to an empty string, but you can't set it to <code>null</code>. For more information about tagging, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_tagging.html">Tagging Organizations resources</a> in the Organizations User Guide.</p><important>
    /// <p>Any tags in the request are checked for compliance with any applicable tag policies when the request is made. The request is rejected if the tags in the request don't match the requirements of the policy at that time. Tag policy compliance is <i> <b>not</b> </i> checked again when the invitation is accepted and the tags are actually attached to the transfer. That means that if the tag policy changes between the invitation and the acceptance, then that tags could potentially be non-compliant.</p>
    /// </important> <note>
    /// <p>If any one of the tags is not valid or if you exceed the allowed number of tags for a transfer, then the entire request fails and invitations are not sent.</p>
    /// </note>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of tags that you want to attach to the transfer. For each tag in the list, you must specify both a tag key and a value. You can set the value to an empty string, but you can't set it to <code>null</code>. For more information about tagging, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_tagging.html">Tagging Organizations resources</a> in the Organizations User Guide.</p><important>
    /// <p>Any tags in the request are checked for compliance with any applicable tag policies when the request is made. The request is rejected if the tags in the request don't match the requirements of the policy at that time. Tag policy compliance is <i> <b>not</b> </i> checked again when the invitation is accepted and the tags are actually attached to the transfer. That means that if the tag policy changes between the invitation and the acceptance, then that tags could potentially be non-compliant.</p>
    /// </important> <note>
    /// <p>If any one of the tags is not valid or if you exceed the allowed number of tags for a transfer, then the entire request fails and invitations are not sent.</p>
    /// </note>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of tags that you want to attach to the transfer. For each tag in the list, you must specify both a tag key and a value. You can set the value to an empty string, but you can't set it to <code>null</code>. For more information about tagging, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_tagging.html">Tagging Organizations resources</a> in the Organizations User Guide.</p><important>
    /// <p>Any tags in the request are checked for compliance with any applicable tag policies when the request is made. The request is rejected if the tags in the request don't match the requirements of the policy at that time. Tag policy compliance is <i> <b>not</b> </i> checked again when the invitation is accepted and the tags are actually attached to the transfer. That means that if the tag policy changes between the invitation and the acceptance, then that tags could potentially be non-compliant.</p>
    /// </important> <note>
    /// <p>If any one of the tags is not valid or if you exceed the allowed number of tags for a transfer, then the entire request fails and invitations are not sent.</p>
    /// </note>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`InviteOrganizationToTransferResponsibilityInput`](crate::operation::invite_organization_to_transfer_responsibility::InviteOrganizationToTransferResponsibilityInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::invite_organization_to_transfer_responsibility::InviteOrganizationToTransferResponsibilityInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(
            crate::operation::invite_organization_to_transfer_responsibility::InviteOrganizationToTransferResponsibilityInput {
                r#type: self.r#type,
                target: self.target,
                notes: self.notes,
                start_timestamp: self.start_timestamp,
                source_name: self.source_name,
                tags: self.tags,
            },
        )
    }
}
impl ::std::fmt::Debug for InviteOrganizationToTransferResponsibilityInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InviteOrganizationToTransferResponsibilityInputBuilder");
        formatter.field("r#type", &self.r#type);
        formatter.field("target", &self.target);
        formatter.field("notes", &"*** Sensitive Data Redacted ***");
        formatter.field("start_timestamp", &self.start_timestamp);
        formatter.field("source_name", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
