// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_anomaly_monitor(&self) -> fluent_builders::CreateAnomalyMonitor<C> {
        fluent_builders::CreateAnomalyMonitor::new(self.handle.clone())
    }
    pub fn create_anomaly_subscription(&self) -> fluent_builders::CreateAnomalySubscription<C> {
        fluent_builders::CreateAnomalySubscription::new(self.handle.clone())
    }
    pub fn create_cost_category_definition(
        &self,
    ) -> fluent_builders::CreateCostCategoryDefinition<C> {
        fluent_builders::CreateCostCategoryDefinition::new(self.handle.clone())
    }
    pub fn delete_anomaly_monitor(&self) -> fluent_builders::DeleteAnomalyMonitor<C> {
        fluent_builders::DeleteAnomalyMonitor::new(self.handle.clone())
    }
    pub fn delete_anomaly_subscription(&self) -> fluent_builders::DeleteAnomalySubscription<C> {
        fluent_builders::DeleteAnomalySubscription::new(self.handle.clone())
    }
    pub fn delete_cost_category_definition(
        &self,
    ) -> fluent_builders::DeleteCostCategoryDefinition<C> {
        fluent_builders::DeleteCostCategoryDefinition::new(self.handle.clone())
    }
    pub fn describe_cost_category_definition(
        &self,
    ) -> fluent_builders::DescribeCostCategoryDefinition<C> {
        fluent_builders::DescribeCostCategoryDefinition::new(self.handle.clone())
    }
    pub fn get_anomalies(&self) -> fluent_builders::GetAnomalies<C> {
        fluent_builders::GetAnomalies::new(self.handle.clone())
    }
    pub fn get_anomaly_monitors(&self) -> fluent_builders::GetAnomalyMonitors<C> {
        fluent_builders::GetAnomalyMonitors::new(self.handle.clone())
    }
    pub fn get_anomaly_subscriptions(&self) -> fluent_builders::GetAnomalySubscriptions<C> {
        fluent_builders::GetAnomalySubscriptions::new(self.handle.clone())
    }
    pub fn get_cost_and_usage(&self) -> fluent_builders::GetCostAndUsage<C> {
        fluent_builders::GetCostAndUsage::new(self.handle.clone())
    }
    pub fn get_cost_and_usage_with_resources(
        &self,
    ) -> fluent_builders::GetCostAndUsageWithResources<C> {
        fluent_builders::GetCostAndUsageWithResources::new(self.handle.clone())
    }
    pub fn get_cost_categories(&self) -> fluent_builders::GetCostCategories<C> {
        fluent_builders::GetCostCategories::new(self.handle.clone())
    }
    pub fn get_cost_forecast(&self) -> fluent_builders::GetCostForecast<C> {
        fluent_builders::GetCostForecast::new(self.handle.clone())
    }
    pub fn get_dimension_values(&self) -> fluent_builders::GetDimensionValues<C> {
        fluent_builders::GetDimensionValues::new(self.handle.clone())
    }
    pub fn get_reservation_coverage(&self) -> fluent_builders::GetReservationCoverage<C> {
        fluent_builders::GetReservationCoverage::new(self.handle.clone())
    }
    pub fn get_reservation_purchase_recommendation(
        &self,
    ) -> fluent_builders::GetReservationPurchaseRecommendation<C> {
        fluent_builders::GetReservationPurchaseRecommendation::new(self.handle.clone())
    }
    pub fn get_reservation_utilization(&self) -> fluent_builders::GetReservationUtilization<C> {
        fluent_builders::GetReservationUtilization::new(self.handle.clone())
    }
    pub fn get_rightsizing_recommendation(
        &self,
    ) -> fluent_builders::GetRightsizingRecommendation<C> {
        fluent_builders::GetRightsizingRecommendation::new(self.handle.clone())
    }
    pub fn get_savings_plans_coverage(&self) -> fluent_builders::GetSavingsPlansCoverage<C> {
        fluent_builders::GetSavingsPlansCoverage::new(self.handle.clone())
    }
    pub fn get_savings_plans_purchase_recommendation(
        &self,
    ) -> fluent_builders::GetSavingsPlansPurchaseRecommendation<C> {
        fluent_builders::GetSavingsPlansPurchaseRecommendation::new(self.handle.clone())
    }
    pub fn get_savings_plans_utilization(&self) -> fluent_builders::GetSavingsPlansUtilization<C> {
        fluent_builders::GetSavingsPlansUtilization::new(self.handle.clone())
    }
    pub fn get_savings_plans_utilization_details(
        &self,
    ) -> fluent_builders::GetSavingsPlansUtilizationDetails<C> {
        fluent_builders::GetSavingsPlansUtilizationDetails::new(self.handle.clone())
    }
    pub fn get_tags(&self) -> fluent_builders::GetTags<C> {
        fluent_builders::GetTags::new(self.handle.clone())
    }
    pub fn get_usage_forecast(&self) -> fluent_builders::GetUsageForecast<C> {
        fluent_builders::GetUsageForecast::new(self.handle.clone())
    }
    pub fn list_cost_category_definitions(
        &self,
    ) -> fluent_builders::ListCostCategoryDefinitions<C> {
        fluent_builders::ListCostCategoryDefinitions::new(self.handle.clone())
    }
    pub fn provide_anomaly_feedback(&self) -> fluent_builders::ProvideAnomalyFeedback<C> {
        fluent_builders::ProvideAnomalyFeedback::new(self.handle.clone())
    }
    pub fn update_anomaly_monitor(&self) -> fluent_builders::UpdateAnomalyMonitor<C> {
        fluent_builders::UpdateAnomalyMonitor::new(self.handle.clone())
    }
    pub fn update_anomaly_subscription(&self) -> fluent_builders::UpdateAnomalySubscription<C> {
        fluent_builders::UpdateAnomalySubscription::new(self.handle.clone())
    }
    pub fn update_cost_category_definition(
        &self,
    ) -> fluent_builders::UpdateCostCategoryDefinition<C> {
        fluent_builders::UpdateCostCategoryDefinition::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateAnomalyMonitor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_anomaly_monitor_input::Builder,
    }
    impl<C> CreateAnomalyMonitor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAnomalyMonitorOutput,
            smithy_http::result::SdkError<crate::error::CreateAnomalyMonitorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The cost anomaly detection monitor object that you want to create.</p>
        pub fn anomaly_monitor(mut self, input: crate::model::AnomalyMonitor) -> Self {
            self.inner = self.inner.anomaly_monitor(input);
            self
        }
        pub fn set_anomaly_monitor(
            mut self,
            input: std::option::Option<crate::model::AnomalyMonitor>,
        ) -> Self {
            self.inner = self.inner.set_anomaly_monitor(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAnomalySubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_anomaly_subscription_input::Builder,
    }
    impl<C> CreateAnomalySubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAnomalySubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateAnomalySubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The cost anomaly subscription object that you want to create.
        /// </p>
        pub fn anomaly_subscription(mut self, input: crate::model::AnomalySubscription) -> Self {
            self.inner = self.inner.anomaly_subscription(input);
            self
        }
        pub fn set_anomaly_subscription(
            mut self,
            input: std::option::Option<crate::model::AnomalySubscription>,
        ) -> Self {
            self.inner = self.inner.set_anomaly_subscription(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCostCategoryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cost_category_definition_input::Builder,
    }
    impl<C> CreateCostCategoryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCostCategoryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::CreateCostCategoryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn rule_version(mut self, input: crate::model::CostCategoryRuleVersion) -> Self {
            self.inner = self.inner.rule_version(input);
            self
        }
        pub fn set_rule_version(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleVersion>,
        ) -> Self {
            self.inner = self.inner.set_rule_version(input);
            self
        }
        /// <p>The Cost Category rules used to categorize costs. For more information, see
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
        pub fn rules(mut self, inp: impl Into<crate::model::CostCategoryRule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_value(input);
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAnomalyMonitor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_anomaly_monitor_input::Builder,
    }
    impl<C> DeleteAnomalyMonitor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAnomalyMonitorOutput,
            smithy_http::result::SdkError<crate::error::DeleteAnomalyMonitorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique identifier of the cost anomaly monitor that you want to delete. </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn(input);
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_monitor_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAnomalySubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_anomaly_subscription_input::Builder,
    }
    impl<C> DeleteAnomalySubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAnomalySubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteAnomalySubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique identifier of the cost anomaly subscription that you want to delete. </p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn(input);
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCostCategoryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cost_category_definition_input::Builder,
    }
    impl<C> DeleteCostCategoryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCostCategoryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DeleteCostCategoryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier for your Cost Category.
        /// </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cost_category_arn(input);
            self
        }
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cost_category_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCostCategoryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cost_category_definition_input::Builder,
    }
    impl<C> DescribeCostCategoryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCostCategoryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DescribeCostCategoryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The unique identifier for your Cost Category.
        /// </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cost_category_arn(input);
            self
        }
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cost_category_arn(input);
            self
        }
        /// <p>
        /// The date when the Cost Category was effective.
        /// </p>
        pub fn effective_on(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.effective_on(input);
            self
        }
        pub fn set_effective_on(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_effective_on(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAnomalies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_anomalies_input::Builder,
    }
    impl<C> GetAnomalies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAnomaliesOutput,
            smithy_http::result::SdkError<crate::error::GetAnomaliesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon
        /// Resource Name (ARN). </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn(input);
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_monitor_arn(input);
            self
        }
        /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object
        /// will have an <code>AnomalyEndDate</code> in the specified time range. </p>
        pub fn date_interval(mut self, input: crate::model::AnomalyDateInterval) -> Self {
            self.inner = self.inner.date_interval(input);
            self
        }
        pub fn set_date_interval(
            mut self,
            input: std::option::Option<crate::model::AnomalyDateInterval>,
        ) -> Self {
            self.inner = self.inner.set_date_interval(input);
            self
        }
        /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
        pub fn feedback(mut self, input: crate::model::AnomalyFeedbackType) -> Self {
            self.inner = self.inner.feedback(input);
            self
        }
        pub fn set_feedback(
            mut self,
            input: std::option::Option<crate::model::AnomalyFeedbackType>,
        ) -> Self {
            self.inner = self.inner.set_feedback(input);
            self
        }
        /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you
        /// can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated
        /// dollar impact greater than 200. </p>
        pub fn total_impact(mut self, input: crate::model::TotalImpactFilter) -> Self {
            self.inner = self.inner.total_impact(input);
            self
        }
        pub fn set_total_impact(
            mut self,
            input: std::option::Option<crate::model::TotalImpactFilter>,
        ) -> Self {
            self.inner = self.inner.set_total_impact(input);
            self
        }
        /// <p>
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        /// </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>
        /// The number of entries a paginated response contains.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAnomalyMonitors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_anomaly_monitors_input::Builder,
    }
    impl<C> GetAnomalyMonitors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAnomalyMonitorsOutput,
            smithy_http::result::SdkError<crate::error::GetAnomalyMonitorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// A list of cost anomaly monitor ARNs.
        /// </p>
        pub fn monitor_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn_list(inp);
            self
        }
        pub fn set_monitor_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_monitor_arn_list(input);
            self
        }
        /// <p>
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        /// </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>
        /// The number of entries a paginated response contains.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAnomalySubscriptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_anomaly_subscriptions_input::Builder,
    }
    impl<C> GetAnomalySubscriptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAnomalySubscriptionsOutput,
            smithy_http::result::SdkError<crate::error::GetAnomalySubscriptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// A list of cost anomaly subscription ARNs.
        /// </p>
        pub fn subscription_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn_list(inp);
            self
        }
        pub fn set_subscription_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn_list(input);
            self
        }
        /// <p>
        /// Cost anomaly monitor ARNs.
        /// </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn(input);
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_monitor_arn(input);
            self
        }
        /// <p>
        /// The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
        /// </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>
        /// The number of entries a paginated response contains.
        /// </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCostAndUsage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cost_and_usage_input::Builder,
    }
    impl<C> GetCostAndUsage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCostAndUsageOutput,
            smithy_http::result::SdkError<crate::error::GetCostAndUsageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Sets the start and end dates for retrieving AWS costs. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Sets the AWS cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set,
        /// the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters AWS costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code>
        /// and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects
        /// to define any combination of dimension filters. For more information, see
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see
        /// <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation
        /// appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>,
        /// <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p>
        /// <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without
        /// taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2,
        /// the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units
        /// (for example, hours vs. GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or
        /// <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p>
        /// <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>You can group AWS costs using up to two different groups, either dimensions, tag keys,
        /// cost categories, or any two group by types.</p>
        /// <p>When you group by tag key, you get all tag values, including empty strings.</p>
        /// <p>Valid values are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>LINKED_ACCOUNT</code>,
        /// <code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TAGS</code>,
        /// <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
        pub fn group_by(mut self, inp: impl Into<crate::model::GroupDefinition>) -> Self {
            self.inner = self.inner.group_by(inp);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_group_by(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCostAndUsageWithResources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cost_and_usage_with_resources_input::Builder,
    }
    impl<C> GetCostAndUsageWithResources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCostAndUsageWithResourcesOutput,
            smithy_http::result::SdkError<crate::error::GetCostAndUsageWithResourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Sets the AWS cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If
        /// <code>Granularity</code> isn't set, the response object doesn't include the
        /// <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify
        /// <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated
        /// with that account's usage of that service. You can nest <code>Expression</code> objects to
        /// define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        /// <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a
        /// <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
        /// <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>Which metrics are returned in the query. For more information about blended and
        /// unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does
        /// the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>,
        /// <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>,
        /// <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and
        /// <code>UsageQuantity</code>. </p>
        /// <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage
        /// numbers without taking the units into account. For example, if you aggregate
        /// <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because
        /// Amazon EC2 compute hours and data transfer are measured in different units (for example, hours
        /// vs. GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by
        /// <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p>
        /// <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
        pub fn group_by(mut self, inp: impl Into<crate::model::GroupDefinition>) -> Self {
            self.inner = self.inner.group_by(inp);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_group_by(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCostCategories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cost_categories_input::Builder,
    }
    impl<C> GetCostCategories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCostCategoriesOutput,
            smithy_http::result::SdkError<crate::error::GetCostCategoriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value that you want to search the filter values for.</p>
        /// <p>If you do not specify a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category names that match the <code>SearchString</code> pattern. If you do specifiy a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.search_string(input);
            self
        }
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_search_string(input);
            self
        }
        /// <p>The time period of the request.
        /// </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn cost_category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cost_category_name(input);
            self
        }
        pub fn set_cost_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cost_category_name(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>BlendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetAmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetUnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UsageQuantity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NormalizedUsageAmount</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <p>When using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
        pub fn sort_by(mut self, inp: impl Into<crate::model::SortDefinition>) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>This field is only used when <code>SortBy</code> is provided in the request.</p>
        /// <p>The maximum number of objects that to be returned for this request.  If <code>MaxResults</code> is not specified with <code>SortBy</code>, the request will return 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetCostCategories</code>, MaxResults has an upper limit of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>If the number of objects that are still available for retrieval exceeds the limit, AWS returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the prior call in your next request.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCostForecast<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_cost_forecast_input::Builder,
    }
    impl<C> GetCostForecast<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCostForecastOutput,
            smithy_http::result::SdkError<crate::error::GetCostForecastError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see
        /// <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation
        /// appear on some line items in my bill?</a>. </p>
        /// <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
        /// <ul>
        /// <li>
        /// <p>AMORTIZED_COST</p>
        /// </li>
        /// <li>
        /// <p>BLENDED_COST</p>
        /// </li>
        /// <li>
        /// <p>NET_AMORTIZED_COST</p>
        /// </li>
        /// <li>
        /// <p>NET_UNBLENDED_COST</p>
        /// </li>
        /// <li>
        /// <p>UNBLENDED_COST</p>
        /// </li>
        /// </ul>
        pub fn metric(mut self, input: crate::model::Metric) -> Self {
            self.inner = self.inner.metric(input);
            self
        }
        pub fn set_metric(mut self, input: std::option::Option<crate::model::Metric>) -> Self {
            self.inner = self.inner.set_metric(input);
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AZ</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT_NAME</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OPERATION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PURCHASE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SERVICE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>USAGE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>USAGE_TYPE_GROUP</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RECORD_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OPERATING_SYSTEM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TENANCY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SCOPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PLATFORM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUBSCRIPTION_ID</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LEGAL_ENTITY_NAME</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DEPLOYMENT_OPTION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DATABASE_ENGINE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE_FAMILY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BILLING_ENTITY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RESERVATION_ID</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SAVINGS_PLAN_ARN</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean
        /// by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value
        /// falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn prediction_interval_level(mut self, input: i32) -> Self {
            self.inner = self.inner.prediction_interval_level(input);
            self
        }
        pub fn set_prediction_interval_level(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_prediction_interval_level(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDimensionValues<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dimension_values_input::Builder,
    }
    impl<C> GetDimensionValues<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDimensionValuesOutput,
            smithy_http::result::SdkError<crate::error::GetDimensionValuesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value that you want to search the filter values for.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.search_string(input);
            self
        }
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_search_string(input);
            self
        }
        /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>.
        /// For more information, see <code>Context</code>.
        /// </p>
        pub fn dimension(mut self, input: crate::model::Dimension) -> Self {
            self.inner = self.inner.dimension(input);
            self
        }
        pub fn set_dimension(
            mut self,
            input: std::option::Option<crate::model::Dimension>,
        ) -> Self {
            self.inner = self.inner.set_dimension(input);
            self
        }
        /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>.
        /// The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values
        /// can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>,
        /// the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
        /// <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following
        /// dimensions for searching:</p>
        /// <ul>
        /// <li>
        /// <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
        /// </li>
        /// <li>
        /// <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
        /// </li>
        /// <li>
        /// <p>LEGAL_ENTITY_NAME - The name of the organization that sells you AWS services, such as Amazon Web Services.</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
        /// field contains the AWS ID of the member account.</p>
        /// </li>
        /// <li>
        /// <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p>
        /// </li>
        /// <li>
        /// <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
        /// </li>
        /// <li>
        /// <p>PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand
        /// Instances and Standard Reserved Instances.</p>
        /// </li>
        /// <li>
        /// <p>SERVICE - The AWS service such as Amazon DynamoDB.</p>
        /// </li>
        /// <li>
        /// <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation
        /// includes a unit attribute. Examples include GB and Hrs.</p>
        /// </li>
        /// <li>
        /// <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this
        /// operation includes a unit attribute.</p>
        /// </li>
        /// <li>
        /// <p>REGION - The AWS Region.</p>
        /// </li>
        /// <li>
        /// <p>RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.</p>
        /// </li>
        /// <li>
        /// <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p>
        /// </li>
        /// </ul>
        /// <p>If you set the context to <code>RESERVATIONS</code>, you can use the following
        /// dimensions for searching:</p>
        /// <ul>
        /// <li>
        /// <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
        /// </li>
        /// <li>
        /// <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p>
        /// </li>
        /// <li>
        /// <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
        /// field contains the AWS ID of the member account.</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
        /// </li>
        /// <li>
        /// <p>REGION - The AWS Region.</p>
        /// </li>
        /// <li>
        /// <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p>
        /// </li>
        /// <li>
        /// <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p>
        /// </li>
        /// <li>
        /// <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p>
        /// </li>
        /// </ul>
        /// <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li>
        /// <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p>
        /// </li>
        /// <li>
        /// <p>PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)</p>
        /// </li>
        /// <li>
        /// <p>REGION - The AWS Region.</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
        /// field contains the AWS ID of the member account.</p>
        /// </li>
        /// <li>
        /// <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan</p>
        /// </li>
        /// </ul>
        pub fn context(mut self, input: crate::model::Context) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<crate::model::Context>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>BlendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetAmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetUnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UsageQuantity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NormalizedUsageAmount</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
        pub fn sort_by(mut self, inp: impl Into<crate::model::SortDefinition>) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReservationCoverage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reservation_coverage_input::Builder,
    }
    impl<C> GetReservationCoverage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetReservationCoverageOutput,
            smithy_http::result::SdkError<crate::error::GetReservationCoverageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data
        /// for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>You can group the data by the following attributes:</p>
        /// <ul>
        /// <li>
        /// <p>AZ</p>
        /// </li>
        /// <li>
        /// <p>CACHE_ENGINE</p>
        /// </li>
        /// <li>
        /// <p>DATABASE_ENGINE</p>
        /// </li>
        /// <li>
        /// <p>DEPLOYMENT_OPTION</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT</p>
        /// </li>
        /// <li>
        /// <p>OPERATING_SYSTEM</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM</p>
        /// </li>
        /// <li>
        /// <p>REGION</p>
        /// </li>
        /// <li>
        /// <p>TENANCY</p>
        /// </li>
        /// </ul>
        pub fn group_by(mut self, inp: impl Into<crate::model::GroupDefinition>) -> Self {
            self.inner = self.inner.group_by(inp);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_group_by(input);
            self
        }
        /// <p>The granularity of the AWS cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set,
        /// the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>AZ</p>
        /// </li>
        /// <li>
        /// <p>CACHE_ENGINE</p>
        /// </li>
        /// <li>
        /// <p>DATABASE_ENGINE</p>
        /// </li>
        /// <li>
        /// <p>DEPLOYMENT_OPTION</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT</p>
        /// </li>
        /// <li>
        /// <p>OPERATING_SYSTEM</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM</p>
        /// </li>
        /// <li>
        /// <p>REGION</p>
        /// </li>
        /// <li>
        /// <p>SERVICE</p>
        /// </li>
        /// <li>
        /// <p>TAG</p>
        /// </li>
        /// <li>
        /// <p>TENANCY</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>GetReservationCoverage</code> uses the same
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
        /// as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep.
        /// If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
        /// <p>Cost category is also supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The measurement that you want your reservation coverage reported in.</p>
        /// <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>OnDemandCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CoverageHoursPercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OnDemandHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReservedHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalRunningHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CoverageNormalizedUnitsPercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OnDemandNormalizedUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReservedNormalizedUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalRunningNormalizedUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Time</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, AWS provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReservationPurchaseRecommendation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reservation_purchase_recommendation_input::Builder,
    }
    impl<C> GetReservationPurchaseRecommendation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetReservationPurchaseRecommendationOutput,
            smithy_http::result::SdkError<crate::error::GetReservationPurchaseRecommendationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID that is associated with the recommendation. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The specific service that you want recommendations for.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.inner = self.inner.account_scope(input);
            self
        }
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.inner = self.inner.set_account_scope(input);
            self
        }
        /// <p>The number of previous days that you want AWS to consider when it calculates your recommendations.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.inner = self.inner.lookback_period_in_days(input);
            self
        }
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.inner = self.inner.set_lookback_period_in_days(input);
            self
        }
        /// <p>The reservation term that you want recommendations for.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.inner = self.inner.term_in_years(input);
            self
        }
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.inner = self.inner.set_term_in_years(input);
            self
        }
        /// <p>The reservation purchase option that you want recommendations for.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.inner = self.inner.payment_option(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.inner = self.inner.set_payment_option(input);
            self
        }
        /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
        pub fn service_specification(mut self, input: crate::model::ServiceSpecification) -> Self {
            self.inner = self.inner.service_specification(input);
            self
        }
        pub fn set_service_specification(
            mut self,
            input: std::option::Option<crate::model::ServiceSpecification>,
        ) -> Self {
            self.inner = self.inner.set_service_specification(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReservationUtilization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reservation_utilization_input::Builder,
    }
    impl<C> GetReservationUtilization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetReservationUtilizationOutput,
            smithy_http::result::SdkError<crate::error::GetReservationUtilizationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Sets the start and end dates for retrieving RI utilization. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
        pub fn group_by(mut self, inp: impl Into<crate::model::GroupDefinition>) -> Self {
            self.inner = self.inner.group_by(inp);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_group_by(input);
            self
        }
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set,
        /// the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.
        /// If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>AZ</p>
        /// </li>
        /// <li>
        /// <p>CACHE_ENGINE</p>
        /// </li>
        /// <li>
        /// <p>DEPLOYMENT_OPTION</p>
        /// </li>
        /// <li>
        /// <p>INSTANCE_TYPE</p>
        /// </li>
        /// <li>
        /// <p>LINKED_ACCOUNT</p>
        /// </li>
        /// <li>
        /// <p>OPERATING_SYSTEM</p>
        /// </li>
        /// <li>
        /// <p>PLATFORM</p>
        /// </li>
        /// <li>
        /// <p>REGION</p>
        /// </li>
        /// <li>
        /// <p>SERVICE</p>
        /// </li>
        /// <li>
        /// <p>SCOPE</p>
        /// </li>
        /// <li>
        /// <p>TENANCY</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>GetReservationUtilization</code> uses the same
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
        /// as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to
        /// only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UtilizationPercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UtilizationPercentageInUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PurchasedHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PurchasedUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalActualHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalActualUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnusedHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnusedUnits</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OnDemandCostOfRIHoursUsed</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetRISavings</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalPotentialRISavings</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedUpfrontFee</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedRecurringFee</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalAmortizedFee</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RICostForUnusedHours</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RealizedSavings</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnrealizedSavings</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, AWS provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRightsizingRecommendation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_rightsizing_recommendation_input::Builder,
    }
    impl<C> GetRightsizingRecommendation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRightsizingRecommendationOutput,
            smithy_http::result::SdkError<crate::error::GetRightsizingRecommendationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p> Enables you to customize recommendations across two attributes. You can choose to view
        /// recommendations for instances within the same instance families or across different instance
        /// families. You can also choose to view your estimated savings associated with recommendations
        /// with consideration of existing Savings Plans or RI benefits, or
        /// neither. </p>
        pub fn configuration(
            mut self,
            input: crate::model::RightsizingRecommendationConfiguration,
        ) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::RightsizingRecommendationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is
        /// "<code>AmazonEC2</code>".</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service(input);
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSavingsPlansCoverage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_savings_plans_coverage_input::Builder,
    }
    impl<C> GetSavingsPlansCoverage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSavingsPlansCoverageOutput,
            smithy_http::result::SdkError<crate::error::GetSavingsPlansCoverageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
        pub fn group_by(mut self, inp: impl Into<crate::model::GroupDefinition>) -> Self {
            self.inner = self.inner.group_by(inp);
            self
        }
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_group_by(input);
            self
        }
        /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
        /// <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SERVICE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_FAMILY</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>GetSavingsPlansCoverage</code> uses the same
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
        /// as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>Cost category is also supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SpendCoveredBySavingsPlan</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OnDemandCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CoveragePercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InstanceFamily</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Region</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Service</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSavingsPlansPurchaseRecommendation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_savings_plans_purchase_recommendation_input::Builder,
    }
    impl<C> GetSavingsPlansPurchaseRecommendation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSavingsPlansPurchaseRecommendationOutput,
            smithy_http::result::SdkError<crate::error::GetSavingsPlansPurchaseRecommendationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Savings Plans recommendation type requested.</p>
        pub fn savings_plans_type(
            mut self,
            input: crate::model::SupportedSavingsPlansType,
        ) -> Self {
            self.inner = self.inner.savings_plans_type(input);
            self
        }
        pub fn set_savings_plans_type(
            mut self,
            input: std::option::Option<crate::model::SupportedSavingsPlansType>,
        ) -> Self {
            self.inner = self.inner.set_savings_plans_type(input);
            self
        }
        /// <p>The savings plan recommendation term used to
        /// generate these
        /// recommendations.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.inner = self.inner.term_in_years(input);
            self
        }
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.inner = self.inner.set_term_in_years(input);
            self
        }
        /// <p>The payment option used to generate these recommendations.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.inner = self.inner.payment_option(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.inner = self.inner.set_payment_option(input);
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.inner = self.inner.account_scope(input);
            self
        }
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.inner = self.inner.set_account_scope(input);
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p>The lookback period used to generate the recommendation.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.inner = self.inner.lookback_period_in_days(input);
            self
        }
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.inner = self.inner.set_lookback_period_in_days(input);
            self
        }
        /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code>
        /// dimension. To filter your recommendations by Account ID, specify <code>Key</code> as
        /// <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) for
        /// which you want to see Savings Plans purchase recommendations.</p>
        /// <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> does not include
        /// <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>.
        /// With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and
        /// <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs for
        /// which you want to see Savings Plans Purchase Recommendations. <code>AND</code> and
        /// <code>OR</code> operators are not supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSavingsPlansUtilization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_savings_plans_utilization_input::Builder,
    }
    impl<C> GetSavingsPlansUtilization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSavingsPlansUtilizationOutput,
            smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
        /// <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions.  You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SAVINGS_PLAN_ARN</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SAVINGS_PLANS_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PAYMENT_OPTION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE_FAMILY</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>GetSavingsPlansUtilization</code> uses the same
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
        /// as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UtilizationPercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UsedCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnusedCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetSavings</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSavingsPlansUtilizationDetails<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_savings_plans_utilization_details_input::Builder,
    }
    impl<C> GetSavingsPlansUtilizationDetails<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSavingsPlansUtilizationDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationDetailsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions.  You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SAVINGS_PLAN_ARN</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PAYMENT_OPTION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE_FAMILY</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>
        /// <code>GetSavingsPlansUtilizationDetails</code> uses the same
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
        /// as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The data type.</p>
        pub fn data_type(mut self, inp: impl Into<crate::model::SavingsPlansDataType>) -> Self {
            self.inner = self.inner.data_type(inp);
            self
        }
        pub fn set_data_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SavingsPlansDataType>>,
        ) -> Self {
            self.inner = self.inner.set_data_type(input);
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UtilizationPercentage</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TotalCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UsedCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnusedCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetSavings</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedRecurringCommitment</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedUpfrontCommitment</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_tags_input::Builder,
    }
    impl<C> GetTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTagsOutput,
            smithy_http::result::SdkError<crate::error::GetTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value that you want to search for.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.search_string(input);
            self
        }
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_search_string(input);
            self
        }
        /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>The key of the tag that you want to return values for.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_key(input);
            self
        }
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_tag_key(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>BlendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetAmortizedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NetUnblendedCost</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UsageQuantity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NormalizedUsageAmount</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <p>When using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
        pub fn sort_by(mut self, inp: impl Into<crate::model::SortDefinition>) -> Self {
            self.inner = self.inner.sort_by(inp);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetTags</code>, MaxResults has an upper limit of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_page_token(input);
            self
        }
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_next_page_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetUsageForecast<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_usage_forecast_input::Builder,
    }
    impl<C> GetUsageForecast<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetUsageForecastOutput,
            smithy_http::result::SdkError<crate::error::GetUsageForecastError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is  
        /// retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.inner = self.inner.time_period(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.inner = self.inner.set_time_period(input);
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast.</p>
        /// <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
        /// <ul>
        /// <li>
        /// <p>USAGE_QUANTITY</p>
        /// </li>
        /// <li>
        /// <p>NORMALIZED_USAGE_AMOUNT</p>
        /// </li>
        /// </ul>
        pub fn metric(mut self, input: crate::model::Metric) -> Self {
            self.inner = self.inner.metric(input);
            self
        }
        pub fn set_metric(mut self, input: std::option::Option<crate::model::Metric>) -> Self {
            self.inner = self.inner.set_metric(input);
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AZ</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LINKED_ACCOUNT_NAME</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OPERATION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PURCHASE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SERVICE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>USAGE_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>USAGE_TYPE_GROUP</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RECORD_TYPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OPERATING_SYSTEM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TENANCY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SCOPE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PLATFORM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUBSCRIPTION_ID</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LEGAL_ENTITY_NAME</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DEPLOYMENT_OPTION</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DATABASE_ENGINE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSTANCE_TYPE_FAMILY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BILLING_ENTITY</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RESERVATION_ID</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SAVINGS_PLAN_ARN</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.inner = self.inner.filter(input);
            self
        }
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean
        /// by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value
        /// falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn prediction_interval_level(mut self, input: i32) -> Self {
            self.inner = self.inner.prediction_interval_level(input);
            self
        }
        pub fn set_prediction_interval_level(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_prediction_interval_level(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListCostCategoryDefinitions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_cost_category_definitions_input::Builder,
    }
    impl<C> ListCostCategoryDefinitions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListCostCategoryDefinitionsOutput,
            smithy_http::result::SdkError<crate::error::ListCostCategoryDefinitionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// The date when the Cost Category was effective.
        /// </p>
        pub fn effective_on(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.effective_on(input);
            self
        }
        pub fn set_effective_on(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_effective_on(input);
            self
        }
        /// <p>
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        /// </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p> The number of entries a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ProvideAnomalyFeedback<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::provide_anomaly_feedback_input::Builder,
    }
    impl<C> ProvideAnomalyFeedback<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ProvideAnomalyFeedbackOutput,
            smithy_http::result::SdkError<crate::error::ProvideAnomalyFeedbackError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>
        /// A cost anomaly ID.
        /// </p>
        pub fn anomaly_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.anomaly_id(input);
            self
        }
        pub fn set_anomaly_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_anomaly_id(input);
            self
        }
        /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
        pub fn feedback(mut self, input: crate::model::AnomalyFeedbackType) -> Self {
            self.inner = self.inner.feedback(input);
            self
        }
        pub fn set_feedback(
            mut self,
            input: std::option::Option<crate::model::AnomalyFeedbackType>,
        ) -> Self {
            self.inner = self.inner.set_feedback(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAnomalyMonitor<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_anomaly_monitor_input::Builder,
    }
    impl<C> UpdateAnomalyMonitor<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAnomalyMonitorOutput,
            smithy_http::result::SdkError<crate::error::UpdateAnomalyMonitorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> Cost anomaly monitor Amazon Resource Names (ARNs). </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn(input);
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_monitor_arn(input);
            self
        }
        /// <p>
        /// The new name for the cost anomaly monitor.
        /// </p>
        pub fn monitor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_name(input);
            self
        }
        pub fn set_monitor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_monitor_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAnomalySubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_anomaly_subscription_input::Builder,
    }
    impl<C> UpdateAnomalySubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAnomalySubscriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdateAnomalySubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> A cost anomaly subscription Amazon Resource Name (ARN). </p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_arn(input);
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_arn(input);
            self
        }
        /// <p>
        /// The update to the threshold value for receiving notifications.
        /// </p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.inner = self.inner.threshold(input);
            self
        }
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_threshold(input);
            self
        }
        /// <p>
        /// The update to the frequency value at which subscribers will receive notifications.
        /// </p>
        pub fn frequency(mut self, input: crate::model::AnomalySubscriptionFrequency) -> Self {
            self.inner = self.inner.frequency(input);
            self
        }
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
        ) -> Self {
            self.inner = self.inner.set_frequency(input);
            self
        }
        /// <p>
        /// A list of cost anomaly monitor ARNs.
        /// </p>
        pub fn monitor_arn_list(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.monitor_arn_list(inp);
            self
        }
        pub fn set_monitor_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_monitor_arn_list(input);
            self
        }
        /// <p>
        /// The update to the subscriber list.
        /// </p>
        pub fn subscribers(mut self, inp: impl Into<crate::model::Subscriber>) -> Self {
            self.inner = self.inner.subscribers(inp);
            self
        }
        pub fn set_subscribers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
        ) -> Self {
            self.inner = self.inner.set_subscribers(input);
            self
        }
        /// <p>
        /// The subscription's new name.
        /// </p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subscription_name(input);
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_subscription_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateCostCategoryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cost_category_definition_input::Builder,
    }
    impl<C> UpdateCostCategoryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCostCategoryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::UpdateCostCategoryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique identifier for your Cost Category.</p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cost_category_arn(input);
            self
        }
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cost_category_arn(input);
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn rule_version(mut self, input: crate::model::CostCategoryRuleVersion) -> Self {
            self.inner = self.inner.rule_version(input);
            self
        }
        pub fn set_rule_version(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleVersion>,
        ) -> Self {
            self.inner = self.inner.set_rule_version(input);
            self
        }
        /// <p>The <code>Expression</code> object used to categorize costs. For more information, see
        /// <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
        pub fn rules(mut self, inp: impl Into<crate::model::CostCategoryRule>) -> Self {
            self.inner = self.inner.rules(inp);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        ) -> Self {
            self.inner = self.inner.set_rules(input);
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_value(input);
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_value(input);
            self
        }
    }
}
