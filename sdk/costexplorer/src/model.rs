// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategoryRule {
    /// <p>The default value for the cost category.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>An <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
    /// object used to categorize costs. This supports dimensions, tags, and nested expressions.
    /// Currently the only dimensions supported are <code>LINKED_ACCOUNT</code>,
    /// <code>SERVICE_CODE</code>, <code>RECORD_TYPE</code>, and
    /// <code>LINKED_ACCOUNT_NAME</code>.</p>
    /// <p>Root level <code>OR</code> is not supported. We recommend that you create a separate
    /// rule instead.</p>
    /// <p>
    /// <code>RECORD_TYPE</code> is a dimension used for Cost Explorer APIs, and is also
    /// supported for Cost Category expressions. This dimension uses different terms, depending
    /// on whether you're using the console or API/JSON editor. For a detailed comparison, see
    /// <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms">Term Comparisons</a> in the <i>AWS Billing and Cost Management User
    /// Guide</i>.</p>
    pub rule: std::option::Option<crate::model::Expression>,
    /// <p>The value the line item will be categorized as, if the line item contains the matched dimension.</p>
    pub inherited_value: std::option::Option<crate::model::CostCategoryInheritedValueDimension>,
    /// <p>You can define the <code>CostCategoryRule</code> rule type as either <code>REGULAR</code> or <code>INHERITED_VALUE</code>. The <code>INHERITED_VALUE</code> rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
    pub r#type: std::option::Option<crate::model::CostCategoryRuleType>,
}
impl std::fmt::Debug for CostCategoryRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategoryRule");
        formatter.field("value", &self.value);
        formatter.field("rule", &self.rule);
        formatter.field("inherited_value", &self.inherited_value);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`CostCategoryRule`](crate::model::CostCategoryRule)
pub mod cost_category_rule {
    /// A builder for [`CostCategoryRule`](crate::model::CostCategoryRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) rule: std::option::Option<crate::model::Expression>,
        pub(crate) inherited_value:
            std::option::Option<crate::model::CostCategoryInheritedValueDimension>,
        pub(crate) r#type: std::option::Option<crate::model::CostCategoryRuleType>,
    }
    impl Builder {
        /// <p>The default value for the cost category.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>An <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
        /// object used to categorize costs. This supports dimensions, tags, and nested expressions.
        /// Currently the only dimensions supported are <code>LINKED_ACCOUNT</code>,
        /// <code>SERVICE_CODE</code>, <code>RECORD_TYPE</code>, and
        /// <code>LINKED_ACCOUNT_NAME</code>.</p>
        /// <p>Root level <code>OR</code> is not supported. We recommend that you create a separate
        /// rule instead.</p>
        /// <p>
        /// <code>RECORD_TYPE</code> is a dimension used for Cost Explorer APIs, and is also
        /// supported for Cost Category expressions. This dimension uses different terms, depending
        /// on whether you're using the console or API/JSON editor. For a detailed comparison, see
        /// <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms">Term Comparisons</a> in the <i>AWS Billing and Cost Management User
        /// Guide</i>.</p>
        pub fn rule(mut self, input: crate::model::Expression) -> Self {
            self.rule = Some(input);
            self
        }
        pub fn set_rule(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.rule = input;
            self
        }
        /// <p>The value the line item will be categorized as, if the line item contains the matched dimension.</p>
        pub fn inherited_value(
            mut self,
            input: crate::model::CostCategoryInheritedValueDimension,
        ) -> Self {
            self.inherited_value = Some(input);
            self
        }
        pub fn set_inherited_value(
            mut self,
            input: std::option::Option<crate::model::CostCategoryInheritedValueDimension>,
        ) -> Self {
            self.inherited_value = input;
            self
        }
        /// <p>You can define the <code>CostCategoryRule</code> rule type as either <code>REGULAR</code> or <code>INHERITED_VALUE</code>. The <code>INHERITED_VALUE</code> rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
        pub fn r#type(mut self, input: crate::model::CostCategoryRuleType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategoryRule`](crate::model::CostCategoryRule)
        pub fn build(self) -> crate::model::CostCategoryRule {
            crate::model::CostCategoryRule {
                value: self.value,
                rule: self.rule,
                inherited_value: self.inherited_value,
                r#type: self.r#type,
            }
        }
    }
}
impl CostCategoryRule {
    /// Creates a new builder-style object to manufacture [`CostCategoryRule`](crate::model::CostCategoryRule)
    pub fn builder() -> crate::model::cost_category_rule::Builder {
        crate::model::cost_category_rule::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostCategoryRuleType {
    InheritedValue,
    Regular,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CostCategoryRuleType {
    fn from(s: &str) -> Self {
        match s {
            "INHERITED_VALUE" => CostCategoryRuleType::InheritedValue,
            "REGULAR" => CostCategoryRuleType::Regular,
            other => CostCategoryRuleType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CostCategoryRuleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostCategoryRuleType::from(s))
    }
}
impl CostCategoryRuleType {
    pub fn as_str(&self) -> &str {
        match self {
            CostCategoryRuleType::InheritedValue => "INHERITED_VALUE",
            CostCategoryRuleType::Regular => "REGULAR",
            CostCategoryRuleType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["INHERITED_VALUE", "REGULAR"]
    }
}
impl AsRef<str> for CostCategoryRuleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>When creating or updating a cost category, you can define the <code>CostCategoryRule</code> rule type as <code>INHERITED_VALUE</code>. This rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategoryInheritedValueDimension {
    /// <p>The name of dimension for which to group costs.</p>
    /// <p>If you specify <code>LINKED_ACCOUNT_NAME</code>, the cost category value will be based on account name. If you specify <code>TAG</code>, the cost category value will be based on the value of the specified tag key.</p>
    pub dimension_name: std::option::Option<crate::model::CostCategoryInheritedValueDimensionName>,
    /// <p>The key to extract cost category values.</p>
    pub dimension_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CostCategoryInheritedValueDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategoryInheritedValueDimension");
        formatter.field("dimension_name", &self.dimension_name);
        formatter.field("dimension_key", &self.dimension_key);
        formatter.finish()
    }
}
/// See [`CostCategoryInheritedValueDimension`](crate::model::CostCategoryInheritedValueDimension)
pub mod cost_category_inherited_value_dimension {
    /// A builder for [`CostCategoryInheritedValueDimension`](crate::model::CostCategoryInheritedValueDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimension_name:
            std::option::Option<crate::model::CostCategoryInheritedValueDimensionName>,
        pub(crate) dimension_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of dimension for which to group costs.</p>
        /// <p>If you specify <code>LINKED_ACCOUNT_NAME</code>, the cost category value will be based on account name. If you specify <code>TAG</code>, the cost category value will be based on the value of the specified tag key.</p>
        pub fn dimension_name(
            mut self,
            input: crate::model::CostCategoryInheritedValueDimensionName,
        ) -> Self {
            self.dimension_name = Some(input);
            self
        }
        pub fn set_dimension_name(
            mut self,
            input: std::option::Option<crate::model::CostCategoryInheritedValueDimensionName>,
        ) -> Self {
            self.dimension_name = input;
            self
        }
        /// <p>The key to extract cost category values.</p>
        pub fn dimension_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_key = Some(input.into());
            self
        }
        pub fn set_dimension_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_key = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategoryInheritedValueDimension`](crate::model::CostCategoryInheritedValueDimension)
        pub fn build(self) -> crate::model::CostCategoryInheritedValueDimension {
            crate::model::CostCategoryInheritedValueDimension {
                dimension_name: self.dimension_name,
                dimension_key: self.dimension_key,
            }
        }
    }
}
impl CostCategoryInheritedValueDimension {
    /// Creates a new builder-style object to manufacture [`CostCategoryInheritedValueDimension`](crate::model::CostCategoryInheritedValueDimension)
    pub fn builder() -> crate::model::cost_category_inherited_value_dimension::Builder {
        crate::model::cost_category_inherited_value_dimension::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostCategoryInheritedValueDimensionName {
    LinkedAccountName,
    Tag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CostCategoryInheritedValueDimensionName {
    fn from(s: &str) -> Self {
        match s {
            "LINKED_ACCOUNT_NAME" => CostCategoryInheritedValueDimensionName::LinkedAccountName,
            "TAG" => CostCategoryInheritedValueDimensionName::Tag,
            other => CostCategoryInheritedValueDimensionName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CostCategoryInheritedValueDimensionName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostCategoryInheritedValueDimensionName::from(s))
    }
}
impl CostCategoryInheritedValueDimensionName {
    pub fn as_str(&self) -> &str {
        match self {
            CostCategoryInheritedValueDimensionName::LinkedAccountName => "LINKED_ACCOUNT_NAME",
            CostCategoryInheritedValueDimensionName::Tag => "TAG",
            CostCategoryInheritedValueDimensionName::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LINKED_ACCOUNT_NAME", "TAG"]
    }
}
impl AsRef<str> for CostCategoryInheritedValueDimensionName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
/// <ul>
/// <li>
/// <p>Simple dimension values - You can set the dimension name and values for the
/// filters that you plan to use. For example, you can filter for
/// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
/// <code>Expression</code> example looks like:</p>
/// <p>
/// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
/// “us-west-1” ] } }</code>
/// </p>
/// <p>The list of dimension values are OR'd together to retrieve cost or usage
/// data. You can create <code>Expression</code> and <code>DimensionValues</code>
/// objects using either <code>with*</code> methods or <code>set*</code> methods in
/// multiple lines. </p>
/// </li>
/// <li>
/// <p>Compound dimension values with logical operations - You can use multiple
/// <code>Expression</code> types and the logical operators
/// <code>AND/OR/NOT</code> to create a list of one or more
/// <code>Expression</code> objects. This allows you to filter on more advanced
/// options. For example, you can filter on <code>((REGION == us-east-1 OR
/// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
/// DataTransfer)</code>. The <code>Expression</code> for that looks like
/// this:</p>
/// <p>
/// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
/// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
/// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
/// "Values": ["DataTransfer"] }}} ] } </code>
/// </p>
/// <note>
/// <p>Because each <code>Expression</code> can have only one operator, the
/// service returns an error if more than one is specified. The following
/// example shows an <code>Expression</code> object that creates an
/// error.</p>
/// </note>
/// <p>
/// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
/// "Values": [ "DataTransfer" ] } } </code>
/// </p>
/// </li>
/// </ul>
/// <note>
/// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
/// supported. OR is not supported between different dimensions, or dimensions and tags.
/// NOT operators aren't supported.
/// Dimensions
/// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
/// <code>RIGHTSIZING_TYPE</code>.</p>
/// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Expression {
    /// <p>Return results that match either <code>Dimension</code> object.</p>
    pub or: std::option::Option<std::vec::Vec<crate::model::Expression>>,
    /// <p>Return results that match both <code>Dimension</code> objects.</p>
    pub and: std::option::Option<std::vec::Vec<crate::model::Expression>>,
    /// <p>Return results that don't match a <code>Dimension</code> object.</p>
    pub not: std::option::Option<std::boxed::Box<crate::model::Expression>>,
    /// <p>The specific <code>Dimension</code> to use for <code>Expression</code>.</p>
    pub dimensions: std::option::Option<crate::model::DimensionValues>,
    /// <p>The specific <code>Tag</code> to use for <code>Expression</code>.</p>
    pub tags: std::option::Option<crate::model::TagValues>,
    /// <p>The filter based on <code>CostCategory</code> values.</p>
    pub cost_categories: std::option::Option<crate::model::CostCategoryValues>,
}
impl std::fmt::Debug for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Expression");
        formatter.field("or", &self.or);
        formatter.field("and", &self.and);
        formatter.field("not", &self.not);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("tags", &self.tags);
        formatter.field("cost_categories", &self.cost_categories);
        formatter.finish()
    }
}
/// See [`Expression`](crate::model::Expression)
pub mod expression {
    /// A builder for [`Expression`](crate::model::Expression)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) or: std::option::Option<std::vec::Vec<crate::model::Expression>>,
        pub(crate) and: std::option::Option<std::vec::Vec<crate::model::Expression>>,
        pub(crate) not: std::option::Option<std::boxed::Box<crate::model::Expression>>,
        pub(crate) dimensions: std::option::Option<crate::model::DimensionValues>,
        pub(crate) tags: std::option::Option<crate::model::TagValues>,
        pub(crate) cost_categories: std::option::Option<crate::model::CostCategoryValues>,
    }
    impl Builder {
        pub fn or(mut self, input: impl Into<crate::model::Expression>) -> Self {
            let mut v = self.or.unwrap_or_default();
            v.push(input.into());
            self.or = Some(v);
            self
        }
        pub fn set_or(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Expression>>,
        ) -> Self {
            self.or = input;
            self
        }
        pub fn and(mut self, input: impl Into<crate::model::Expression>) -> Self {
            let mut v = self.and.unwrap_or_default();
            v.push(input.into());
            self.and = Some(v);
            self
        }
        pub fn set_and(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Expression>>,
        ) -> Self {
            self.and = input;
            self
        }
        /// <p>Return results that don't match a <code>Dimension</code> object.</p>
        pub fn not(mut self, input: impl Into<std::boxed::Box<crate::model::Expression>>) -> Self {
            self.not = Some(input.into());
            self
        }
        pub fn set_not(
            mut self,
            input: std::option::Option<std::boxed::Box<crate::model::Expression>>,
        ) -> Self {
            self.not = input;
            self
        }
        /// <p>The specific <code>Dimension</code> to use for <code>Expression</code>.</p>
        pub fn dimensions(mut self, input: crate::model::DimensionValues) -> Self {
            self.dimensions = Some(input);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::DimensionValues>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The specific <code>Tag</code> to use for <code>Expression</code>.</p>
        pub fn tags(mut self, input: crate::model::TagValues) -> Self {
            self.tags = Some(input);
            self
        }
        pub fn set_tags(mut self, input: std::option::Option<crate::model::TagValues>) -> Self {
            self.tags = input;
            self
        }
        /// <p>The filter based on <code>CostCategory</code> values.</p>
        pub fn cost_categories(mut self, input: crate::model::CostCategoryValues) -> Self {
            self.cost_categories = Some(input);
            self
        }
        pub fn set_cost_categories(
            mut self,
            input: std::option::Option<crate::model::CostCategoryValues>,
        ) -> Self {
            self.cost_categories = input;
            self
        }
        /// Consumes the builder and constructs a [`Expression`](crate::model::Expression)
        pub fn build(self) -> crate::model::Expression {
            crate::model::Expression {
                or: self.or,
                and: self.and,
                not: self.not,
                dimensions: self.dimensions,
                tags: self.tags,
                cost_categories: self.cost_categories,
            }
        }
    }
}
impl Expression {
    /// Creates a new builder-style object to manufacture [`Expression`](crate::model::Expression)
    pub fn builder() -> crate::model::expression::Builder {
        crate::model::expression::Builder::default()
    }
}

/// <p>The Cost Categories values used for filtering the costs.</p>
/// <p>If <code>Values</code> and <code>Key</code> are not specified, the <code>ABSENT</code>
/// <code>MatchOption</code> is applied to all Cost Categories. That is, filtering on resources that are not mapped to any Cost Categories.</p>
/// <p>If <code>Values</code> is provided and <code>Key</code> is not specified, the <code>ABSENT</code>
/// <code>MatchOption</code> is applied to the Cost Categories <code>Key</code> only. That is, filtering on resources without the given Cost Categories key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategoryValues {
    /// <p>The unique name of the Cost Category.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The specific value of the Cost Category.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for <code>MatchOptions</code> is <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.
    /// </p>
    pub match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
}
impl std::fmt::Debug for CostCategoryValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategoryValues");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("match_options", &self.match_options);
        formatter.finish()
    }
}
/// See [`CostCategoryValues`](crate::model::CostCategoryValues)
pub mod cost_category_values {
    /// A builder for [`CostCategoryValues`](crate::model::CostCategoryValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
    }
    impl Builder {
        /// <p>The unique name of the Cost Category.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        pub fn match_options(mut self, input: impl Into<crate::model::MatchOption>) -> Self {
            let mut v = self.match_options.unwrap_or_default();
            v.push(input.into());
            self.match_options = Some(v);
            self
        }
        pub fn set_match_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
        ) -> Self {
            self.match_options = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategoryValues`](crate::model::CostCategoryValues)
        pub fn build(self) -> crate::model::CostCategoryValues {
            crate::model::CostCategoryValues {
                key: self.key,
                values: self.values,
                match_options: self.match_options,
            }
        }
    }
}
impl CostCategoryValues {
    /// Creates a new builder-style object to manufacture [`CostCategoryValues`](crate::model::CostCategoryValues)
    pub fn builder() -> crate::model::cost_category_values::Builder {
        crate::model::cost_category_values::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MatchOption {
    Absent,
    CaseInsensitive,
    CaseSensitive,
    Contains,
    EndsWith,
    Equals,
    StartsWith,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MatchOption {
    fn from(s: &str) -> Self {
        match s {
            "ABSENT" => MatchOption::Absent,
            "CASE_INSENSITIVE" => MatchOption::CaseInsensitive,
            "CASE_SENSITIVE" => MatchOption::CaseSensitive,
            "CONTAINS" => MatchOption::Contains,
            "ENDS_WITH" => MatchOption::EndsWith,
            "EQUALS" => MatchOption::Equals,
            "STARTS_WITH" => MatchOption::StartsWith,
            other => MatchOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MatchOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MatchOption::from(s))
    }
}
impl MatchOption {
    pub fn as_str(&self) -> &str {
        match self {
            MatchOption::Absent => "ABSENT",
            MatchOption::CaseInsensitive => "CASE_INSENSITIVE",
            MatchOption::CaseSensitive => "CASE_SENSITIVE",
            MatchOption::Contains => "CONTAINS",
            MatchOption::EndsWith => "ENDS_WITH",
            MatchOption::Equals => "EQUALS",
            MatchOption::StartsWith => "STARTS_WITH",
            MatchOption::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ABSENT",
            "CASE_INSENSITIVE",
            "CASE_SENSITIVE",
            "CONTAINS",
            "ENDS_WITH",
            "EQUALS",
            "STARTS_WITH",
        ]
    }
}
impl AsRef<str> for MatchOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The values that are available for a tag.</p>
/// <p>If <code>Values</code> and <code>Key</code> are not specified, the <code>ABSENT</code>
/// <code>MatchOption</code> is applied to all tags. That is, filtering on resources with no tags.</p>
/// <p>If <code>Values</code> is provided and <code>Key</code> is not specified, the <code>ABSENT</code>
/// <code>MatchOption</code> is applied to the tag <code>Key</code> only. That is, filtering on resources without the given tag key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagValues {
    /// <p>The key for the tag.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The specific value of the tag.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The match options that you can use to filter your results.
    /// <code>MatchOptions</code> is only applicable for actions related to Cost Category.
    /// The default values for <code>MatchOptions</code> are <code>EQUALS</code> and
    /// <code>CASE_SENSITIVE</code>.</p>
    pub match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
}
impl std::fmt::Debug for TagValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagValues");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("match_options", &self.match_options);
        formatter.finish()
    }
}
/// See [`TagValues`](crate::model::TagValues)
pub mod tag_values {
    /// A builder for [`TagValues`](crate::model::TagValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
    }
    impl Builder {
        /// <p>The key for the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        pub fn match_options(mut self, input: impl Into<crate::model::MatchOption>) -> Self {
            let mut v = self.match_options.unwrap_or_default();
            v.push(input.into());
            self.match_options = Some(v);
            self
        }
        pub fn set_match_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
        ) -> Self {
            self.match_options = input;
            self
        }
        /// Consumes the builder and constructs a [`TagValues`](crate::model::TagValues)
        pub fn build(self) -> crate::model::TagValues {
            crate::model::TagValues {
                key: self.key,
                values: self.values,
                match_options: self.match_options,
            }
        }
    }
}
impl TagValues {
    /// Creates a new builder-style object to manufacture [`TagValues`](crate::model::TagValues)
    pub fn builder() -> crate::model::tag_values::Builder {
        crate::model::tag_values::Builder::default()
    }
}

/// <p>The metadata that you can use to filter and group your results. You can use
/// <code>GetDimensionValues</code> to find specific values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DimensionValues {
    /// <p>The names of the metadata types that you can use to filter and group your results.
    /// For example, <code>AZ</code> returns a list of Availability Zones.</p>
    pub key: std::option::Option<crate::model::Dimension>,
    /// <p>The metadata values that you can use to filter and group your results. You can use
    /// <code>GetDimensionValues</code> to find specific values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The match options that you can use to filter your results.
    /// <code>MatchOptions</code> is only applicable for actions related to Cost Category.
    /// The default values for <code>MatchOptions</code> are <code>EQUALS</code> and
    /// <code>CASE_SENSITIVE</code>.</p>
    pub match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
}
impl std::fmt::Debug for DimensionValues {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DimensionValues");
        formatter.field("key", &self.key);
        formatter.field("values", &self.values);
        formatter.field("match_options", &self.match_options);
        formatter.finish()
    }
}
/// See [`DimensionValues`](crate::model::DimensionValues)
pub mod dimension_values {
    /// A builder for [`DimensionValues`](crate::model::DimensionValues)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::Dimension>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) match_options: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
    }
    impl Builder {
        /// <p>The names of the metadata types that you can use to filter and group your results.
        /// For example, <code>AZ</code> returns a list of Availability Zones.</p>
        pub fn key(mut self, input: crate::model::Dimension) -> Self {
            self.key = Some(input);
            self
        }
        pub fn set_key(mut self, input: std::option::Option<crate::model::Dimension>) -> Self {
            self.key = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        pub fn match_options(mut self, input: impl Into<crate::model::MatchOption>) -> Self {
            let mut v = self.match_options.unwrap_or_default();
            v.push(input.into());
            self.match_options = Some(v);
            self
        }
        pub fn set_match_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MatchOption>>,
        ) -> Self {
            self.match_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DimensionValues`](crate::model::DimensionValues)
        pub fn build(self) -> crate::model::DimensionValues {
            crate::model::DimensionValues {
                key: self.key,
                values: self.values,
                match_options: self.match_options,
            }
        }
    }
}
impl DimensionValues {
    /// Creates a new builder-style object to manufacture [`DimensionValues`](crate::model::DimensionValues)
    pub fn builder() -> crate::model::dimension_values::Builder {
        crate::model::dimension_values::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Dimension {
    AgreementEndDateTimeAfter,
    AgreementEndDateTimeBefore,
    Az,
    BillingEntity,
    CacheEngine,
    DatabaseEngine,
    DeploymentOption,
    InstanceType,
    InstanceTypeFamily,
    LegalEntityName,
    LinkedAccount,
    LinkedAccountName,
    OperatingSystem,
    Operation,
    PaymentOption,
    Platform,
    PurchaseType,
    RecordType,
    Region,
    ReservationId,
    ResourceId,
    RightsizingType,
    SavingsPlansType,
    SavingsPlanArn,
    Scope,
    Service,
    ServiceCode,
    SubscriptionId,
    Tenancy,
    UsageType,
    UsageTypeGroup,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Dimension {
    fn from(s: &str) -> Self {
        match s {
            "AGREEMENT_END_DATE_TIME_AFTER" => Dimension::AgreementEndDateTimeAfter,
            "AGREEMENT_END_DATE_TIME_BEFORE" => Dimension::AgreementEndDateTimeBefore,
            "AZ" => Dimension::Az,
            "BILLING_ENTITY" => Dimension::BillingEntity,
            "CACHE_ENGINE" => Dimension::CacheEngine,
            "DATABASE_ENGINE" => Dimension::DatabaseEngine,
            "DEPLOYMENT_OPTION" => Dimension::DeploymentOption,
            "INSTANCE_TYPE" => Dimension::InstanceType,
            "INSTANCE_TYPE_FAMILY" => Dimension::InstanceTypeFamily,
            "LEGAL_ENTITY_NAME" => Dimension::LegalEntityName,
            "LINKED_ACCOUNT" => Dimension::LinkedAccount,
            "LINKED_ACCOUNT_NAME" => Dimension::LinkedAccountName,
            "OPERATING_SYSTEM" => Dimension::OperatingSystem,
            "OPERATION" => Dimension::Operation,
            "PAYMENT_OPTION" => Dimension::PaymentOption,
            "PLATFORM" => Dimension::Platform,
            "PURCHASE_TYPE" => Dimension::PurchaseType,
            "RECORD_TYPE" => Dimension::RecordType,
            "REGION" => Dimension::Region,
            "RESERVATION_ID" => Dimension::ReservationId,
            "RESOURCE_ID" => Dimension::ResourceId,
            "RIGHTSIZING_TYPE" => Dimension::RightsizingType,
            "SAVINGS_PLANS_TYPE" => Dimension::SavingsPlansType,
            "SAVINGS_PLAN_ARN" => Dimension::SavingsPlanArn,
            "SCOPE" => Dimension::Scope,
            "SERVICE" => Dimension::Service,
            "SERVICE_CODE" => Dimension::ServiceCode,
            "SUBSCRIPTION_ID" => Dimension::SubscriptionId,
            "TENANCY" => Dimension::Tenancy,
            "USAGE_TYPE" => Dimension::UsageType,
            "USAGE_TYPE_GROUP" => Dimension::UsageTypeGroup,
            other => Dimension::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Dimension {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Dimension::from(s))
    }
}
impl Dimension {
    pub fn as_str(&self) -> &str {
        match self {
            Dimension::AgreementEndDateTimeAfter => "AGREEMENT_END_DATE_TIME_AFTER",
            Dimension::AgreementEndDateTimeBefore => "AGREEMENT_END_DATE_TIME_BEFORE",
            Dimension::Az => "AZ",
            Dimension::BillingEntity => "BILLING_ENTITY",
            Dimension::CacheEngine => "CACHE_ENGINE",
            Dimension::DatabaseEngine => "DATABASE_ENGINE",
            Dimension::DeploymentOption => "DEPLOYMENT_OPTION",
            Dimension::InstanceType => "INSTANCE_TYPE",
            Dimension::InstanceTypeFamily => "INSTANCE_TYPE_FAMILY",
            Dimension::LegalEntityName => "LEGAL_ENTITY_NAME",
            Dimension::LinkedAccount => "LINKED_ACCOUNT",
            Dimension::LinkedAccountName => "LINKED_ACCOUNT_NAME",
            Dimension::OperatingSystem => "OPERATING_SYSTEM",
            Dimension::Operation => "OPERATION",
            Dimension::PaymentOption => "PAYMENT_OPTION",
            Dimension::Platform => "PLATFORM",
            Dimension::PurchaseType => "PURCHASE_TYPE",
            Dimension::RecordType => "RECORD_TYPE",
            Dimension::Region => "REGION",
            Dimension::ReservationId => "RESERVATION_ID",
            Dimension::ResourceId => "RESOURCE_ID",
            Dimension::RightsizingType => "RIGHTSIZING_TYPE",
            Dimension::SavingsPlansType => "SAVINGS_PLANS_TYPE",
            Dimension::SavingsPlanArn => "SAVINGS_PLAN_ARN",
            Dimension::Scope => "SCOPE",
            Dimension::Service => "SERVICE",
            Dimension::ServiceCode => "SERVICE_CODE",
            Dimension::SubscriptionId => "SUBSCRIPTION_ID",
            Dimension::Tenancy => "TENANCY",
            Dimension::UsageType => "USAGE_TYPE",
            Dimension::UsageTypeGroup => "USAGE_TYPE_GROUP",
            Dimension::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AGREEMENT_END_DATE_TIME_AFTER",
            "AGREEMENT_END_DATE_TIME_BEFORE",
            "AZ",
            "BILLING_ENTITY",
            "CACHE_ENGINE",
            "DATABASE_ENGINE",
            "DEPLOYMENT_OPTION",
            "INSTANCE_TYPE",
            "INSTANCE_TYPE_FAMILY",
            "LEGAL_ENTITY_NAME",
            "LINKED_ACCOUNT",
            "LINKED_ACCOUNT_NAME",
            "OPERATING_SYSTEM",
            "OPERATION",
            "PAYMENT_OPTION",
            "PLATFORM",
            "PURCHASE_TYPE",
            "RECORD_TYPE",
            "REGION",
            "RESERVATION_ID",
            "RESOURCE_ID",
            "RIGHTSIZING_TYPE",
            "SAVINGS_PLANS_TYPE",
            "SAVINGS_PLAN_ARN",
            "SCOPE",
            "SERVICE",
            "SERVICE_CODE",
            "SUBSCRIPTION_ID",
            "TENANCY",
            "USAGE_TYPE",
            "USAGE_TYPE_GROUP",
        ]
    }
}
impl AsRef<str> for Dimension {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The rule schema version in this particular Cost Category.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostCategoryRuleVersion {
    CostCategoryExpressionV1,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CostCategoryRuleVersion {
    fn from(s: &str) -> Self {
        match s {
            "CostCategoryExpression.v1" => CostCategoryRuleVersion::CostCategoryExpressionV1,
            other => CostCategoryRuleVersion::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CostCategoryRuleVersion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostCategoryRuleVersion::from(s))
    }
}
impl CostCategoryRuleVersion {
    pub fn as_str(&self) -> &str {
        match self {
            CostCategoryRuleVersion::CostCategoryExpressionV1 => "CostCategoryExpression.v1",
            CostCategoryRuleVersion::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CostCategoryExpression.v1"]
    }
}
impl AsRef<str> for CostCategoryRuleVersion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>
/// The recipient of <code>AnomalySubscription</code> notifications.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Subscriber {
    /// <p> The email address or SNS Amazon Resource Name (ARN), depending on the <code>Type</code>. </p>
    pub address: std::option::Option<std::string::String>,
    /// <p>
    /// The notification delivery channel.
    /// </p>
    pub r#type: std::option::Option<crate::model::SubscriberType>,
    /// <p> Indicates if the subscriber accepts the notifications. </p>
    pub status: std::option::Option<crate::model::SubscriberStatus>,
}
impl std::fmt::Debug for Subscriber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Subscriber");
        formatter.field("address", &self.address);
        formatter.field("r#type", &self.r#type);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`Subscriber`](crate::model::Subscriber)
pub mod subscriber {
    /// A builder for [`Subscriber`](crate::model::Subscriber)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::SubscriberType>,
        pub(crate) status: std::option::Option<crate::model::SubscriberStatus>,
    }
    impl Builder {
        /// <p> The email address or SNS Amazon Resource Name (ARN), depending on the <code>Type</code>. </p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>
        /// The notification delivery channel.
        /// </p>
        pub fn r#type(mut self, input: crate::model::SubscriberType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SubscriberType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p> Indicates if the subscriber accepts the notifications. </p>
        pub fn status(mut self, input: crate::model::SubscriberStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SubscriberStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`Subscriber`](crate::model::Subscriber)
        pub fn build(self) -> crate::model::Subscriber {
            crate::model::Subscriber {
                address: self.address,
                r#type: self.r#type,
                status: self.status,
            }
        }
    }
}
impl Subscriber {
    /// Creates a new builder-style object to manufacture [`Subscriber`](crate::model::Subscriber)
    pub fn builder() -> crate::model::subscriber::Builder {
        crate::model::subscriber::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubscriberStatus {
    Confirmed,
    Declined,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubscriberStatus {
    fn from(s: &str) -> Self {
        match s {
            "CONFIRMED" => SubscriberStatus::Confirmed,
            "DECLINED" => SubscriberStatus::Declined,
            other => SubscriberStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubscriberStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubscriberStatus::from(s))
    }
}
impl SubscriberStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SubscriberStatus::Confirmed => "CONFIRMED",
            SubscriberStatus::Declined => "DECLINED",
            SubscriberStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CONFIRMED", "DECLINED"]
    }
}
impl AsRef<str> for SubscriberStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SubscriberType {
    Email,
    Sns,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SubscriberType {
    fn from(s: &str) -> Self {
        match s {
            "EMAIL" => SubscriberType::Email,
            "SNS" => SubscriberType::Sns,
            other => SubscriberType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SubscriberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SubscriberType::from(s))
    }
}
impl SubscriberType {
    pub fn as_str(&self) -> &str {
        match self {
            SubscriberType::Email => "EMAIL",
            SubscriberType::Sns => "SNS",
            SubscriberType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EMAIL", "SNS"]
    }
}
impl AsRef<str> for SubscriberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnomalySubscriptionFrequency {
    Daily,
    Immediate,
    Weekly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AnomalySubscriptionFrequency {
    fn from(s: &str) -> Self {
        match s {
            "DAILY" => AnomalySubscriptionFrequency::Daily,
            "IMMEDIATE" => AnomalySubscriptionFrequency::Immediate,
            "WEEKLY" => AnomalySubscriptionFrequency::Weekly,
            other => AnomalySubscriptionFrequency::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AnomalySubscriptionFrequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnomalySubscriptionFrequency::from(s))
    }
}
impl AnomalySubscriptionFrequency {
    pub fn as_str(&self) -> &str {
        match self {
            AnomalySubscriptionFrequency::Daily => "DAILY",
            AnomalySubscriptionFrequency::Immediate => "IMMEDIATE",
            AnomalySubscriptionFrequency::Weekly => "WEEKLY",
            AnomalySubscriptionFrequency::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DAILY", "IMMEDIATE", "WEEKLY"]
    }
}
impl AsRef<str> for AnomalySubscriptionFrequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AnomalyFeedbackType {
    No,
    PlannedActivity,
    Yes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AnomalyFeedbackType {
    fn from(s: &str) -> Self {
        match s {
            "NO" => AnomalyFeedbackType::No,
            "PLANNED_ACTIVITY" => AnomalyFeedbackType::PlannedActivity,
            "YES" => AnomalyFeedbackType::Yes,
            other => AnomalyFeedbackType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AnomalyFeedbackType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AnomalyFeedbackType::from(s))
    }
}
impl AnomalyFeedbackType {
    pub fn as_str(&self) -> &str {
        match self {
            AnomalyFeedbackType::No => "NO",
            AnomalyFeedbackType::PlannedActivity => "PLANNED_ACTIVITY",
            AnomalyFeedbackType::Yes => "YES",
            AnomalyFeedbackType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["NO", "PLANNED_ACTIVITY", "YES"]
    }
}
impl AsRef<str> for AnomalyFeedbackType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A reference to a Cost Category containing only enough information to identify the Cost Category.</p>
/// <p>You can use this information to retrieve the full Cost Category information using <code>DescribeCostCategory</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategoryReference {
    /// <p>
    /// The unique identifier for your Cost Category.
    /// </p>
    pub cost_category_arn: std::option::Option<std::string::String>,
    /// <p>The unique name of the Cost Category.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>
    /// The Cost Category's effective start date.</p>
    pub effective_start: std::option::Option<std::string::String>,
    /// <p>
    /// The Cost Category's effective end date.</p>
    pub effective_end: std::option::Option<std::string::String>,
    /// <p>
    /// The number of rules associated with a specific Cost Category.
    /// </p>
    pub number_of_rules: i32,
    /// <p>
    /// The list of processing statuses for Cost Management products for a specific cost category.
    /// </p>
    pub processing_status:
        std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
    /// <p>
    /// A list of unique cost category values in a specific cost category.
    /// </p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The default value for the cost category.</p>
    pub default_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CostCategoryReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategoryReference");
        formatter.field("cost_category_arn", &self.cost_category_arn);
        formatter.field("name", &self.name);
        formatter.field("effective_start", &self.effective_start);
        formatter.field("effective_end", &self.effective_end);
        formatter.field("number_of_rules", &self.number_of_rules);
        formatter.field("processing_status", &self.processing_status);
        formatter.field("values", &self.values);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`CostCategoryReference`](crate::model::CostCategoryReference)
pub mod cost_category_reference {
    /// A builder for [`CostCategoryReference`](crate::model::CostCategoryReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_category_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) effective_start: std::option::Option<std::string::String>,
        pub(crate) effective_end: std::option::Option<std::string::String>,
        pub(crate) number_of_rules: std::option::Option<i32>,
        pub(crate) processing_status:
            std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The unique identifier for your Cost Category.
        /// </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_arn = Some(input.into());
            self
        }
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_arn = input;
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>
        /// The Cost Category's effective start date.</p>
        pub fn effective_start(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_start = Some(input.into());
            self
        }
        pub fn set_effective_start(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_start = input;
            self
        }
        /// <p>
        /// The Cost Category's effective end date.</p>
        pub fn effective_end(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_end = Some(input.into());
            self
        }
        pub fn set_effective_end(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_end = input;
            self
        }
        /// <p>
        /// The number of rules associated with a specific Cost Category.
        /// </p>
        pub fn number_of_rules(mut self, input: i32) -> Self {
            self.number_of_rules = Some(input);
            self
        }
        pub fn set_number_of_rules(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_rules = input;
            self
        }
        pub fn processing_status(
            mut self,
            input: impl Into<crate::model::CostCategoryProcessingStatus>,
        ) -> Self {
            let mut v = self.processing_status.unwrap_or_default();
            v.push(input.into());
            self.processing_status = Some(v);
            self
        }
        pub fn set_processing_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
        ) -> Self {
            self.processing_status = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategoryReference`](crate::model::CostCategoryReference)
        pub fn build(self) -> crate::model::CostCategoryReference {
            crate::model::CostCategoryReference {
                cost_category_arn: self.cost_category_arn,
                name: self.name,
                effective_start: self.effective_start,
                effective_end: self.effective_end,
                number_of_rules: self.number_of_rules.unwrap_or_default(),
                processing_status: self.processing_status,
                values: self.values,
                default_value: self.default_value,
            }
        }
    }
}
impl CostCategoryReference {
    /// Creates a new builder-style object to manufacture [`CostCategoryReference`](crate::model::CostCategoryReference)
    pub fn builder() -> crate::model::cost_category_reference::Builder {
        crate::model::cost_category_reference::Builder::default()
    }
}

/// <p>
/// The list of processing statuses for Cost Management products for a specific cost category.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategoryProcessingStatus {
    /// <p>
    /// The Cost Management product name of the applied status.
    /// </p>
    pub component: std::option::Option<crate::model::CostCategoryStatusComponent>,
    /// <p>
    /// The process status for a specific cost category.
    /// </p>
    pub status: std::option::Option<crate::model::CostCategoryStatus>,
}
impl std::fmt::Debug for CostCategoryProcessingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategoryProcessingStatus");
        formatter.field("component", &self.component);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`CostCategoryProcessingStatus`](crate::model::CostCategoryProcessingStatus)
pub mod cost_category_processing_status {
    /// A builder for [`CostCategoryProcessingStatus`](crate::model::CostCategoryProcessingStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) component: std::option::Option<crate::model::CostCategoryStatusComponent>,
        pub(crate) status: std::option::Option<crate::model::CostCategoryStatus>,
    }
    impl Builder {
        /// <p>
        /// The Cost Management product name of the applied status.
        /// </p>
        pub fn component(mut self, input: crate::model::CostCategoryStatusComponent) -> Self {
            self.component = Some(input);
            self
        }
        pub fn set_component(
            mut self,
            input: std::option::Option<crate::model::CostCategoryStatusComponent>,
        ) -> Self {
            self.component = input;
            self
        }
        /// <p>
        /// The process status for a specific cost category.
        /// </p>
        pub fn status(mut self, input: crate::model::CostCategoryStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CostCategoryStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategoryProcessingStatus`](crate::model::CostCategoryProcessingStatus)
        pub fn build(self) -> crate::model::CostCategoryProcessingStatus {
            crate::model::CostCategoryProcessingStatus {
                component: self.component,
                status: self.status,
            }
        }
    }
}
impl CostCategoryProcessingStatus {
    /// Creates a new builder-style object to manufacture [`CostCategoryProcessingStatus`](crate::model::CostCategoryProcessingStatus)
    pub fn builder() -> crate::model::cost_category_processing_status::Builder {
        crate::model::cost_category_processing_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostCategoryStatus {
    Applied,
    Processing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CostCategoryStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPLIED" => CostCategoryStatus::Applied,
            "PROCESSING" => CostCategoryStatus::Processing,
            other => CostCategoryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CostCategoryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostCategoryStatus::from(s))
    }
}
impl CostCategoryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            CostCategoryStatus::Applied => "APPLIED",
            CostCategoryStatus::Processing => "PROCESSING",
            CostCategoryStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["APPLIED", "PROCESSING"]
    }
}
impl AsRef<str> for CostCategoryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CostCategoryStatusComponent {
    CostExplorer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CostCategoryStatusComponent {
    fn from(s: &str) -> Self {
        match s {
            "COST_EXPLORER" => CostCategoryStatusComponent::CostExplorer,
            other => CostCategoryStatusComponent::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CostCategoryStatusComponent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CostCategoryStatusComponent::from(s))
    }
}
impl CostCategoryStatusComponent {
    pub fn as_str(&self) -> &str {
        match self {
            CostCategoryStatusComponent::CostExplorer => "COST_EXPLORER",
            CostCategoryStatusComponent::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COST_EXPLORER"]
    }
}
impl AsRef<str> for CostCategoryStatusComponent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The forecast created for your query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForecastResult {
    /// <p>The period of time that the forecast covers.</p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The mean value of the forecast.</p>
    pub mean_value: std::option::Option<std::string::String>,
    /// <p>The lower limit for the prediction interval. </p>
    pub prediction_interval_lower_bound: std::option::Option<std::string::String>,
    /// <p>The upper limit for the prediction interval. </p>
    pub prediction_interval_upper_bound: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForecastResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForecastResult");
        formatter.field("time_period", &self.time_period);
        formatter.field("mean_value", &self.mean_value);
        formatter.field(
            "prediction_interval_lower_bound",
            &self.prediction_interval_lower_bound,
        );
        formatter.field(
            "prediction_interval_upper_bound",
            &self.prediction_interval_upper_bound,
        );
        formatter.finish()
    }
}
/// See [`ForecastResult`](crate::model::ForecastResult)
pub mod forecast_result {
    /// A builder for [`ForecastResult`](crate::model::ForecastResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) mean_value: std::option::Option<std::string::String>,
        pub(crate) prediction_interval_lower_bound: std::option::Option<std::string::String>,
        pub(crate) prediction_interval_upper_bound: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The period of time that the forecast covers.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>The mean value of the forecast.</p>
        pub fn mean_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.mean_value = Some(input.into());
            self
        }
        pub fn set_mean_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mean_value = input;
            self
        }
        /// <p>The lower limit for the prediction interval. </p>
        pub fn prediction_interval_lower_bound(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.prediction_interval_lower_bound = Some(input.into());
            self
        }
        pub fn set_prediction_interval_lower_bound(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prediction_interval_lower_bound = input;
            self
        }
        /// <p>The upper limit for the prediction interval. </p>
        pub fn prediction_interval_upper_bound(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.prediction_interval_upper_bound = Some(input.into());
            self
        }
        pub fn set_prediction_interval_upper_bound(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prediction_interval_upper_bound = input;
            self
        }
        /// Consumes the builder and constructs a [`ForecastResult`](crate::model::ForecastResult)
        pub fn build(self) -> crate::model::ForecastResult {
            crate::model::ForecastResult {
                time_period: self.time_period,
                mean_value: self.mean_value,
                prediction_interval_lower_bound: self.prediction_interval_lower_bound,
                prediction_interval_upper_bound: self.prediction_interval_upper_bound,
            }
        }
    }
}
impl ForecastResult {
    /// Creates a new builder-style object to manufacture [`ForecastResult`](crate::model::ForecastResult)
    pub fn builder() -> crate::model::forecast_result::Builder {
        crate::model::forecast_result::Builder::default()
    }
}

/// <p>The time period of the request.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DateInterval {
    /// <p>The beginning of the time period. The start
    /// date is inclusive. For example, if <code>start</code> is <code>2017-01-01</code>, AWS
    /// retrieves cost and usage data starting at <code>2017-01-01</code> up to the end
    /// date. The start date must be equal to or no later than the current date to avoid a validation error.</p>
    pub start: std::option::Option<std::string::String>,
    /// <p>The end of the time period. The end date is
    /// exclusive. For example, if <code>end</code> is <code>2017-05-01</code>, AWS retrieves
    /// cost and usage data from the start date up to, but not including,
    /// <code>2017-05-01</code>.</p>
    pub end: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DateInterval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DateInterval");
        formatter.field("start", &self.start);
        formatter.field("end", &self.end);
        formatter.finish()
    }
}
/// See [`DateInterval`](crate::model::DateInterval)
pub mod date_interval {
    /// A builder for [`DateInterval`](crate::model::DateInterval)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start: std::option::Option<std::string::String>,
        pub(crate) end: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The beginning of the time period. The start
        /// date is inclusive. For example, if <code>start</code> is <code>2017-01-01</code>, AWS
        /// retrieves cost and usage data starting at <code>2017-01-01</code> up to the end
        /// date. The start date must be equal to or no later than the current date to avoid a validation error.</p>
        pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
            self.start = Some(input.into());
            self
        }
        pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start = input;
            self
        }
        /// <p>The end of the time period. The end date is
        /// exclusive. For example, if <code>end</code> is <code>2017-05-01</code>, AWS retrieves
        /// cost and usage data from the start date up to, but not including,
        /// <code>2017-05-01</code>.</p>
        pub fn end(mut self, input: impl Into<std::string::String>) -> Self {
            self.end = Some(input.into());
            self
        }
        pub fn set_end(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end = input;
            self
        }
        /// Consumes the builder and constructs a [`DateInterval`](crate::model::DateInterval)
        pub fn build(self) -> crate::model::DateInterval {
            crate::model::DateInterval {
                start: self.start,
                end: self.end,
            }
        }
    }
}
impl DateInterval {
    /// Creates a new builder-style object to manufacture [`DateInterval`](crate::model::DateInterval)
    pub fn builder() -> crate::model::date_interval::Builder {
        crate::model::date_interval::Builder::default()
    }
}

/// <p>The aggregated value for a metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricValue {
    /// <p>The actual number that represents the metric.</p>
    pub amount: std::option::Option<std::string::String>,
    /// <p>The unit that the metric is given in.</p>
    pub unit: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricValue");
        formatter.field("amount", &self.amount);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`MetricValue`](crate::model::MetricValue)
pub mod metric_value {
    /// A builder for [`MetricValue`](crate::model::MetricValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amount: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The actual number that represents the metric.</p>
        pub fn amount(mut self, input: impl Into<std::string::String>) -> Self {
            self.amount = Some(input.into());
            self
        }
        pub fn set_amount(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amount = input;
            self
        }
        /// <p>The unit that the metric is given in.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricValue`](crate::model::MetricValue)
        pub fn build(self) -> crate::model::MetricValue {
            crate::model::MetricValue {
                amount: self.amount,
                unit: self.unit,
            }
        }
    }
}
impl MetricValue {
    /// Creates a new builder-style object to manufacture [`MetricValue`](crate::model::MetricValue)
    pub fn builder() -> crate::model::metric_value::Builder {
        crate::model::metric_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Granularity {
    Daily,
    Hourly,
    Monthly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Granularity {
    fn from(s: &str) -> Self {
        match s {
            "DAILY" => Granularity::Daily,
            "HOURLY" => Granularity::Hourly,
            "MONTHLY" => Granularity::Monthly,
            other => Granularity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Granularity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Granularity::from(s))
    }
}
impl Granularity {
    pub fn as_str(&self) -> &str {
        match self {
            Granularity::Daily => "DAILY",
            Granularity::Hourly => "HOURLY",
            Granularity::Monthly => "MONTHLY",
            Granularity::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DAILY", "HOURLY", "MONTHLY"]
    }
}
impl AsRef<str> for Granularity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Metric {
    AmortizedCost,
    BlendedCost,
    NetAmortizedCost,
    NetUnblendedCost,
    NormalizedUsageAmount,
    UnblendedCost,
    UsageQuantity,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Metric {
    fn from(s: &str) -> Self {
        match s {
            "AMORTIZED_COST" => Metric::AmortizedCost,
            "BLENDED_COST" => Metric::BlendedCost,
            "NET_AMORTIZED_COST" => Metric::NetAmortizedCost,
            "NET_UNBLENDED_COST" => Metric::NetUnblendedCost,
            "NORMALIZED_USAGE_AMOUNT" => Metric::NormalizedUsageAmount,
            "UNBLENDED_COST" => Metric::UnblendedCost,
            "USAGE_QUANTITY" => Metric::UsageQuantity,
            other => Metric::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Metric {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Metric::from(s))
    }
}
impl Metric {
    pub fn as_str(&self) -> &str {
        match self {
            Metric::AmortizedCost => "AMORTIZED_COST",
            Metric::BlendedCost => "BLENDED_COST",
            Metric::NetAmortizedCost => "NET_AMORTIZED_COST",
            Metric::NetUnblendedCost => "NET_UNBLENDED_COST",
            Metric::NormalizedUsageAmount => "NORMALIZED_USAGE_AMOUNT",
            Metric::UnblendedCost => "UNBLENDED_COST",
            Metric::UsageQuantity => "USAGE_QUANTITY",
            Metric::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AMORTIZED_COST",
            "BLENDED_COST",
            "NET_AMORTIZED_COST",
            "NET_UNBLENDED_COST",
            "NORMALIZED_USAGE_AMOUNT",
            "UNBLENDED_COST",
            "USAGE_QUANTITY",
        ]
    }
}
impl AsRef<str> for Metric {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of how to sort the data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SortDefinition {
    /// <p>The key by which to sort the data.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The order in which to sort the data.</p>
    pub sort_order: std::option::Option<crate::model::SortOrder>,
}
impl std::fmt::Debug for SortDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SortDefinition");
        formatter.field("key", &self.key);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}
/// See [`SortDefinition`](crate::model::SortDefinition)
pub mod sort_definition {
    /// A builder for [`SortDefinition`](crate::model::SortDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::SortOrder>,
    }
    impl Builder {
        /// <p>The key by which to sort the data.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The order in which to sort the data.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.sort_order = Some(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`SortDefinition`](crate::model::SortDefinition)
        pub fn build(self) -> crate::model::SortDefinition {
            crate::model::SortDefinition {
                key: self.key,
                sort_order: self.sort_order,
            }
        }
    }
}
impl SortDefinition {
    /// Creates a new builder-style object to manufacture [`SortDefinition`](crate::model::SortDefinition)
    pub fn builder() -> crate::model::sort_definition::Builder {
        crate::model::sort_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    Ascending,
    Descending,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The aggregated utilization metrics for your Savings Plans usage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansUtilizationAggregates {
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    pub utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans, as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    pub savings: std::option::Option<crate::model::SavingsPlansSavings>,
    /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
    pub amortized_commitment: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
}
impl std::fmt::Debug for SavingsPlansUtilizationAggregates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansUtilizationAggregates");
        formatter.field("utilization", &self.utilization);
        formatter.field("savings", &self.savings);
        formatter.field("amortized_commitment", &self.amortized_commitment);
        formatter.finish()
    }
}
/// See [`SavingsPlansUtilizationAggregates`](crate::model::SavingsPlansUtilizationAggregates)
pub mod savings_plans_utilization_aggregates {
    /// A builder for [`SavingsPlansUtilizationAggregates`](crate::model::SavingsPlansUtilizationAggregates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
        pub(crate) savings: std::option::Option<crate::model::SavingsPlansSavings>,
        pub(crate) amortized_commitment:
            std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
    }
    impl Builder {
        /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
        pub fn utilization(mut self, input: crate::model::SavingsPlansUtilization) -> Self {
            self.utilization = Some(input);
            self
        }
        pub fn set_utilization(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansUtilization>,
        ) -> Self {
            self.utilization = input;
            self
        }
        /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans, as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
        pub fn savings(mut self, input: crate::model::SavingsPlansSavings) -> Self {
            self.savings = Some(input);
            self
        }
        pub fn set_savings(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansSavings>,
        ) -> Self {
            self.savings = input;
            self
        }
        /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
        pub fn amortized_commitment(
            mut self,
            input: crate::model::SavingsPlansAmortizedCommitment,
        ) -> Self {
            self.amortized_commitment = Some(input);
            self
        }
        pub fn set_amortized_commitment(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
        ) -> Self {
            self.amortized_commitment = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansUtilizationAggregates`](crate::model::SavingsPlansUtilizationAggregates)
        pub fn build(self) -> crate::model::SavingsPlansUtilizationAggregates {
            crate::model::SavingsPlansUtilizationAggregates {
                utilization: self.utilization,
                savings: self.savings,
                amortized_commitment: self.amortized_commitment,
            }
        }
    }
}
impl SavingsPlansUtilizationAggregates {
    /// Creates a new builder-style object to manufacture [`SavingsPlansUtilizationAggregates`](crate::model::SavingsPlansUtilizationAggregates)
    pub fn builder() -> crate::model::savings_plans_utilization_aggregates::Builder {
        crate::model::savings_plans_utilization_aggregates::Builder::default()
    }
}

/// <p>The amortized amount of Savings Plans purchased in a specific account during a specific time interval.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansAmortizedCommitment {
    /// <p>The amortized amount of your Savings Plans commitment that was purchased with either a <code>Partial</code> or a <code>NoUpfront</code>.</p>
    pub amortized_recurring_commitment: std::option::Option<std::string::String>,
    /// <p>The amortized amount of your Savings Plans commitment that was purchased with an <code>Upfront</code> or <code>PartialUpfront</code> Savings Plans.</p>
    pub amortized_upfront_commitment: std::option::Option<std::string::String>,
    /// <p>The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method. </p>
    pub total_amortized_commitment: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansAmortizedCommitment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansAmortizedCommitment");
        formatter.field(
            "amortized_recurring_commitment",
            &self.amortized_recurring_commitment,
        );
        formatter.field(
            "amortized_upfront_commitment",
            &self.amortized_upfront_commitment,
        );
        formatter.field(
            "total_amortized_commitment",
            &self.total_amortized_commitment,
        );
        formatter.finish()
    }
}
/// See [`SavingsPlansAmortizedCommitment`](crate::model::SavingsPlansAmortizedCommitment)
pub mod savings_plans_amortized_commitment {
    /// A builder for [`SavingsPlansAmortizedCommitment`](crate::model::SavingsPlansAmortizedCommitment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amortized_recurring_commitment: std::option::Option<std::string::String>,
        pub(crate) amortized_upfront_commitment: std::option::Option<std::string::String>,
        pub(crate) total_amortized_commitment: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The amortized amount of your Savings Plans commitment that was purchased with either a <code>Partial</code> or a <code>NoUpfront</code>.</p>
        pub fn amortized_recurring_commitment(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.amortized_recurring_commitment = Some(input.into());
            self
        }
        pub fn set_amortized_recurring_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.amortized_recurring_commitment = input;
            self
        }
        /// <p>The amortized amount of your Savings Plans commitment that was purchased with an <code>Upfront</code> or <code>PartialUpfront</code> Savings Plans.</p>
        pub fn amortized_upfront_commitment(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.amortized_upfront_commitment = Some(input.into());
            self
        }
        pub fn set_amortized_upfront_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.amortized_upfront_commitment = input;
            self
        }
        /// <p>The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method. </p>
        pub fn total_amortized_commitment(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_amortized_commitment = Some(input.into());
            self
        }
        pub fn set_total_amortized_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_amortized_commitment = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansAmortizedCommitment`](crate::model::SavingsPlansAmortizedCommitment)
        pub fn build(self) -> crate::model::SavingsPlansAmortizedCommitment {
            crate::model::SavingsPlansAmortizedCommitment {
                amortized_recurring_commitment: self.amortized_recurring_commitment,
                amortized_upfront_commitment: self.amortized_upfront_commitment,
                total_amortized_commitment: self.total_amortized_commitment,
            }
        }
    }
}
impl SavingsPlansAmortizedCommitment {
    /// Creates a new builder-style object to manufacture [`SavingsPlansAmortizedCommitment`](crate::model::SavingsPlansAmortizedCommitment)
    pub fn builder() -> crate::model::savings_plans_amortized_commitment::Builder {
        crate::model::savings_plans_amortized_commitment::Builder::default()
    }
}

/// <p>The amount of savings you're accumulating, against the public On-Demand rate of the usage accrued in an account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansSavings {
    /// <p>The savings amount that you are accumulating for the usage that is covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.</p>
    pub net_savings: std::option::Option<std::string::String>,
    /// <p>How much the amount that the usage would have cost if it was
    /// accrued
    /// at the On-Demand rate.</p>
    pub on_demand_cost_equivalent: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansSavings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansSavings");
        formatter.field("net_savings", &self.net_savings);
        formatter.field("on_demand_cost_equivalent", &self.on_demand_cost_equivalent);
        formatter.finish()
    }
}
/// See [`SavingsPlansSavings`](crate::model::SavingsPlansSavings)
pub mod savings_plans_savings {
    /// A builder for [`SavingsPlansSavings`](crate::model::SavingsPlansSavings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) net_savings: std::option::Option<std::string::String>,
        pub(crate) on_demand_cost_equivalent: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The savings amount that you are accumulating for the usage that is covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.</p>
        pub fn net_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.net_savings = Some(input.into());
            self
        }
        pub fn set_net_savings(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.net_savings = input;
            self
        }
        /// <p>How much the amount that the usage would have cost if it was
        /// accrued
        /// at the On-Demand rate.</p>
        pub fn on_demand_cost_equivalent(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_cost_equivalent = Some(input.into());
            self
        }
        pub fn set_on_demand_cost_equivalent(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_cost_equivalent = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansSavings`](crate::model::SavingsPlansSavings)
        pub fn build(self) -> crate::model::SavingsPlansSavings {
            crate::model::SavingsPlansSavings {
                net_savings: self.net_savings,
                on_demand_cost_equivalent: self.on_demand_cost_equivalent,
            }
        }
    }
}
impl SavingsPlansSavings {
    /// Creates a new builder-style object to manufacture [`SavingsPlansSavings`](crate::model::SavingsPlansSavings)
    pub fn builder() -> crate::model::savings_plans_savings::Builder {
        crate::model::savings_plans_savings::Builder::default()
    }
}

/// <p>The measurement of how well you are using your existing Savings Plans.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansUtilization {
    /// <p>The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).</p>
    pub total_commitment: std::option::Option<std::string::String>,
    /// <p>The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.</p>
    pub used_commitment: std::option::Option<std::string::String>,
    /// <p>The amount of your Savings Plans commitment that was not consumed from Savings Plans eligible usage in a specific period.</p>
    pub unused_commitment: std::option::Option<std::string::String>,
    /// <p>The amount of <code>UsedCommitment</code> divided by the <code>TotalCommitment</code> for your Savings Plans.</p>
    pub utilization_percentage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansUtilization");
        formatter.field("total_commitment", &self.total_commitment);
        formatter.field("used_commitment", &self.used_commitment);
        formatter.field("unused_commitment", &self.unused_commitment);
        formatter.field("utilization_percentage", &self.utilization_percentage);
        formatter.finish()
    }
}
/// See [`SavingsPlansUtilization`](crate::model::SavingsPlansUtilization)
pub mod savings_plans_utilization {
    /// A builder for [`SavingsPlansUtilization`](crate::model::SavingsPlansUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_commitment: std::option::Option<std::string::String>,
        pub(crate) used_commitment: std::option::Option<std::string::String>,
        pub(crate) unused_commitment: std::option::Option<std::string::String>,
        pub(crate) utilization_percentage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).</p>
        pub fn total_commitment(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_commitment = Some(input.into());
            self
        }
        pub fn set_total_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_commitment = input;
            self
        }
        /// <p>The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.</p>
        pub fn used_commitment(mut self, input: impl Into<std::string::String>) -> Self {
            self.used_commitment = Some(input.into());
            self
        }
        pub fn set_used_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.used_commitment = input;
            self
        }
        /// <p>The amount of your Savings Plans commitment that was not consumed from Savings Plans eligible usage in a specific period.</p>
        pub fn unused_commitment(mut self, input: impl Into<std::string::String>) -> Self {
            self.unused_commitment = Some(input.into());
            self
        }
        pub fn set_unused_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unused_commitment = input;
            self
        }
        /// <p>The amount of <code>UsedCommitment</code> divided by the <code>TotalCommitment</code> for your Savings Plans.</p>
        pub fn utilization_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.utilization_percentage = Some(input.into());
            self
        }
        pub fn set_utilization_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.utilization_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansUtilization`](crate::model::SavingsPlansUtilization)
        pub fn build(self) -> crate::model::SavingsPlansUtilization {
            crate::model::SavingsPlansUtilization {
                total_commitment: self.total_commitment,
                used_commitment: self.used_commitment,
                unused_commitment: self.unused_commitment,
                utilization_percentage: self.utilization_percentage,
            }
        }
    }
}
impl SavingsPlansUtilization {
    /// Creates a new builder-style object to manufacture [`SavingsPlansUtilization`](crate::model::SavingsPlansUtilization)
    pub fn builder() -> crate::model::savings_plans_utilization::Builder {
        crate::model::savings_plans_utilization::Builder::default()
    }
}

/// <p>A single daily or monthly Savings Plans utilization rate, and details for your account. A management account in an organization have access to member accounts. You can use <code>GetDimensionValues</code> to determine the possible dimension values. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansUtilizationDetail {
    /// <p>The unique Amazon Resource Name (ARN) for a particular Savings Plan.</p>
    pub savings_plan_arn: std::option::Option<std::string::String>,
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    pub utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    pub savings: std::option::Option<crate::model::SavingsPlansSavings>,
    /// <p>The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.</p>
    pub amortized_commitment: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
}
impl std::fmt::Debug for SavingsPlansUtilizationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansUtilizationDetail");
        formatter.field("savings_plan_arn", &self.savings_plan_arn);
        formatter.field("attributes", &self.attributes);
        formatter.field("utilization", &self.utilization);
        formatter.field("savings", &self.savings);
        formatter.field("amortized_commitment", &self.amortized_commitment);
        formatter.finish()
    }
}
/// See [`SavingsPlansUtilizationDetail`](crate::model::SavingsPlansUtilizationDetail)
pub mod savings_plans_utilization_detail {
    /// A builder for [`SavingsPlansUtilizationDetail`](crate::model::SavingsPlansUtilizationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) savings_plan_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
        pub(crate) savings: std::option::Option<crate::model::SavingsPlansSavings>,
        pub(crate) amortized_commitment:
            std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
    }
    impl Builder {
        /// <p>The unique Amazon Resource Name (ARN) for a particular Savings Plan.</p>
        pub fn savings_plan_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.savings_plan_arn = Some(input.into());
            self
        }
        pub fn set_savings_plan_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.savings_plan_arn = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
        pub fn utilization(mut self, input: crate::model::SavingsPlansUtilization) -> Self {
            self.utilization = Some(input);
            self
        }
        pub fn set_utilization(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansUtilization>,
        ) -> Self {
            self.utilization = input;
            self
        }
        /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
        pub fn savings(mut self, input: crate::model::SavingsPlansSavings) -> Self {
            self.savings = Some(input);
            self
        }
        pub fn set_savings(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansSavings>,
        ) -> Self {
            self.savings = input;
            self
        }
        /// <p>The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.</p>
        pub fn amortized_commitment(
            mut self,
            input: crate::model::SavingsPlansAmortizedCommitment,
        ) -> Self {
            self.amortized_commitment = Some(input);
            self
        }
        pub fn set_amortized_commitment(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
        ) -> Self {
            self.amortized_commitment = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansUtilizationDetail`](crate::model::SavingsPlansUtilizationDetail)
        pub fn build(self) -> crate::model::SavingsPlansUtilizationDetail {
            crate::model::SavingsPlansUtilizationDetail {
                savings_plan_arn: self.savings_plan_arn,
                attributes: self.attributes,
                utilization: self.utilization,
                savings: self.savings,
                amortized_commitment: self.amortized_commitment,
            }
        }
    }
}
impl SavingsPlansUtilizationDetail {
    /// Creates a new builder-style object to manufacture [`SavingsPlansUtilizationDetail`](crate::model::SavingsPlansUtilizationDetail)
    pub fn builder() -> crate::model::savings_plans_utilization_detail::Builder {
        crate::model::savings_plans_utilization_detail::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SavingsPlansDataType {
    AmortizedCommitment,
    Attributes,
    Savings,
    Utilization,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SavingsPlansDataType {
    fn from(s: &str) -> Self {
        match s {
            "AMORTIZED_COMMITMENT" => SavingsPlansDataType::AmortizedCommitment,
            "ATTRIBUTES" => SavingsPlansDataType::Attributes,
            "SAVINGS" => SavingsPlansDataType::Savings,
            "UTILIZATION" => SavingsPlansDataType::Utilization,
            other => SavingsPlansDataType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SavingsPlansDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SavingsPlansDataType::from(s))
    }
}
impl SavingsPlansDataType {
    pub fn as_str(&self) -> &str {
        match self {
            SavingsPlansDataType::AmortizedCommitment => "AMORTIZED_COMMITMENT",
            SavingsPlansDataType::Attributes => "ATTRIBUTES",
            SavingsPlansDataType::Savings => "SAVINGS",
            SavingsPlansDataType::Utilization => "UTILIZATION",
            SavingsPlansDataType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AMORTIZED_COMMITMENT",
            "ATTRIBUTES",
            "SAVINGS",
            "UTILIZATION",
        ]
    }
}
impl AsRef<str> for SavingsPlansDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The amount of Savings Plans utilization, in hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansUtilizationByTime {
    /// <p>The time period of the request.
    /// </p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    pub utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    pub savings: std::option::Option<crate::model::SavingsPlansSavings>,
    /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
    pub amortized_commitment: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
}
impl std::fmt::Debug for SavingsPlansUtilizationByTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansUtilizationByTime");
        formatter.field("time_period", &self.time_period);
        formatter.field("utilization", &self.utilization);
        formatter.field("savings", &self.savings);
        formatter.field("amortized_commitment", &self.amortized_commitment);
        formatter.finish()
    }
}
/// See [`SavingsPlansUtilizationByTime`](crate::model::SavingsPlansUtilizationByTime)
pub mod savings_plans_utilization_by_time {
    /// A builder for [`SavingsPlansUtilizationByTime`](crate::model::SavingsPlansUtilizationByTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) utilization: std::option::Option<crate::model::SavingsPlansUtilization>,
        pub(crate) savings: std::option::Option<crate::model::SavingsPlansSavings>,
        pub(crate) amortized_commitment:
            std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
    }
    impl Builder {
        /// <p>The time period of the request.
        /// </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
        pub fn utilization(mut self, input: crate::model::SavingsPlansUtilization) -> Self {
            self.utilization = Some(input);
            self
        }
        pub fn set_utilization(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansUtilization>,
        ) -> Self {
            self.utilization = input;
            self
        }
        /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
        pub fn savings(mut self, input: crate::model::SavingsPlansSavings) -> Self {
            self.savings = Some(input);
            self
        }
        pub fn set_savings(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansSavings>,
        ) -> Self {
            self.savings = input;
            self
        }
        /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
        pub fn amortized_commitment(
            mut self,
            input: crate::model::SavingsPlansAmortizedCommitment,
        ) -> Self {
            self.amortized_commitment = Some(input);
            self
        }
        pub fn set_amortized_commitment(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansAmortizedCommitment>,
        ) -> Self {
            self.amortized_commitment = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansUtilizationByTime`](crate::model::SavingsPlansUtilizationByTime)
        pub fn build(self) -> crate::model::SavingsPlansUtilizationByTime {
            crate::model::SavingsPlansUtilizationByTime {
                time_period: self.time_period,
                utilization: self.utilization,
                savings: self.savings,
                amortized_commitment: self.amortized_commitment,
            }
        }
    }
}
impl SavingsPlansUtilizationByTime {
    /// Creates a new builder-style object to manufacture [`SavingsPlansUtilizationByTime`](crate::model::SavingsPlansUtilizationByTime)
    pub fn builder() -> crate::model::savings_plans_utilization_by_time::Builder {
        crate::model::savings_plans_utilization_by_time::Builder::default()
    }
}

/// <p>Contains your request parameters, Savings Plan Recommendations Summary, and Details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansPurchaseRecommendation {
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    pub account_scope: std::option::Option<crate::model::AccountScope>,
    /// <p>The requested Savings Plans recommendation type.</p>
    pub savings_plans_type: std::option::Option<crate::model::SupportedSavingsPlansType>,
    /// <p>The Savings Plans recommendation term in years, used to generate the recommendation.</p>
    pub term_in_years: std::option::Option<crate::model::TermInYears>,
    /// <p>The payment option used to generate the recommendation.</p>
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The lookback period in days, used to generate the recommendation.</p>
    pub lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
    /// <p>Details for the Savings Plans we recommend that you purchase to cover existing Savings
    /// Plans eligible workloads.</p>
    pub savings_plans_purchase_recommendation_details:
        std::option::Option<std::vec::Vec<crate::model::SavingsPlansPurchaseRecommendationDetail>>,
    /// <p>Summary metrics for your Savings Plans Recommendations. </p>
    pub savings_plans_purchase_recommendation_summary:
        std::option::Option<crate::model::SavingsPlansPurchaseRecommendationSummary>,
}
impl std::fmt::Debug for SavingsPlansPurchaseRecommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansPurchaseRecommendation");
        formatter.field("account_scope", &self.account_scope);
        formatter.field("savings_plans_type", &self.savings_plans_type);
        formatter.field("term_in_years", &self.term_in_years);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("lookback_period_in_days", &self.lookback_period_in_days);
        formatter.field(
            "savings_plans_purchase_recommendation_details",
            &self.savings_plans_purchase_recommendation_details,
        );
        formatter.field(
            "savings_plans_purchase_recommendation_summary",
            &self.savings_plans_purchase_recommendation_summary,
        );
        formatter.finish()
    }
}
/// See [`SavingsPlansPurchaseRecommendation`](crate::model::SavingsPlansPurchaseRecommendation)
pub mod savings_plans_purchase_recommendation {
    /// A builder for [`SavingsPlansPurchaseRecommendation`](crate::model::SavingsPlansPurchaseRecommendation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_scope: std::option::Option<crate::model::AccountScope>,
        pub(crate) savings_plans_type: std::option::Option<crate::model::SupportedSavingsPlansType>,
        pub(crate) term_in_years: std::option::Option<crate::model::TermInYears>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
        pub(crate) savings_plans_purchase_recommendation_details: std::option::Option<
            std::vec::Vec<crate::model::SavingsPlansPurchaseRecommendationDetail>,
        >,
        pub(crate) savings_plans_purchase_recommendation_summary:
            std::option::Option<crate::model::SavingsPlansPurchaseRecommendationSummary>,
    }
    impl Builder {
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.account_scope = Some(input);
            self
        }
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.account_scope = input;
            self
        }
        /// <p>The requested Savings Plans recommendation type.</p>
        pub fn savings_plans_type(
            mut self,
            input: crate::model::SupportedSavingsPlansType,
        ) -> Self {
            self.savings_plans_type = Some(input);
            self
        }
        pub fn set_savings_plans_type(
            mut self,
            input: std::option::Option<crate::model::SupportedSavingsPlansType>,
        ) -> Self {
            self.savings_plans_type = input;
            self
        }
        /// <p>The Savings Plans recommendation term in years, used to generate the recommendation.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.term_in_years = Some(input);
            self
        }
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.term_in_years = input;
            self
        }
        /// <p>The payment option used to generate the recommendation.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The lookback period in days, used to generate the recommendation.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.lookback_period_in_days = input;
            self
        }
        pub fn savings_plans_purchase_recommendation_details(
            mut self,
            input: impl Into<crate::model::SavingsPlansPurchaseRecommendationDetail>,
        ) -> Self {
            let mut v = self
                .savings_plans_purchase_recommendation_details
                .unwrap_or_default();
            v.push(input.into());
            self.savings_plans_purchase_recommendation_details = Some(v);
            self
        }
        pub fn set_savings_plans_purchase_recommendation_details(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::SavingsPlansPurchaseRecommendationDetail>,
            >,
        ) -> Self {
            self.savings_plans_purchase_recommendation_details = input;
            self
        }
        /// <p>Summary metrics for your Savings Plans Recommendations. </p>
        pub fn savings_plans_purchase_recommendation_summary(
            mut self,
            input: crate::model::SavingsPlansPurchaseRecommendationSummary,
        ) -> Self {
            self.savings_plans_purchase_recommendation_summary = Some(input);
            self
        }
        pub fn set_savings_plans_purchase_recommendation_summary(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansPurchaseRecommendationSummary>,
        ) -> Self {
            self.savings_plans_purchase_recommendation_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansPurchaseRecommendation`](crate::model::SavingsPlansPurchaseRecommendation)
        pub fn build(self) -> crate::model::SavingsPlansPurchaseRecommendation {
            crate::model::SavingsPlansPurchaseRecommendation {
                account_scope: self.account_scope,
                savings_plans_type: self.savings_plans_type,
                term_in_years: self.term_in_years,
                payment_option: self.payment_option,
                lookback_period_in_days: self.lookback_period_in_days,
                savings_plans_purchase_recommendation_details: self
                    .savings_plans_purchase_recommendation_details,
                savings_plans_purchase_recommendation_summary: self
                    .savings_plans_purchase_recommendation_summary,
            }
        }
    }
}
impl SavingsPlansPurchaseRecommendation {
    /// Creates a new builder-style object to manufacture [`SavingsPlansPurchaseRecommendation`](crate::model::SavingsPlansPurchaseRecommendation)
    pub fn builder() -> crate::model::savings_plans_purchase_recommendation::Builder {
        crate::model::savings_plans_purchase_recommendation::Builder::default()
    }
}

/// <p>Summary metrics for your Savings Plans Purchase Recommendations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansPurchaseRecommendationSummary {
    /// <p>The estimated return on investment based on the recommended Savings Plans and estimated savings.</p>
    pub estimated_roi: std::option::Option<std::string::String>,
    /// <p>The currency code AWS used to generate the recommendations and present potential
    /// savings.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.</p>
    pub estimated_total_cost: std::option::Option<std::string::String>,
    /// <p>The current total on demand spend of the applicable usage types over the lookback period.</p>
    pub current_on_demand_spend: std::option::Option<std::string::String>,
    /// <p>The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.</p>
    pub estimated_savings_amount: std::option::Option<std::string::String>,
    /// <p>The aggregate number of Savings Plans recommendations that exist for your account.</p>
    pub total_recommendation_count: std::option::Option<std::string::String>,
    /// <p>The recommended Savings Plans cost on a daily (24 hourly) basis.</p>
    pub daily_commitment_to_purchase: std::option::Option<std::string::String>,
    /// <p>The recommended hourly commitment based on the recommendation parameters.</p>
    pub hourly_commitment_to_purchase: std::option::Option<std::string::String>,
    /// <p>The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as <code>estimatedSavingsAmount</code>/ <code>CurrentOnDemandSpend</code>*100.</p>
    pub estimated_savings_percentage: std::option::Option<std::string::String>,
    /// <p>The estimated monthly savings amount, based on the recommended Savings Plans purchase.</p>
    pub estimated_monthly_savings_amount: std::option::Option<std::string::String>,
    /// <p>
    /// The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
    /// </p>
    pub estimated_on_demand_cost_with_current_commitment: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansPurchaseRecommendationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansPurchaseRecommendationSummary");
        formatter.field("estimated_roi", &self.estimated_roi);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("estimated_total_cost", &self.estimated_total_cost);
        formatter.field("current_on_demand_spend", &self.current_on_demand_spend);
        formatter.field("estimated_savings_amount", &self.estimated_savings_amount);
        formatter.field(
            "total_recommendation_count",
            &self.total_recommendation_count,
        );
        formatter.field(
            "daily_commitment_to_purchase",
            &self.daily_commitment_to_purchase,
        );
        formatter.field(
            "hourly_commitment_to_purchase",
            &self.hourly_commitment_to_purchase,
        );
        formatter.field(
            "estimated_savings_percentage",
            &self.estimated_savings_percentage,
        );
        formatter.field(
            "estimated_monthly_savings_amount",
            &self.estimated_monthly_savings_amount,
        );
        formatter.field(
            "estimated_on_demand_cost_with_current_commitment",
            &self.estimated_on_demand_cost_with_current_commitment,
        );
        formatter.finish()
    }
}
/// See [`SavingsPlansPurchaseRecommendationSummary`](crate::model::SavingsPlansPurchaseRecommendationSummary)
pub mod savings_plans_purchase_recommendation_summary {
    /// A builder for [`SavingsPlansPurchaseRecommendationSummary`](crate::model::SavingsPlansPurchaseRecommendationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) estimated_roi: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) estimated_total_cost: std::option::Option<std::string::String>,
        pub(crate) current_on_demand_spend: std::option::Option<std::string::String>,
        pub(crate) estimated_savings_amount: std::option::Option<std::string::String>,
        pub(crate) total_recommendation_count: std::option::Option<std::string::String>,
        pub(crate) daily_commitment_to_purchase: std::option::Option<std::string::String>,
        pub(crate) hourly_commitment_to_purchase: std::option::Option<std::string::String>,
        pub(crate) estimated_savings_percentage: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_savings_amount: std::option::Option<std::string::String>,
        pub(crate) estimated_on_demand_cost_with_current_commitment:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The estimated return on investment based on the recommended Savings Plans and estimated savings.</p>
        pub fn estimated_roi(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_roi = Some(input.into());
            self
        }
        pub fn set_estimated_roi(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_roi = input;
            self
        }
        /// <p>The currency code AWS used to generate the recommendations and present potential
        /// savings.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.</p>
        pub fn estimated_total_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_total_cost = Some(input.into());
            self
        }
        pub fn set_estimated_total_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_total_cost = input;
            self
        }
        /// <p>The current total on demand spend of the applicable usage types over the lookback period.</p>
        pub fn current_on_demand_spend(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_on_demand_spend = Some(input.into());
            self
        }
        pub fn set_current_on_demand_spend(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_on_demand_spend = input;
            self
        }
        /// <p>The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.</p>
        pub fn estimated_savings_amount(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_savings_amount = input;
            self
        }
        /// <p>The aggregate number of Savings Plans recommendations that exist for your account.</p>
        pub fn total_recommendation_count(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_recommendation_count = Some(input.into());
            self
        }
        pub fn set_total_recommendation_count(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_recommendation_count = input;
            self
        }
        /// <p>The recommended Savings Plans cost on a daily (24 hourly) basis.</p>
        pub fn daily_commitment_to_purchase(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.daily_commitment_to_purchase = Some(input.into());
            self
        }
        pub fn set_daily_commitment_to_purchase(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.daily_commitment_to_purchase = input;
            self
        }
        /// <p>The recommended hourly commitment based on the recommendation parameters.</p>
        pub fn hourly_commitment_to_purchase(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hourly_commitment_to_purchase = Some(input.into());
            self
        }
        pub fn set_hourly_commitment_to_purchase(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hourly_commitment_to_purchase = input;
            self
        }
        /// <p>The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as <code>estimatedSavingsAmount</code>/ <code>CurrentOnDemandSpend</code>*100.</p>
        pub fn estimated_savings_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_savings_percentage = Some(input.into());
            self
        }
        pub fn set_estimated_savings_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_savings_percentage = input;
            self
        }
        /// <p>The estimated monthly savings amount, based on the recommended Savings Plans purchase.</p>
        pub fn estimated_monthly_savings_amount(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = input;
            self
        }
        /// <p>
        /// The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        /// </p>
        pub fn estimated_on_demand_cost_with_current_commitment(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_on_demand_cost_with_current_commitment = Some(input.into());
            self
        }
        pub fn set_estimated_on_demand_cost_with_current_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_on_demand_cost_with_current_commitment = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansPurchaseRecommendationSummary`](crate::model::SavingsPlansPurchaseRecommendationSummary)
        pub fn build(self) -> crate::model::SavingsPlansPurchaseRecommendationSummary {
            crate::model::SavingsPlansPurchaseRecommendationSummary {
                estimated_roi: self.estimated_roi,
                currency_code: self.currency_code,
                estimated_total_cost: self.estimated_total_cost,
                current_on_demand_spend: self.current_on_demand_spend,
                estimated_savings_amount: self.estimated_savings_amount,
                total_recommendation_count: self.total_recommendation_count,
                daily_commitment_to_purchase: self.daily_commitment_to_purchase,
                hourly_commitment_to_purchase: self.hourly_commitment_to_purchase,
                estimated_savings_percentage: self.estimated_savings_percentage,
                estimated_monthly_savings_amount: self.estimated_monthly_savings_amount,
                estimated_on_demand_cost_with_current_commitment: self
                    .estimated_on_demand_cost_with_current_commitment,
            }
        }
    }
}
impl SavingsPlansPurchaseRecommendationSummary {
    /// Creates a new builder-style object to manufacture [`SavingsPlansPurchaseRecommendationSummary`](crate::model::SavingsPlansPurchaseRecommendationSummary)
    pub fn builder() -> crate::model::savings_plans_purchase_recommendation_summary::Builder {
        crate::model::savings_plans_purchase_recommendation_summary::Builder::default()
    }
}

/// <p>Details for your recommended Savings Plans.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansPurchaseRecommendationDetail {
    /// <p>Details for your recommended Savings Plans.</p>
    pub savings_plans_details: std::option::Option<crate::model::SavingsPlansDetails>,
    /// <p>The <code>AccountID</code> the recommendation is generated for.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The upfront cost of the recommended Savings Plans, based on the selected payment option.</p>
    pub upfront_cost: std::option::Option<std::string::String>,
    /// <p>The estimated return on investment based on the recommended Savings Plans purchased. This is calculated as <code>estimatedSavingsAmount</code>/ <code>estimatedSPCost</code>*100.</p>
    pub estimated_roi: std::option::Option<std::string::String>,
    /// <p>The currency code AWS used to generate the recommendations and present potential
    /// savings.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>The cost of the recommended Savings Plans over the length of the lookback period.</p>
    pub estimated_sp_cost: std::option::Option<std::string::String>,
    /// <p>The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.</p>
    pub estimated_on_demand_cost: std::option::Option<std::string::String>,
    /// <p>
    /// The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
    /// </p>
    pub estimated_on_demand_cost_with_current_commitment: std::option::Option<std::string::String>,
    /// <p>The estimated savings amount based on the recommended Savings Plans over the length of the lookback period.</p>
    pub estimated_savings_amount: std::option::Option<std::string::String>,
    /// <p>The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.</p>
    pub estimated_savings_percentage: std::option::Option<std::string::String>,
    /// <p>The recommended hourly commitment level for the Savings Plans type, and configuration based on the usage during the lookback period.</p>
    pub hourly_commitment_to_purchase: std::option::Option<std::string::String>,
    /// <p>The estimated utilization of the recommended Savings Plans.</p>
    pub estimated_average_utilization: std::option::Option<std::string::String>,
    /// <p>The estimated monthly savings amount, based on the recommended Savings Plans.</p>
    pub estimated_monthly_savings_amount: std::option::Option<std::string::String>,
    /// <p>The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    pub current_minimum_hourly_on_demand_spend: std::option::Option<std::string::String>,
    /// <p>The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    pub current_maximum_hourly_on_demand_spend: std::option::Option<std::string::String>,
    /// <p>The average value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    pub current_average_hourly_on_demand_spend: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansPurchaseRecommendationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansPurchaseRecommendationDetail");
        formatter.field("savings_plans_details", &self.savings_plans_details);
        formatter.field("account_id", &self.account_id);
        formatter.field("upfront_cost", &self.upfront_cost);
        formatter.field("estimated_roi", &self.estimated_roi);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("estimated_sp_cost", &self.estimated_sp_cost);
        formatter.field("estimated_on_demand_cost", &self.estimated_on_demand_cost);
        formatter.field(
            "estimated_on_demand_cost_with_current_commitment",
            &self.estimated_on_demand_cost_with_current_commitment,
        );
        formatter.field("estimated_savings_amount", &self.estimated_savings_amount);
        formatter.field(
            "estimated_savings_percentage",
            &self.estimated_savings_percentage,
        );
        formatter.field(
            "hourly_commitment_to_purchase",
            &self.hourly_commitment_to_purchase,
        );
        formatter.field(
            "estimated_average_utilization",
            &self.estimated_average_utilization,
        );
        formatter.field(
            "estimated_monthly_savings_amount",
            &self.estimated_monthly_savings_amount,
        );
        formatter.field(
            "current_minimum_hourly_on_demand_spend",
            &self.current_minimum_hourly_on_demand_spend,
        );
        formatter.field(
            "current_maximum_hourly_on_demand_spend",
            &self.current_maximum_hourly_on_demand_spend,
        );
        formatter.field(
            "current_average_hourly_on_demand_spend",
            &self.current_average_hourly_on_demand_spend,
        );
        formatter.finish()
    }
}
/// See [`SavingsPlansPurchaseRecommendationDetail`](crate::model::SavingsPlansPurchaseRecommendationDetail)
pub mod savings_plans_purchase_recommendation_detail {
    /// A builder for [`SavingsPlansPurchaseRecommendationDetail`](crate::model::SavingsPlansPurchaseRecommendationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) savings_plans_details: std::option::Option<crate::model::SavingsPlansDetails>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) upfront_cost: std::option::Option<std::string::String>,
        pub(crate) estimated_roi: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) estimated_sp_cost: std::option::Option<std::string::String>,
        pub(crate) estimated_on_demand_cost: std::option::Option<std::string::String>,
        pub(crate) estimated_on_demand_cost_with_current_commitment:
            std::option::Option<std::string::String>,
        pub(crate) estimated_savings_amount: std::option::Option<std::string::String>,
        pub(crate) estimated_savings_percentage: std::option::Option<std::string::String>,
        pub(crate) hourly_commitment_to_purchase: std::option::Option<std::string::String>,
        pub(crate) estimated_average_utilization: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_savings_amount: std::option::Option<std::string::String>,
        pub(crate) current_minimum_hourly_on_demand_spend: std::option::Option<std::string::String>,
        pub(crate) current_maximum_hourly_on_demand_spend: std::option::Option<std::string::String>,
        pub(crate) current_average_hourly_on_demand_spend: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Details for your recommended Savings Plans.</p>
        pub fn savings_plans_details(mut self, input: crate::model::SavingsPlansDetails) -> Self {
            self.savings_plans_details = Some(input);
            self
        }
        pub fn set_savings_plans_details(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansDetails>,
        ) -> Self {
            self.savings_plans_details = input;
            self
        }
        /// <p>The <code>AccountID</code> the recommendation is generated for.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The upfront cost of the recommended Savings Plans, based on the selected payment option.</p>
        pub fn upfront_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.upfront_cost = Some(input.into());
            self
        }
        pub fn set_upfront_cost(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upfront_cost = input;
            self
        }
        /// <p>The estimated return on investment based on the recommended Savings Plans purchased. This is calculated as <code>estimatedSavingsAmount</code>/ <code>estimatedSPCost</code>*100.</p>
        pub fn estimated_roi(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_roi = Some(input.into());
            self
        }
        pub fn set_estimated_roi(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_roi = input;
            self
        }
        /// <p>The currency code AWS used to generate the recommendations and present potential
        /// savings.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>The cost of the recommended Savings Plans over the length of the lookback period.</p>
        pub fn estimated_sp_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_sp_cost = Some(input.into());
            self
        }
        pub fn set_estimated_sp_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_sp_cost = input;
            self
        }
        /// <p>The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.</p>
        pub fn estimated_on_demand_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_on_demand_cost = Some(input.into());
            self
        }
        pub fn set_estimated_on_demand_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_on_demand_cost = input;
            self
        }
        /// <p>
        /// The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        /// </p>
        pub fn estimated_on_demand_cost_with_current_commitment(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_on_demand_cost_with_current_commitment = Some(input.into());
            self
        }
        pub fn set_estimated_on_demand_cost_with_current_commitment(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_on_demand_cost_with_current_commitment = input;
            self
        }
        /// <p>The estimated savings amount based on the recommended Savings Plans over the length of the lookback period.</p>
        pub fn estimated_savings_amount(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_savings_amount = input;
            self
        }
        /// <p>The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.</p>
        pub fn estimated_savings_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_savings_percentage = Some(input.into());
            self
        }
        pub fn set_estimated_savings_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_savings_percentage = input;
            self
        }
        /// <p>The recommended hourly commitment level for the Savings Plans type, and configuration based on the usage during the lookback period.</p>
        pub fn hourly_commitment_to_purchase(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.hourly_commitment_to_purchase = Some(input.into());
            self
        }
        pub fn set_hourly_commitment_to_purchase(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hourly_commitment_to_purchase = input;
            self
        }
        /// <p>The estimated utilization of the recommended Savings Plans.</p>
        pub fn estimated_average_utilization(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_average_utilization = Some(input.into());
            self
        }
        pub fn set_estimated_average_utilization(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_average_utilization = input;
            self
        }
        /// <p>The estimated monthly savings amount, based on the recommended Savings Plans.</p>
        pub fn estimated_monthly_savings_amount(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = input;
            self
        }
        /// <p>The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
        pub fn current_minimum_hourly_on_demand_spend(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.current_minimum_hourly_on_demand_spend = Some(input.into());
            self
        }
        pub fn set_current_minimum_hourly_on_demand_spend(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_minimum_hourly_on_demand_spend = input;
            self
        }
        /// <p>The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
        pub fn current_maximum_hourly_on_demand_spend(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.current_maximum_hourly_on_demand_spend = Some(input.into());
            self
        }
        pub fn set_current_maximum_hourly_on_demand_spend(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_maximum_hourly_on_demand_spend = input;
            self
        }
        /// <p>The average value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
        pub fn current_average_hourly_on_demand_spend(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.current_average_hourly_on_demand_spend = Some(input.into());
            self
        }
        pub fn set_current_average_hourly_on_demand_spend(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_average_hourly_on_demand_spend = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansPurchaseRecommendationDetail`](crate::model::SavingsPlansPurchaseRecommendationDetail)
        pub fn build(self) -> crate::model::SavingsPlansPurchaseRecommendationDetail {
            crate::model::SavingsPlansPurchaseRecommendationDetail {
                savings_plans_details: self.savings_plans_details,
                account_id: self.account_id,
                upfront_cost: self.upfront_cost,
                estimated_roi: self.estimated_roi,
                currency_code: self.currency_code,
                estimated_sp_cost: self.estimated_sp_cost,
                estimated_on_demand_cost: self.estimated_on_demand_cost,
                estimated_on_demand_cost_with_current_commitment: self
                    .estimated_on_demand_cost_with_current_commitment,
                estimated_savings_amount: self.estimated_savings_amount,
                estimated_savings_percentage: self.estimated_savings_percentage,
                hourly_commitment_to_purchase: self.hourly_commitment_to_purchase,
                estimated_average_utilization: self.estimated_average_utilization,
                estimated_monthly_savings_amount: self.estimated_monthly_savings_amount,
                current_minimum_hourly_on_demand_spend: self.current_minimum_hourly_on_demand_spend,
                current_maximum_hourly_on_demand_spend: self.current_maximum_hourly_on_demand_spend,
                current_average_hourly_on_demand_spend: self.current_average_hourly_on_demand_spend,
            }
        }
    }
}
impl SavingsPlansPurchaseRecommendationDetail {
    /// Creates a new builder-style object to manufacture [`SavingsPlansPurchaseRecommendationDetail`](crate::model::SavingsPlansPurchaseRecommendationDetail)
    pub fn builder() -> crate::model::savings_plans_purchase_recommendation_detail::Builder {
        crate::model::savings_plans_purchase_recommendation_detail::Builder::default()
    }
}

/// <p>Attribute details on a specific Savings Plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansDetails {
    /// <p>A collection of AWS resources in a geographic area. Each AWS Region is isolated and independent of the other Regions.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>A group of instance types that Savings Plans applies to.</p>
    pub instance_family: std::option::Option<std::string::String>,
    /// <p>The unique ID used to distinguish Savings Plans from one another.</p>
    pub offering_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansDetails");
        formatter.field("region", &self.region);
        formatter.field("instance_family", &self.instance_family);
        formatter.field("offering_id", &self.offering_id);
        formatter.finish()
    }
}
/// See [`SavingsPlansDetails`](crate::model::SavingsPlansDetails)
pub mod savings_plans_details {
    /// A builder for [`SavingsPlansDetails`](crate::model::SavingsPlansDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) instance_family: std::option::Option<std::string::String>,
        pub(crate) offering_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A collection of AWS resources in a geographic area. Each AWS Region is isolated and independent of the other Regions.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>A group of instance types that Savings Plans applies to.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_family = Some(input.into());
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_family = input;
            self
        }
        /// <p>The unique ID used to distinguish Savings Plans from one another.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.offering_id = Some(input.into());
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.offering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansDetails`](crate::model::SavingsPlansDetails)
        pub fn build(self) -> crate::model::SavingsPlansDetails {
            crate::model::SavingsPlansDetails {
                region: self.region,
                instance_family: self.instance_family,
                offering_id: self.offering_id,
            }
        }
    }
}
impl SavingsPlansDetails {
    /// Creates a new builder-style object to manufacture [`SavingsPlansDetails`](crate::model::SavingsPlansDetails)
    pub fn builder() -> crate::model::savings_plans_details::Builder {
        crate::model::savings_plans_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LookbackPeriodInDays {
    SevenDays,
    SixtyDays,
    ThirtyDays,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LookbackPeriodInDays {
    fn from(s: &str) -> Self {
        match s {
            "SEVEN_DAYS" => LookbackPeriodInDays::SevenDays,
            "SIXTY_DAYS" => LookbackPeriodInDays::SixtyDays,
            "THIRTY_DAYS" => LookbackPeriodInDays::ThirtyDays,
            other => LookbackPeriodInDays::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LookbackPeriodInDays {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LookbackPeriodInDays::from(s))
    }
}
impl LookbackPeriodInDays {
    pub fn as_str(&self) -> &str {
        match self {
            LookbackPeriodInDays::SevenDays => "SEVEN_DAYS",
            LookbackPeriodInDays::SixtyDays => "SIXTY_DAYS",
            LookbackPeriodInDays::ThirtyDays => "THIRTY_DAYS",
            LookbackPeriodInDays::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["SEVEN_DAYS", "SIXTY_DAYS", "THIRTY_DAYS"]
    }
}
impl AsRef<str> for LookbackPeriodInDays {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PaymentOption {
    AllUpfront,
    HeavyUtilization,
    LightUtilization,
    MediumUtilization,
    NoUpfront,
    PartialUpfront,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PaymentOption {
    fn from(s: &str) -> Self {
        match s {
            "ALL_UPFRONT" => PaymentOption::AllUpfront,
            "HEAVY_UTILIZATION" => PaymentOption::HeavyUtilization,
            "LIGHT_UTILIZATION" => PaymentOption::LightUtilization,
            "MEDIUM_UTILIZATION" => PaymentOption::MediumUtilization,
            "NO_UPFRONT" => PaymentOption::NoUpfront,
            "PARTIAL_UPFRONT" => PaymentOption::PartialUpfront,
            other => PaymentOption::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PaymentOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PaymentOption::from(s))
    }
}
impl PaymentOption {
    pub fn as_str(&self) -> &str {
        match self {
            PaymentOption::AllUpfront => "ALL_UPFRONT",
            PaymentOption::HeavyUtilization => "HEAVY_UTILIZATION",
            PaymentOption::LightUtilization => "LIGHT_UTILIZATION",
            PaymentOption::MediumUtilization => "MEDIUM_UTILIZATION",
            PaymentOption::NoUpfront => "NO_UPFRONT",
            PaymentOption::PartialUpfront => "PARTIAL_UPFRONT",
            PaymentOption::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ALL_UPFRONT",
            "HEAVY_UTILIZATION",
            "LIGHT_UTILIZATION",
            "MEDIUM_UTILIZATION",
            "NO_UPFRONT",
            "PARTIAL_UPFRONT",
        ]
    }
}
impl AsRef<str> for PaymentOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TermInYears {
    OneYear,
    ThreeYears,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TermInYears {
    fn from(s: &str) -> Self {
        match s {
            "ONE_YEAR" => TermInYears::OneYear,
            "THREE_YEARS" => TermInYears::ThreeYears,
            other => TermInYears::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TermInYears {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TermInYears::from(s))
    }
}
impl TermInYears {
    pub fn as_str(&self) -> &str {
        match self {
            TermInYears::OneYear => "ONE_YEAR",
            TermInYears::ThreeYears => "THREE_YEARS",
            TermInYears::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ONE_YEAR", "THREE_YEARS"]
    }
}
impl AsRef<str> for TermInYears {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SupportedSavingsPlansType {
    ComputeSp,
    Ec2InstanceSp,
    SagemakerSp,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SupportedSavingsPlansType {
    fn from(s: &str) -> Self {
        match s {
            "COMPUTE_SP" => SupportedSavingsPlansType::ComputeSp,
            "EC2_INSTANCE_SP" => SupportedSavingsPlansType::Ec2InstanceSp,
            "SAGEMAKER_SP" => SupportedSavingsPlansType::SagemakerSp,
            other => SupportedSavingsPlansType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SupportedSavingsPlansType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SupportedSavingsPlansType::from(s))
    }
}
impl SupportedSavingsPlansType {
    pub fn as_str(&self) -> &str {
        match self {
            SupportedSavingsPlansType::ComputeSp => "COMPUTE_SP",
            SupportedSavingsPlansType::Ec2InstanceSp => "EC2_INSTANCE_SP",
            SupportedSavingsPlansType::SagemakerSp => "SAGEMAKER_SP",
            SupportedSavingsPlansType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COMPUTE_SP", "EC2_INSTANCE_SP", "SAGEMAKER_SP"]
    }
}
impl AsRef<str> for SupportedSavingsPlansType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccountScope {
    Linked,
    Payer,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AccountScope {
    fn from(s: &str) -> Self {
        match s {
            "LINKED" => AccountScope::Linked,
            "PAYER" => AccountScope::Payer,
            other => AccountScope::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AccountScope {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccountScope::from(s))
    }
}
impl AccountScope {
    pub fn as_str(&self) -> &str {
        match self {
            AccountScope::Linked => "LINKED",
            AccountScope::Payer => "PAYER",
            AccountScope::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LINKED", "PAYER"]
    }
}
impl AsRef<str> for AccountScope {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Metadata about your Savings Plans Purchase Recommendations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansPurchaseRecommendationMetadata {
    /// <p>The unique identifier for the recommendation set.</p>
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p>The timestamp showing when the recommendations were generated.</p>
    pub generation_timestamp: std::option::Option<std::string::String>,
    /// <p>Additional metadata that may be applicable to the recommendation.</p>
    pub additional_metadata: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansPurchaseRecommendationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansPurchaseRecommendationMetadata");
        formatter.field("recommendation_id", &self.recommendation_id);
        formatter.field("generation_timestamp", &self.generation_timestamp);
        formatter.field("additional_metadata", &self.additional_metadata);
        formatter.finish()
    }
}
/// See [`SavingsPlansPurchaseRecommendationMetadata`](crate::model::SavingsPlansPurchaseRecommendationMetadata)
pub mod savings_plans_purchase_recommendation_metadata {
    /// A builder for [`SavingsPlansPurchaseRecommendationMetadata`](crate::model::SavingsPlansPurchaseRecommendationMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) generation_timestamp: std::option::Option<std::string::String>,
        pub(crate) additional_metadata: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the recommendation set.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p>The timestamp showing when the recommendations were generated.</p>
        pub fn generation_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.generation_timestamp = Some(input.into());
            self
        }
        pub fn set_generation_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generation_timestamp = input;
            self
        }
        /// <p>Additional metadata that may be applicable to the recommendation.</p>
        pub fn additional_metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_metadata = Some(input.into());
            self
        }
        pub fn set_additional_metadata(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansPurchaseRecommendationMetadata`](crate::model::SavingsPlansPurchaseRecommendationMetadata)
        pub fn build(self) -> crate::model::SavingsPlansPurchaseRecommendationMetadata {
            crate::model::SavingsPlansPurchaseRecommendationMetadata {
                recommendation_id: self.recommendation_id,
                generation_timestamp: self.generation_timestamp,
                additional_metadata: self.additional_metadata,
            }
        }
    }
}
impl SavingsPlansPurchaseRecommendationMetadata {
    /// Creates a new builder-style object to manufacture [`SavingsPlansPurchaseRecommendationMetadata`](crate::model::SavingsPlansPurchaseRecommendationMetadata)
    pub fn builder() -> crate::model::savings_plans_purchase_recommendation_metadata::Builder {
        crate::model::savings_plans_purchase_recommendation_metadata::Builder::default()
    }
}

/// <p>The amount of Savings Plans eligible usage that is covered by Savings Plans. All calculations consider the On-Demand equivalent of your Savings Plans usage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansCoverage {
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The amount of Savings Plans eligible usage that the Savings Plans covered.</p>
    pub coverage: std::option::Option<crate::model::SavingsPlansCoverageData>,
    /// <p>The time period of the request.
    /// </p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
}
impl std::fmt::Debug for SavingsPlansCoverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansCoverage");
        formatter.field("attributes", &self.attributes);
        formatter.field("coverage", &self.coverage);
        formatter.field("time_period", &self.time_period);
        formatter.finish()
    }
}
/// See [`SavingsPlansCoverage`](crate::model::SavingsPlansCoverage)
pub mod savings_plans_coverage {
    /// A builder for [`SavingsPlansCoverage`](crate::model::SavingsPlansCoverage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) coverage: std::option::Option<crate::model::SavingsPlansCoverageData>,
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
    }
    impl Builder {
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The amount of Savings Plans eligible usage that the Savings Plans covered.</p>
        pub fn coverage(mut self, input: crate::model::SavingsPlansCoverageData) -> Self {
            self.coverage = Some(input);
            self
        }
        pub fn set_coverage(
            mut self,
            input: std::option::Option<crate::model::SavingsPlansCoverageData>,
        ) -> Self {
            self.coverage = input;
            self
        }
        /// <p>The time period of the request.
        /// </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansCoverage`](crate::model::SavingsPlansCoverage)
        pub fn build(self) -> crate::model::SavingsPlansCoverage {
            crate::model::SavingsPlansCoverage {
                attributes: self.attributes,
                coverage: self.coverage,
                time_period: self.time_period,
            }
        }
    }
}
impl SavingsPlansCoverage {
    /// Creates a new builder-style object to manufacture [`SavingsPlansCoverage`](crate::model::SavingsPlansCoverage)
    pub fn builder() -> crate::model::savings_plans_coverage::Builder {
        crate::model::savings_plans_coverage::Builder::default()
    }
}

/// <p>Specific coverage percentage, On-Demand costs, and spend covered by Savings Plans, and total Savings Plans costs for an account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SavingsPlansCoverageData {
    /// <p>The amount of your AWS usage that is covered by a Savings Plans.</p>
    pub spend_covered_by_savings_plans: std::option::Option<std::string::String>,
    /// <p>The cost of your AWS usage at the public On-Demand rate.</p>
    pub on_demand_cost: std::option::Option<std::string::String>,
    /// <p>The total cost of your AWS usage, regardless of your purchase option.</p>
    pub total_cost: std::option::Option<std::string::String>,
    /// <p>The percentage of your existing Savings Plans covered usage, divided by all of your
    /// eligible Savings Plans usage in an account(or set of accounts).</p>
    pub coverage_percentage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SavingsPlansCoverageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SavingsPlansCoverageData");
        formatter.field(
            "spend_covered_by_savings_plans",
            &self.spend_covered_by_savings_plans,
        );
        formatter.field("on_demand_cost", &self.on_demand_cost);
        formatter.field("total_cost", &self.total_cost);
        formatter.field("coverage_percentage", &self.coverage_percentage);
        formatter.finish()
    }
}
/// See [`SavingsPlansCoverageData`](crate::model::SavingsPlansCoverageData)
pub mod savings_plans_coverage_data {
    /// A builder for [`SavingsPlansCoverageData`](crate::model::SavingsPlansCoverageData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) spend_covered_by_savings_plans: std::option::Option<std::string::String>,
        pub(crate) on_demand_cost: std::option::Option<std::string::String>,
        pub(crate) total_cost: std::option::Option<std::string::String>,
        pub(crate) coverage_percentage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The amount of your AWS usage that is covered by a Savings Plans.</p>
        pub fn spend_covered_by_savings_plans(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.spend_covered_by_savings_plans = Some(input.into());
            self
        }
        pub fn set_spend_covered_by_savings_plans(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spend_covered_by_savings_plans = input;
            self
        }
        /// <p>The cost of your AWS usage at the public On-Demand rate.</p>
        pub fn on_demand_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_cost = Some(input.into());
            self
        }
        pub fn set_on_demand_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_cost = input;
            self
        }
        /// <p>The total cost of your AWS usage, regardless of your purchase option.</p>
        pub fn total_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_cost = Some(input.into());
            self
        }
        pub fn set_total_cost(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.total_cost = input;
            self
        }
        /// <p>The percentage of your existing Savings Plans covered usage, divided by all of your
        /// eligible Savings Plans usage in an account(or set of accounts).</p>
        pub fn coverage_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.coverage_percentage = Some(input.into());
            self
        }
        pub fn set_coverage_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.coverage_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`SavingsPlansCoverageData`](crate::model::SavingsPlansCoverageData)
        pub fn build(self) -> crate::model::SavingsPlansCoverageData {
            crate::model::SavingsPlansCoverageData {
                spend_covered_by_savings_plans: self.spend_covered_by_savings_plans,
                on_demand_cost: self.on_demand_cost,
                total_cost: self.total_cost,
                coverage_percentage: self.coverage_percentage,
            }
        }
    }
}
impl SavingsPlansCoverageData {
    /// Creates a new builder-style object to manufacture [`SavingsPlansCoverageData`](crate::model::SavingsPlansCoverageData)
    pub fn builder() -> crate::model::savings_plans_coverage_data::Builder {
        crate::model::savings_plans_coverage_data::Builder::default()
    }
}

/// <p>Represents a group when you specify a group by criteria or in the response to a
/// query with a specific grouping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GroupDefinition {
    /// <p>The string that represents the type of group.</p>
    pub r#type: std::option::Option<crate::model::GroupDefinitionType>,
    /// <p>The string that represents a key for a specified group.</p>
    pub key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GroupDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GroupDefinition");
        formatter.field("r#type", &self.r#type);
        formatter.field("key", &self.key);
        formatter.finish()
    }
}
/// See [`GroupDefinition`](crate::model::GroupDefinition)
pub mod group_definition {
    /// A builder for [`GroupDefinition`](crate::model::GroupDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::GroupDefinitionType>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The string that represents the type of group.</p>
        pub fn r#type(mut self, input: crate::model::GroupDefinitionType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::GroupDefinitionType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The string that represents a key for a specified group.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupDefinition`](crate::model::GroupDefinition)
        pub fn build(self) -> crate::model::GroupDefinition {
            crate::model::GroupDefinition {
                r#type: self.r#type,
                key: self.key,
            }
        }
    }
}
impl GroupDefinition {
    /// Creates a new builder-style object to manufacture [`GroupDefinition`](crate::model::GroupDefinition)
    pub fn builder() -> crate::model::group_definition::Builder {
        crate::model::group_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GroupDefinitionType {
    CostCategory,
    Dimension,
    Tag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for GroupDefinitionType {
    fn from(s: &str) -> Self {
        match s {
            "COST_CATEGORY" => GroupDefinitionType::CostCategory,
            "DIMENSION" => GroupDefinitionType::Dimension,
            "TAG" => GroupDefinitionType::Tag,
            other => GroupDefinitionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for GroupDefinitionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(GroupDefinitionType::from(s))
    }
}
impl GroupDefinitionType {
    pub fn as_str(&self) -> &str {
        match self {
            GroupDefinitionType::CostCategory => "COST_CATEGORY",
            GroupDefinitionType::Dimension => "DIMENSION",
            GroupDefinitionType::Tag => "TAG",
            GroupDefinitionType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COST_CATEGORY", "DIMENSION", "TAG"]
    }
}
impl AsRef<str> for GroupDefinitionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Enables you to customize recommendations across two attributes. You can choose to view
/// recommendations for instances within the same instance families or across different instance
/// families. You can also choose to view your estimated savings associated with recommendations
/// with consideration of existing Savings Plans or RI benefits, or
/// neither. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RightsizingRecommendationConfiguration {
    /// <p>
    /// The option to see recommendations within the same instance family, or recommendations for instances across other families. The default value is <code>SAME_INSTANCE_FAMILY</code>.
    /// </p>
    pub recommendation_target: std::option::Option<crate::model::RecommendationTarget>,
    /// <p>
    /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is <code>TRUE</code>.
    /// </p>
    pub benefits_considered: bool,
}
impl std::fmt::Debug for RightsizingRecommendationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RightsizingRecommendationConfiguration");
        formatter.field("recommendation_target", &self.recommendation_target);
        formatter.field("benefits_considered", &self.benefits_considered);
        formatter.finish()
    }
}
/// See [`RightsizingRecommendationConfiguration`](crate::model::RightsizingRecommendationConfiguration)
pub mod rightsizing_recommendation_configuration {
    /// A builder for [`RightsizingRecommendationConfiguration`](crate::model::RightsizingRecommendationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_target: std::option::Option<crate::model::RecommendationTarget>,
        pub(crate) benefits_considered: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>
        /// The option to see recommendations within the same instance family, or recommendations for instances across other families. The default value is <code>SAME_INSTANCE_FAMILY</code>.
        /// </p>
        pub fn recommendation_target(mut self, input: crate::model::RecommendationTarget) -> Self {
            self.recommendation_target = Some(input);
            self
        }
        pub fn set_recommendation_target(
            mut self,
            input: std::option::Option<crate::model::RecommendationTarget>,
        ) -> Self {
            self.recommendation_target = input;
            self
        }
        /// <p>
        /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is <code>TRUE</code>.
        /// </p>
        pub fn benefits_considered(mut self, input: bool) -> Self {
            self.benefits_considered = Some(input);
            self
        }
        pub fn set_benefits_considered(mut self, input: std::option::Option<bool>) -> Self {
            self.benefits_considered = input;
            self
        }
        /// Consumes the builder and constructs a [`RightsizingRecommendationConfiguration`](crate::model::RightsizingRecommendationConfiguration)
        pub fn build(self) -> crate::model::RightsizingRecommendationConfiguration {
            crate::model::RightsizingRecommendationConfiguration {
                recommendation_target: self.recommendation_target,
                benefits_considered: self.benefits_considered.unwrap_or_default(),
            }
        }
    }
}
impl RightsizingRecommendationConfiguration {
    /// Creates a new builder-style object to manufacture [`RightsizingRecommendationConfiguration`](crate::model::RightsizingRecommendationConfiguration)
    pub fn builder() -> crate::model::rightsizing_recommendation_configuration::Builder {
        crate::model::rightsizing_recommendation_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecommendationTarget {
    CrossInstanceFamily,
    SameInstanceFamily,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecommendationTarget {
    fn from(s: &str) -> Self {
        match s {
            "CROSS_INSTANCE_FAMILY" => RecommendationTarget::CrossInstanceFamily,
            "SAME_INSTANCE_FAMILY" => RecommendationTarget::SameInstanceFamily,
            other => RecommendationTarget::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecommendationTarget {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecommendationTarget::from(s))
    }
}
impl RecommendationTarget {
    pub fn as_str(&self) -> &str {
        match self {
            RecommendationTarget::CrossInstanceFamily => "CROSS_INSTANCE_FAMILY",
            RecommendationTarget::SameInstanceFamily => "SAME_INSTANCE_FAMILY",
            RecommendationTarget::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CROSS_INSTANCE_FAMILY", "SAME_INSTANCE_FAMILY"]
    }
}
impl AsRef<str> for RecommendationTarget {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Recommendations to rightsize resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RightsizingRecommendation {
    /// <p>The account that this recommendation is for.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p> Context regarding the current instance.</p>
    pub current_instance: std::option::Option<crate::model::CurrentInstance>,
    /// <p>Recommendation to either terminate or modify the resource.</p>
    pub rightsizing_type: std::option::Option<crate::model::RightsizingType>,
    /// <p> Details for modification recommendations.  </p>
    pub modify_recommendation_detail: std::option::Option<crate::model::ModifyRecommendationDetail>,
    /// <p>Details for termination recommendations.</p>
    pub terminate_recommendation_detail:
        std::option::Option<crate::model::TerminateRecommendationDetail>,
    /// <p>
    /// The list of possible reasons why the recommendation is generated such as under or over utilization of specific metrics (for example, CPU, Memory, Network).
    /// </p>
    pub finding_reason_codes: std::option::Option<std::vec::Vec<crate::model::FindingReasonCode>>,
}
impl std::fmt::Debug for RightsizingRecommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RightsizingRecommendation");
        formatter.field("account_id", &self.account_id);
        formatter.field("current_instance", &self.current_instance);
        formatter.field("rightsizing_type", &self.rightsizing_type);
        formatter.field(
            "modify_recommendation_detail",
            &self.modify_recommendation_detail,
        );
        formatter.field(
            "terminate_recommendation_detail",
            &self.terminate_recommendation_detail,
        );
        formatter.field("finding_reason_codes", &self.finding_reason_codes);
        formatter.finish()
    }
}
/// See [`RightsizingRecommendation`](crate::model::RightsizingRecommendation)
pub mod rightsizing_recommendation {
    /// A builder for [`RightsizingRecommendation`](crate::model::RightsizingRecommendation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) current_instance: std::option::Option<crate::model::CurrentInstance>,
        pub(crate) rightsizing_type: std::option::Option<crate::model::RightsizingType>,
        pub(crate) modify_recommendation_detail:
            std::option::Option<crate::model::ModifyRecommendationDetail>,
        pub(crate) terminate_recommendation_detail:
            std::option::Option<crate::model::TerminateRecommendationDetail>,
        pub(crate) finding_reason_codes:
            std::option::Option<std::vec::Vec<crate::model::FindingReasonCode>>,
    }
    impl Builder {
        /// <p>The account that this recommendation is for.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p> Context regarding the current instance.</p>
        pub fn current_instance(mut self, input: crate::model::CurrentInstance) -> Self {
            self.current_instance = Some(input);
            self
        }
        pub fn set_current_instance(
            mut self,
            input: std::option::Option<crate::model::CurrentInstance>,
        ) -> Self {
            self.current_instance = input;
            self
        }
        /// <p>Recommendation to either terminate or modify the resource.</p>
        pub fn rightsizing_type(mut self, input: crate::model::RightsizingType) -> Self {
            self.rightsizing_type = Some(input);
            self
        }
        pub fn set_rightsizing_type(
            mut self,
            input: std::option::Option<crate::model::RightsizingType>,
        ) -> Self {
            self.rightsizing_type = input;
            self
        }
        /// <p> Details for modification recommendations.  </p>
        pub fn modify_recommendation_detail(
            mut self,
            input: crate::model::ModifyRecommendationDetail,
        ) -> Self {
            self.modify_recommendation_detail = Some(input);
            self
        }
        pub fn set_modify_recommendation_detail(
            mut self,
            input: std::option::Option<crate::model::ModifyRecommendationDetail>,
        ) -> Self {
            self.modify_recommendation_detail = input;
            self
        }
        /// <p>Details for termination recommendations.</p>
        pub fn terminate_recommendation_detail(
            mut self,
            input: crate::model::TerminateRecommendationDetail,
        ) -> Self {
            self.terminate_recommendation_detail = Some(input);
            self
        }
        pub fn set_terminate_recommendation_detail(
            mut self,
            input: std::option::Option<crate::model::TerminateRecommendationDetail>,
        ) -> Self {
            self.terminate_recommendation_detail = input;
            self
        }
        pub fn finding_reason_codes(
            mut self,
            input: impl Into<crate::model::FindingReasonCode>,
        ) -> Self {
            let mut v = self.finding_reason_codes.unwrap_or_default();
            v.push(input.into());
            self.finding_reason_codes = Some(v);
            self
        }
        pub fn set_finding_reason_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FindingReasonCode>>,
        ) -> Self {
            self.finding_reason_codes = input;
            self
        }
        /// Consumes the builder and constructs a [`RightsizingRecommendation`](crate::model::RightsizingRecommendation)
        pub fn build(self) -> crate::model::RightsizingRecommendation {
            crate::model::RightsizingRecommendation {
                account_id: self.account_id,
                current_instance: self.current_instance,
                rightsizing_type: self.rightsizing_type,
                modify_recommendation_detail: self.modify_recommendation_detail,
                terminate_recommendation_detail: self.terminate_recommendation_detail,
                finding_reason_codes: self.finding_reason_codes,
            }
        }
    }
}
impl RightsizingRecommendation {
    /// Creates a new builder-style object to manufacture [`RightsizingRecommendation`](crate::model::RightsizingRecommendation)
    pub fn builder() -> crate::model::rightsizing_recommendation::Builder {
        crate::model::rightsizing_recommendation::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FindingReasonCode {
    CpuOverProvisioned,
    CpuUnderProvisioned,
    DiskIopsOverProvisioned,
    DiskIopsUnderProvisioned,
    DiskThroughputOverProvisioned,
    DiskThroughputUnderProvisioned,
    EbsIopsOverProvisioned,
    EbsIopsUnderProvisioned,
    EbsThroughputOverProvisioned,
    EbsThroughputUnderProvisioned,
    MemoryOverProvisioned,
    MemoryUnderProvisioned,
    NetworkBandwidthOverProvisioned,
    NetworkBandwidthUnderProvisioned,
    NetworkPpsOverProvisioned,
    NetworkPpsUnderProvisioned,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FindingReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "CPU_OVER_PROVISIONED" => FindingReasonCode::CpuOverProvisioned,
            "CPU_UNDER_PROVISIONED" => FindingReasonCode::CpuUnderProvisioned,
            "DISK_IOPS_OVER_PROVISIONED" => FindingReasonCode::DiskIopsOverProvisioned,
            "DISK_IOPS_UNDER_PROVISIONED" => FindingReasonCode::DiskIopsUnderProvisioned,
            "DISK_THROUGHPUT_OVER_PROVISIONED" => FindingReasonCode::DiskThroughputOverProvisioned,
            "DISK_THROUGHPUT_UNDER_PROVISIONED" => {
                FindingReasonCode::DiskThroughputUnderProvisioned
            }
            "EBS_IOPS_OVER_PROVISIONED" => FindingReasonCode::EbsIopsOverProvisioned,
            "EBS_IOPS_UNDER_PROVISIONED" => FindingReasonCode::EbsIopsUnderProvisioned,
            "EBS_THROUGHPUT_OVER_PROVISIONED" => FindingReasonCode::EbsThroughputOverProvisioned,
            "EBS_THROUGHPUT_UNDER_PROVISIONED" => FindingReasonCode::EbsThroughputUnderProvisioned,
            "MEMORY_OVER_PROVISIONED" => FindingReasonCode::MemoryOverProvisioned,
            "MEMORY_UNDER_PROVISIONED" => FindingReasonCode::MemoryUnderProvisioned,
            "NETWORK_BANDWIDTH_OVER_PROVISIONED" => {
                FindingReasonCode::NetworkBandwidthOverProvisioned
            }
            "NETWORK_BANDWIDTH_UNDER_PROVISIONED" => {
                FindingReasonCode::NetworkBandwidthUnderProvisioned
            }
            "NETWORK_PPS_OVER_PROVISIONED" => FindingReasonCode::NetworkPpsOverProvisioned,
            "NETWORK_PPS_UNDER_PROVISIONED" => FindingReasonCode::NetworkPpsUnderProvisioned,
            other => FindingReasonCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FindingReasonCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FindingReasonCode::from(s))
    }
}
impl FindingReasonCode {
    pub fn as_str(&self) -> &str {
        match self {
            FindingReasonCode::CpuOverProvisioned => "CPU_OVER_PROVISIONED",
            FindingReasonCode::CpuUnderProvisioned => "CPU_UNDER_PROVISIONED",
            FindingReasonCode::DiskIopsOverProvisioned => "DISK_IOPS_OVER_PROVISIONED",
            FindingReasonCode::DiskIopsUnderProvisioned => "DISK_IOPS_UNDER_PROVISIONED",
            FindingReasonCode::DiskThroughputOverProvisioned => "DISK_THROUGHPUT_OVER_PROVISIONED",
            FindingReasonCode::DiskThroughputUnderProvisioned => {
                "DISK_THROUGHPUT_UNDER_PROVISIONED"
            }
            FindingReasonCode::EbsIopsOverProvisioned => "EBS_IOPS_OVER_PROVISIONED",
            FindingReasonCode::EbsIopsUnderProvisioned => "EBS_IOPS_UNDER_PROVISIONED",
            FindingReasonCode::EbsThroughputOverProvisioned => "EBS_THROUGHPUT_OVER_PROVISIONED",
            FindingReasonCode::EbsThroughputUnderProvisioned => "EBS_THROUGHPUT_UNDER_PROVISIONED",
            FindingReasonCode::MemoryOverProvisioned => "MEMORY_OVER_PROVISIONED",
            FindingReasonCode::MemoryUnderProvisioned => "MEMORY_UNDER_PROVISIONED",
            FindingReasonCode::NetworkBandwidthOverProvisioned => {
                "NETWORK_BANDWIDTH_OVER_PROVISIONED"
            }
            FindingReasonCode::NetworkBandwidthUnderProvisioned => {
                "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
            }
            FindingReasonCode::NetworkPpsOverProvisioned => "NETWORK_PPS_OVER_PROVISIONED",
            FindingReasonCode::NetworkPpsUnderProvisioned => "NETWORK_PPS_UNDER_PROVISIONED",
            FindingReasonCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CPU_OVER_PROVISIONED",
            "CPU_UNDER_PROVISIONED",
            "DISK_IOPS_OVER_PROVISIONED",
            "DISK_IOPS_UNDER_PROVISIONED",
            "DISK_THROUGHPUT_OVER_PROVISIONED",
            "DISK_THROUGHPUT_UNDER_PROVISIONED",
            "EBS_IOPS_OVER_PROVISIONED",
            "EBS_IOPS_UNDER_PROVISIONED",
            "EBS_THROUGHPUT_OVER_PROVISIONED",
            "EBS_THROUGHPUT_UNDER_PROVISIONED",
            "MEMORY_OVER_PROVISIONED",
            "MEMORY_UNDER_PROVISIONED",
            "NETWORK_BANDWIDTH_OVER_PROVISIONED",
            "NETWORK_BANDWIDTH_UNDER_PROVISIONED",
            "NETWORK_PPS_OVER_PROVISIONED",
            "NETWORK_PPS_UNDER_PROVISIONED",
        ]
    }
}
impl AsRef<str> for FindingReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Details on termination recommendation.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TerminateRecommendationDetail {
    /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
    pub estimated_monthly_savings: std::option::Option<std::string::String>,
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    pub currency_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TerminateRecommendationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TerminateRecommendationDetail");
        formatter.field("estimated_monthly_savings", &self.estimated_monthly_savings);
        formatter.field("currency_code", &self.currency_code);
        formatter.finish()
    }
}
/// See [`TerminateRecommendationDetail`](crate::model::TerminateRecommendationDetail)
pub mod terminate_recommendation_detail {
    /// A builder for [`TerminateRecommendationDetail`](crate::model::TerminateRecommendationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) estimated_monthly_savings: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
        pub fn estimated_monthly_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_monthly_savings = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings = input;
            self
        }
        /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// Consumes the builder and constructs a [`TerminateRecommendationDetail`](crate::model::TerminateRecommendationDetail)
        pub fn build(self) -> crate::model::TerminateRecommendationDetail {
            crate::model::TerminateRecommendationDetail {
                estimated_monthly_savings: self.estimated_monthly_savings,
                currency_code: self.currency_code,
            }
        }
    }
}
impl TerminateRecommendationDetail {
    /// Creates a new builder-style object to manufacture [`TerminateRecommendationDetail`](crate::model::TerminateRecommendationDetail)
    pub fn builder() -> crate::model::terminate_recommendation_detail::Builder {
        crate::model::terminate_recommendation_detail::Builder::default()
    }
}

/// <p> Details on the modification recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModifyRecommendationDetail {
    /// <p>Identifies whether this instance type is the AWS default recommendation.</p>
    pub target_instances: std::option::Option<std::vec::Vec<crate::model::TargetInstance>>,
}
impl std::fmt::Debug for ModifyRecommendationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModifyRecommendationDetail");
        formatter.field("target_instances", &self.target_instances);
        formatter.finish()
    }
}
/// See [`ModifyRecommendationDetail`](crate::model::ModifyRecommendationDetail)
pub mod modify_recommendation_detail {
    /// A builder for [`ModifyRecommendationDetail`](crate::model::ModifyRecommendationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_instances:
            std::option::Option<std::vec::Vec<crate::model::TargetInstance>>,
    }
    impl Builder {
        pub fn target_instances(mut self, input: impl Into<crate::model::TargetInstance>) -> Self {
            let mut v = self.target_instances.unwrap_or_default();
            v.push(input.into());
            self.target_instances = Some(v);
            self
        }
        pub fn set_target_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetInstance>>,
        ) -> Self {
            self.target_instances = input;
            self
        }
        /// Consumes the builder and constructs a [`ModifyRecommendationDetail`](crate::model::ModifyRecommendationDetail)
        pub fn build(self) -> crate::model::ModifyRecommendationDetail {
            crate::model::ModifyRecommendationDetail {
                target_instances: self.target_instances,
            }
        }
    }
}
impl ModifyRecommendationDetail {
    /// Creates a new builder-style object to manufacture [`ModifyRecommendationDetail`](crate::model::ModifyRecommendationDetail)
    pub fn builder() -> crate::model::modify_recommendation_detail::Builder {
        crate::model::modify_recommendation_detail::Builder::default()
    }
}

/// <p> Details on recommended instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetInstance {
    /// <p> Expected cost to operate this instance type on a monthly basis.</p>
    pub estimated_monthly_cost: std::option::Option<std::string::String>,
    /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
    pub estimated_monthly_savings: std::option::Option<std::string::String>,
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p> Indicates whether this recommendation is the defaulted AWS recommendation.</p>
    pub default_target_instance: bool,
    /// <p> Details on the target instance type.  </p>
    pub resource_details: std::option::Option<crate::model::ResourceDetails>,
    /// <p> Expected utilization metrics for target instance type.</p>
    pub expected_resource_utilization: std::option::Option<crate::model::ResourceUtilization>,
    /// <p>
    /// Explains the actions you might need to take in order to successfully migrate your workloads from the current instance type to the recommended instance type.
    /// </p>
    pub platform_differences: std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>,
}
impl std::fmt::Debug for TargetInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetInstance");
        formatter.field("estimated_monthly_cost", &self.estimated_monthly_cost);
        formatter.field("estimated_monthly_savings", &self.estimated_monthly_savings);
        formatter.field("currency_code", &self.currency_code);
        formatter.field("default_target_instance", &self.default_target_instance);
        formatter.field("resource_details", &self.resource_details);
        formatter.field(
            "expected_resource_utilization",
            &self.expected_resource_utilization,
        );
        formatter.field("platform_differences", &self.platform_differences);
        formatter.finish()
    }
}
/// See [`TargetInstance`](crate::model::TargetInstance)
pub mod target_instance {
    /// A builder for [`TargetInstance`](crate::model::TargetInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) estimated_monthly_cost: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_savings: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) default_target_instance: std::option::Option<bool>,
        pub(crate) resource_details: std::option::Option<crate::model::ResourceDetails>,
        pub(crate) expected_resource_utilization:
            std::option::Option<crate::model::ResourceUtilization>,
        pub(crate) platform_differences:
            std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>,
    }
    impl Builder {
        /// <p> Expected cost to operate this instance type on a monthly basis.</p>
        pub fn estimated_monthly_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_monthly_cost = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_cost = input;
            self
        }
        /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
        pub fn estimated_monthly_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.estimated_monthly_savings = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings = input;
            self
        }
        /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p> Indicates whether this recommendation is the defaulted AWS recommendation.</p>
        pub fn default_target_instance(mut self, input: bool) -> Self {
            self.default_target_instance = Some(input);
            self
        }
        pub fn set_default_target_instance(mut self, input: std::option::Option<bool>) -> Self {
            self.default_target_instance = input;
            self
        }
        /// <p> Details on the target instance type.  </p>
        pub fn resource_details(mut self, input: crate::model::ResourceDetails) -> Self {
            self.resource_details = Some(input);
            self
        }
        pub fn set_resource_details(
            mut self,
            input: std::option::Option<crate::model::ResourceDetails>,
        ) -> Self {
            self.resource_details = input;
            self
        }
        /// <p> Expected utilization metrics for target instance type.</p>
        pub fn expected_resource_utilization(
            mut self,
            input: crate::model::ResourceUtilization,
        ) -> Self {
            self.expected_resource_utilization = Some(input);
            self
        }
        pub fn set_expected_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::ResourceUtilization>,
        ) -> Self {
            self.expected_resource_utilization = input;
            self
        }
        pub fn platform_differences(
            mut self,
            input: impl Into<crate::model::PlatformDifference>,
        ) -> Self {
            let mut v = self.platform_differences.unwrap_or_default();
            v.push(input.into());
            self.platform_differences = Some(v);
            self
        }
        pub fn set_platform_differences(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlatformDifference>>,
        ) -> Self {
            self.platform_differences = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetInstance`](crate::model::TargetInstance)
        pub fn build(self) -> crate::model::TargetInstance {
            crate::model::TargetInstance {
                estimated_monthly_cost: self.estimated_monthly_cost,
                estimated_monthly_savings: self.estimated_monthly_savings,
                currency_code: self.currency_code,
                default_target_instance: self.default_target_instance.unwrap_or_default(),
                resource_details: self.resource_details,
                expected_resource_utilization: self.expected_resource_utilization,
                platform_differences: self.platform_differences,
            }
        }
    }
}
impl TargetInstance {
    /// Creates a new builder-style object to manufacture [`TargetInstance`](crate::model::TargetInstance)
    pub fn builder() -> crate::model::target_instance::Builder {
        crate::model::target_instance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlatformDifference {
    Hypervisor,
    InstanceStoreAvailability,
    NetworkInterface,
    StorageInterface,
    VirtualizationType,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PlatformDifference {
    fn from(s: &str) -> Self {
        match s {
            "HYPERVISOR" => PlatformDifference::Hypervisor,
            "INSTANCE_STORE_AVAILABILITY" => PlatformDifference::InstanceStoreAvailability,
            "NETWORK_INTERFACE" => PlatformDifference::NetworkInterface,
            "STORAGE_INTERFACE" => PlatformDifference::StorageInterface,
            "VIRTUALIZATION_TYPE" => PlatformDifference::VirtualizationType,
            other => PlatformDifference::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PlatformDifference {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlatformDifference::from(s))
    }
}
impl PlatformDifference {
    pub fn as_str(&self) -> &str {
        match self {
            PlatformDifference::Hypervisor => "HYPERVISOR",
            PlatformDifference::InstanceStoreAvailability => "INSTANCE_STORE_AVAILABILITY",
            PlatformDifference::NetworkInterface => "NETWORK_INTERFACE",
            PlatformDifference::StorageInterface => "STORAGE_INTERFACE",
            PlatformDifference::VirtualizationType => "VIRTUALIZATION_TYPE",
            PlatformDifference::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "HYPERVISOR",
            "INSTANCE_STORE_AVAILABILITY",
            "NETWORK_INTERFACE",
            "STORAGE_INTERFACE",
            "VIRTUALIZATION_TYPE",
        ]
    }
}
impl AsRef<str> for PlatformDifference {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Resource utilization of current resource.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceUtilization {
    /// <p>Utilization of current Amazon EC2 instance. </p>
    pub ec2_resource_utilization: std::option::Option<crate::model::Ec2ResourceUtilization>,
}
impl std::fmt::Debug for ResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceUtilization");
        formatter.field("ec2_resource_utilization", &self.ec2_resource_utilization);
        formatter.finish()
    }
}
/// See [`ResourceUtilization`](crate::model::ResourceUtilization)
pub mod resource_utilization {
    /// A builder for [`ResourceUtilization`](crate::model::ResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ec2_resource_utilization:
            std::option::Option<crate::model::Ec2ResourceUtilization>,
    }
    impl Builder {
        /// <p>Utilization of current Amazon EC2 instance. </p>
        pub fn ec2_resource_utilization(
            mut self,
            input: crate::model::Ec2ResourceUtilization,
        ) -> Self {
            self.ec2_resource_utilization = Some(input);
            self
        }
        pub fn set_ec2_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::Ec2ResourceUtilization>,
        ) -> Self {
            self.ec2_resource_utilization = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceUtilization`](crate::model::ResourceUtilization)
        pub fn build(self) -> crate::model::ResourceUtilization {
            crate::model::ResourceUtilization {
                ec2_resource_utilization: self.ec2_resource_utilization,
            }
        }
    }
}
impl ResourceUtilization {
    /// Creates a new builder-style object to manufacture [`ResourceUtilization`](crate::model::ResourceUtilization)
    pub fn builder() -> crate::model::resource_utilization::Builder {
        crate::model::resource_utilization::Builder::default()
    }
}

/// <p> Utilization metrics of the instance.  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2ResourceUtilization {
    /// <p> Maximum observed or expected CPU utilization of the instance.</p>
    pub max_cpu_utilization_percentage: std::option::Option<std::string::String>,
    /// <p> Maximum observed or expected memory utilization of the instance.</p>
    pub max_memory_utilization_percentage: std::option::Option<std::string::String>,
    /// <p> Maximum observed or expected storage utilization of the instance (does not measure EBS storage).</p>
    pub max_storage_utilization_percentage: std::option::Option<std::string::String>,
    /// <p>
    /// The EBS field that contains a list of EBS metrics associated with the current instance.
    /// </p>
    pub ebs_resource_utilization: std::option::Option<crate::model::EbsResourceUtilization>,
    /// <p>
    /// The field that contains a list of disk (local storage) metrics associated with the current instance.
    /// </p>
    pub disk_resource_utilization: std::option::Option<crate::model::DiskResourceUtilization>,
    /// <p>
    /// The network field that contains a list of network metrics associated with the current instance.
    /// </p>
    pub network_resource_utilization: std::option::Option<crate::model::NetworkResourceUtilization>,
}
impl std::fmt::Debug for Ec2ResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2ResourceUtilization");
        formatter.field(
            "max_cpu_utilization_percentage",
            &self.max_cpu_utilization_percentage,
        );
        formatter.field(
            "max_memory_utilization_percentage",
            &self.max_memory_utilization_percentage,
        );
        formatter.field(
            "max_storage_utilization_percentage",
            &self.max_storage_utilization_percentage,
        );
        formatter.field("ebs_resource_utilization", &self.ebs_resource_utilization);
        formatter.field("disk_resource_utilization", &self.disk_resource_utilization);
        formatter.field(
            "network_resource_utilization",
            &self.network_resource_utilization,
        );
        formatter.finish()
    }
}
/// See [`Ec2ResourceUtilization`](crate::model::Ec2ResourceUtilization)
pub mod ec2_resource_utilization {
    /// A builder for [`Ec2ResourceUtilization`](crate::model::Ec2ResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_cpu_utilization_percentage: std::option::Option<std::string::String>,
        pub(crate) max_memory_utilization_percentage: std::option::Option<std::string::String>,
        pub(crate) max_storage_utilization_percentage: std::option::Option<std::string::String>,
        pub(crate) ebs_resource_utilization:
            std::option::Option<crate::model::EbsResourceUtilization>,
        pub(crate) disk_resource_utilization:
            std::option::Option<crate::model::DiskResourceUtilization>,
        pub(crate) network_resource_utilization:
            std::option::Option<crate::model::NetworkResourceUtilization>,
    }
    impl Builder {
        /// <p> Maximum observed or expected CPU utilization of the instance.</p>
        pub fn max_cpu_utilization_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.max_cpu_utilization_percentage = Some(input.into());
            self
        }
        pub fn set_max_cpu_utilization_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_cpu_utilization_percentage = input;
            self
        }
        /// <p> Maximum observed or expected memory utilization of the instance.</p>
        pub fn max_memory_utilization_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.max_memory_utilization_percentage = Some(input.into());
            self
        }
        pub fn set_max_memory_utilization_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_memory_utilization_percentage = input;
            self
        }
        /// <p> Maximum observed or expected storage utilization of the instance (does not measure EBS storage).</p>
        pub fn max_storage_utilization_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.max_storage_utilization_percentage = Some(input.into());
            self
        }
        pub fn set_max_storage_utilization_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.max_storage_utilization_percentage = input;
            self
        }
        /// <p>
        /// The EBS field that contains a list of EBS metrics associated with the current instance.
        /// </p>
        pub fn ebs_resource_utilization(
            mut self,
            input: crate::model::EbsResourceUtilization,
        ) -> Self {
            self.ebs_resource_utilization = Some(input);
            self
        }
        pub fn set_ebs_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::EbsResourceUtilization>,
        ) -> Self {
            self.ebs_resource_utilization = input;
            self
        }
        /// <p>
        /// The field that contains a list of disk (local storage) metrics associated with the current instance.
        /// </p>
        pub fn disk_resource_utilization(
            mut self,
            input: crate::model::DiskResourceUtilization,
        ) -> Self {
            self.disk_resource_utilization = Some(input);
            self
        }
        pub fn set_disk_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::DiskResourceUtilization>,
        ) -> Self {
            self.disk_resource_utilization = input;
            self
        }
        /// <p>
        /// The network field that contains a list of network metrics associated with the current instance.
        /// </p>
        pub fn network_resource_utilization(
            mut self,
            input: crate::model::NetworkResourceUtilization,
        ) -> Self {
            self.network_resource_utilization = Some(input);
            self
        }
        pub fn set_network_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::NetworkResourceUtilization>,
        ) -> Self {
            self.network_resource_utilization = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2ResourceUtilization`](crate::model::Ec2ResourceUtilization)
        pub fn build(self) -> crate::model::Ec2ResourceUtilization {
            crate::model::Ec2ResourceUtilization {
                max_cpu_utilization_percentage: self.max_cpu_utilization_percentage,
                max_memory_utilization_percentage: self.max_memory_utilization_percentage,
                max_storage_utilization_percentage: self.max_storage_utilization_percentage,
                ebs_resource_utilization: self.ebs_resource_utilization,
                disk_resource_utilization: self.disk_resource_utilization,
                network_resource_utilization: self.network_resource_utilization,
            }
        }
    }
}
impl Ec2ResourceUtilization {
    /// Creates a new builder-style object to manufacture [`Ec2ResourceUtilization`](crate::model::Ec2ResourceUtilization)
    pub fn builder() -> crate::model::ec2_resource_utilization::Builder {
        crate::model::ec2_resource_utilization::Builder::default()
    }
}

/// <p>
/// The network field that contains a list of network metrics associated with the current instance.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkResourceUtilization {
    /// <p>
    /// The network ingress throughput utilization measured in Bytes per second.
    /// </p>
    pub network_in_bytes_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The network outgress throughput utilization measured in Bytes per second.
    /// </p>
    pub network_out_bytes_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The network ingress packets measured in packets per second.
    /// </p>
    pub network_packets_in_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The network outgress packets measured in packets per second.
    /// </p>
    pub network_packets_out_per_second: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NetworkResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkResourceUtilization");
        formatter.field(
            "network_in_bytes_per_second",
            &self.network_in_bytes_per_second,
        );
        formatter.field(
            "network_out_bytes_per_second",
            &self.network_out_bytes_per_second,
        );
        formatter.field(
            "network_packets_in_per_second",
            &self.network_packets_in_per_second,
        );
        formatter.field(
            "network_packets_out_per_second",
            &self.network_packets_out_per_second,
        );
        formatter.finish()
    }
}
/// See [`NetworkResourceUtilization`](crate::model::NetworkResourceUtilization)
pub mod network_resource_utilization {
    /// A builder for [`NetworkResourceUtilization`](crate::model::NetworkResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_in_bytes_per_second: std::option::Option<std::string::String>,
        pub(crate) network_out_bytes_per_second: std::option::Option<std::string::String>,
        pub(crate) network_packets_in_per_second: std::option::Option<std::string::String>,
        pub(crate) network_packets_out_per_second: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The network ingress throughput utilization measured in Bytes per second.
        /// </p>
        pub fn network_in_bytes_per_second(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_in_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_network_in_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_in_bytes_per_second = input;
            self
        }
        /// <p>
        /// The network outgress throughput utilization measured in Bytes per second.
        /// </p>
        pub fn network_out_bytes_per_second(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_out_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_network_out_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_out_bytes_per_second = input;
            self
        }
        /// <p>
        /// The network ingress packets measured in packets per second.
        /// </p>
        pub fn network_packets_in_per_second(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_packets_in_per_second = Some(input.into());
            self
        }
        pub fn set_network_packets_in_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_packets_in_per_second = input;
            self
        }
        /// <p>
        /// The network outgress packets measured in packets per second.
        /// </p>
        pub fn network_packets_out_per_second(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.network_packets_out_per_second = Some(input.into());
            self
        }
        pub fn set_network_packets_out_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_packets_out_per_second = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkResourceUtilization`](crate::model::NetworkResourceUtilization)
        pub fn build(self) -> crate::model::NetworkResourceUtilization {
            crate::model::NetworkResourceUtilization {
                network_in_bytes_per_second: self.network_in_bytes_per_second,
                network_out_bytes_per_second: self.network_out_bytes_per_second,
                network_packets_in_per_second: self.network_packets_in_per_second,
                network_packets_out_per_second: self.network_packets_out_per_second,
            }
        }
    }
}
impl NetworkResourceUtilization {
    /// Creates a new builder-style object to manufacture [`NetworkResourceUtilization`](crate::model::NetworkResourceUtilization)
    pub fn builder() -> crate::model::network_resource_utilization::Builder {
        crate::model::network_resource_utilization::Builder::default()
    }
}

/// <p>
/// The field that contains a list of disk (local storage) metrics associated with the current instance.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DiskResourceUtilization {
    /// <p>
    /// The maximum number of read operations per second.
    /// </p>
    pub disk_read_ops_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum number of write operations per second.
    /// </p>
    pub disk_write_ops_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum read throughput operations per second.
    /// </p>
    pub disk_read_bytes_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum write throughput operations per second.
    /// </p>
    pub disk_write_bytes_per_second: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DiskResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DiskResourceUtilization");
        formatter.field("disk_read_ops_per_second", &self.disk_read_ops_per_second);
        formatter.field("disk_write_ops_per_second", &self.disk_write_ops_per_second);
        formatter.field(
            "disk_read_bytes_per_second",
            &self.disk_read_bytes_per_second,
        );
        formatter.field(
            "disk_write_bytes_per_second",
            &self.disk_write_bytes_per_second,
        );
        formatter.finish()
    }
}
/// See [`DiskResourceUtilization`](crate::model::DiskResourceUtilization)
pub mod disk_resource_utilization {
    /// A builder for [`DiskResourceUtilization`](crate::model::DiskResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disk_read_ops_per_second: std::option::Option<std::string::String>,
        pub(crate) disk_write_ops_per_second: std::option::Option<std::string::String>,
        pub(crate) disk_read_bytes_per_second: std::option::Option<std::string::String>,
        pub(crate) disk_write_bytes_per_second: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The maximum number of read operations per second.
        /// </p>
        pub fn disk_read_ops_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_read_ops_per_second = Some(input.into());
            self
        }
        pub fn set_disk_read_ops_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_read_ops_per_second = input;
            self
        }
        /// <p>
        /// The maximum number of write operations per second.
        /// </p>
        pub fn disk_write_ops_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_write_ops_per_second = Some(input.into());
            self
        }
        pub fn set_disk_write_ops_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_write_ops_per_second = input;
            self
        }
        /// <p>
        /// The maximum read throughput operations per second.
        /// </p>
        pub fn disk_read_bytes_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk_read_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_disk_read_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_read_bytes_per_second = input;
            self
        }
        /// <p>
        /// The maximum write throughput operations per second.
        /// </p>
        pub fn disk_write_bytes_per_second(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.disk_write_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_disk_write_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.disk_write_bytes_per_second = input;
            self
        }
        /// Consumes the builder and constructs a [`DiskResourceUtilization`](crate::model::DiskResourceUtilization)
        pub fn build(self) -> crate::model::DiskResourceUtilization {
            crate::model::DiskResourceUtilization {
                disk_read_ops_per_second: self.disk_read_ops_per_second,
                disk_write_ops_per_second: self.disk_write_ops_per_second,
                disk_read_bytes_per_second: self.disk_read_bytes_per_second,
                disk_write_bytes_per_second: self.disk_write_bytes_per_second,
            }
        }
    }
}
impl DiskResourceUtilization {
    /// Creates a new builder-style object to manufacture [`DiskResourceUtilization`](crate::model::DiskResourceUtilization)
    pub fn builder() -> crate::model::disk_resource_utilization::Builder {
        crate::model::disk_resource_utilization::Builder::default()
    }
}

/// <p>
/// The EBS field that contains a list of EBS metrics associated with the current instance.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EbsResourceUtilization {
    /// <p>
    /// The maximum number of read operations per second.
    /// </p>
    pub ebs_read_ops_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum number of write operations per second.
    /// </p>
    pub ebs_write_ops_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum size of read operations per second
    /// </p>
    pub ebs_read_bytes_per_second: std::option::Option<std::string::String>,
    /// <p>
    /// The maximum size of write operations per second.
    /// </p>
    pub ebs_write_bytes_per_second: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EbsResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EbsResourceUtilization");
        formatter.field("ebs_read_ops_per_second", &self.ebs_read_ops_per_second);
        formatter.field("ebs_write_ops_per_second", &self.ebs_write_ops_per_second);
        formatter.field("ebs_read_bytes_per_second", &self.ebs_read_bytes_per_second);
        formatter.field(
            "ebs_write_bytes_per_second",
            &self.ebs_write_bytes_per_second,
        );
        formatter.finish()
    }
}
/// See [`EbsResourceUtilization`](crate::model::EbsResourceUtilization)
pub mod ebs_resource_utilization {
    /// A builder for [`EbsResourceUtilization`](crate::model::EbsResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ebs_read_ops_per_second: std::option::Option<std::string::String>,
        pub(crate) ebs_write_ops_per_second: std::option::Option<std::string::String>,
        pub(crate) ebs_read_bytes_per_second: std::option::Option<std::string::String>,
        pub(crate) ebs_write_bytes_per_second: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The maximum number of read operations per second.
        /// </p>
        pub fn ebs_read_ops_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_read_ops_per_second = Some(input.into());
            self
        }
        pub fn set_ebs_read_ops_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_read_ops_per_second = input;
            self
        }
        /// <p>
        /// The maximum number of write operations per second.
        /// </p>
        pub fn ebs_write_ops_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_write_ops_per_second = Some(input.into());
            self
        }
        pub fn set_ebs_write_ops_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_write_ops_per_second = input;
            self
        }
        /// <p>
        /// The maximum size of read operations per second
        /// </p>
        pub fn ebs_read_bytes_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_read_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_ebs_read_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_read_bytes_per_second = input;
            self
        }
        /// <p>
        /// The maximum size of write operations per second.
        /// </p>
        pub fn ebs_write_bytes_per_second(mut self, input: impl Into<std::string::String>) -> Self {
            self.ebs_write_bytes_per_second = Some(input.into());
            self
        }
        pub fn set_ebs_write_bytes_per_second(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ebs_write_bytes_per_second = input;
            self
        }
        /// Consumes the builder and constructs a [`EbsResourceUtilization`](crate::model::EbsResourceUtilization)
        pub fn build(self) -> crate::model::EbsResourceUtilization {
            crate::model::EbsResourceUtilization {
                ebs_read_ops_per_second: self.ebs_read_ops_per_second,
                ebs_write_ops_per_second: self.ebs_write_ops_per_second,
                ebs_read_bytes_per_second: self.ebs_read_bytes_per_second,
                ebs_write_bytes_per_second: self.ebs_write_bytes_per_second,
            }
        }
    }
}
impl EbsResourceUtilization {
    /// Creates a new builder-style object to manufacture [`EbsResourceUtilization`](crate::model::EbsResourceUtilization)
    pub fn builder() -> crate::model::ebs_resource_utilization::Builder {
        crate::model::ebs_resource_utilization::Builder::default()
    }
}

/// <p>Details on the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceDetails {
    /// <p>Details on the Amazon EC2 resource.</p>
    pub ec2_resource_details: std::option::Option<crate::model::Ec2ResourceDetails>,
}
impl std::fmt::Debug for ResourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceDetails");
        formatter.field("ec2_resource_details", &self.ec2_resource_details);
        formatter.finish()
    }
}
/// See [`ResourceDetails`](crate::model::ResourceDetails)
pub mod resource_details {
    /// A builder for [`ResourceDetails`](crate::model::ResourceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ec2_resource_details: std::option::Option<crate::model::Ec2ResourceDetails>,
    }
    impl Builder {
        /// <p>Details on the Amazon EC2 resource.</p>
        pub fn ec2_resource_details(mut self, input: crate::model::Ec2ResourceDetails) -> Self {
            self.ec2_resource_details = Some(input);
            self
        }
        pub fn set_ec2_resource_details(
            mut self,
            input: std::option::Option<crate::model::Ec2ResourceDetails>,
        ) -> Self {
            self.ec2_resource_details = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDetails`](crate::model::ResourceDetails)
        pub fn build(self) -> crate::model::ResourceDetails {
            crate::model::ResourceDetails {
                ec2_resource_details: self.ec2_resource_details,
            }
        }
    }
}
impl ResourceDetails {
    /// Creates a new builder-style object to manufacture [`ResourceDetails`](crate::model::ResourceDetails)
    pub fn builder() -> crate::model::resource_details::Builder {
        crate::model::resource_details::Builder::default()
    }
}

/// <p> Details on the Amazon EC2 Resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2ResourceDetails {
    /// <p> Hourly public On-Demand rate for the instance type.</p>
    pub hourly_on_demand_rate: std::option::Option<std::string::String>,
    /// <p> The type of AWS instance.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p> The platform of the AWS instance. The platform is the specific combination of
    /// operating system, license model, and software on an instance.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p> The AWS Region of the instance.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p> The SKU of the product.</p>
    pub sku: std::option::Option<std::string::String>,
    /// <p> Memory capacity of the AWS instance.</p>
    pub memory: std::option::Option<std::string::String>,
    /// <p> Network performance capacity of the AWS instance.</p>
    pub network_performance: std::option::Option<std::string::String>,
    /// <p> The disk storage of the AWS instance (not EBS storage).</p>
    pub storage: std::option::Option<std::string::String>,
    /// <p> Number of VCPU cores in the AWS instance type.</p>
    pub vcpu: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Ec2ResourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2ResourceDetails");
        formatter.field("hourly_on_demand_rate", &self.hourly_on_demand_rate);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("platform", &self.platform);
        formatter.field("region", &self.region);
        formatter.field("sku", &self.sku);
        formatter.field("memory", &self.memory);
        formatter.field("network_performance", &self.network_performance);
        formatter.field("storage", &self.storage);
        formatter.field("vcpu", &self.vcpu);
        formatter.finish()
    }
}
/// See [`Ec2ResourceDetails`](crate::model::Ec2ResourceDetails)
pub mod ec2_resource_details {
    /// A builder for [`Ec2ResourceDetails`](crate::model::Ec2ResourceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) hourly_on_demand_rate: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) sku: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) network_performance: std::option::Option<std::string::String>,
        pub(crate) storage: std::option::Option<std::string::String>,
        pub(crate) vcpu: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Hourly public On-Demand rate for the instance type.</p>
        pub fn hourly_on_demand_rate(mut self, input: impl Into<std::string::String>) -> Self {
            self.hourly_on_demand_rate = Some(input.into());
            self
        }
        pub fn set_hourly_on_demand_rate(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hourly_on_demand_rate = input;
            self
        }
        /// <p> The type of AWS instance.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p> The platform of the AWS instance. The platform is the specific combination of
        /// operating system, license model, and software on an instance.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p> The AWS Region of the instance.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p> The SKU of the product.</p>
        pub fn sku(mut self, input: impl Into<std::string::String>) -> Self {
            self.sku = Some(input.into());
            self
        }
        pub fn set_sku(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sku = input;
            self
        }
        /// <p> Memory capacity of the AWS instance.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p> Network performance capacity of the AWS instance.</p>
        pub fn network_performance(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_performance = Some(input.into());
            self
        }
        pub fn set_network_performance(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_performance = input;
            self
        }
        /// <p> The disk storage of the AWS instance (not EBS storage).</p>
        pub fn storage(mut self, input: impl Into<std::string::String>) -> Self {
            self.storage = Some(input.into());
            self
        }
        pub fn set_storage(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.storage = input;
            self
        }
        /// <p> Number of VCPU cores in the AWS instance type.</p>
        pub fn vcpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.vcpu = Some(input.into());
            self
        }
        pub fn set_vcpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vcpu = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2ResourceDetails`](crate::model::Ec2ResourceDetails)
        pub fn build(self) -> crate::model::Ec2ResourceDetails {
            crate::model::Ec2ResourceDetails {
                hourly_on_demand_rate: self.hourly_on_demand_rate,
                instance_type: self.instance_type,
                platform: self.platform,
                region: self.region,
                sku: self.sku,
                memory: self.memory,
                network_performance: self.network_performance,
                storage: self.storage,
                vcpu: self.vcpu,
            }
        }
    }
}
impl Ec2ResourceDetails {
    /// Creates a new builder-style object to manufacture [`Ec2ResourceDetails`](crate::model::Ec2ResourceDetails)
    pub fn builder() -> crate::model::ec2_resource_details::Builder {
        crate::model::ec2_resource_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RightsizingType {
    Modify,
    Terminate,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RightsizingType {
    fn from(s: &str) -> Self {
        match s {
            "MODIFY" => RightsizingType::Modify,
            "TERMINATE" => RightsizingType::Terminate,
            other => RightsizingType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RightsizingType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RightsizingType::from(s))
    }
}
impl RightsizingType {
    pub fn as_str(&self) -> &str {
        match self {
            RightsizingType::Modify => "MODIFY",
            RightsizingType::Terminate => "TERMINATE",
            RightsizingType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["MODIFY", "TERMINATE"]
    }
}
impl AsRef<str> for RightsizingType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Context about the current instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CurrentInstance {
    /// <p>Resource ID of the current instance.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The name you've given an instance. This field will show as blank if you haven't given the instance a name.</p>
    pub instance_name: std::option::Option<std::string::String>,
    /// <p>Cost allocation resource tags applied to the instance.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::TagValues>>,
    /// <p> Details about the resource and utilization.</p>
    pub resource_details: std::option::Option<crate::model::ResourceDetails>,
    /// <p> Utilization information of the current instance during the lookback period.</p>
    pub resource_utilization: std::option::Option<crate::model::ResourceUtilization>,
    /// <p> Number of hours during the lookback period covered by reservations.</p>
    pub reservation_covered_hours_in_lookback_period: std::option::Option<std::string::String>,
    /// <p>Number of hours during the lookback period covered by Savings Plans.</p>
    pub savings_plans_covered_hours_in_lookback_period: std::option::Option<std::string::String>,
    /// <p> Number of hours during the lookback period billed at On-Demand rates.</p>
    pub on_demand_hours_in_lookback_period: std::option::Option<std::string::String>,
    /// <p> The total number of hours the instance ran during the lookback period.</p>
    pub total_running_hours_in_lookback_period: std::option::Option<std::string::String>,
    /// <p> Current On-Demand cost of operating this instance on a monthly basis.</p>
    pub monthly_cost: std::option::Option<std::string::String>,
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    pub currency_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CurrentInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CurrentInstance");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("instance_name", &self.instance_name);
        formatter.field("tags", &self.tags);
        formatter.field("resource_details", &self.resource_details);
        formatter.field("resource_utilization", &self.resource_utilization);
        formatter.field(
            "reservation_covered_hours_in_lookback_period",
            &self.reservation_covered_hours_in_lookback_period,
        );
        formatter.field(
            "savings_plans_covered_hours_in_lookback_period",
            &self.savings_plans_covered_hours_in_lookback_period,
        );
        formatter.field(
            "on_demand_hours_in_lookback_period",
            &self.on_demand_hours_in_lookback_period,
        );
        formatter.field(
            "total_running_hours_in_lookback_period",
            &self.total_running_hours_in_lookback_period,
        );
        formatter.field("monthly_cost", &self.monthly_cost);
        formatter.field("currency_code", &self.currency_code);
        formatter.finish()
    }
}
/// See [`CurrentInstance`](crate::model::CurrentInstance)
pub mod current_instance {
    /// A builder for [`CurrentInstance`](crate::model::CurrentInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) instance_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::TagValues>>,
        pub(crate) resource_details: std::option::Option<crate::model::ResourceDetails>,
        pub(crate) resource_utilization: std::option::Option<crate::model::ResourceUtilization>,
        pub(crate) reservation_covered_hours_in_lookback_period:
            std::option::Option<std::string::String>,
        pub(crate) savings_plans_covered_hours_in_lookback_period:
            std::option::Option<std::string::String>,
        pub(crate) on_demand_hours_in_lookback_period: std::option::Option<std::string::String>,
        pub(crate) total_running_hours_in_lookback_period: std::option::Option<std::string::String>,
        pub(crate) monthly_cost: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Resource ID of the current instance.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The name you've given an instance. This field will show as blank if you haven't given the instance a name.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_name = Some(input.into());
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_name = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::TagValues>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagValues>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p> Details about the resource and utilization.</p>
        pub fn resource_details(mut self, input: crate::model::ResourceDetails) -> Self {
            self.resource_details = Some(input);
            self
        }
        pub fn set_resource_details(
            mut self,
            input: std::option::Option<crate::model::ResourceDetails>,
        ) -> Self {
            self.resource_details = input;
            self
        }
        /// <p> Utilization information of the current instance during the lookback period.</p>
        pub fn resource_utilization(mut self, input: crate::model::ResourceUtilization) -> Self {
            self.resource_utilization = Some(input);
            self
        }
        pub fn set_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::ResourceUtilization>,
        ) -> Self {
            self.resource_utilization = input;
            self
        }
        /// <p> Number of hours during the lookback period covered by reservations.</p>
        pub fn reservation_covered_hours_in_lookback_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.reservation_covered_hours_in_lookback_period = Some(input.into());
            self
        }
        pub fn set_reservation_covered_hours_in_lookback_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reservation_covered_hours_in_lookback_period = input;
            self
        }
        /// <p>Number of hours during the lookback period covered by Savings Plans.</p>
        pub fn savings_plans_covered_hours_in_lookback_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.savings_plans_covered_hours_in_lookback_period = Some(input.into());
            self
        }
        pub fn set_savings_plans_covered_hours_in_lookback_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.savings_plans_covered_hours_in_lookback_period = input;
            self
        }
        /// <p> Number of hours during the lookback period billed at On-Demand rates.</p>
        pub fn on_demand_hours_in_lookback_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.on_demand_hours_in_lookback_period = Some(input.into());
            self
        }
        pub fn set_on_demand_hours_in_lookback_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_hours_in_lookback_period = input;
            self
        }
        /// <p> The total number of hours the instance ran during the lookback period.</p>
        pub fn total_running_hours_in_lookback_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.total_running_hours_in_lookback_period = Some(input.into());
            self
        }
        pub fn set_total_running_hours_in_lookback_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_running_hours_in_lookback_period = input;
            self
        }
        /// <p> Current On-Demand cost of operating this instance on a monthly basis.</p>
        pub fn monthly_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.monthly_cost = Some(input.into());
            self
        }
        pub fn set_monthly_cost(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monthly_cost = input;
            self
        }
        /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// Consumes the builder and constructs a [`CurrentInstance`](crate::model::CurrentInstance)
        pub fn build(self) -> crate::model::CurrentInstance {
            crate::model::CurrentInstance {
                resource_id: self.resource_id,
                instance_name: self.instance_name,
                tags: self.tags,
                resource_details: self.resource_details,
                resource_utilization: self.resource_utilization,
                reservation_covered_hours_in_lookback_period: self
                    .reservation_covered_hours_in_lookback_period,
                savings_plans_covered_hours_in_lookback_period: self
                    .savings_plans_covered_hours_in_lookback_period,
                on_demand_hours_in_lookback_period: self.on_demand_hours_in_lookback_period,
                total_running_hours_in_lookback_period: self.total_running_hours_in_lookback_period,
                monthly_cost: self.monthly_cost,
                currency_code: self.currency_code,
            }
        }
    }
}
impl CurrentInstance {
    /// Creates a new builder-style object to manufacture [`CurrentInstance`](crate::model::CurrentInstance)
    pub fn builder() -> crate::model::current_instance::Builder {
        crate::model::current_instance::Builder::default()
    }
}

/// <p> Summary of rightsizing recommendations  </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RightsizingRecommendationSummary {
    /// <p> Total number of instance recommendations.</p>
    pub total_recommendation_count: std::option::Option<std::string::String>,
    /// <p> Estimated total savings resulting from modifications, on a monthly basis.</p>
    pub estimated_total_monthly_savings_amount: std::option::Option<std::string::String>,
    /// <p> The currency code that AWS used to calculate the savings.</p>
    pub savings_currency_code: std::option::Option<std::string::String>,
    /// <p> Savings percentage based on the recommended modifications, relative to the total
    /// On-Demand
    /// costs associated with these instances.</p>
    pub savings_percentage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RightsizingRecommendationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RightsizingRecommendationSummary");
        formatter.field(
            "total_recommendation_count",
            &self.total_recommendation_count,
        );
        formatter.field(
            "estimated_total_monthly_savings_amount",
            &self.estimated_total_monthly_savings_amount,
        );
        formatter.field("savings_currency_code", &self.savings_currency_code);
        formatter.field("savings_percentage", &self.savings_percentage);
        formatter.finish()
    }
}
/// See [`RightsizingRecommendationSummary`](crate::model::RightsizingRecommendationSummary)
pub mod rightsizing_recommendation_summary {
    /// A builder for [`RightsizingRecommendationSummary`](crate::model::RightsizingRecommendationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_recommendation_count: std::option::Option<std::string::String>,
        pub(crate) estimated_total_monthly_savings_amount: std::option::Option<std::string::String>,
        pub(crate) savings_currency_code: std::option::Option<std::string::String>,
        pub(crate) savings_percentage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Total number of instance recommendations.</p>
        pub fn total_recommendation_count(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_recommendation_count = Some(input.into());
            self
        }
        pub fn set_total_recommendation_count(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_recommendation_count = input;
            self
        }
        /// <p> Estimated total savings resulting from modifications, on a monthly basis.</p>
        pub fn estimated_total_monthly_savings_amount(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_total_monthly_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_total_monthly_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_total_monthly_savings_amount = input;
            self
        }
        /// <p> The currency code that AWS used to calculate the savings.</p>
        pub fn savings_currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.savings_currency_code = Some(input.into());
            self
        }
        pub fn set_savings_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.savings_currency_code = input;
            self
        }
        /// <p> Savings percentage based on the recommended modifications, relative to the total
        /// On-Demand
        /// costs associated with these instances.</p>
        pub fn savings_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.savings_percentage = Some(input.into());
            self
        }
        pub fn set_savings_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.savings_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`RightsizingRecommendationSummary`](crate::model::RightsizingRecommendationSummary)
        pub fn build(self) -> crate::model::RightsizingRecommendationSummary {
            crate::model::RightsizingRecommendationSummary {
                total_recommendation_count: self.total_recommendation_count,
                estimated_total_monthly_savings_amount: self.estimated_total_monthly_savings_amount,
                savings_currency_code: self.savings_currency_code,
                savings_percentage: self.savings_percentage,
            }
        }
    }
}
impl RightsizingRecommendationSummary {
    /// Creates a new builder-style object to manufacture [`RightsizingRecommendationSummary`](crate::model::RightsizingRecommendationSummary)
    pub fn builder() -> crate::model::rightsizing_recommendation_summary::Builder {
        crate::model::rightsizing_recommendation_summary::Builder::default()
    }
}

/// <p>Metadata for this recommendation set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RightsizingRecommendationMetadata {
    /// <p> The ID for this specific recommendation.</p>
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p> The timestamp for when AWS made this recommendation.</p>
    pub generation_timestamp: std::option::Option<std::string::String>,
    /// <p> How many days of previous usage that AWS considers when making this
    /// recommendation.</p>
    pub lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
    /// <p>Additional metadata that may be applicable to the recommendation.</p>
    pub additional_metadata: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RightsizingRecommendationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RightsizingRecommendationMetadata");
        formatter.field("recommendation_id", &self.recommendation_id);
        formatter.field("generation_timestamp", &self.generation_timestamp);
        formatter.field("lookback_period_in_days", &self.lookback_period_in_days);
        formatter.field("additional_metadata", &self.additional_metadata);
        formatter.finish()
    }
}
/// See [`RightsizingRecommendationMetadata`](crate::model::RightsizingRecommendationMetadata)
pub mod rightsizing_recommendation_metadata {
    /// A builder for [`RightsizingRecommendationMetadata`](crate::model::RightsizingRecommendationMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) generation_timestamp: std::option::Option<std::string::String>,
        pub(crate) lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
        pub(crate) additional_metadata: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID for this specific recommendation.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p> The timestamp for when AWS made this recommendation.</p>
        pub fn generation_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.generation_timestamp = Some(input.into());
            self
        }
        pub fn set_generation_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generation_timestamp = input;
            self
        }
        /// <p> How many days of previous usage that AWS considers when making this
        /// recommendation.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.lookback_period_in_days = input;
            self
        }
        /// <p>Additional metadata that may be applicable to the recommendation.</p>
        pub fn additional_metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.additional_metadata = Some(input.into());
            self
        }
        pub fn set_additional_metadata(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.additional_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`RightsizingRecommendationMetadata`](crate::model::RightsizingRecommendationMetadata)
        pub fn build(self) -> crate::model::RightsizingRecommendationMetadata {
            crate::model::RightsizingRecommendationMetadata {
                recommendation_id: self.recommendation_id,
                generation_timestamp: self.generation_timestamp,
                lookback_period_in_days: self.lookback_period_in_days,
                additional_metadata: self.additional_metadata,
            }
        }
    }
}
impl RightsizingRecommendationMetadata {
    /// Creates a new builder-style object to manufacture [`RightsizingRecommendationMetadata`](crate::model::RightsizingRecommendationMetadata)
    pub fn builder() -> crate::model::rightsizing_recommendation_metadata::Builder {
        crate::model::rightsizing_recommendation_metadata::Builder::default()
    }
}

/// <p>The aggregated numbers for your reservation usage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationAggregates {
    /// <p>The percentage of reservation time that you used.</p>
    pub utilization_percentage: std::option::Option<std::string::String>,
    /// <p>The percentage of Amazon EC2 reservation time that you used, converted to normalized
    /// units. Normalized units are available only for Amazon EC2 usage after November 11,
    /// 2017.</p>
    pub utilization_percentage_in_units: std::option::Option<std::string::String>,
    /// <p>How many reservation hours that you purchased.</p>
    pub purchased_hours: std::option::Option<std::string::String>,
    /// <p>How many Amazon EC2 reservation hours that you purchased, converted to normalized units.
    /// Normalized units are available only for Amazon EC2 usage after November 11, 2017.</p>
    pub purchased_units: std::option::Option<std::string::String>,
    /// <p>The total number of reservation hours that you used.</p>
    pub total_actual_hours: std::option::Option<std::string::String>,
    /// <p>The total number of Amazon EC2 reservation hours that you used, converted to normalized
    /// units. Normalized units are available only for Amazon EC2 usage after November 11,
    /// 2017.</p>
    pub total_actual_units: std::option::Option<std::string::String>,
    /// <p>The number of reservation hours that you didn't use.</p>
    pub unused_hours: std::option::Option<std::string::String>,
    /// <p>The number of Amazon EC2 reservation hours that you didn't use, converted to normalized
    /// units. Normalized units are available only for Amazon EC2 usage after November 11,
    /// 2017.</p>
    pub unused_units: std::option::Option<std::string::String>,
    /// <p>How much your reservation would cost if charged On-Demand rates.</p>
    pub on_demand_cost_of_ri_hours_used: std::option::Option<std::string::String>,
    /// <p>How much you saved due to purchasing and utilizing reservation. AWS calculates this
    /// by subtracting <code>TotalAmortizedFee</code> from
    /// <code>OnDemandCostOfRIHoursUsed</code>.</p>
    pub net_ri_savings: std::option::Option<std::string::String>,
    /// <p>How much you could save if you use your entire reservation.</p>
    pub total_potential_ri_savings: std::option::Option<std::string::String>,
    /// <p>The upfront cost of your reservation, amortized over the reservation
    /// period.</p>
    pub amortized_upfront_fee: std::option::Option<std::string::String>,
    /// <p>The monthly cost of your reservation, amortized over the reservation
    /// period.</p>
    pub amortized_recurring_fee: std::option::Option<std::string::String>,
    /// <p>The total cost of your reservation, amortized over the reservation
    /// period.</p>
    pub total_amortized_fee: std::option::Option<std::string::String>,
    /// <p>The cost of unused hours for your reservation.</p>
    pub ri_cost_for_unused_hours: std::option::Option<std::string::String>,
    /// <p>The realized savings due to purchasing and using a reservation.</p>
    pub realized_savings: std::option::Option<std::string::String>,
    /// <p>The unrealized savings due to purchasing and using a reservation.</p>
    pub unrealized_savings: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservationAggregates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationAggregates");
        formatter.field("utilization_percentage", &self.utilization_percentage);
        formatter.field(
            "utilization_percentage_in_units",
            &self.utilization_percentage_in_units,
        );
        formatter.field("purchased_hours", &self.purchased_hours);
        formatter.field("purchased_units", &self.purchased_units);
        formatter.field("total_actual_hours", &self.total_actual_hours);
        formatter.field("total_actual_units", &self.total_actual_units);
        formatter.field("unused_hours", &self.unused_hours);
        formatter.field("unused_units", &self.unused_units);
        formatter.field(
            "on_demand_cost_of_ri_hours_used",
            &self.on_demand_cost_of_ri_hours_used,
        );
        formatter.field("net_ri_savings", &self.net_ri_savings);
        formatter.field(
            "total_potential_ri_savings",
            &self.total_potential_ri_savings,
        );
        formatter.field("amortized_upfront_fee", &self.amortized_upfront_fee);
        formatter.field("amortized_recurring_fee", &self.amortized_recurring_fee);
        formatter.field("total_amortized_fee", &self.total_amortized_fee);
        formatter.field("ri_cost_for_unused_hours", &self.ri_cost_for_unused_hours);
        formatter.field("realized_savings", &self.realized_savings);
        formatter.field("unrealized_savings", &self.unrealized_savings);
        formatter.finish()
    }
}
/// See [`ReservationAggregates`](crate::model::ReservationAggregates)
pub mod reservation_aggregates {
    /// A builder for [`ReservationAggregates`](crate::model::ReservationAggregates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) utilization_percentage: std::option::Option<std::string::String>,
        pub(crate) utilization_percentage_in_units: std::option::Option<std::string::String>,
        pub(crate) purchased_hours: std::option::Option<std::string::String>,
        pub(crate) purchased_units: std::option::Option<std::string::String>,
        pub(crate) total_actual_hours: std::option::Option<std::string::String>,
        pub(crate) total_actual_units: std::option::Option<std::string::String>,
        pub(crate) unused_hours: std::option::Option<std::string::String>,
        pub(crate) unused_units: std::option::Option<std::string::String>,
        pub(crate) on_demand_cost_of_ri_hours_used: std::option::Option<std::string::String>,
        pub(crate) net_ri_savings: std::option::Option<std::string::String>,
        pub(crate) total_potential_ri_savings: std::option::Option<std::string::String>,
        pub(crate) amortized_upfront_fee: std::option::Option<std::string::String>,
        pub(crate) amortized_recurring_fee: std::option::Option<std::string::String>,
        pub(crate) total_amortized_fee: std::option::Option<std::string::String>,
        pub(crate) ri_cost_for_unused_hours: std::option::Option<std::string::String>,
        pub(crate) realized_savings: std::option::Option<std::string::String>,
        pub(crate) unrealized_savings: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The percentage of reservation time that you used.</p>
        pub fn utilization_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.utilization_percentage = Some(input.into());
            self
        }
        pub fn set_utilization_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.utilization_percentage = input;
            self
        }
        /// <p>The percentage of Amazon EC2 reservation time that you used, converted to normalized
        /// units. Normalized units are available only for Amazon EC2 usage after November 11,
        /// 2017.</p>
        pub fn utilization_percentage_in_units(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.utilization_percentage_in_units = Some(input.into());
            self
        }
        pub fn set_utilization_percentage_in_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.utilization_percentage_in_units = input;
            self
        }
        /// <p>How many reservation hours that you purchased.</p>
        pub fn purchased_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.purchased_hours = Some(input.into());
            self
        }
        pub fn set_purchased_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.purchased_hours = input;
            self
        }
        /// <p>How many Amazon EC2 reservation hours that you purchased, converted to normalized units.
        /// Normalized units are available only for Amazon EC2 usage after November 11, 2017.</p>
        pub fn purchased_units(mut self, input: impl Into<std::string::String>) -> Self {
            self.purchased_units = Some(input.into());
            self
        }
        pub fn set_purchased_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.purchased_units = input;
            self
        }
        /// <p>The total number of reservation hours that you used.</p>
        pub fn total_actual_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_actual_hours = Some(input.into());
            self
        }
        pub fn set_total_actual_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_actual_hours = input;
            self
        }
        /// <p>The total number of Amazon EC2 reservation hours that you used, converted to normalized
        /// units. Normalized units are available only for Amazon EC2 usage after November 11,
        /// 2017.</p>
        pub fn total_actual_units(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_actual_units = Some(input.into());
            self
        }
        pub fn set_total_actual_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_actual_units = input;
            self
        }
        /// <p>The number of reservation hours that you didn't use.</p>
        pub fn unused_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.unused_hours = Some(input.into());
            self
        }
        pub fn set_unused_hours(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unused_hours = input;
            self
        }
        /// <p>The number of Amazon EC2 reservation hours that you didn't use, converted to normalized
        /// units. Normalized units are available only for Amazon EC2 usage after November 11,
        /// 2017.</p>
        pub fn unused_units(mut self, input: impl Into<std::string::String>) -> Self {
            self.unused_units = Some(input.into());
            self
        }
        pub fn set_unused_units(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unused_units = input;
            self
        }
        /// <p>How much your reservation would cost if charged On-Demand rates.</p>
        pub fn on_demand_cost_of_ri_hours_used(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.on_demand_cost_of_ri_hours_used = Some(input.into());
            self
        }
        pub fn set_on_demand_cost_of_ri_hours_used(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_cost_of_ri_hours_used = input;
            self
        }
        /// <p>How much you saved due to purchasing and utilizing reservation. AWS calculates this
        /// by subtracting <code>TotalAmortizedFee</code> from
        /// <code>OnDemandCostOfRIHoursUsed</code>.</p>
        pub fn net_ri_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.net_ri_savings = Some(input.into());
            self
        }
        pub fn set_net_ri_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.net_ri_savings = input;
            self
        }
        /// <p>How much you could save if you use your entire reservation.</p>
        pub fn total_potential_ri_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_potential_ri_savings = Some(input.into());
            self
        }
        pub fn set_total_potential_ri_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_potential_ri_savings = input;
            self
        }
        /// <p>The upfront cost of your reservation, amortized over the reservation
        /// period.</p>
        pub fn amortized_upfront_fee(mut self, input: impl Into<std::string::String>) -> Self {
            self.amortized_upfront_fee = Some(input.into());
            self
        }
        pub fn set_amortized_upfront_fee(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.amortized_upfront_fee = input;
            self
        }
        /// <p>The monthly cost of your reservation, amortized over the reservation
        /// period.</p>
        pub fn amortized_recurring_fee(mut self, input: impl Into<std::string::String>) -> Self {
            self.amortized_recurring_fee = Some(input.into());
            self
        }
        pub fn set_amortized_recurring_fee(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.amortized_recurring_fee = input;
            self
        }
        /// <p>The total cost of your reservation, amortized over the reservation
        /// period.</p>
        pub fn total_amortized_fee(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_amortized_fee = Some(input.into());
            self
        }
        pub fn set_total_amortized_fee(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_amortized_fee = input;
            self
        }
        /// <p>The cost of unused hours for your reservation.</p>
        pub fn ri_cost_for_unused_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.ri_cost_for_unused_hours = Some(input.into());
            self
        }
        pub fn set_ri_cost_for_unused_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ri_cost_for_unused_hours = input;
            self
        }
        /// <p>The realized savings due to purchasing and using a reservation.</p>
        pub fn realized_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.realized_savings = Some(input.into());
            self
        }
        pub fn set_realized_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.realized_savings = input;
            self
        }
        /// <p>The unrealized savings due to purchasing and using a reservation.</p>
        pub fn unrealized_savings(mut self, input: impl Into<std::string::String>) -> Self {
            self.unrealized_savings = Some(input.into());
            self
        }
        pub fn set_unrealized_savings(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.unrealized_savings = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationAggregates`](crate::model::ReservationAggregates)
        pub fn build(self) -> crate::model::ReservationAggregates {
            crate::model::ReservationAggregates {
                utilization_percentage: self.utilization_percentage,
                utilization_percentage_in_units: self.utilization_percentage_in_units,
                purchased_hours: self.purchased_hours,
                purchased_units: self.purchased_units,
                total_actual_hours: self.total_actual_hours,
                total_actual_units: self.total_actual_units,
                unused_hours: self.unused_hours,
                unused_units: self.unused_units,
                on_demand_cost_of_ri_hours_used: self.on_demand_cost_of_ri_hours_used,
                net_ri_savings: self.net_ri_savings,
                total_potential_ri_savings: self.total_potential_ri_savings,
                amortized_upfront_fee: self.amortized_upfront_fee,
                amortized_recurring_fee: self.amortized_recurring_fee,
                total_amortized_fee: self.total_amortized_fee,
                ri_cost_for_unused_hours: self.ri_cost_for_unused_hours,
                realized_savings: self.realized_savings,
                unrealized_savings: self.unrealized_savings,
            }
        }
    }
}
impl ReservationAggregates {
    /// Creates a new builder-style object to manufacture [`ReservationAggregates`](crate::model::ReservationAggregates)
    pub fn builder() -> crate::model::reservation_aggregates::Builder {
        crate::model::reservation_aggregates::Builder::default()
    }
}

/// <p>The amount of utilization, in hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UtilizationByTime {
    /// <p>The period of time that this utilization was used for.</p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The groups that this utilization result uses.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::ReservationUtilizationGroup>>,
    /// <p>The total number of reservation hours that were used.</p>
    pub total: std::option::Option<crate::model::ReservationAggregates>,
}
impl std::fmt::Debug for UtilizationByTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UtilizationByTime");
        formatter.field("time_period", &self.time_period);
        formatter.field("groups", &self.groups);
        formatter.field("total", &self.total);
        formatter.finish()
    }
}
/// See [`UtilizationByTime`](crate::model::UtilizationByTime)
pub mod utilization_by_time {
    /// A builder for [`UtilizationByTime`](crate::model::UtilizationByTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) groups:
            std::option::Option<std::vec::Vec<crate::model::ReservationUtilizationGroup>>,
        pub(crate) total: std::option::Option<crate::model::ReservationAggregates>,
    }
    impl Builder {
        /// <p>The period of time that this utilization was used for.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        pub fn groups(
            mut self,
            input: impl Into<crate::model::ReservationUtilizationGroup>,
        ) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReservationUtilizationGroup>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The total number of reservation hours that were used.</p>
        pub fn total(mut self, input: crate::model::ReservationAggregates) -> Self {
            self.total = Some(input);
            self
        }
        pub fn set_total(
            mut self,
            input: std::option::Option<crate::model::ReservationAggregates>,
        ) -> Self {
            self.total = input;
            self
        }
        /// Consumes the builder and constructs a [`UtilizationByTime`](crate::model::UtilizationByTime)
        pub fn build(self) -> crate::model::UtilizationByTime {
            crate::model::UtilizationByTime {
                time_period: self.time_period,
                groups: self.groups,
                total: self.total,
            }
        }
    }
}
impl UtilizationByTime {
    /// Creates a new builder-style object to manufacture [`UtilizationByTime`](crate::model::UtilizationByTime)
    pub fn builder() -> crate::model::utilization_by_time::Builder {
        crate::model::utilization_by_time::Builder::default()
    }
}

/// <p>A group of reservations that share a set of attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationUtilizationGroup {
    /// <p>The key for a specific reservation attribute.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of a specific reservation attribute.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The attributes for this group of reservations.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>How much you used this group of reservations.</p>
    pub utilization: std::option::Option<crate::model::ReservationAggregates>,
}
impl std::fmt::Debug for ReservationUtilizationGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationUtilizationGroup");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.field("attributes", &self.attributes);
        formatter.field("utilization", &self.utilization);
        formatter.finish()
    }
}
/// See [`ReservationUtilizationGroup`](crate::model::ReservationUtilizationGroup)
pub mod reservation_utilization_group {
    /// A builder for [`ReservationUtilizationGroup`](crate::model::ReservationUtilizationGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) utilization: std::option::Option<crate::model::ReservationAggregates>,
    }
    impl Builder {
        /// <p>The key for a specific reservation attribute.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of a specific reservation attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>How much you used this group of reservations.</p>
        pub fn utilization(mut self, input: crate::model::ReservationAggregates) -> Self {
            self.utilization = Some(input);
            self
        }
        pub fn set_utilization(
            mut self,
            input: std::option::Option<crate::model::ReservationAggregates>,
        ) -> Self {
            self.utilization = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationUtilizationGroup`](crate::model::ReservationUtilizationGroup)
        pub fn build(self) -> crate::model::ReservationUtilizationGroup {
            crate::model::ReservationUtilizationGroup {
                key: self.key,
                value: self.value,
                attributes: self.attributes,
                utilization: self.utilization,
            }
        }
    }
}
impl ReservationUtilizationGroup {
    /// Creates a new builder-style object to manufacture [`ReservationUtilizationGroup`](crate::model::ReservationUtilizationGroup)
    pub fn builder() -> crate::model::reservation_utilization_group::Builder {
        crate::model::reservation_utilization_group::Builder::default()
    }
}

/// <p>A specific reservation that AWS recommends for purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationPurchaseRecommendation {
    /// <p>The account scope that AWS recommends that you purchase this instance for. For
    /// example, you can purchase this reservation for an entire organization in AWS
    /// Organizations.</p>
    pub account_scope: std::option::Option<crate::model::AccountScope>,
    /// <p>How many days of previous usage that AWS considers when making this
    /// recommendation.</p>
    pub lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
    /// <p>The term of the reservation that you want recommendations for, in years.</p>
    pub term_in_years: std::option::Option<crate::model::TermInYears>,
    /// <p>The payment option for the reservation. For example, <code>AllUpfront</code> or
    /// <code>NoUpfront</code>.</p>
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>Hardware specifications for the service that you want recommendations
    /// for.</p>
    pub service_specification: std::option::Option<crate::model::ServiceSpecification>,
    /// <p>Details about the recommended purchases.</p>
    pub recommendation_details:
        std::option::Option<std::vec::Vec<crate::model::ReservationPurchaseRecommendationDetail>>,
    /// <p>A summary about the recommended purchase.</p>
    pub recommendation_summary:
        std::option::Option<crate::model::ReservationPurchaseRecommendationSummary>,
}
impl std::fmt::Debug for ReservationPurchaseRecommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationPurchaseRecommendation");
        formatter.field("account_scope", &self.account_scope);
        formatter.field("lookback_period_in_days", &self.lookback_period_in_days);
        formatter.field("term_in_years", &self.term_in_years);
        formatter.field("payment_option", &self.payment_option);
        formatter.field("service_specification", &self.service_specification);
        formatter.field("recommendation_details", &self.recommendation_details);
        formatter.field("recommendation_summary", &self.recommendation_summary);
        formatter.finish()
    }
}
/// See [`ReservationPurchaseRecommendation`](crate::model::ReservationPurchaseRecommendation)
pub mod reservation_purchase_recommendation {
    /// A builder for [`ReservationPurchaseRecommendation`](crate::model::ReservationPurchaseRecommendation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_scope: std::option::Option<crate::model::AccountScope>,
        pub(crate) lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
        pub(crate) term_in_years: std::option::Option<crate::model::TermInYears>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) service_specification: std::option::Option<crate::model::ServiceSpecification>,
        pub(crate) recommendation_details: std::option::Option<
            std::vec::Vec<crate::model::ReservationPurchaseRecommendationDetail>,
        >,
        pub(crate) recommendation_summary:
            std::option::Option<crate::model::ReservationPurchaseRecommendationSummary>,
    }
    impl Builder {
        /// <p>The account scope that AWS recommends that you purchase this instance for. For
        /// example, you can purchase this reservation for an entire organization in AWS
        /// Organizations.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.account_scope = Some(input);
            self
        }
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.account_scope = input;
            self
        }
        /// <p>How many days of previous usage that AWS considers when making this
        /// recommendation.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.lookback_period_in_days = input;
            self
        }
        /// <p>The term of the reservation that you want recommendations for, in years.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.term_in_years = Some(input);
            self
        }
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.term_in_years = input;
            self
        }
        /// <p>The payment option for the reservation. For example, <code>AllUpfront</code> or
        /// <code>NoUpfront</code>.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>Hardware specifications for the service that you want recommendations
        /// for.</p>
        pub fn service_specification(mut self, input: crate::model::ServiceSpecification) -> Self {
            self.service_specification = Some(input);
            self
        }
        pub fn set_service_specification(
            mut self,
            input: std::option::Option<crate::model::ServiceSpecification>,
        ) -> Self {
            self.service_specification = input;
            self
        }
        pub fn recommendation_details(
            mut self,
            input: impl Into<crate::model::ReservationPurchaseRecommendationDetail>,
        ) -> Self {
            let mut v = self.recommendation_details.unwrap_or_default();
            v.push(input.into());
            self.recommendation_details = Some(v);
            self
        }
        pub fn set_recommendation_details(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ReservationPurchaseRecommendationDetail>,
            >,
        ) -> Self {
            self.recommendation_details = input;
            self
        }
        /// <p>A summary about the recommended purchase.</p>
        pub fn recommendation_summary(
            mut self,
            input: crate::model::ReservationPurchaseRecommendationSummary,
        ) -> Self {
            self.recommendation_summary = Some(input);
            self
        }
        pub fn set_recommendation_summary(
            mut self,
            input: std::option::Option<crate::model::ReservationPurchaseRecommendationSummary>,
        ) -> Self {
            self.recommendation_summary = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationPurchaseRecommendation`](crate::model::ReservationPurchaseRecommendation)
        pub fn build(self) -> crate::model::ReservationPurchaseRecommendation {
            crate::model::ReservationPurchaseRecommendation {
                account_scope: self.account_scope,
                lookback_period_in_days: self.lookback_period_in_days,
                term_in_years: self.term_in_years,
                payment_option: self.payment_option,
                service_specification: self.service_specification,
                recommendation_details: self.recommendation_details,
                recommendation_summary: self.recommendation_summary,
            }
        }
    }
}
impl ReservationPurchaseRecommendation {
    /// Creates a new builder-style object to manufacture [`ReservationPurchaseRecommendation`](crate::model::ReservationPurchaseRecommendation)
    pub fn builder() -> crate::model::reservation_purchase_recommendation::Builder {
        crate::model::reservation_purchase_recommendation::Builder::default()
    }
}

/// <p>A summary about this recommendation, such as the currency code, the amount that AWS
/// estimates that you could save, and the total amount of reservation to
/// purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationPurchaseRecommendationSummary {
    /// <p>The total amount that AWS estimates that this recommendation could save you in a
    /// month.</p>
    pub total_estimated_monthly_savings_amount: std::option::Option<std::string::String>,
    /// <p>The total amount that AWS estimates that this recommendation could save you in a
    /// month, as a percentage of your costs.</p>
    pub total_estimated_monthly_savings_percentage: std::option::Option<std::string::String>,
    /// <p>The currency code used for this recommendation.</p>
    pub currency_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservationPurchaseRecommendationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationPurchaseRecommendationSummary");
        formatter.field(
            "total_estimated_monthly_savings_amount",
            &self.total_estimated_monthly_savings_amount,
        );
        formatter.field(
            "total_estimated_monthly_savings_percentage",
            &self.total_estimated_monthly_savings_percentage,
        );
        formatter.field("currency_code", &self.currency_code);
        formatter.finish()
    }
}
/// See [`ReservationPurchaseRecommendationSummary`](crate::model::ReservationPurchaseRecommendationSummary)
pub mod reservation_purchase_recommendation_summary {
    /// A builder for [`ReservationPurchaseRecommendationSummary`](crate::model::ReservationPurchaseRecommendationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_estimated_monthly_savings_amount: std::option::Option<std::string::String>,
        pub(crate) total_estimated_monthly_savings_percentage:
            std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The total amount that AWS estimates that this recommendation could save you in a
        /// month.</p>
        pub fn total_estimated_monthly_savings_amount(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.total_estimated_monthly_savings_amount = Some(input.into());
            self
        }
        pub fn set_total_estimated_monthly_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_estimated_monthly_savings_amount = input;
            self
        }
        /// <p>The total amount that AWS estimates that this recommendation could save you in a
        /// month, as a percentage of your costs.</p>
        pub fn total_estimated_monthly_savings_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.total_estimated_monthly_savings_percentage = Some(input.into());
            self
        }
        pub fn set_total_estimated_monthly_savings_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_estimated_monthly_savings_percentage = input;
            self
        }
        /// <p>The currency code used for this recommendation.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationPurchaseRecommendationSummary`](crate::model::ReservationPurchaseRecommendationSummary)
        pub fn build(self) -> crate::model::ReservationPurchaseRecommendationSummary {
            crate::model::ReservationPurchaseRecommendationSummary {
                total_estimated_monthly_savings_amount: self.total_estimated_monthly_savings_amount,
                total_estimated_monthly_savings_percentage: self
                    .total_estimated_monthly_savings_percentage,
                currency_code: self.currency_code,
            }
        }
    }
}
impl ReservationPurchaseRecommendationSummary {
    /// Creates a new builder-style object to manufacture [`ReservationPurchaseRecommendationSummary`](crate::model::ReservationPurchaseRecommendationSummary)
    pub fn builder() -> crate::model::reservation_purchase_recommendation_summary::Builder {
        crate::model::reservation_purchase_recommendation_summary::Builder::default()
    }
}

/// <p>Details about your recommended reservation purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationPurchaseRecommendationDetail {
    /// <p>The account that this RI recommendation is for.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>Details about the instances that AWS recommends that you purchase.</p>
    pub instance_details: std::option::Option<crate::model::InstanceDetails>,
    /// <p>The number of instances that AWS recommends that you purchase.</p>
    pub recommended_number_of_instances_to_purchase: std::option::Option<std::string::String>,
    /// <p>The number of normalized units that AWS recommends that you purchase.</p>
    pub recommended_normalized_units_to_purchase: std::option::Option<std::string::String>,
    /// <p>The minimum number of instances that you used in an hour during the historical
    /// period. AWS uses this to calculate your recommended reservation purchases.</p>
    pub minimum_number_of_instances_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The minimum number of normalized units that you used in an hour during the
    /// historical period. AWS uses this to calculate your recommended reservation
    /// purchases.</p>
    pub minimum_normalized_units_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The maximum number of instances that you used in an hour during the historical
    /// period. AWS uses this to calculate your recommended reservation purchases.</p>
    pub maximum_number_of_instances_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The maximum number of normalized units that you used in an hour during the
    /// historical period. AWS uses this to calculate your recommended reservation
    /// purchases.</p>
    pub maximum_normalized_units_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The average number of instances that you used in an hour during the historical
    /// period. AWS uses this to calculate your recommended reservation purchases.</p>
    pub average_number_of_instances_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The average number of normalized units that you used in an hour during the
    /// historical period. AWS uses this to calculate your recommended reservation
    /// purchases.</p>
    pub average_normalized_units_used_per_hour: std::option::Option<std::string::String>,
    /// <p>The average utilization of your instances. AWS uses this to calculate your
    /// recommended reservation purchases.</p>
    pub average_utilization: std::option::Option<std::string::String>,
    /// <p>How long AWS estimates that it takes for this instance to start saving you money,
    /// in months.</p>
    pub estimated_break_even_in_months: std::option::Option<std::string::String>,
    /// <p>The currency code that AWS used to calculate the costs for this instance.</p>
    pub currency_code: std::option::Option<std::string::String>,
    /// <p>How much AWS estimates that this specific recommendation could save you in a
    /// month.</p>
    pub estimated_monthly_savings_amount: std::option::Option<std::string::String>,
    /// <p>How much AWS estimates that this specific recommendation could save you in a month,
    /// as a percentage of your overall costs.</p>
    pub estimated_monthly_savings_percentage: std::option::Option<std::string::String>,
    /// <p>How much AWS estimates that you spend on On-Demand Instances in a month.</p>
    pub estimated_monthly_on_demand_cost: std::option::Option<std::string::String>,
    /// <p>How much AWS estimates that you would have spent for all usage during the specified
    /// historical period if you had
    /// a
    /// reservation.</p>
    pub estimated_reservation_cost_for_lookback_period: std::option::Option<std::string::String>,
    /// <p>How much purchasing this instance costs you upfront.</p>
    pub upfront_cost: std::option::Option<std::string::String>,
    /// <p>How much purchasing this instance costs you on a monthly basis.</p>
    pub recurring_standard_monthly_cost: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservationPurchaseRecommendationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationPurchaseRecommendationDetail");
        formatter.field("account_id", &self.account_id);
        formatter.field("instance_details", &self.instance_details);
        formatter.field(
            "recommended_number_of_instances_to_purchase",
            &self.recommended_number_of_instances_to_purchase,
        );
        formatter.field(
            "recommended_normalized_units_to_purchase",
            &self.recommended_normalized_units_to_purchase,
        );
        formatter.field(
            "minimum_number_of_instances_used_per_hour",
            &self.minimum_number_of_instances_used_per_hour,
        );
        formatter.field(
            "minimum_normalized_units_used_per_hour",
            &self.minimum_normalized_units_used_per_hour,
        );
        formatter.field(
            "maximum_number_of_instances_used_per_hour",
            &self.maximum_number_of_instances_used_per_hour,
        );
        formatter.field(
            "maximum_normalized_units_used_per_hour",
            &self.maximum_normalized_units_used_per_hour,
        );
        formatter.field(
            "average_number_of_instances_used_per_hour",
            &self.average_number_of_instances_used_per_hour,
        );
        formatter.field(
            "average_normalized_units_used_per_hour",
            &self.average_normalized_units_used_per_hour,
        );
        formatter.field("average_utilization", &self.average_utilization);
        formatter.field(
            "estimated_break_even_in_months",
            &self.estimated_break_even_in_months,
        );
        formatter.field("currency_code", &self.currency_code);
        formatter.field(
            "estimated_monthly_savings_amount",
            &self.estimated_monthly_savings_amount,
        );
        formatter.field(
            "estimated_monthly_savings_percentage",
            &self.estimated_monthly_savings_percentage,
        );
        formatter.field(
            "estimated_monthly_on_demand_cost",
            &self.estimated_monthly_on_demand_cost,
        );
        formatter.field(
            "estimated_reservation_cost_for_lookback_period",
            &self.estimated_reservation_cost_for_lookback_period,
        );
        formatter.field("upfront_cost", &self.upfront_cost);
        formatter.field(
            "recurring_standard_monthly_cost",
            &self.recurring_standard_monthly_cost,
        );
        formatter.finish()
    }
}
/// See [`ReservationPurchaseRecommendationDetail`](crate::model::ReservationPurchaseRecommendationDetail)
pub mod reservation_purchase_recommendation_detail {
    /// A builder for [`ReservationPurchaseRecommendationDetail`](crate::model::ReservationPurchaseRecommendationDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) instance_details: std::option::Option<crate::model::InstanceDetails>,
        pub(crate) recommended_number_of_instances_to_purchase:
            std::option::Option<std::string::String>,
        pub(crate) recommended_normalized_units_to_purchase:
            std::option::Option<std::string::String>,
        pub(crate) minimum_number_of_instances_used_per_hour:
            std::option::Option<std::string::String>,
        pub(crate) minimum_normalized_units_used_per_hour: std::option::Option<std::string::String>,
        pub(crate) maximum_number_of_instances_used_per_hour:
            std::option::Option<std::string::String>,
        pub(crate) maximum_normalized_units_used_per_hour: std::option::Option<std::string::String>,
        pub(crate) average_number_of_instances_used_per_hour:
            std::option::Option<std::string::String>,
        pub(crate) average_normalized_units_used_per_hour: std::option::Option<std::string::String>,
        pub(crate) average_utilization: std::option::Option<std::string::String>,
        pub(crate) estimated_break_even_in_months: std::option::Option<std::string::String>,
        pub(crate) currency_code: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_savings_amount: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_savings_percentage: std::option::Option<std::string::String>,
        pub(crate) estimated_monthly_on_demand_cost: std::option::Option<std::string::String>,
        pub(crate) estimated_reservation_cost_for_lookback_period:
            std::option::Option<std::string::String>,
        pub(crate) upfront_cost: std::option::Option<std::string::String>,
        pub(crate) recurring_standard_monthly_cost: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account that this RI recommendation is for.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>Details about the instances that AWS recommends that you purchase.</p>
        pub fn instance_details(mut self, input: crate::model::InstanceDetails) -> Self {
            self.instance_details = Some(input);
            self
        }
        pub fn set_instance_details(
            mut self,
            input: std::option::Option<crate::model::InstanceDetails>,
        ) -> Self {
            self.instance_details = input;
            self
        }
        /// <p>The number of instances that AWS recommends that you purchase.</p>
        pub fn recommended_number_of_instances_to_purchase(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommended_number_of_instances_to_purchase = Some(input.into());
            self
        }
        pub fn set_recommended_number_of_instances_to_purchase(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommended_number_of_instances_to_purchase = input;
            self
        }
        /// <p>The number of normalized units that AWS recommends that you purchase.</p>
        pub fn recommended_normalized_units_to_purchase(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommended_normalized_units_to_purchase = Some(input.into());
            self
        }
        pub fn set_recommended_normalized_units_to_purchase(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommended_normalized_units_to_purchase = input;
            self
        }
        /// <p>The minimum number of instances that you used in an hour during the historical
        /// period. AWS uses this to calculate your recommended reservation purchases.</p>
        pub fn minimum_number_of_instances_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.minimum_number_of_instances_used_per_hour = Some(input.into());
            self
        }
        pub fn set_minimum_number_of_instances_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.minimum_number_of_instances_used_per_hour = input;
            self
        }
        /// <p>The minimum number of normalized units that you used in an hour during the
        /// historical period. AWS uses this to calculate your recommended reservation
        /// purchases.</p>
        pub fn minimum_normalized_units_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.minimum_normalized_units_used_per_hour = Some(input.into());
            self
        }
        pub fn set_minimum_normalized_units_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.minimum_normalized_units_used_per_hour = input;
            self
        }
        /// <p>The maximum number of instances that you used in an hour during the historical
        /// period. AWS uses this to calculate your recommended reservation purchases.</p>
        pub fn maximum_number_of_instances_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.maximum_number_of_instances_used_per_hour = Some(input.into());
            self
        }
        pub fn set_maximum_number_of_instances_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maximum_number_of_instances_used_per_hour = input;
            self
        }
        /// <p>The maximum number of normalized units that you used in an hour during the
        /// historical period. AWS uses this to calculate your recommended reservation
        /// purchases.</p>
        pub fn maximum_normalized_units_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.maximum_normalized_units_used_per_hour = Some(input.into());
            self
        }
        pub fn set_maximum_normalized_units_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.maximum_normalized_units_used_per_hour = input;
            self
        }
        /// <p>The average number of instances that you used in an hour during the historical
        /// period. AWS uses this to calculate your recommended reservation purchases.</p>
        pub fn average_number_of_instances_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.average_number_of_instances_used_per_hour = Some(input.into());
            self
        }
        pub fn set_average_number_of_instances_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.average_number_of_instances_used_per_hour = input;
            self
        }
        /// <p>The average number of normalized units that you used in an hour during the
        /// historical period. AWS uses this to calculate your recommended reservation
        /// purchases.</p>
        pub fn average_normalized_units_used_per_hour(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.average_normalized_units_used_per_hour = Some(input.into());
            self
        }
        pub fn set_average_normalized_units_used_per_hour(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.average_normalized_units_used_per_hour = input;
            self
        }
        /// <p>The average utilization of your instances. AWS uses this to calculate your
        /// recommended reservation purchases.</p>
        pub fn average_utilization(mut self, input: impl Into<std::string::String>) -> Self {
            self.average_utilization = Some(input.into());
            self
        }
        pub fn set_average_utilization(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.average_utilization = input;
            self
        }
        /// <p>How long AWS estimates that it takes for this instance to start saving you money,
        /// in months.</p>
        pub fn estimated_break_even_in_months(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_break_even_in_months = Some(input.into());
            self
        }
        pub fn set_estimated_break_even_in_months(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_break_even_in_months = input;
            self
        }
        /// <p>The currency code that AWS used to calculate the costs for this instance.</p>
        pub fn currency_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.currency_code = Some(input.into());
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.currency_code = input;
            self
        }
        /// <p>How much AWS estimates that this specific recommendation could save you in a
        /// month.</p>
        pub fn estimated_monthly_savings_amount(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings_amount(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_amount = input;
            self
        }
        /// <p>How much AWS estimates that this specific recommendation could save you in a month,
        /// as a percentage of your overall costs.</p>
        pub fn estimated_monthly_savings_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_percentage = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_savings_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_savings_percentage = input;
            self
        }
        /// <p>How much AWS estimates that you spend on On-Demand Instances in a month.</p>
        pub fn estimated_monthly_on_demand_cost(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_monthly_on_demand_cost = Some(input.into());
            self
        }
        pub fn set_estimated_monthly_on_demand_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_monthly_on_demand_cost = input;
            self
        }
        /// <p>How much AWS estimates that you would have spent for all usage during the specified
        /// historical period if you had
        /// a
        /// reservation.</p>
        pub fn estimated_reservation_cost_for_lookback_period(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.estimated_reservation_cost_for_lookback_period = Some(input.into());
            self
        }
        pub fn set_estimated_reservation_cost_for_lookback_period(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.estimated_reservation_cost_for_lookback_period = input;
            self
        }
        /// <p>How much purchasing this instance costs you upfront.</p>
        pub fn upfront_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.upfront_cost = Some(input.into());
            self
        }
        pub fn set_upfront_cost(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.upfront_cost = input;
            self
        }
        /// <p>How much purchasing this instance costs you on a monthly basis.</p>
        pub fn recurring_standard_monthly_cost(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recurring_standard_monthly_cost = Some(input.into());
            self
        }
        pub fn set_recurring_standard_monthly_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recurring_standard_monthly_cost = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationPurchaseRecommendationDetail`](crate::model::ReservationPurchaseRecommendationDetail)
        pub fn build(self) -> crate::model::ReservationPurchaseRecommendationDetail {
            crate::model::ReservationPurchaseRecommendationDetail {
                account_id: self.account_id,
                instance_details: self.instance_details,
                recommended_number_of_instances_to_purchase: self
                    .recommended_number_of_instances_to_purchase,
                recommended_normalized_units_to_purchase: self
                    .recommended_normalized_units_to_purchase,
                minimum_number_of_instances_used_per_hour: self
                    .minimum_number_of_instances_used_per_hour,
                minimum_normalized_units_used_per_hour: self.minimum_normalized_units_used_per_hour,
                maximum_number_of_instances_used_per_hour: self
                    .maximum_number_of_instances_used_per_hour,
                maximum_normalized_units_used_per_hour: self.maximum_normalized_units_used_per_hour,
                average_number_of_instances_used_per_hour: self
                    .average_number_of_instances_used_per_hour,
                average_normalized_units_used_per_hour: self.average_normalized_units_used_per_hour,
                average_utilization: self.average_utilization,
                estimated_break_even_in_months: self.estimated_break_even_in_months,
                currency_code: self.currency_code,
                estimated_monthly_savings_amount: self.estimated_monthly_savings_amount,
                estimated_monthly_savings_percentage: self.estimated_monthly_savings_percentage,
                estimated_monthly_on_demand_cost: self.estimated_monthly_on_demand_cost,
                estimated_reservation_cost_for_lookback_period: self
                    .estimated_reservation_cost_for_lookback_period,
                upfront_cost: self.upfront_cost,
                recurring_standard_monthly_cost: self.recurring_standard_monthly_cost,
            }
        }
    }
}
impl ReservationPurchaseRecommendationDetail {
    /// Creates a new builder-style object to manufacture [`ReservationPurchaseRecommendationDetail`](crate::model::ReservationPurchaseRecommendationDetail)
    pub fn builder() -> crate::model::reservation_purchase_recommendation_detail::Builder {
        crate::model::reservation_purchase_recommendation_detail::Builder::default()
    }
}

/// <p>Details about the instances that AWS recommends that you purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceDetails {
    /// <p>The Amazon EC2 instances that AWS recommends that you purchase.</p>
    pub ec2_instance_details: std::option::Option<crate::model::Ec2InstanceDetails>,
    /// <p>The Amazon RDS instances that AWS recommends that you purchase.</p>
    pub rds_instance_details: std::option::Option<crate::model::RdsInstanceDetails>,
    /// <p>The Amazon Redshift instances that AWS recommends that you purchase.</p>
    pub redshift_instance_details: std::option::Option<crate::model::RedshiftInstanceDetails>,
    /// <p>The ElastiCache instances that AWS recommends that you purchase.</p>
    pub elasti_cache_instance_details:
        std::option::Option<crate::model::ElastiCacheInstanceDetails>,
    /// <p>The Amazon ES instances that AWS recommends that you purchase.</p>
    pub es_instance_details: std::option::Option<crate::model::EsInstanceDetails>,
}
impl std::fmt::Debug for InstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceDetails");
        formatter.field("ec2_instance_details", &self.ec2_instance_details);
        formatter.field("rds_instance_details", &self.rds_instance_details);
        formatter.field("redshift_instance_details", &self.redshift_instance_details);
        formatter.field(
            "elasti_cache_instance_details",
            &self.elasti_cache_instance_details,
        );
        formatter.field("es_instance_details", &self.es_instance_details);
        formatter.finish()
    }
}
/// See [`InstanceDetails`](crate::model::InstanceDetails)
pub mod instance_details {
    /// A builder for [`InstanceDetails`](crate::model::InstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ec2_instance_details: std::option::Option<crate::model::Ec2InstanceDetails>,
        pub(crate) rds_instance_details: std::option::Option<crate::model::RdsInstanceDetails>,
        pub(crate) redshift_instance_details:
            std::option::Option<crate::model::RedshiftInstanceDetails>,
        pub(crate) elasti_cache_instance_details:
            std::option::Option<crate::model::ElastiCacheInstanceDetails>,
        pub(crate) es_instance_details: std::option::Option<crate::model::EsInstanceDetails>,
    }
    impl Builder {
        /// <p>The Amazon EC2 instances that AWS recommends that you purchase.</p>
        pub fn ec2_instance_details(mut self, input: crate::model::Ec2InstanceDetails) -> Self {
            self.ec2_instance_details = Some(input);
            self
        }
        pub fn set_ec2_instance_details(
            mut self,
            input: std::option::Option<crate::model::Ec2InstanceDetails>,
        ) -> Self {
            self.ec2_instance_details = input;
            self
        }
        /// <p>The Amazon RDS instances that AWS recommends that you purchase.</p>
        pub fn rds_instance_details(mut self, input: crate::model::RdsInstanceDetails) -> Self {
            self.rds_instance_details = Some(input);
            self
        }
        pub fn set_rds_instance_details(
            mut self,
            input: std::option::Option<crate::model::RdsInstanceDetails>,
        ) -> Self {
            self.rds_instance_details = input;
            self
        }
        /// <p>The Amazon Redshift instances that AWS recommends that you purchase.</p>
        pub fn redshift_instance_details(
            mut self,
            input: crate::model::RedshiftInstanceDetails,
        ) -> Self {
            self.redshift_instance_details = Some(input);
            self
        }
        pub fn set_redshift_instance_details(
            mut self,
            input: std::option::Option<crate::model::RedshiftInstanceDetails>,
        ) -> Self {
            self.redshift_instance_details = input;
            self
        }
        /// <p>The ElastiCache instances that AWS recommends that you purchase.</p>
        pub fn elasti_cache_instance_details(
            mut self,
            input: crate::model::ElastiCacheInstanceDetails,
        ) -> Self {
            self.elasti_cache_instance_details = Some(input);
            self
        }
        pub fn set_elasti_cache_instance_details(
            mut self,
            input: std::option::Option<crate::model::ElastiCacheInstanceDetails>,
        ) -> Self {
            self.elasti_cache_instance_details = input;
            self
        }
        /// <p>The Amazon ES instances that AWS recommends that you purchase.</p>
        pub fn es_instance_details(mut self, input: crate::model::EsInstanceDetails) -> Self {
            self.es_instance_details = Some(input);
            self
        }
        pub fn set_es_instance_details(
            mut self,
            input: std::option::Option<crate::model::EsInstanceDetails>,
        ) -> Self {
            self.es_instance_details = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceDetails`](crate::model::InstanceDetails)
        pub fn build(self) -> crate::model::InstanceDetails {
            crate::model::InstanceDetails {
                ec2_instance_details: self.ec2_instance_details,
                rds_instance_details: self.rds_instance_details,
                redshift_instance_details: self.redshift_instance_details,
                elasti_cache_instance_details: self.elasti_cache_instance_details,
                es_instance_details: self.es_instance_details,
            }
        }
    }
}
impl InstanceDetails {
    /// Creates a new builder-style object to manufacture [`InstanceDetails`](crate::model::InstanceDetails)
    pub fn builder() -> crate::model::instance_details::Builder {
        crate::model::instance_details::Builder::default()
    }
}

/// <p>Details about the Amazon ES instances that AWS recommends that you
/// purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EsInstanceDetails {
    /// <p>The class of instance that AWS recommends.</p>
    pub instance_class: std::option::Option<std::string::String>,
    /// <p>The size of instance that AWS recommends.</p>
    pub instance_size: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the recommended reservation.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a current-generation instance.</p>
    pub current_generation: bool,
    /// <p>Whether the recommended reservation is size flexible.</p>
    pub size_flex_eligible: bool,
}
impl std::fmt::Debug for EsInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EsInstanceDetails");
        formatter.field("instance_class", &self.instance_class);
        formatter.field("instance_size", &self.instance_size);
        formatter.field("region", &self.region);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("size_flex_eligible", &self.size_flex_eligible);
        formatter.finish()
    }
}
/// See [`EsInstanceDetails`](crate::model::EsInstanceDetails)
pub mod es_instance_details {
    /// A builder for [`EsInstanceDetails`](crate::model::EsInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_class: std::option::Option<std::string::String>,
        pub(crate) instance_size: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) size_flex_eligible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The class of instance that AWS recommends.</p>
        pub fn instance_class(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_class = Some(input.into());
            self
        }
        pub fn set_instance_class(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_class = input;
            self
        }
        /// <p>The size of instance that AWS recommends.</p>
        pub fn instance_size(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_size = Some(input.into());
            self
        }
        pub fn set_instance_size(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_size = input;
            self
        }
        /// <p>The AWS Region of the recommended reservation.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>Whether the recommendation is for a current-generation instance.</p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Whether the recommended reservation is size flexible.</p>
        pub fn size_flex_eligible(mut self, input: bool) -> Self {
            self.size_flex_eligible = Some(input);
            self
        }
        pub fn set_size_flex_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.size_flex_eligible = input;
            self
        }
        /// Consumes the builder and constructs a [`EsInstanceDetails`](crate::model::EsInstanceDetails)
        pub fn build(self) -> crate::model::EsInstanceDetails {
            crate::model::EsInstanceDetails {
                instance_class: self.instance_class,
                instance_size: self.instance_size,
                region: self.region,
                current_generation: self.current_generation.unwrap_or_default(),
                size_flex_eligible: self.size_flex_eligible.unwrap_or_default(),
            }
        }
    }
}
impl EsInstanceDetails {
    /// Creates a new builder-style object to manufacture [`EsInstanceDetails`](crate::model::EsInstanceDetails)
    pub fn builder() -> crate::model::es_instance_details::Builder {
        crate::model::es_instance_details::Builder::default()
    }
}

/// <p>Details about the Amazon ElastiCache instances that AWS recommends that you
/// purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ElastiCacheInstanceDetails {
    /// <p>The instance family of the recommended reservation.</p>
    pub family: std::option::Option<std::string::String>,
    /// <p>The type of node that AWS recommends.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the recommended reservation.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The description of the recommended reservation.</p>
    pub product_description: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a current generation instance.</p>
    pub current_generation: bool,
    /// <p>Whether the recommended reservation is size flexible.</p>
    pub size_flex_eligible: bool,
}
impl std::fmt::Debug for ElastiCacheInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ElastiCacheInstanceDetails");
        formatter.field("family", &self.family);
        formatter.field("node_type", &self.node_type);
        formatter.field("region", &self.region);
        formatter.field("product_description", &self.product_description);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("size_flex_eligible", &self.size_flex_eligible);
        formatter.finish()
    }
}
/// See [`ElastiCacheInstanceDetails`](crate::model::ElastiCacheInstanceDetails)
pub mod elasti_cache_instance_details {
    /// A builder for [`ElastiCacheInstanceDetails`](crate::model::ElastiCacheInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) product_description: std::option::Option<std::string::String>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) size_flex_eligible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The instance family of the recommended reservation.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// <p>The type of node that AWS recommends.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The AWS Region of the recommended reservation.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The description of the recommended reservation.</p>
        pub fn product_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_description = Some(input.into());
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.product_description = input;
            self
        }
        /// <p>Whether the recommendation is for a current generation instance.</p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Whether the recommended reservation is size flexible.</p>
        pub fn size_flex_eligible(mut self, input: bool) -> Self {
            self.size_flex_eligible = Some(input);
            self
        }
        pub fn set_size_flex_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.size_flex_eligible = input;
            self
        }
        /// Consumes the builder and constructs a [`ElastiCacheInstanceDetails`](crate::model::ElastiCacheInstanceDetails)
        pub fn build(self) -> crate::model::ElastiCacheInstanceDetails {
            crate::model::ElastiCacheInstanceDetails {
                family: self.family,
                node_type: self.node_type,
                region: self.region,
                product_description: self.product_description,
                current_generation: self.current_generation.unwrap_or_default(),
                size_flex_eligible: self.size_flex_eligible.unwrap_or_default(),
            }
        }
    }
}
impl ElastiCacheInstanceDetails {
    /// Creates a new builder-style object to manufacture [`ElastiCacheInstanceDetails`](crate::model::ElastiCacheInstanceDetails)
    pub fn builder() -> crate::model::elasti_cache_instance_details::Builder {
        crate::model::elasti_cache_instance_details::Builder::default()
    }
}

/// <p>Details about the Amazon Redshift instances that AWS recommends that you
/// purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedshiftInstanceDetails {
    /// <p>The instance family of the recommended reservation.</p>
    pub family: std::option::Option<std::string::String>,
    /// <p>The type of node that AWS recommends.</p>
    pub node_type: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the recommended reservation.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a current-generation instance.</p>
    pub current_generation: bool,
    /// <p>Whether the recommended reservation is size flexible.</p>
    pub size_flex_eligible: bool,
}
impl std::fmt::Debug for RedshiftInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedshiftInstanceDetails");
        formatter.field("family", &self.family);
        formatter.field("node_type", &self.node_type);
        formatter.field("region", &self.region);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("size_flex_eligible", &self.size_flex_eligible);
        formatter.finish()
    }
}
/// See [`RedshiftInstanceDetails`](crate::model::RedshiftInstanceDetails)
pub mod redshift_instance_details {
    /// A builder for [`RedshiftInstanceDetails`](crate::model::RedshiftInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) node_type: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) size_flex_eligible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The instance family of the recommended reservation.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// <p>The type of node that AWS recommends.</p>
        pub fn node_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.node_type = Some(input.into());
            self
        }
        pub fn set_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.node_type = input;
            self
        }
        /// <p>The AWS Region of the recommended reservation.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>Whether the recommendation is for a current-generation instance.</p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Whether the recommended reservation is size flexible.</p>
        pub fn size_flex_eligible(mut self, input: bool) -> Self {
            self.size_flex_eligible = Some(input);
            self
        }
        pub fn set_size_flex_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.size_flex_eligible = input;
            self
        }
        /// Consumes the builder and constructs a [`RedshiftInstanceDetails`](crate::model::RedshiftInstanceDetails)
        pub fn build(self) -> crate::model::RedshiftInstanceDetails {
            crate::model::RedshiftInstanceDetails {
                family: self.family,
                node_type: self.node_type,
                region: self.region,
                current_generation: self.current_generation.unwrap_or_default(),
                size_flex_eligible: self.size_flex_eligible.unwrap_or_default(),
            }
        }
    }
}
impl RedshiftInstanceDetails {
    /// Creates a new builder-style object to manufacture [`RedshiftInstanceDetails`](crate::model::RedshiftInstanceDetails)
    pub fn builder() -> crate::model::redshift_instance_details::Builder {
        crate::model::redshift_instance_details::Builder::default()
    }
}

/// <p>Details about the Amazon RDS instances that AWS recommends that you
/// purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RdsInstanceDetails {
    /// <p>The instance family of the recommended reservation.</p>
    pub family: std::option::Option<std::string::String>,
    /// <p>The type of instance that AWS recommends.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the recommended reservation.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The database engine that the recommended reservation supports.</p>
    pub database_engine: std::option::Option<std::string::String>,
    /// <p>The database edition that the recommended reservation supports.</p>
    pub database_edition: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a reservation in a single Availability Zone or a
    /// reservation with a backup in a second Availability Zone.</p>
    pub deployment_option: std::option::Option<std::string::String>,
    /// <p>The license model that the recommended reservation supports.</p>
    pub license_model: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a current-generation instance. </p>
    pub current_generation: bool,
    /// <p>Whether the recommended reservation is size flexible.</p>
    pub size_flex_eligible: bool,
}
impl std::fmt::Debug for RdsInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RdsInstanceDetails");
        formatter.field("family", &self.family);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("region", &self.region);
        formatter.field("database_engine", &self.database_engine);
        formatter.field("database_edition", &self.database_edition);
        formatter.field("deployment_option", &self.deployment_option);
        formatter.field("license_model", &self.license_model);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("size_flex_eligible", &self.size_flex_eligible);
        formatter.finish()
    }
}
/// See [`RdsInstanceDetails`](crate::model::RdsInstanceDetails)
pub mod rds_instance_details {
    /// A builder for [`RdsInstanceDetails`](crate::model::RdsInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) database_engine: std::option::Option<std::string::String>,
        pub(crate) database_edition: std::option::Option<std::string::String>,
        pub(crate) deployment_option: std::option::Option<std::string::String>,
        pub(crate) license_model: std::option::Option<std::string::String>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) size_flex_eligible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The instance family of the recommended reservation.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// <p>The type of instance that AWS recommends.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The AWS Region of the recommended reservation.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The database engine that the recommended reservation supports.</p>
        pub fn database_engine(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_engine = Some(input.into());
            self
        }
        pub fn set_database_engine(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_engine = input;
            self
        }
        /// <p>The database edition that the recommended reservation supports.</p>
        pub fn database_edition(mut self, input: impl Into<std::string::String>) -> Self {
            self.database_edition = Some(input.into());
            self
        }
        pub fn set_database_edition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.database_edition = input;
            self
        }
        /// <p>Whether the recommendation is for a reservation in a single Availability Zone or a
        /// reservation with a backup in a second Availability Zone.</p>
        pub fn deployment_option(mut self, input: impl Into<std::string::String>) -> Self {
            self.deployment_option = Some(input.into());
            self
        }
        pub fn set_deployment_option(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.deployment_option = input;
            self
        }
        /// <p>The license model that the recommended reservation supports.</p>
        pub fn license_model(mut self, input: impl Into<std::string::String>) -> Self {
            self.license_model = Some(input.into());
            self
        }
        pub fn set_license_model(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.license_model = input;
            self
        }
        /// <p>Whether the recommendation is for a current-generation instance. </p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Whether the recommended reservation is size flexible.</p>
        pub fn size_flex_eligible(mut self, input: bool) -> Self {
            self.size_flex_eligible = Some(input);
            self
        }
        pub fn set_size_flex_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.size_flex_eligible = input;
            self
        }
        /// Consumes the builder and constructs a [`RdsInstanceDetails`](crate::model::RdsInstanceDetails)
        pub fn build(self) -> crate::model::RdsInstanceDetails {
            crate::model::RdsInstanceDetails {
                family: self.family,
                instance_type: self.instance_type,
                region: self.region,
                database_engine: self.database_engine,
                database_edition: self.database_edition,
                deployment_option: self.deployment_option,
                license_model: self.license_model,
                current_generation: self.current_generation.unwrap_or_default(),
                size_flex_eligible: self.size_flex_eligible.unwrap_or_default(),
            }
        }
    }
}
impl RdsInstanceDetails {
    /// Creates a new builder-style object to manufacture [`RdsInstanceDetails`](crate::model::RdsInstanceDetails)
    pub fn builder() -> crate::model::rds_instance_details::Builder {
        crate::model::rds_instance_details::Builder::default()
    }
}

/// <p>Details about the Amazon EC2 instances that AWS recommends that you purchase.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2InstanceDetails {
    /// <p>The instance family of the recommended reservation.</p>
    pub family: std::option::Option<std::string::String>,
    /// <p>The type of instance that AWS recommends.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The AWS Region of the recommended reservation.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The Availability Zone of the recommended reservation.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The platform of the recommended reservation. The platform is the specific
    /// combination of operating system, license model, and software on an instance.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>Whether the recommended reservation is dedicated or shared.</p>
    pub tenancy: std::option::Option<std::string::String>,
    /// <p>Whether the recommendation is for a current-generation instance. </p>
    pub current_generation: bool,
    /// <p>Whether the recommended reservation is size flexible.</p>
    pub size_flex_eligible: bool,
}
impl std::fmt::Debug for Ec2InstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2InstanceDetails");
        formatter.field("family", &self.family);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("region", &self.region);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("platform", &self.platform);
        formatter.field("tenancy", &self.tenancy);
        formatter.field("current_generation", &self.current_generation);
        formatter.field("size_flex_eligible", &self.size_flex_eligible);
        formatter.finish()
    }
}
/// See [`Ec2InstanceDetails`](crate::model::Ec2InstanceDetails)
pub mod ec2_instance_details {
    /// A builder for [`Ec2InstanceDetails`](crate::model::Ec2InstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) family: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) tenancy: std::option::Option<std::string::String>,
        pub(crate) current_generation: std::option::Option<bool>,
        pub(crate) size_flex_eligible: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The instance family of the recommended reservation.</p>
        pub fn family(mut self, input: impl Into<std::string::String>) -> Self {
            self.family = Some(input.into());
            self
        }
        pub fn set_family(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.family = input;
            self
        }
        /// <p>The type of instance that AWS recommends.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The AWS Region of the recommended reservation.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The Availability Zone of the recommended reservation.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The platform of the recommended reservation. The platform is the specific
        /// combination of operating system, license model, and software on an instance.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>Whether the recommended reservation is dedicated or shared.</p>
        pub fn tenancy(mut self, input: impl Into<std::string::String>) -> Self {
            self.tenancy = Some(input.into());
            self
        }
        pub fn set_tenancy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>Whether the recommendation is for a current-generation instance. </p>
        pub fn current_generation(mut self, input: bool) -> Self {
            self.current_generation = Some(input);
            self
        }
        pub fn set_current_generation(mut self, input: std::option::Option<bool>) -> Self {
            self.current_generation = input;
            self
        }
        /// <p>Whether the recommended reservation is size flexible.</p>
        pub fn size_flex_eligible(mut self, input: bool) -> Self {
            self.size_flex_eligible = Some(input);
            self
        }
        pub fn set_size_flex_eligible(mut self, input: std::option::Option<bool>) -> Self {
            self.size_flex_eligible = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2InstanceDetails`](crate::model::Ec2InstanceDetails)
        pub fn build(self) -> crate::model::Ec2InstanceDetails {
            crate::model::Ec2InstanceDetails {
                family: self.family,
                instance_type: self.instance_type,
                region: self.region,
                availability_zone: self.availability_zone,
                platform: self.platform,
                tenancy: self.tenancy,
                current_generation: self.current_generation.unwrap_or_default(),
                size_flex_eligible: self.size_flex_eligible.unwrap_or_default(),
            }
        }
    }
}
impl Ec2InstanceDetails {
    /// Creates a new builder-style object to manufacture [`Ec2InstanceDetails`](crate::model::Ec2InstanceDetails)
    pub fn builder() -> crate::model::ec2_instance_details::Builder {
        crate::model::ec2_instance_details::Builder::default()
    }
}

/// <p>Hardware specifications for the service that you want recommendations
/// for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceSpecification {
    /// <p>The Amazon EC2 hardware specifications that you want AWS to provide recommendations
    /// for.</p>
    pub ec2_specification: std::option::Option<crate::model::Ec2Specification>,
}
impl std::fmt::Debug for ServiceSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceSpecification");
        formatter.field("ec2_specification", &self.ec2_specification);
        formatter.finish()
    }
}
/// See [`ServiceSpecification`](crate::model::ServiceSpecification)
pub mod service_specification {
    /// A builder for [`ServiceSpecification`](crate::model::ServiceSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ec2_specification: std::option::Option<crate::model::Ec2Specification>,
    }
    impl Builder {
        /// <p>The Amazon EC2 hardware specifications that you want AWS to provide recommendations
        /// for.</p>
        pub fn ec2_specification(mut self, input: crate::model::Ec2Specification) -> Self {
            self.ec2_specification = Some(input);
            self
        }
        pub fn set_ec2_specification(
            mut self,
            input: std::option::Option<crate::model::Ec2Specification>,
        ) -> Self {
            self.ec2_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceSpecification`](crate::model::ServiceSpecification)
        pub fn build(self) -> crate::model::ServiceSpecification {
            crate::model::ServiceSpecification {
                ec2_specification: self.ec2_specification,
            }
        }
    }
}
impl ServiceSpecification {
    /// Creates a new builder-style object to manufacture [`ServiceSpecification`](crate::model::ServiceSpecification)
    pub fn builder() -> crate::model::service_specification::Builder {
        crate::model::service_specification::Builder::default()
    }
}

/// <p>The Amazon EC2 hardware specifications that you want AWS to provide recommendations
/// for.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ec2Specification {
    /// <p>Whether you want a recommendation for standard or convertible
    /// reservations.</p>
    pub offering_class: std::option::Option<crate::model::OfferingClass>,
}
impl std::fmt::Debug for Ec2Specification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ec2Specification");
        formatter.field("offering_class", &self.offering_class);
        formatter.finish()
    }
}
/// See [`Ec2Specification`](crate::model::Ec2Specification)
pub mod ec2_specification {
    /// A builder for [`Ec2Specification`](crate::model::Ec2Specification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) offering_class: std::option::Option<crate::model::OfferingClass>,
    }
    impl Builder {
        /// <p>Whether you want a recommendation for standard or convertible
        /// reservations.</p>
        pub fn offering_class(mut self, input: crate::model::OfferingClass) -> Self {
            self.offering_class = Some(input);
            self
        }
        pub fn set_offering_class(
            mut self,
            input: std::option::Option<crate::model::OfferingClass>,
        ) -> Self {
            self.offering_class = input;
            self
        }
        /// Consumes the builder and constructs a [`Ec2Specification`](crate::model::Ec2Specification)
        pub fn build(self) -> crate::model::Ec2Specification {
            crate::model::Ec2Specification {
                offering_class: self.offering_class,
            }
        }
    }
}
impl Ec2Specification {
    /// Creates a new builder-style object to manufacture [`Ec2Specification`](crate::model::Ec2Specification)
    pub fn builder() -> crate::model::ec2_specification::Builder {
        crate::model::ec2_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OfferingClass {
    Convertible,
    Standard,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OfferingClass {
    fn from(s: &str) -> Self {
        match s {
            "CONVERTIBLE" => OfferingClass::Convertible,
            "STANDARD" => OfferingClass::Standard,
            other => OfferingClass::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OfferingClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OfferingClass::from(s))
    }
}
impl OfferingClass {
    pub fn as_str(&self) -> &str {
        match self {
            OfferingClass::Convertible => "CONVERTIBLE",
            OfferingClass::Standard => "STANDARD",
            OfferingClass::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CONVERTIBLE", "STANDARD"]
    }
}
impl AsRef<str> for OfferingClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about this specific recommendation, such as the timestamp for when AWS
/// made a specific recommendation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationPurchaseRecommendationMetadata {
    /// <p>The ID for this specific recommendation.</p>
    pub recommendation_id: std::option::Option<std::string::String>,
    /// <p>The timestamp for when AWS made this recommendation.</p>
    pub generation_timestamp: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservationPurchaseRecommendationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationPurchaseRecommendationMetadata");
        formatter.field("recommendation_id", &self.recommendation_id);
        formatter.field("generation_timestamp", &self.generation_timestamp);
        formatter.finish()
    }
}
/// See [`ReservationPurchaseRecommendationMetadata`](crate::model::ReservationPurchaseRecommendationMetadata)
pub mod reservation_purchase_recommendation_metadata {
    /// A builder for [`ReservationPurchaseRecommendationMetadata`](crate::model::ReservationPurchaseRecommendationMetadata)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recommendation_id: std::option::Option<std::string::String>,
        pub(crate) generation_timestamp: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID for this specific recommendation.</p>
        pub fn recommendation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommendation_id = Some(input.into());
            self
        }
        pub fn set_recommendation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_id = input;
            self
        }
        /// <p>The timestamp for when AWS made this recommendation.</p>
        pub fn generation_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.generation_timestamp = Some(input.into());
            self
        }
        pub fn set_generation_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.generation_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationPurchaseRecommendationMetadata`](crate::model::ReservationPurchaseRecommendationMetadata)
        pub fn build(self) -> crate::model::ReservationPurchaseRecommendationMetadata {
            crate::model::ReservationPurchaseRecommendationMetadata {
                recommendation_id: self.recommendation_id,
                generation_timestamp: self.generation_timestamp,
            }
        }
    }
}
impl ReservationPurchaseRecommendationMetadata {
    /// Creates a new builder-style object to manufacture [`ReservationPurchaseRecommendationMetadata`](crate::model::ReservationPurchaseRecommendationMetadata)
    pub fn builder() -> crate::model::reservation_purchase_recommendation_metadata::Builder {
        crate::model::reservation_purchase_recommendation_metadata::Builder::default()
    }
}

/// <p>The amount of instance usage that a reservation covered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Coverage {
    /// <p>The amount of instance usage that the reservation covered, in hours.</p>
    pub coverage_hours: std::option::Option<crate::model::CoverageHours>,
    /// <p>The amount of instance usage that the reservation covered, in normalized
    /// units.</p>
    pub coverage_normalized_units: std::option::Option<crate::model::CoverageNormalizedUnits>,
    /// <p>The amount of cost that the reservation covered.</p>
    pub coverage_cost: std::option::Option<crate::model::CoverageCost>,
}
impl std::fmt::Debug for Coverage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Coverage");
        formatter.field("coverage_hours", &self.coverage_hours);
        formatter.field("coverage_normalized_units", &self.coverage_normalized_units);
        formatter.field("coverage_cost", &self.coverage_cost);
        formatter.finish()
    }
}
/// See [`Coverage`](crate::model::Coverage)
pub mod coverage {
    /// A builder for [`Coverage`](crate::model::Coverage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) coverage_hours: std::option::Option<crate::model::CoverageHours>,
        pub(crate) coverage_normalized_units:
            std::option::Option<crate::model::CoverageNormalizedUnits>,
        pub(crate) coverage_cost: std::option::Option<crate::model::CoverageCost>,
    }
    impl Builder {
        /// <p>The amount of instance usage that the reservation covered, in hours.</p>
        pub fn coverage_hours(mut self, input: crate::model::CoverageHours) -> Self {
            self.coverage_hours = Some(input);
            self
        }
        pub fn set_coverage_hours(
            mut self,
            input: std::option::Option<crate::model::CoverageHours>,
        ) -> Self {
            self.coverage_hours = input;
            self
        }
        /// <p>The amount of instance usage that the reservation covered, in normalized
        /// units.</p>
        pub fn coverage_normalized_units(
            mut self,
            input: crate::model::CoverageNormalizedUnits,
        ) -> Self {
            self.coverage_normalized_units = Some(input);
            self
        }
        pub fn set_coverage_normalized_units(
            mut self,
            input: std::option::Option<crate::model::CoverageNormalizedUnits>,
        ) -> Self {
            self.coverage_normalized_units = input;
            self
        }
        /// <p>The amount of cost that the reservation covered.</p>
        pub fn coverage_cost(mut self, input: crate::model::CoverageCost) -> Self {
            self.coverage_cost = Some(input);
            self
        }
        pub fn set_coverage_cost(
            mut self,
            input: std::option::Option<crate::model::CoverageCost>,
        ) -> Self {
            self.coverage_cost = input;
            self
        }
        /// Consumes the builder and constructs a [`Coverage`](crate::model::Coverage)
        pub fn build(self) -> crate::model::Coverage {
            crate::model::Coverage {
                coverage_hours: self.coverage_hours,
                coverage_normalized_units: self.coverage_normalized_units,
                coverage_cost: self.coverage_cost,
            }
        }
    }
}
impl Coverage {
    /// Creates a new builder-style object to manufacture [`Coverage`](crate::model::Coverage)
    pub fn builder() -> crate::model::coverage::Builder {
        crate::model::coverage::Builder::default()
    }
}

/// <p>How much it costs to run an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoverageCost {
    /// <p>How much an On-Demand Instance costs.</p>
    pub on_demand_cost: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CoverageCost {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoverageCost");
        formatter.field("on_demand_cost", &self.on_demand_cost);
        formatter.finish()
    }
}
/// See [`CoverageCost`](crate::model::CoverageCost)
pub mod coverage_cost {
    /// A builder for [`CoverageCost`](crate::model::CoverageCost)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_demand_cost: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>How much an On-Demand Instance costs.</p>
        pub fn on_demand_cost(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_cost = Some(input.into());
            self
        }
        pub fn set_on_demand_cost(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_cost = input;
            self
        }
        /// Consumes the builder and constructs a [`CoverageCost`](crate::model::CoverageCost)
        pub fn build(self) -> crate::model::CoverageCost {
            crate::model::CoverageCost {
                on_demand_cost: self.on_demand_cost,
            }
        }
    }
}
impl CoverageCost {
    /// Creates a new builder-style object to manufacture [`CoverageCost`](crate::model::CoverageCost)
    pub fn builder() -> crate::model::coverage_cost::Builder {
        crate::model::coverage_cost::Builder::default()
    }
}

/// <p>The amount of instance usage, in normalized units. Normalized units enable you to
/// see your EC2 usage for multiple sizes of instances in a uniform way. For example,
/// suppose you run an xlarge instance and a 2xlarge instance. If you run both instances for
/// the same amount of time, the 2xlarge instance uses twice as much of your reservation as
/// the xlarge instance, even though both instances show only one instance-hour. Using
/// normalized units instead of instance-hours, the xlarge instance used 8 normalized units,
/// and the 2xlarge instance used 16 normalized units.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html">Modifying Reserved Instances</a> in the <i>Amazon Elastic Compute Cloud User Guide for
/// Linux Instances</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoverageNormalizedUnits {
    /// <p>The number of normalized units that are covered by On-Demand Instances instead of a
    /// reservation.</p>
    pub on_demand_normalized_units: std::option::Option<std::string::String>,
    /// <p>The number of normalized units that a reservation covers.</p>
    pub reserved_normalized_units: std::option::Option<std::string::String>,
    /// <p>The total number of normalized units that you used.</p>
    pub total_running_normalized_units: std::option::Option<std::string::String>,
    /// <p>The percentage of your used instance normalized units that a reservation
    /// covers.</p>
    pub coverage_normalized_units_percentage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CoverageNormalizedUnits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoverageNormalizedUnits");
        formatter.field(
            "on_demand_normalized_units",
            &self.on_demand_normalized_units,
        );
        formatter.field("reserved_normalized_units", &self.reserved_normalized_units);
        formatter.field(
            "total_running_normalized_units",
            &self.total_running_normalized_units,
        );
        formatter.field(
            "coverage_normalized_units_percentage",
            &self.coverage_normalized_units_percentage,
        );
        formatter.finish()
    }
}
/// See [`CoverageNormalizedUnits`](crate::model::CoverageNormalizedUnits)
pub mod coverage_normalized_units {
    /// A builder for [`CoverageNormalizedUnits`](crate::model::CoverageNormalizedUnits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_demand_normalized_units: std::option::Option<std::string::String>,
        pub(crate) reserved_normalized_units: std::option::Option<std::string::String>,
        pub(crate) total_running_normalized_units: std::option::Option<std::string::String>,
        pub(crate) coverage_normalized_units_percentage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of normalized units that are covered by On-Demand Instances instead of a
        /// reservation.</p>
        pub fn on_demand_normalized_units(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_normalized_units = Some(input.into());
            self
        }
        pub fn set_on_demand_normalized_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_normalized_units = input;
            self
        }
        /// <p>The number of normalized units that a reservation covers.</p>
        pub fn reserved_normalized_units(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_normalized_units = Some(input.into());
            self
        }
        pub fn set_reserved_normalized_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_normalized_units = input;
            self
        }
        /// <p>The total number of normalized units that you used.</p>
        pub fn total_running_normalized_units(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.total_running_normalized_units = Some(input.into());
            self
        }
        pub fn set_total_running_normalized_units(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_running_normalized_units = input;
            self
        }
        /// <p>The percentage of your used instance normalized units that a reservation
        /// covers.</p>
        pub fn coverage_normalized_units_percentage(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.coverage_normalized_units_percentage = Some(input.into());
            self
        }
        pub fn set_coverage_normalized_units_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.coverage_normalized_units_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`CoverageNormalizedUnits`](crate::model::CoverageNormalizedUnits)
        pub fn build(self) -> crate::model::CoverageNormalizedUnits {
            crate::model::CoverageNormalizedUnits {
                on_demand_normalized_units: self.on_demand_normalized_units,
                reserved_normalized_units: self.reserved_normalized_units,
                total_running_normalized_units: self.total_running_normalized_units,
                coverage_normalized_units_percentage: self.coverage_normalized_units_percentage,
            }
        }
    }
}
impl CoverageNormalizedUnits {
    /// Creates a new builder-style object to manufacture [`CoverageNormalizedUnits`](crate::model::CoverageNormalizedUnits)
    pub fn builder() -> crate::model::coverage_normalized_units::Builder {
        crate::model::coverage_normalized_units::Builder::default()
    }
}

/// <p>How long a running instance either used a reservation or was On-Demand.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoverageHours {
    /// <p>The number of instance running hours that On-Demand Instances covered.</p>
    pub on_demand_hours: std::option::Option<std::string::String>,
    /// <p>The number of instance running hours that reservations covered.</p>
    pub reserved_hours: std::option::Option<std::string::String>,
    /// <p>The total instance usage, in hours.</p>
    pub total_running_hours: std::option::Option<std::string::String>,
    /// <p>The percentage of instance hours that a reservation covered.</p>
    pub coverage_hours_percentage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CoverageHours {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoverageHours");
        formatter.field("on_demand_hours", &self.on_demand_hours);
        formatter.field("reserved_hours", &self.reserved_hours);
        formatter.field("total_running_hours", &self.total_running_hours);
        formatter.field("coverage_hours_percentage", &self.coverage_hours_percentage);
        formatter.finish()
    }
}
/// See [`CoverageHours`](crate::model::CoverageHours)
pub mod coverage_hours {
    /// A builder for [`CoverageHours`](crate::model::CoverageHours)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_demand_hours: std::option::Option<std::string::String>,
        pub(crate) reserved_hours: std::option::Option<std::string::String>,
        pub(crate) total_running_hours: std::option::Option<std::string::String>,
        pub(crate) coverage_hours_percentage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of instance running hours that On-Demand Instances covered.</p>
        pub fn on_demand_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.on_demand_hours = Some(input.into());
            self
        }
        pub fn set_on_demand_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_hours = input;
            self
        }
        /// <p>The number of instance running hours that reservations covered.</p>
        pub fn reserved_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.reserved_hours = Some(input.into());
            self
        }
        pub fn set_reserved_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reserved_hours = input;
            self
        }
        /// <p>The total instance usage, in hours.</p>
        pub fn total_running_hours(mut self, input: impl Into<std::string::String>) -> Self {
            self.total_running_hours = Some(input.into());
            self
        }
        pub fn set_total_running_hours(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.total_running_hours = input;
            self
        }
        /// <p>The percentage of instance hours that a reservation covered.</p>
        pub fn coverage_hours_percentage(mut self, input: impl Into<std::string::String>) -> Self {
            self.coverage_hours_percentage = Some(input.into());
            self
        }
        pub fn set_coverage_hours_percentage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.coverage_hours_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`CoverageHours`](crate::model::CoverageHours)
        pub fn build(self) -> crate::model::CoverageHours {
            crate::model::CoverageHours {
                on_demand_hours: self.on_demand_hours,
                reserved_hours: self.reserved_hours,
                total_running_hours: self.total_running_hours,
                coverage_hours_percentage: self.coverage_hours_percentage,
            }
        }
    }
}
impl CoverageHours {
    /// Creates a new builder-style object to manufacture [`CoverageHours`](crate::model::CoverageHours)
    pub fn builder() -> crate::model::coverage_hours::Builder {
        crate::model::coverage_hours::Builder::default()
    }
}

/// <p>Reservation
/// coverage for a specified period, in
/// hours.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CoverageByTime {
    /// <p>The period that this coverage was used over.</p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The groups of instances that the reservation covered.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::ReservationCoverageGroup>>,
    /// <p>The total reservation coverage, in hours.</p>
    pub total: std::option::Option<crate::model::Coverage>,
}
impl std::fmt::Debug for CoverageByTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CoverageByTime");
        formatter.field("time_period", &self.time_period);
        formatter.field("groups", &self.groups);
        formatter.field("total", &self.total);
        formatter.finish()
    }
}
/// See [`CoverageByTime`](crate::model::CoverageByTime)
pub mod coverage_by_time {
    /// A builder for [`CoverageByTime`](crate::model::CoverageByTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) groups:
            std::option::Option<std::vec::Vec<crate::model::ReservationCoverageGroup>>,
        pub(crate) total: std::option::Option<crate::model::Coverage>,
    }
    impl Builder {
        /// <p>The period that this coverage was used over.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::ReservationCoverageGroup>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReservationCoverageGroup>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>The total reservation coverage, in hours.</p>
        pub fn total(mut self, input: crate::model::Coverage) -> Self {
            self.total = Some(input);
            self
        }
        pub fn set_total(mut self, input: std::option::Option<crate::model::Coverage>) -> Self {
            self.total = input;
            self
        }
        /// Consumes the builder and constructs a [`CoverageByTime`](crate::model::CoverageByTime)
        pub fn build(self) -> crate::model::CoverageByTime {
            crate::model::CoverageByTime {
                time_period: self.time_period,
                groups: self.groups,
                total: self.total,
            }
        }
    }
}
impl CoverageByTime {
    /// Creates a new builder-style object to manufacture [`CoverageByTime`](crate::model::CoverageByTime)
    pub fn builder() -> crate::model::coverage_by_time::Builder {
        crate::model::coverage_by_time::Builder::default()
    }
}

/// <p>A
/// group of reservations that share a set of attributes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservationCoverageGroup {
    /// <p>The attributes for this group of reservations.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>How much instance usage this group of reservations covered.</p>
    pub coverage: std::option::Option<crate::model::Coverage>,
}
impl std::fmt::Debug for ReservationCoverageGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservationCoverageGroup");
        formatter.field("attributes", &self.attributes);
        formatter.field("coverage", &self.coverage);
        formatter.finish()
    }
}
/// See [`ReservationCoverageGroup`](crate::model::ReservationCoverageGroup)
pub mod reservation_coverage_group {
    /// A builder for [`ReservationCoverageGroup`](crate::model::ReservationCoverageGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) coverage: std::option::Option<crate::model::Coverage>,
    }
    impl Builder {
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>How much instance usage this group of reservations covered.</p>
        pub fn coverage(mut self, input: crate::model::Coverage) -> Self {
            self.coverage = Some(input);
            self
        }
        pub fn set_coverage(mut self, input: std::option::Option<crate::model::Coverage>) -> Self {
            self.coverage = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservationCoverageGroup`](crate::model::ReservationCoverageGroup)
        pub fn build(self) -> crate::model::ReservationCoverageGroup {
            crate::model::ReservationCoverageGroup {
                attributes: self.attributes,
                coverage: self.coverage,
            }
        }
    }
}
impl ReservationCoverageGroup {
    /// Creates a new builder-style object to manufacture [`ReservationCoverageGroup`](crate::model::ReservationCoverageGroup)
    pub fn builder() -> crate::model::reservation_coverage_group::Builder {
        crate::model::reservation_coverage_group::Builder::default()
    }
}

/// <p>The metadata of a specific type that you can use to filter and group your results.
/// You can use <code>GetDimensionValues</code> to find specific values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DimensionValuesWithAttributes {
    /// <p>The value of a dimension with a specific attribute.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for DimensionValuesWithAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DimensionValuesWithAttributes");
        formatter.field("value", &self.value);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`DimensionValuesWithAttributes`](crate::model::DimensionValuesWithAttributes)
pub mod dimension_values_with_attributes {
    /// A builder for [`DimensionValuesWithAttributes`](crate::model::DimensionValuesWithAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The value of a dimension with a specific attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`DimensionValuesWithAttributes`](crate::model::DimensionValuesWithAttributes)
        pub fn build(self) -> crate::model::DimensionValuesWithAttributes {
            crate::model::DimensionValuesWithAttributes {
                value: self.value,
                attributes: self.attributes,
            }
        }
    }
}
impl DimensionValuesWithAttributes {
    /// Creates a new builder-style object to manufacture [`DimensionValuesWithAttributes`](crate::model::DimensionValuesWithAttributes)
    pub fn builder() -> crate::model::dimension_values_with_attributes::Builder {
        crate::model::dimension_values_with_attributes::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Context {
    CostAndUsage,
    Reservations,
    SavingsPlans,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Context {
    fn from(s: &str) -> Self {
        match s {
            "COST_AND_USAGE" => Context::CostAndUsage,
            "RESERVATIONS" => Context::Reservations,
            "SAVINGS_PLANS" => Context::SavingsPlans,
            other => Context::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Context {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Context::from(s))
    }
}
impl Context {
    pub fn as_str(&self) -> &str {
        match self {
            Context::CostAndUsage => "COST_AND_USAGE",
            Context::Reservations => "RESERVATIONS",
            Context::SavingsPlans => "SAVINGS_PLANS",
            Context::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["COST_AND_USAGE", "RESERVATIONS", "SAVINGS_PLANS"]
    }
}
impl AsRef<str> for Context {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The result that is associated with a time period.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultByTime {
    /// <p>The time period that the result covers.</p>
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The total amount of cost or usage accrued during the time period.</p>
    pub total: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetricValue>,
    >,
    /// <p>The groups that this time period includes.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::Group>>,
    /// <p>Whether
    /// the result is estimated.</p>
    pub estimated: bool,
}
impl std::fmt::Debug for ResultByTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultByTime");
        formatter.field("time_period", &self.time_period);
        formatter.field("total", &self.total);
        formatter.field("groups", &self.groups);
        formatter.field("estimated", &self.estimated);
        formatter.finish()
    }
}
/// See [`ResultByTime`](crate::model::ResultByTime)
pub mod result_by_time {
    /// A builder for [`ResultByTime`](crate::model::ResultByTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) total: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MetricValue>,
        >,
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::Group>>,
        pub(crate) estimated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The time period that the result covers.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        pub fn total(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetricValue>,
        ) -> Self {
            let mut hash_map = self.total.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.total = Some(hash_map);
            self
        }
        pub fn set_total(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetricValue>,
            >,
        ) -> Self {
            self.total = input;
            self
        }
        pub fn groups(mut self, input: impl Into<crate::model::Group>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Group>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>Whether
        /// the result is estimated.</p>
        pub fn estimated(mut self, input: bool) -> Self {
            self.estimated = Some(input);
            self
        }
        pub fn set_estimated(mut self, input: std::option::Option<bool>) -> Self {
            self.estimated = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultByTime`](crate::model::ResultByTime)
        pub fn build(self) -> crate::model::ResultByTime {
            crate::model::ResultByTime {
                time_period: self.time_period,
                total: self.total,
                groups: self.groups,
                estimated: self.estimated.unwrap_or_default(),
            }
        }
    }
}
impl ResultByTime {
    /// Creates a new builder-style object to manufacture [`ResultByTime`](crate::model::ResultByTime)
    pub fn builder() -> crate::model::result_by_time::Builder {
        crate::model::result_by_time::Builder::default()
    }
}

/// <p>One level of grouped data in the results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Group {
    /// <p>The keys that are included in this group.</p>
    pub keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The metrics that are included in this group.</p>
    pub metrics: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetricValue>,
    >,
}
impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Group");
        formatter.field("keys", &self.keys);
        formatter.field("metrics", &self.metrics);
        formatter.finish()
    }
}
/// See [`Group`](crate::model::Group)
pub mod group {
    /// A builder for [`Group`](crate::model::Group)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) metrics: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MetricValue>,
        >,
    }
    impl Builder {
        pub fn keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.keys.unwrap_or_default();
            v.push(input.into());
            self.keys = Some(v);
            self
        }
        pub fn set_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.keys = input;
            self
        }
        pub fn metrics(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetricValue>,
        ) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetricValue>,
            >,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group)
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                keys: self.keys,
                metrics: self.metrics,
            }
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group)
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// <p>
/// The association between a monitor, threshold, and list of subscribers used to deliver notifications about anomalies detected by a monitor that exceeds a threshold. The content consists of the detailed metadata and the current status of the <code>AnomalySubscription</code> object.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnomalySubscription {
    /// <p> The <code>AnomalySubscription</code> Amazon Resource Name (ARN). </p>
    pub subscription_arn: std::option::Option<std::string::String>,
    /// <p>
    /// Your unique account identifier.
    /// </p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>
    /// A list of cost anomaly monitors.
    /// </p>
    pub monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>
    /// A list of subscribers to notify.
    /// </p>
    pub subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
    /// <p>
    /// The dollar value that triggers a notification if the threshold is exceeded.
    /// </p>
    pub threshold: std::option::Option<f64>,
    /// <p>
    /// The frequency at which anomaly reports are sent over email.
    /// </p>
    pub frequency: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
    /// <p>
    /// The name for the subscription.
    /// </p>
    pub subscription_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnomalySubscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnomalySubscription");
        formatter.field("subscription_arn", &self.subscription_arn);
        formatter.field("account_id", &self.account_id);
        formatter.field("monitor_arn_list", &self.monitor_arn_list);
        formatter.field("subscribers", &self.subscribers);
        formatter.field("threshold", &self.threshold);
        formatter.field("frequency", &self.frequency);
        formatter.field("subscription_name", &self.subscription_name);
        formatter.finish()
    }
}
/// See [`AnomalySubscription`](crate::model::AnomalySubscription)
pub mod anomaly_subscription {
    /// A builder for [`AnomalySubscription`](crate::model::AnomalySubscription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_arn: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
        pub(crate) threshold: std::option::Option<f64>,
        pub(crate) frequency: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
        pub(crate) subscription_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The <code>AnomalySubscription</code> Amazon Resource Name (ARN). </p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_arn = Some(input.into());
            self
        }
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_arn = input;
            self
        }
        /// <p>
        /// Your unique account identifier.
        /// </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        pub fn monitor_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.monitor_arn_list.unwrap_or_default();
            v.push(input.into());
            self.monitor_arn_list = Some(v);
            self
        }
        pub fn set_monitor_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.monitor_arn_list = input;
            self
        }
        pub fn subscribers(mut self, input: impl Into<crate::model::Subscriber>) -> Self {
            let mut v = self.subscribers.unwrap_or_default();
            v.push(input.into());
            self.subscribers = Some(v);
            self
        }
        pub fn set_subscribers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
        ) -> Self {
            self.subscribers = input;
            self
        }
        /// <p>
        /// The dollar value that triggers a notification if the threshold is exceeded.
        /// </p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.threshold = Some(input);
            self
        }
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>
        /// The frequency at which anomaly reports are sent over email.
        /// </p>
        pub fn frequency(mut self, input: crate::model::AnomalySubscriptionFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// <p>
        /// The name for the subscription.
        /// </p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_name = Some(input.into());
            self
        }
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_name = input;
            self
        }
        /// Consumes the builder and constructs a [`AnomalySubscription`](crate::model::AnomalySubscription)
        pub fn build(self) -> crate::model::AnomalySubscription {
            crate::model::AnomalySubscription {
                subscription_arn: self.subscription_arn,
                account_id: self.account_id,
                monitor_arn_list: self.monitor_arn_list,
                subscribers: self.subscribers,
                threshold: self.threshold,
                frequency: self.frequency,
                subscription_name: self.subscription_name,
            }
        }
    }
}
impl AnomalySubscription {
    /// Creates a new builder-style object to manufacture [`AnomalySubscription`](crate::model::AnomalySubscription)
    pub fn builder() -> crate::model::anomaly_subscription::Builder {
        crate::model::anomaly_subscription::Builder::default()
    }
}

/// <p> This object continuously inspects your account's cost data for anomalies, based on
/// <code>MonitorType</code> and <code>MonitorSpecification</code>. The content consists
/// of detailed metadata and the current status of the monitor object. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnomalyMonitor {
    /// <p> The Amazon Resource Name (ARN) value. </p>
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>
    /// The name of the monitor.
    /// </p>
    pub monitor_name: std::option::Option<std::string::String>,
    /// <p>
    /// The date when the monitor was created.
    /// </p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>
    /// The date when the monitor was last updated.
    /// </p>
    pub last_updated_date: std::option::Option<std::string::String>,
    /// <p>
    /// The date when the monitor last evaluated for anomalies.
    /// </p>
    pub last_evaluated_date: std::option::Option<std::string::String>,
    /// <p>
    /// The possible type values.
    /// </p>
    pub monitor_type: std::option::Option<crate::model::MonitorType>,
    /// <p>
    /// The dimensions to evaluate.
    /// </p>
    pub monitor_dimension: std::option::Option<crate::model::MonitorDimension>,
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    /// <ul>
    /// <li>
    /// <p>Simple dimension values - You can set the dimension name and values for the
    /// filters that you plan to use. For example, you can filter for
    /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    /// <code>Expression</code> example looks like:</p>
    /// <p>
    /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    /// “us-west-1” ] } }</code>
    /// </p>
    /// <p>The list of dimension values are OR'd together to retrieve cost or usage
    /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
    /// objects using either <code>with*</code> methods or <code>set*</code> methods in
    /// multiple lines. </p>
    /// </li>
    /// <li>
    /// <p>Compound dimension values with logical operations - You can use multiple
    /// <code>Expression</code> types and the logical operators
    /// <code>AND/OR/NOT</code> to create a list of one or more
    /// <code>Expression</code> objects. This allows you to filter on more advanced
    /// options. For example, you can filter on <code>((REGION == us-east-1 OR
    /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    /// DataTransfer)</code>. The <code>Expression</code> for that looks like
    /// this:</p>
    /// <p>
    /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    /// "Values": ["DataTransfer"] }}} ] } </code>
    /// </p>
    /// <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the
    /// service returns an error if more than one is specified. The following
    /// example shows an <code>Expression</code> object that creates an
    /// error.</p>
    /// </note>
    /// <p>
    /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    /// "Values": [ "DataTransfer" ] } } </code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    /// supported. OR is not supported between different dimensions, or dimensions and tags.
    /// NOT operators aren't supported.
    /// Dimensions
    /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    /// <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub monitor_specification: std::option::Option<crate::model::Expression>,
    /// <p>
    /// The value for evaluated dimensions.
    /// </p>
    pub dimensional_value_count: i32,
}
impl std::fmt::Debug for AnomalyMonitor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnomalyMonitor");
        formatter.field("monitor_arn", &self.monitor_arn);
        formatter.field("monitor_name", &self.monitor_name);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("last_updated_date", &self.last_updated_date);
        formatter.field("last_evaluated_date", &self.last_evaluated_date);
        formatter.field("monitor_type", &self.monitor_type);
        formatter.field("monitor_dimension", &self.monitor_dimension);
        formatter.field("monitor_specification", &self.monitor_specification);
        formatter.field("dimensional_value_count", &self.dimensional_value_count);
        formatter.finish()
    }
}
/// See [`AnomalyMonitor`](crate::model::AnomalyMonitor)
pub mod anomaly_monitor {
    /// A builder for [`AnomalyMonitor`](crate::model::AnomalyMonitor)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) monitor_name: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) last_updated_date: std::option::Option<std::string::String>,
        pub(crate) last_evaluated_date: std::option::Option<std::string::String>,
        pub(crate) monitor_type: std::option::Option<crate::model::MonitorType>,
        pub(crate) monitor_dimension: std::option::Option<crate::model::MonitorDimension>,
        pub(crate) monitor_specification: std::option::Option<crate::model::Expression>,
        pub(crate) dimensional_value_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) value. </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>
        /// The name of the monitor.
        /// </p>
        pub fn monitor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_name = Some(input.into());
            self
        }
        pub fn set_monitor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_name = input;
            self
        }
        /// <p>
        /// The date when the monitor was created.
        /// </p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>
        /// The date when the monitor was last updated.
        /// </p>
        pub fn last_updated_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_date = Some(input.into());
            self
        }
        pub fn set_last_updated_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_date = input;
            self
        }
        /// <p>
        /// The date when the monitor last evaluated for anomalies.
        /// </p>
        pub fn last_evaluated_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_evaluated_date = Some(input.into());
            self
        }
        pub fn set_last_evaluated_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_evaluated_date = input;
            self
        }
        /// <p>
        /// The possible type values.
        /// </p>
        pub fn monitor_type(mut self, input: crate::model::MonitorType) -> Self {
            self.monitor_type = Some(input);
            self
        }
        pub fn set_monitor_type(
            mut self,
            input: std::option::Option<crate::model::MonitorType>,
        ) -> Self {
            self.monitor_type = input;
            self
        }
        /// <p>
        /// The dimensions to evaluate.
        /// </p>
        pub fn monitor_dimension(mut self, input: crate::model::MonitorDimension) -> Self {
            self.monitor_dimension = Some(input);
            self
        }
        pub fn set_monitor_dimension(
            mut self,
            input: std::option::Option<crate::model::MonitorDimension>,
        ) -> Self {
            self.monitor_dimension = input;
            self
        }
        /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
        /// <ul>
        /// <li>
        /// <p>Simple dimension values - You can set the dimension name and values for the
        /// filters that you plan to use. For example, you can filter for
        /// <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
        /// <code>Expression</code> example looks like:</p>
        /// <p>
        /// <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
        /// “us-west-1” ] } }</code>
        /// </p>
        /// <p>The list of dimension values are OR'd together to retrieve cost or usage
        /// data. You can create <code>Expression</code> and <code>DimensionValues</code>
        /// objects using either <code>with*</code> methods or <code>set*</code> methods in
        /// multiple lines. </p>
        /// </li>
        /// <li>
        /// <p>Compound dimension values with logical operations - You can use multiple
        /// <code>Expression</code> types and the logical operators
        /// <code>AND/OR/NOT</code> to create a list of one or more
        /// <code>Expression</code> objects. This allows you to filter on more advanced
        /// options. For example, you can filter on <code>((REGION == us-east-1 OR
        /// REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
        /// DataTransfer)</code>. The <code>Expression</code> for that looks like
        /// this:</p>
        /// <p>
        /// <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
        /// "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
        /// "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
        /// "Values": ["DataTransfer"] }}} ] } </code>
        /// </p>
        /// <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the
        /// service returns an error if more than one is specified. The following
        /// example shows an <code>Expression</code> object that creates an
        /// error.</p>
        /// </note>
        /// <p>
        /// <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
        /// "Values": [ "DataTransfer" ] } } </code>
        /// </p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
        /// supported. OR is not supported between different dimensions, or dimensions and tags.
        /// NOT operators aren't supported.
        /// Dimensions
        /// are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
        /// <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn monitor_specification(mut self, input: crate::model::Expression) -> Self {
            self.monitor_specification = Some(input);
            self
        }
        pub fn set_monitor_specification(
            mut self,
            input: std::option::Option<crate::model::Expression>,
        ) -> Self {
            self.monitor_specification = input;
            self
        }
        /// <p>
        /// The value for evaluated dimensions.
        /// </p>
        pub fn dimensional_value_count(mut self, input: i32) -> Self {
            self.dimensional_value_count = Some(input);
            self
        }
        pub fn set_dimensional_value_count(mut self, input: std::option::Option<i32>) -> Self {
            self.dimensional_value_count = input;
            self
        }
        /// Consumes the builder and constructs a [`AnomalyMonitor`](crate::model::AnomalyMonitor)
        pub fn build(self) -> crate::model::AnomalyMonitor {
            crate::model::AnomalyMonitor {
                monitor_arn: self.monitor_arn,
                monitor_name: self.monitor_name,
                creation_date: self.creation_date,
                last_updated_date: self.last_updated_date,
                last_evaluated_date: self.last_evaluated_date,
                monitor_type: self.monitor_type,
                monitor_dimension: self.monitor_dimension,
                monitor_specification: self.monitor_specification,
                dimensional_value_count: self.dimensional_value_count.unwrap_or_default(),
            }
        }
    }
}
impl AnomalyMonitor {
    /// Creates a new builder-style object to manufacture [`AnomalyMonitor`](crate::model::AnomalyMonitor)
    pub fn builder() -> crate::model::anomaly_monitor::Builder {
        crate::model::anomaly_monitor::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitorDimension {
    Service,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitorDimension {
    fn from(s: &str) -> Self {
        match s {
            "SERVICE" => MonitorDimension::Service,
            other => MonitorDimension::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitorDimension {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitorDimension::from(s))
    }
}
impl MonitorDimension {
    pub fn as_str(&self) -> &str {
        match self {
            MonitorDimension::Service => "SERVICE",
            MonitorDimension::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["SERVICE"]
    }
}
impl AsRef<str> for MonitorDimension {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MonitorType {
    Custom,
    Dimensional,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MonitorType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM" => MonitorType::Custom,
            "DIMENSIONAL" => MonitorType::Dimensional,
            other => MonitorType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MonitorType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MonitorType::from(s))
    }
}
impl MonitorType {
    pub fn as_str(&self) -> &str {
        match self {
            MonitorType::Custom => "CUSTOM",
            MonitorType::Dimensional => "DIMENSIONAL",
            MonitorType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CUSTOM", "DIMENSIONAL"]
    }
}
impl AsRef<str> for MonitorType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>
/// An unusual cost pattern. This consists of the detailed metadata and the current status of the anomaly object.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Anomaly {
    /// <p>
    /// The unique identifier for the anomaly.
    /// </p>
    pub anomaly_id: std::option::Option<std::string::String>,
    /// <p>
    /// The first day the anomaly is detected.
    /// </p>
    pub anomaly_start_date: std::option::Option<std::string::String>,
    /// <p>
    /// The last day the anomaly is detected.
    /// </p>
    pub anomaly_end_date: std::option::Option<std::string::String>,
    /// <p>
    /// The dimension for the anomaly. For example, an AWS service in a service monitor.
    /// </p>
    pub dimension_value: std::option::Option<std::string::String>,
    /// <p>
    /// The list of identified root causes for the anomaly.
    /// </p>
    pub root_causes: std::option::Option<std::vec::Vec<crate::model::RootCause>>,
    /// <p>
    /// The latest and maximum score for the anomaly.
    /// </p>
    pub anomaly_score: std::option::Option<crate::model::AnomalyScore>,
    /// <p>
    /// The dollar impact for the anomaly.
    /// </p>
    pub impact: std::option::Option<crate::model::Impact>,
    /// <p> The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly. </p>
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>
    /// The feedback value.
    /// </p>
    pub feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
}
impl std::fmt::Debug for Anomaly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Anomaly");
        formatter.field("anomaly_id", &self.anomaly_id);
        formatter.field("anomaly_start_date", &self.anomaly_start_date);
        formatter.field("anomaly_end_date", &self.anomaly_end_date);
        formatter.field("dimension_value", &self.dimension_value);
        formatter.field("root_causes", &self.root_causes);
        formatter.field("anomaly_score", &self.anomaly_score);
        formatter.field("impact", &self.impact);
        formatter.field("monitor_arn", &self.monitor_arn);
        formatter.field("feedback", &self.feedback);
        formatter.finish()
    }
}
/// See [`Anomaly`](crate::model::Anomaly)
pub mod anomaly {
    /// A builder for [`Anomaly`](crate::model::Anomaly)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) anomaly_id: std::option::Option<std::string::String>,
        pub(crate) anomaly_start_date: std::option::Option<std::string::String>,
        pub(crate) anomaly_end_date: std::option::Option<std::string::String>,
        pub(crate) dimension_value: std::option::Option<std::string::String>,
        pub(crate) root_causes: std::option::Option<std::vec::Vec<crate::model::RootCause>>,
        pub(crate) anomaly_score: std::option::Option<crate::model::AnomalyScore>,
        pub(crate) impact: std::option::Option<crate::model::Impact>,
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
    }
    impl Builder {
        /// <p>
        /// The unique identifier for the anomaly.
        /// </p>
        pub fn anomaly_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.anomaly_id = Some(input.into());
            self
        }
        pub fn set_anomaly_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.anomaly_id = input;
            self
        }
        /// <p>
        /// The first day the anomaly is detected.
        /// </p>
        pub fn anomaly_start_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.anomaly_start_date = Some(input.into());
            self
        }
        pub fn set_anomaly_start_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.anomaly_start_date = input;
            self
        }
        /// <p>
        /// The last day the anomaly is detected.
        /// </p>
        pub fn anomaly_end_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.anomaly_end_date = Some(input.into());
            self
        }
        pub fn set_anomaly_end_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.anomaly_end_date = input;
            self
        }
        /// <p>
        /// The dimension for the anomaly. For example, an AWS service in a service monitor.
        /// </p>
        pub fn dimension_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.dimension_value = Some(input.into());
            self
        }
        pub fn set_dimension_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dimension_value = input;
            self
        }
        pub fn root_causes(mut self, input: impl Into<crate::model::RootCause>) -> Self {
            let mut v = self.root_causes.unwrap_or_default();
            v.push(input.into());
            self.root_causes = Some(v);
            self
        }
        pub fn set_root_causes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RootCause>>,
        ) -> Self {
            self.root_causes = input;
            self
        }
        /// <p>
        /// The latest and maximum score for the anomaly.
        /// </p>
        pub fn anomaly_score(mut self, input: crate::model::AnomalyScore) -> Self {
            self.anomaly_score = Some(input);
            self
        }
        pub fn set_anomaly_score(
            mut self,
            input: std::option::Option<crate::model::AnomalyScore>,
        ) -> Self {
            self.anomaly_score = input;
            self
        }
        /// <p>
        /// The dollar impact for the anomaly.
        /// </p>
        pub fn impact(mut self, input: crate::model::Impact) -> Self {
            self.impact = Some(input);
            self
        }
        pub fn set_impact(mut self, input: std::option::Option<crate::model::Impact>) -> Self {
            self.impact = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly. </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>
        /// The feedback value.
        /// </p>
        pub fn feedback(mut self, input: crate::model::AnomalyFeedbackType) -> Self {
            self.feedback = Some(input);
            self
        }
        pub fn set_feedback(
            mut self,
            input: std::option::Option<crate::model::AnomalyFeedbackType>,
        ) -> Self {
            self.feedback = input;
            self
        }
        /// Consumes the builder and constructs a [`Anomaly`](crate::model::Anomaly)
        pub fn build(self) -> crate::model::Anomaly {
            crate::model::Anomaly {
                anomaly_id: self.anomaly_id,
                anomaly_start_date: self.anomaly_start_date,
                anomaly_end_date: self.anomaly_end_date,
                dimension_value: self.dimension_value,
                root_causes: self.root_causes,
                anomaly_score: self.anomaly_score,
                impact: self.impact,
                monitor_arn: self.monitor_arn,
                feedback: self.feedback,
            }
        }
    }
}
impl Anomaly {
    /// Creates a new builder-style object to manufacture [`Anomaly`](crate::model::Anomaly)
    pub fn builder() -> crate::model::anomaly::Builder {
        crate::model::anomaly::Builder::default()
    }
}

/// <p>
/// The anomaly's dollar value.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Impact {
    /// <p>
    /// The maximum dollar value observed for an anomaly.
    /// </p>
    pub max_impact: f64,
    /// <p>
    /// The cumulative dollar value observed for an anomaly.
    /// </p>
    pub total_impact: f64,
}
impl std::fmt::Debug for Impact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Impact");
        formatter.field("max_impact", &self.max_impact);
        formatter.field("total_impact", &self.total_impact);
        formatter.finish()
    }
}
/// See [`Impact`](crate::model::Impact)
pub mod impact {
    /// A builder for [`Impact`](crate::model::Impact)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_impact: std::option::Option<f64>,
        pub(crate) total_impact: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>
        /// The maximum dollar value observed for an anomaly.
        /// </p>
        pub fn max_impact(mut self, input: f64) -> Self {
            self.max_impact = Some(input);
            self
        }
        pub fn set_max_impact(mut self, input: std::option::Option<f64>) -> Self {
            self.max_impact = input;
            self
        }
        /// <p>
        /// The cumulative dollar value observed for an anomaly.
        /// </p>
        pub fn total_impact(mut self, input: f64) -> Self {
            self.total_impact = Some(input);
            self
        }
        pub fn set_total_impact(mut self, input: std::option::Option<f64>) -> Self {
            self.total_impact = input;
            self
        }
        /// Consumes the builder and constructs a [`Impact`](crate::model::Impact)
        pub fn build(self) -> crate::model::Impact {
            crate::model::Impact {
                max_impact: self.max_impact.unwrap_or_default(),
                total_impact: self.total_impact.unwrap_or_default(),
            }
        }
    }
}
impl Impact {
    /// Creates a new builder-style object to manufacture [`Impact`](crate::model::Impact)
    pub fn builder() -> crate::model::impact::Builder {
        crate::model::impact::Builder::default()
    }
}

/// <p> Quantifies the anomaly. The higher score means that it is more anomalous. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnomalyScore {
    /// <p>
    /// The maximum score observed during the <code>AnomalyDateInterval</code>.
    /// </p>
    pub max_score: f64,
    /// <p>
    /// The last observed score.
    /// </p>
    pub current_score: f64,
}
impl std::fmt::Debug for AnomalyScore {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnomalyScore");
        formatter.field("max_score", &self.max_score);
        formatter.field("current_score", &self.current_score);
        formatter.finish()
    }
}
/// See [`AnomalyScore`](crate::model::AnomalyScore)
pub mod anomaly_score {
    /// A builder for [`AnomalyScore`](crate::model::AnomalyScore)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_score: std::option::Option<f64>,
        pub(crate) current_score: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>
        /// The maximum score observed during the <code>AnomalyDateInterval</code>.
        /// </p>
        pub fn max_score(mut self, input: f64) -> Self {
            self.max_score = Some(input);
            self
        }
        pub fn set_max_score(mut self, input: std::option::Option<f64>) -> Self {
            self.max_score = input;
            self
        }
        /// <p>
        /// The last observed score.
        /// </p>
        pub fn current_score(mut self, input: f64) -> Self {
            self.current_score = Some(input);
            self
        }
        pub fn set_current_score(mut self, input: std::option::Option<f64>) -> Self {
            self.current_score = input;
            self
        }
        /// Consumes the builder and constructs a [`AnomalyScore`](crate::model::AnomalyScore)
        pub fn build(self) -> crate::model::AnomalyScore {
            crate::model::AnomalyScore {
                max_score: self.max_score.unwrap_or_default(),
                current_score: self.current_score.unwrap_or_default(),
            }
        }
    }
}
impl AnomalyScore {
    /// Creates a new builder-style object to manufacture [`AnomalyScore`](crate::model::AnomalyScore)
    pub fn builder() -> crate::model::anomaly_score::Builder {
        crate::model::anomaly_score::Builder::default()
    }
}

/// <p>
/// The combination of AWS service, linked account, Region, and usage type where a cost anomaly is observed.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RootCause {
    /// <p>
    /// The AWS service name associated with the cost anomaly.
    /// </p>
    pub service: std::option::Option<std::string::String>,
    /// <p>
    /// The AWS Region associated with the cost anomaly.
    /// </p>
    pub region: std::option::Option<std::string::String>,
    /// <p>
    /// The linked account value associated with the cost anomaly.
    /// </p>
    pub linked_account: std::option::Option<std::string::String>,
    /// <p>
    /// The <code>UsageType</code> value associated with the cost anomaly.
    /// </p>
    pub usage_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RootCause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RootCause");
        formatter.field("service", &self.service);
        formatter.field("region", &self.region);
        formatter.field("linked_account", &self.linked_account);
        formatter.field("usage_type", &self.usage_type);
        formatter.finish()
    }
}
/// See [`RootCause`](crate::model::RootCause)
pub mod root_cause {
    /// A builder for [`RootCause`](crate::model::RootCause)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) linked_account: std::option::Option<std::string::String>,
        pub(crate) usage_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The AWS service name associated with the cost anomaly.
        /// </p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.service = Some(input.into());
            self
        }
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service = input;
            self
        }
        /// <p>
        /// The AWS Region associated with the cost anomaly.
        /// </p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>
        /// The linked account value associated with the cost anomaly.
        /// </p>
        pub fn linked_account(mut self, input: impl Into<std::string::String>) -> Self {
            self.linked_account = Some(input.into());
            self
        }
        pub fn set_linked_account(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.linked_account = input;
            self
        }
        /// <p>
        /// The <code>UsageType</code> value associated with the cost anomaly.
        /// </p>
        pub fn usage_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.usage_type = Some(input.into());
            self
        }
        pub fn set_usage_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.usage_type = input;
            self
        }
        /// Consumes the builder and constructs a [`RootCause`](crate::model::RootCause)
        pub fn build(self) -> crate::model::RootCause {
            crate::model::RootCause {
                service: self.service,
                region: self.region,
                linked_account: self.linked_account,
                usage_type: self.usage_type,
            }
        }
    }
}
impl RootCause {
    /// Creates a new builder-style object to manufacture [`RootCause`](crate::model::RootCause)
    pub fn builder() -> crate::model::root_cause::Builder {
        crate::model::root_cause::Builder::default()
    }
}

/// <p> Filters cost anomalies based on the total impact. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TotalImpactFilter {
    /// <p>
    /// The comparing value used in the filter.
    /// </p>
    pub numeric_operator: std::option::Option<crate::model::NumericOperator>,
    /// <p>
    /// The lower bound dollar value used in the filter.
    /// </p>
    pub start_value: f64,
    /// <p> The upper bound dollar value used in the filter. </p>
    pub end_value: f64,
}
impl std::fmt::Debug for TotalImpactFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TotalImpactFilter");
        formatter.field("numeric_operator", &self.numeric_operator);
        formatter.field("start_value", &self.start_value);
        formatter.field("end_value", &self.end_value);
        formatter.finish()
    }
}
/// See [`TotalImpactFilter`](crate::model::TotalImpactFilter)
pub mod total_impact_filter {
    /// A builder for [`TotalImpactFilter`](crate::model::TotalImpactFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) numeric_operator: std::option::Option<crate::model::NumericOperator>,
        pub(crate) start_value: std::option::Option<f64>,
        pub(crate) end_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>
        /// The comparing value used in the filter.
        /// </p>
        pub fn numeric_operator(mut self, input: crate::model::NumericOperator) -> Self {
            self.numeric_operator = Some(input);
            self
        }
        pub fn set_numeric_operator(
            mut self,
            input: std::option::Option<crate::model::NumericOperator>,
        ) -> Self {
            self.numeric_operator = input;
            self
        }
        /// <p>
        /// The lower bound dollar value used in the filter.
        /// </p>
        pub fn start_value(mut self, input: f64) -> Self {
            self.start_value = Some(input);
            self
        }
        pub fn set_start_value(mut self, input: std::option::Option<f64>) -> Self {
            self.start_value = input;
            self
        }
        /// <p> The upper bound dollar value used in the filter. </p>
        pub fn end_value(mut self, input: f64) -> Self {
            self.end_value = Some(input);
            self
        }
        pub fn set_end_value(mut self, input: std::option::Option<f64>) -> Self {
            self.end_value = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalImpactFilter`](crate::model::TotalImpactFilter)
        pub fn build(self) -> crate::model::TotalImpactFilter {
            crate::model::TotalImpactFilter {
                numeric_operator: self.numeric_operator,
                start_value: self.start_value.unwrap_or_default(),
                end_value: self.end_value.unwrap_or_default(),
            }
        }
    }
}
impl TotalImpactFilter {
    /// Creates a new builder-style object to manufacture [`TotalImpactFilter`](crate::model::TotalImpactFilter)
    pub fn builder() -> crate::model::total_impact_filter::Builder {
        crate::model::total_impact_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NumericOperator {
    Between,
    Equal,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for NumericOperator {
    fn from(s: &str) -> Self {
        match s {
            "BETWEEN" => NumericOperator::Between,
            "EQUAL" => NumericOperator::Equal,
            "GREATER_THAN" => NumericOperator::GreaterThan,
            "GREATER_THAN_OR_EQUAL" => NumericOperator::GreaterThanOrEqual,
            "LESS_THAN" => NumericOperator::LessThan,
            "LESS_THAN_OR_EQUAL" => NumericOperator::LessThanOrEqual,
            other => NumericOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for NumericOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NumericOperator::from(s))
    }
}
impl NumericOperator {
    pub fn as_str(&self) -> &str {
        match self {
            NumericOperator::Between => "BETWEEN",
            NumericOperator::Equal => "EQUAL",
            NumericOperator::GreaterThan => "GREATER_THAN",
            NumericOperator::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
            NumericOperator::LessThan => "LESS_THAN",
            NumericOperator::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
            NumericOperator::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "BETWEEN",
            "EQUAL",
            "GREATER_THAN",
            "GREATER_THAN_OR_EQUAL",
            "LESS_THAN",
            "LESS_THAN_OR_EQUAL",
        ]
    }
}
impl AsRef<str> for NumericOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>
/// The time period for an anomaly.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AnomalyDateInterval {
    /// <p>
    /// The first date an anomaly was observed.
    /// </p>
    pub start_date: std::option::Option<std::string::String>,
    /// <p>
    /// The last date an anomaly was observed.
    /// </p>
    pub end_date: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AnomalyDateInterval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AnomalyDateInterval");
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.finish()
    }
}
/// See [`AnomalyDateInterval`](crate::model::AnomalyDateInterval)
pub mod anomaly_date_interval {
    /// A builder for [`AnomalyDateInterval`](crate::model::AnomalyDateInterval)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_date: std::option::Option<std::string::String>,
        pub(crate) end_date: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The first date an anomaly was observed.
        /// </p>
        pub fn start_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_date = Some(input.into());
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_date = input;
            self
        }
        /// <p>
        /// The last date an anomaly was observed.
        /// </p>
        pub fn end_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_date = Some(input.into());
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_date = input;
            self
        }
        /// Consumes the builder and constructs a [`AnomalyDateInterval`](crate::model::AnomalyDateInterval)
        pub fn build(self) -> crate::model::AnomalyDateInterval {
            crate::model::AnomalyDateInterval {
                start_date: self.start_date,
                end_date: self.end_date,
            }
        }
    }
}
impl AnomalyDateInterval {
    /// Creates a new builder-style object to manufacture [`AnomalyDateInterval`](crate::model::AnomalyDateInterval)
    pub fn builder() -> crate::model::anomaly_date_interval::Builder {
        crate::model::anomaly_date_interval::Builder::default()
    }
}

/// <p>The structure of Cost Categories. This includes detailed metadata and the set of rules for the <code>CostCategory</code> object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CostCategory {
    /// <p>
    /// The unique identifier for your Cost Category.
    /// </p>
    pub cost_category_arn: std::option::Option<std::string::String>,
    /// <p>
    /// The Cost Category's effective start date.</p>
    pub effective_start: std::option::Option<std::string::String>,
    /// <p>
    /// The Cost Category's effective end date.</p>
    pub effective_end: std::option::Option<std::string::String>,
    /// <p>The unique name of the Cost Category.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The rule schema version in this particular Cost Category.</p>
    pub rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
    /// <p>
    /// Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
    /// </p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
    /// <p>
    /// The list of processing statuses for Cost Management products for a specific cost category.
    /// </p>
    pub processing_status:
        std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
    /// <p>The default value for the cost category.</p>
    pub default_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CostCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CostCategory");
        formatter.field("cost_category_arn", &self.cost_category_arn);
        formatter.field("effective_start", &self.effective_start);
        formatter.field("effective_end", &self.effective_end);
        formatter.field("name", &self.name);
        formatter.field("rule_version", &self.rule_version);
        formatter.field("rules", &self.rules);
        formatter.field("processing_status", &self.processing_status);
        formatter.field("default_value", &self.default_value);
        formatter.finish()
    }
}
/// See [`CostCategory`](crate::model::CostCategory)
pub mod cost_category {
    /// A builder for [`CostCategory`](crate::model::CostCategory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_category_arn: std::option::Option<std::string::String>,
        pub(crate) effective_start: std::option::Option<std::string::String>,
        pub(crate) effective_end: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        pub(crate) processing_status:
            std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The unique identifier for your Cost Category.
        /// </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_arn = Some(input.into());
            self
        }
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_arn = input;
            self
        }
        /// <p>
        /// The Cost Category's effective start date.</p>
        pub fn effective_start(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_start = Some(input.into());
            self
        }
        pub fn set_effective_start(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_start = input;
            self
        }
        /// <p>
        /// The Cost Category's effective end date.</p>
        pub fn effective_end(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_end = Some(input.into());
            self
        }
        pub fn set_effective_end(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_end = input;
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn rule_version(mut self, input: crate::model::CostCategoryRuleVersion) -> Self {
            self.rule_version = Some(input);
            self
        }
        pub fn set_rule_version(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleVersion>,
        ) -> Self {
            self.rule_version = input;
            self
        }
        pub fn rules(mut self, input: impl Into<crate::model::CostCategoryRule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        pub fn processing_status(
            mut self,
            input: impl Into<crate::model::CostCategoryProcessingStatus>,
        ) -> Self {
            let mut v = self.processing_status.unwrap_or_default();
            v.push(input.into());
            self.processing_status = Some(v);
            self
        }
        pub fn set_processing_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryProcessingStatus>>,
        ) -> Self {
            self.processing_status = input;
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`CostCategory`](crate::model::CostCategory)
        pub fn build(self) -> crate::model::CostCategory {
            crate::model::CostCategory {
                cost_category_arn: self.cost_category_arn,
                effective_start: self.effective_start,
                effective_end: self.effective_end,
                name: self.name,
                rule_version: self.rule_version,
                rules: self.rules,
                processing_status: self.processing_status,
                default_value: self.default_value,
            }
        }
    }
}
impl CostCategory {
    /// Creates a new builder-style object to manufacture [`CostCategory`](crate::model::CostCategory)
    pub fn builder() -> crate::model::cost_category::Builder {
        crate::model::cost_category::Builder::default()
    }
}
