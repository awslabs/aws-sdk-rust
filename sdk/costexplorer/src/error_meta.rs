// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The requested report expired. Update the date interval and try again.</p>
    BillExpirationException(crate::error::BillExpirationException),
    /// <p>The requested data is unavailable.</p>
    DataUnavailableException(crate::error::DataUnavailableException),
    /// <p>A request to generate a recommendation is already in progress.</p>
    GenerationExistsException(crate::error::GenerationExistsException),
    /// <p>The pagination token is invalid. Try again without a pagination token.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>You made too many calls in a short period of time. Try again later.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>Your request parameters changed between pages. Try again with the old parameters or without a pagination token.</p>
    RequestChangedException(crate::error::RequestChangedException),
    /// <p> The specified ARN in the request doesn't exist. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// <p>The cost anomaly monitor does not exist for the account. </p>
    UnknownMonitorException(crate::error::UnknownMonitorException),
    /// <p>The cost anomaly subscription does not exist for the account. </p>
    UnknownSubscriptionException(crate::error::UnknownSubscriptionException),
    /// <p>Cost Explorer was unable to identify the usage unit. Provide <code>UsageType/UsageTypeGroup</code> filter selections that contain matching units, for example: <code>hours</code>.</p>
    UnresolvableUsageUnitException(crate::error::UnresolvableUsageUnitException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BillExpirationException(inner) => inner.fmt(f),
            Error::DataUnavailableException(inner) => inner.fmt(f),
            Error::GenerationExistsException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::RequestChangedException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::ServiceQuotaExceededException(inner) => inner.fmt(f),
            Error::TooManyTagsException(inner) => inner.fmt(f),
            Error::UnknownMonitorException(inner) => inner.fmt(f),
            Error::UnknownSubscriptionException(inner) => inner.fmt(f),
            Error::UnresolvableUsageUnitException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAnomalyMonitorError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateAnomalyMonitorError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateAnomalyMonitorError> for Error {
    fn from(err: crate::error::CreateAnomalyMonitorError) -> Self {
        match err.kind {
            crate::error::CreateAnomalyMonitorErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateAnomalyMonitorErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAnomalySubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateAnomalySubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateAnomalySubscriptionError> for Error {
    fn from(err: crate::error::CreateAnomalySubscriptionError) -> Self {
        match err.kind {
            crate::error::CreateAnomalySubscriptionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateAnomalySubscriptionErrorKind::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::error::CreateAnomalySubscriptionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCostCategoryDefinitionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateCostCategoryDefinitionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::CreateCostCategoryDefinitionError) -> Self {
        match err.kind {
            crate::error::CreateCostCategoryDefinitionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::CreateCostCategoryDefinitionErrorKind::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::error::CreateCostCategoryDefinitionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAnomalyMonitorError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteAnomalyMonitorError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteAnomalyMonitorError> for Error {
    fn from(err: crate::error::DeleteAnomalyMonitorError) -> Self {
        match err.kind {
            crate::error::DeleteAnomalyMonitorErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::DeleteAnomalyMonitorErrorKind::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::error::DeleteAnomalyMonitorErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAnomalySubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteAnomalySubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteAnomalySubscriptionError> for Error {
    fn from(err: crate::error::DeleteAnomalySubscriptionError) -> Self {
        match err.kind {
            crate::error::DeleteAnomalySubscriptionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::DeleteAnomalySubscriptionErrorKind::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::error::DeleteAnomalySubscriptionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCostCategoryDefinitionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteCostCategoryDefinitionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::DeleteCostCategoryDefinitionError) -> Self {
        match err.kind {
            crate::error::DeleteCostCategoryDefinitionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::DeleteCostCategoryDefinitionErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::DeleteCostCategoryDefinitionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeCostCategoryDefinitionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeCostCategoryDefinitionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DescribeCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::DescribeCostCategoryDefinitionError) -> Self {
        match err.kind {
            crate::error::DescribeCostCategoryDefinitionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::DescribeCostCategoryDefinitionErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeCostCategoryDefinitionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomaliesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAnomaliesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetAnomaliesError> for Error {
    fn from(err: crate::error::GetAnomaliesError) -> Self {
        match err.kind {
            crate::error::GetAnomaliesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetAnomaliesErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetAnomaliesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomalyMonitorsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAnomalyMonitorsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetAnomalyMonitorsError> for Error {
    fn from(err: crate::error::GetAnomalyMonitorsError) -> Self {
        match err.kind {
            crate::error::GetAnomalyMonitorsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetAnomalyMonitorsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetAnomalyMonitorsErrorKind::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::error::GetAnomalyMonitorsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomalySubscriptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAnomalySubscriptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetAnomalySubscriptionsError> for Error {
    fn from(err: crate::error::GetAnomalySubscriptionsError) -> Self {
        match err.kind {
            crate::error::GetAnomalySubscriptionsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetAnomalySubscriptionsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetAnomalySubscriptionsErrorKind::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::error::GetAnomalySubscriptionsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetCostAndUsageError> for Error {
    fn from(err: crate::error::GetCostAndUsageError) -> Self {
        match err.kind {
            crate::error::GetCostAndUsageErrorKind::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::error::GetCostAndUsageErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetCostAndUsageErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetCostAndUsageErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetCostAndUsageErrorKind::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::error::GetCostAndUsageErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageWithResourcesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageWithResourcesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetCostAndUsageWithResourcesError> for Error {
    fn from(err: crate::error::GetCostAndUsageWithResourcesError) -> Self {
        match err.kind {
            crate::error::GetCostAndUsageWithResourcesErrorKind::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::error::GetCostAndUsageWithResourcesErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetCostAndUsageWithResourcesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetCostAndUsageWithResourcesErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetCostAndUsageWithResourcesErrorKind::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::error::GetCostAndUsageWithResourcesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostCategoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostCategoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetCostCategoriesError> for Error {
    fn from(err: crate::error::GetCostCategoriesError) -> Self {
        match err.kind {
            crate::error::GetCostCategoriesErrorKind::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::error::GetCostCategoriesErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetCostCategoriesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetCostCategoriesErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetCostCategoriesErrorKind::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::error::GetCostCategoriesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostForecastError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostForecastError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetCostForecastError> for Error {
    fn from(err: crate::error::GetCostForecastError) -> Self {
        match err.kind {
            crate::error::GetCostForecastErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetCostForecastErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetCostForecastErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDimensionValuesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDimensionValuesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDimensionValuesError> for Error {
    fn from(err: crate::error::GetDimensionValuesError) -> Self {
        match err.kind {
            crate::error::GetDimensionValuesErrorKind::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::error::GetDimensionValuesErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetDimensionValuesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetDimensionValuesErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetDimensionValuesErrorKind::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::error::GetDimensionValuesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReservationCoverageError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetReservationCoverageError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetReservationCoverageError> for Error {
    fn from(err: crate::error::GetReservationCoverageError) -> Self {
        match err.kind {
            crate::error::GetReservationCoverageErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetReservationCoverageErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetReservationCoverageErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetReservationCoverageErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReservationPurchaseRecommendationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetReservationPurchaseRecommendationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetReservationPurchaseRecommendationError> for Error {
    fn from(err: crate::error::GetReservationPurchaseRecommendationError) -> Self {
        match err.kind {
            crate::error::GetReservationPurchaseRecommendationErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetReservationPurchaseRecommendationErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetReservationPurchaseRecommendationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetReservationPurchaseRecommendationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReservationUtilizationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetReservationUtilizationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetReservationUtilizationError> for Error {
    fn from(err: crate::error::GetReservationUtilizationError) -> Self {
        match err.kind {
            crate::error::GetReservationUtilizationErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetReservationUtilizationErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetReservationUtilizationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetReservationUtilizationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetRightsizingRecommendationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetRightsizingRecommendationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetRightsizingRecommendationError> for Error {
    fn from(err: crate::error::GetRightsizingRecommendationError) -> Self {
        match err.kind {
            crate::error::GetRightsizingRecommendationErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetRightsizingRecommendationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetRightsizingRecommendationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansCoverageError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansCoverageError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetSavingsPlansCoverageError> for Error {
    fn from(err: crate::error::GetSavingsPlansCoverageError) -> Self {
        match err.kind {
            crate::error::GetSavingsPlansCoverageErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetSavingsPlansCoverageErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetSavingsPlansCoverageErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetSavingsPlansCoverageErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansPurchaseRecommendationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansPurchaseRecommendationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetSavingsPlansPurchaseRecommendationError> for Error {
    fn from(err: crate::error::GetSavingsPlansPurchaseRecommendationError) -> Self {
        match err.kind {
            crate::error::GetSavingsPlansPurchaseRecommendationErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetSavingsPlansPurchaseRecommendationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetSavingsPlansPurchaseRecommendationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetSavingsPlansUtilizationError> for Error {
    fn from(err: crate::error::GetSavingsPlansUtilizationError) -> Self {
        match err.kind {
            crate::error::GetSavingsPlansUtilizationErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetSavingsPlansUtilizationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetSavingsPlansUtilizationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationDetailsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationDetailsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetSavingsPlansUtilizationDetailsError> for Error {
    fn from(err: crate::error::GetSavingsPlansUtilizationDetailsError) -> Self {
        match err.kind {
            crate::error::GetSavingsPlansUtilizationDetailsErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetSavingsPlansUtilizationDetailsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetSavingsPlansUtilizationDetailsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetSavingsPlansUtilizationDetailsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTagsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetTagsError> for Error {
    fn from(err: crate::error::GetTagsError) -> Self {
        match err.kind {
            crate::error::GetTagsErrorKind::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::error::GetTagsErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetTagsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::GetTagsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetTagsErrorKind::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::error::GetTagsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetUsageForecastError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetUsageForecastError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetUsageForecastError> for Error {
    fn from(err: crate::error::GetUsageForecastError) -> Self {
        match err.kind {
            crate::error::GetUsageForecastErrorKind::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::error::GetUsageForecastErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::GetUsageForecastErrorKind::UnresolvableUsageUnitException(inner) => Error::UnresolvableUsageUnitException(inner),
            crate::error::GetUsageForecastErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCostAllocationTagsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListCostAllocationTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListCostAllocationTagsError> for Error {
    fn from(err: crate::error::ListCostAllocationTagsError) -> Self {
        match err.kind {
            crate::error::ListCostAllocationTagsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListCostAllocationTagsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ListCostAllocationTagsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCostCategoryDefinitionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListCostCategoryDefinitionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListCostCategoryDefinitionsError> for Error {
    fn from(err: crate::error::ListCostCategoryDefinitionsError) -> Self {
        match err.kind {
            crate::error::ListCostCategoryDefinitionsErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ListCostCategoryDefinitionsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListSavingsPlansPurchaseRecommendationGenerationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListSavingsPlansPurchaseRecommendationGenerationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::error::ListSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err.kind {
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err.kind {
            crate::error::ListTagsForResourceErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ListTagsForResourceErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::ListTagsForResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ProvideAnomalyFeedbackError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ProvideAnomalyFeedbackError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ProvideAnomalyFeedbackError> for Error {
    fn from(err: crate::error::ProvideAnomalyFeedbackError) -> Self {
        match err.kind {
            crate::error::ProvideAnomalyFeedbackErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ProvideAnomalyFeedbackErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StartSavingsPlansPurchaseRecommendationGenerationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::StartSavingsPlansPurchaseRecommendationGenerationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::StartSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::error::StartSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err.kind {
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationErrorKind::GenerationExistsException(inner) => Error::GenerationExistsException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationErrorKind::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err.kind {
            crate::error::TagResourceErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::TagResourceErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::TagResourceErrorKind::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::error::TagResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err.kind {
            crate::error::UntagResourceErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UntagResourceErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::UntagResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAnomalyMonitorError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateAnomalyMonitorError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateAnomalyMonitorError> for Error {
    fn from(err: crate::error::UpdateAnomalyMonitorError) -> Self {
        match err.kind {
            crate::error::UpdateAnomalyMonitorErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UpdateAnomalyMonitorErrorKind::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::error::UpdateAnomalyMonitorErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAnomalySubscriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateAnomalySubscriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateAnomalySubscriptionError> for Error {
    fn from(err: crate::error::UpdateAnomalySubscriptionError) -> Self {
        match err.kind {
            crate::error::UpdateAnomalySubscriptionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UpdateAnomalySubscriptionErrorKind::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::error::UpdateAnomalySubscriptionErrorKind::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::error::UpdateAnomalySubscriptionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCostAllocationTagsStatusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateCostAllocationTagsStatusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateCostAllocationTagsStatusError> for Error {
    fn from(err: crate::error::UpdateCostAllocationTagsStatusError) -> Self {
        match err.kind {
            crate::error::UpdateCostAllocationTagsStatusErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UpdateCostAllocationTagsStatusErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCostCategoryDefinitionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateCostCategoryDefinitionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::UpdateCostCategoryDefinitionError) -> Self {
        match err.kind {
            crate::error::UpdateCostCategoryDefinitionErrorKind::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::UpdateCostCategoryDefinitionErrorKind::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::error::UpdateCostCategoryDefinitionErrorKind::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::error::UpdateCostCategoryDefinitionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl std::error::Error for Error {}

