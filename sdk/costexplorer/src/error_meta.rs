// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The requested report expired. Update the date interval and try again.</p>
    BillExpirationException(crate::error::BillExpirationException),
    /// <p>The requested data is unavailable.</p>
    DataUnavailableException(crate::error::DataUnavailableException),
    /// <p>A request to generate a recommendation is already in progress.</p>
    GenerationExistsException(crate::error::GenerationExistsException),
    /// <p>The pagination token is invalid. Try again without a pagination token.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>You made too many calls in a short period of time. Try again later.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>Your request parameters changed between pages. Try again with the old parameters or without a pagination token.</p>
    RequestChangedException(crate::error::RequestChangedException),
    /// <p> The specified ARN in the request doesn't exist. </p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p> You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource. </p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// <p>The cost anomaly monitor does not exist for the account. </p>
    UnknownMonitorException(crate::error::UnknownMonitorException),
    /// <p>The cost anomaly subscription does not exist for the account. </p>
    UnknownSubscriptionException(crate::error::UnknownSubscriptionException),
    /// <p>Cost Explorer was unable to identify the usage unit. Provide <code>UsageType/UsageTypeGroup</code> filter selections that contain matching units, for example: <code>hours</code>.</p>
    UnresolvableUsageUnitException(crate::error::UnresolvableUsageUnitException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BillExpirationException(inner) => inner.fmt(f),
            Error::DataUnavailableException(inner) => inner.fmt(f),
            Error::GenerationExistsException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::RequestChangedException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::ServiceQuotaExceededException(inner) => inner.fmt(f),
            Error::TooManyTagsException(inner) => inner.fmt(f),
            Error::UnknownMonitorException(inner) => inner.fmt(f),
            Error::UnknownSubscriptionException(inner) => inner.fmt(f),
            Error::UnresolvableUsageUnitException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAnomalyMonitorError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateAnomalyMonitorError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateAnomalyMonitorError> for Error {
    fn from(err: crate::error::CreateAnomalyMonitorError) -> Self {
        match err {
            crate::error::CreateAnomalyMonitorError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAnomalySubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateAnomalySubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateAnomalySubscriptionError> for Error {
    fn from(err: crate::error::CreateAnomalySubscriptionError) -> Self {
        match err {
            crate::error::CreateAnomalySubscriptionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateAnomalySubscriptionError::UnknownMonitorException(inner) => {
                Error::UnknownMonitorException(inner)
            }
            crate::error::CreateAnomalySubscriptionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCostCategoryDefinitionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateCostCategoryDefinitionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::CreateCostCategoryDefinitionError) -> Self {
        match err {
            crate::error::CreateCostCategoryDefinitionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateCostCategoryDefinitionError::ServiceQuotaExceededException(
                inner,
            ) => Error::ServiceQuotaExceededException(inner),
            crate::error::CreateCostCategoryDefinitionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAnomalyMonitorError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteAnomalyMonitorError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteAnomalyMonitorError> for Error {
    fn from(err: crate::error::DeleteAnomalyMonitorError) -> Self {
        match err {
            crate::error::DeleteAnomalyMonitorError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteAnomalyMonitorError::UnknownMonitorException(inner) => {
                Error::UnknownMonitorException(inner)
            }
            crate::error::DeleteAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAnomalySubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteAnomalySubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteAnomalySubscriptionError> for Error {
    fn from(err: crate::error::DeleteAnomalySubscriptionError) -> Self {
        match err {
            crate::error::DeleteAnomalySubscriptionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteAnomalySubscriptionError::UnknownSubscriptionException(inner) => {
                Error::UnknownSubscriptionException(inner)
            }
            crate::error::DeleteAnomalySubscriptionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCostCategoryDefinitionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteCostCategoryDefinitionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::DeleteCostCategoryDefinitionError) -> Self {
        match err {
            crate::error::DeleteCostCategoryDefinitionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteCostCategoryDefinitionError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteCostCategoryDefinitionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeCostCategoryDefinitionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeCostCategoryDefinitionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::DescribeCostCategoryDefinitionError) -> Self {
        match err {
            crate::error::DescribeCostCategoryDefinitionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DescribeCostCategoryDefinitionError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeCostCategoryDefinitionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomaliesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetAnomaliesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetAnomaliesError> for Error {
    fn from(err: crate::error::GetAnomaliesError) -> Self {
        match err {
            crate::error::GetAnomaliesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetAnomaliesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetAnomaliesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomalyMonitorsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetAnomalyMonitorsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetAnomalyMonitorsError> for Error {
    fn from(err: crate::error::GetAnomalyMonitorsError) -> Self {
        match err {
            crate::error::GetAnomalyMonitorsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetAnomalyMonitorsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetAnomalyMonitorsError::UnknownMonitorException(inner) => {
                Error::UnknownMonitorException(inner)
            }
            crate::error::GetAnomalyMonitorsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetAnomalySubscriptionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetAnomalySubscriptionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetAnomalySubscriptionsError> for Error {
    fn from(err: crate::error::GetAnomalySubscriptionsError) -> Self {
        match err {
            crate::error::GetAnomalySubscriptionsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetAnomalySubscriptionsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetAnomalySubscriptionsError::UnknownSubscriptionException(inner) => {
                Error::UnknownSubscriptionException(inner)
            }
            crate::error::GetAnomalySubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCostAndUsageError> for Error {
    fn from(err: crate::error::GetCostAndUsageError) -> Self {
        match err {
            crate::error::GetCostAndUsageError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::error::GetCostAndUsageError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetCostAndUsageError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetCostAndUsageError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCostAndUsageError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::error::GetCostAndUsageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageWithResourcesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCostAndUsageWithResourcesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCostAndUsageWithResourcesError> for Error {
    fn from(err: crate::error::GetCostAndUsageWithResourcesError) -> Self {
        match err {
            crate::error::GetCostAndUsageWithResourcesError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::error::GetCostAndUsageWithResourcesError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetCostAndUsageWithResourcesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetCostAndUsageWithResourcesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCostAndUsageWithResourcesError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::error::GetCostAndUsageWithResourcesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostCategoriesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetCostCategoriesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCostCategoriesError> for Error {
    fn from(err: crate::error::GetCostCategoriesError) -> Self {
        match err {
            crate::error::GetCostCategoriesError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::error::GetCostCategoriesError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetCostCategoriesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetCostCategoriesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCostCategoriesError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::error::GetCostCategoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCostForecastError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCostForecastError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetCostForecastError> for Error {
    fn from(err: crate::error::GetCostForecastError) -> Self {
        match err {
            crate::error::GetCostForecastError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetCostForecastError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetCostForecastError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDimensionValuesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDimensionValuesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDimensionValuesError> for Error {
    fn from(err: crate::error::GetDimensionValuesError) -> Self {
        match err {
            crate::error::GetDimensionValuesError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::error::GetDimensionValuesError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetDimensionValuesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetDimensionValuesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetDimensionValuesError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::error::GetDimensionValuesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReservationCoverageError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetReservationCoverageError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReservationCoverageError> for Error {
    fn from(err: crate::error::GetReservationCoverageError) -> Self {
        match err {
            crate::error::GetReservationCoverageError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetReservationCoverageError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetReservationCoverageError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetReservationCoverageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetReservationPurchaseRecommendationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetReservationPurchaseRecommendationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReservationPurchaseRecommendationError> for Error {
    fn from(err: crate::error::GetReservationPurchaseRecommendationError) -> Self {
        match err {
            crate::error::GetReservationPurchaseRecommendationError::DataUnavailableException(
                inner,
            ) => Error::DataUnavailableException(inner),
            crate::error::GetReservationPurchaseRecommendationError::InvalidNextTokenException(
                inner,
            ) => Error::InvalidNextTokenException(inner),
            crate::error::GetReservationPurchaseRecommendationError::LimitExceededException(
                inner,
            ) => Error::LimitExceededException(inner),
            crate::error::GetReservationPurchaseRecommendationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetReservationUtilizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetReservationUtilizationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetReservationUtilizationError> for Error {
    fn from(err: crate::error::GetReservationUtilizationError) -> Self {
        match err {
            crate::error::GetReservationUtilizationError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetReservationUtilizationError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetReservationUtilizationError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetReservationUtilizationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetRightsizingRecommendationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetRightsizingRecommendationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetRightsizingRecommendationError> for Error {
    fn from(err: crate::error::GetRightsizingRecommendationError) -> Self {
        match err {
            crate::error::GetRightsizingRecommendationError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetRightsizingRecommendationError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetRightsizingRecommendationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansCoverageError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansCoverageError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetSavingsPlansCoverageError> for Error {
    fn from(err: crate::error::GetSavingsPlansCoverageError) -> Self {
        match err {
            crate::error::GetSavingsPlansCoverageError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetSavingsPlansCoverageError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetSavingsPlansCoverageError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetSavingsPlansCoverageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::GetSavingsPlansPurchaseRecommendationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetSavingsPlansPurchaseRecommendationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetSavingsPlansPurchaseRecommendationError> for Error {
    fn from(err: crate::error::GetSavingsPlansPurchaseRecommendationError) -> Self {
        match err {
            crate::error::GetSavingsPlansPurchaseRecommendationError::InvalidNextTokenException(
                inner,
            ) => Error::InvalidNextTokenException(inner),
            crate::error::GetSavingsPlansPurchaseRecommendationError::LimitExceededException(
                inner,
            ) => Error::LimitExceededException(inner),
            crate::error::GetSavingsPlansPurchaseRecommendationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetSavingsPlansUtilizationError> for Error {
    fn from(err: crate::error::GetSavingsPlansUtilizationError) -> Self {
        match err {
            crate::error::GetSavingsPlansUtilizationError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetSavingsPlansUtilizationError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetSavingsPlansUtilizationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::GetSavingsPlansUtilizationDetailsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::GetSavingsPlansUtilizationDetailsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetSavingsPlansUtilizationDetailsError> for Error {
    fn from(err: crate::error::GetSavingsPlansUtilizationDetailsError) -> Self {
        match err {
            crate::error::GetSavingsPlansUtilizationDetailsError::DataUnavailableException(
                inner,
            ) => Error::DataUnavailableException(inner),
            crate::error::GetSavingsPlansUtilizationDetailsError::InvalidNextTokenException(
                inner,
            ) => Error::InvalidNextTokenException(inner),
            crate::error::GetSavingsPlansUtilizationDetailsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetSavingsPlansUtilizationDetailsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetTagsError> for Error {
    fn from(err: crate::error::GetTagsError) -> Self {
        match err {
            crate::error::GetTagsError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::error::GetTagsError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetTagsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::GetTagsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetTagsError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::error::GetTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetUsageForecastError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetUsageForecastError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetUsageForecastError> for Error {
    fn from(err: crate::error::GetUsageForecastError) -> Self {
        match err {
            crate::error::GetUsageForecastError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::error::GetUsageForecastError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::GetUsageForecastError::UnresolvableUsageUnitException(inner) => {
                Error::UnresolvableUsageUnitException(inner)
            }
            crate::error::GetUsageForecastError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCostAllocationTagsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCostAllocationTagsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCostAllocationTagsError> for Error {
    fn from(err: crate::error::ListCostAllocationTagsError) -> Self {
        match err {
            crate::error::ListCostAllocationTagsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListCostAllocationTagsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListCostAllocationTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListCostCategoryDefinitionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListCostCategoryDefinitionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListCostCategoryDefinitionsError> for Error {
    fn from(err: crate::error::ListCostCategoryDefinitionsError) -> Self {
        match err {
            crate::error::ListCostCategoryDefinitionsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListCostCategoryDefinitionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::error::ListSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err {
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ListSavingsPlansPurchaseRecommendationGenerationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListTagsForResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ProvideAnomalyFeedbackError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ProvideAnomalyFeedbackError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ProvideAnomalyFeedbackError> for Error {
    fn from(err: crate::error::ProvideAnomalyFeedbackError) -> Self {
        match err {
            crate::error::ProvideAnomalyFeedbackError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ProvideAnomalyFeedbackError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StartSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::error::StartSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err {
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError::GenerationExistsException(inner) => Error::GenerationExistsException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::error::StartSavingsPlansPurchaseRecommendationGenerationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::TagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TagResourceError::TooManyTagsException(inner) => {
                Error::TooManyTagsException(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UntagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAnomalyMonitorError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateAnomalyMonitorError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateAnomalyMonitorError> for Error {
    fn from(err: crate::error::UpdateAnomalyMonitorError) -> Self {
        match err {
            crate::error::UpdateAnomalyMonitorError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateAnomalyMonitorError::UnknownMonitorException(inner) => {
                Error::UnknownMonitorException(inner)
            }
            crate::error::UpdateAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateAnomalySubscriptionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateAnomalySubscriptionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateAnomalySubscriptionError> for Error {
    fn from(err: crate::error::UpdateAnomalySubscriptionError) -> Self {
        match err {
            crate::error::UpdateAnomalySubscriptionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateAnomalySubscriptionError::UnknownMonitorException(inner) => {
                Error::UnknownMonitorException(inner)
            }
            crate::error::UpdateAnomalySubscriptionError::UnknownSubscriptionException(inner) => {
                Error::UnknownSubscriptionException(inner)
            }
            crate::error::UpdateAnomalySubscriptionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::UpdateCostAllocationTagsStatusError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::UpdateCostAllocationTagsStatusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCostAllocationTagsStatusError> for Error {
    fn from(err: crate::error::UpdateCostAllocationTagsStatusError) -> Self {
        match err {
            crate::error::UpdateCostAllocationTagsStatusError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateCostAllocationTagsStatusError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCostCategoryDefinitionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateCostCategoryDefinitionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateCostCategoryDefinitionError> for Error {
    fn from(err: crate::error::UpdateCostCategoryDefinitionError) -> Self {
        match err {
            crate::error::UpdateCostCategoryDefinitionError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateCostCategoryDefinitionError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateCostCategoryDefinitionError::ServiceQuotaExceededException(
                inner,
            ) => Error::ServiceQuotaExceededException(inner),
            crate::error::UpdateCostCategoryDefinitionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::BillExpirationException(e) => e.request_id(),
            Self::DataUnavailableException(e) => e.request_id(),
            Self::GenerationExistsException(e) => e.request_id(),
            Self::InvalidNextTokenException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::RequestChangedException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::ServiceQuotaExceededException(e) => e.request_id(),
            Self::TooManyTagsException(e) => e.request_id(),
            Self::UnknownMonitorException(e) => e.request_id(),
            Self::UnknownSubscriptionException(e) => e.request_id(),
            Self::UnresolvableUsageUnitException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
