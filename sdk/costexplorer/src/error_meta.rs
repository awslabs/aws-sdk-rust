// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The requested report expired. Update the date interval and try again.</p>
    BillExpirationException(crate::types::error::BillExpirationException),
    /// <p>The requested data is unavailable.</p>
    DataUnavailableException(crate::types::error::DataUnavailableException),
    /// <p>A request to generate a recommendation is already in progress.</p>
    GenerationExistsException(crate::types::error::GenerationExistsException),
    /// <p>The pagination token is invalid. Try again without a pagination token.</p>
    InvalidNextTokenException(crate::types::error::InvalidNextTokenException),
    /// <p>You made too many calls in a short period of time. Try again later.</p>
    LimitExceededException(crate::types::error::LimitExceededException),
    /// <p>Your request parameters changed between pages. Try again with the old parameters or without a pagination token.</p>
    RequestChangedException(crate::types::error::RequestChangedException),
    /// <p> The specified ARN in the request doesn't exist. </p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// <p> You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource. </p>
    ServiceQuotaExceededException(crate::types::error::ServiceQuotaExceededException),
    /// <p>Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.</p>
    TooManyTagsException(crate::types::error::TooManyTagsException),
    /// <p>The cost anomaly monitor does not exist for the account. </p>
    UnknownMonitorException(crate::types::error::UnknownMonitorException),
    /// <p>The cost anomaly subscription does not exist for the account. </p>
    UnknownSubscriptionException(crate::types::error::UnknownSubscriptionException),
    /// <p>Cost Explorer was unable to identify the usage unit. Provide <code>UsageType/UsageTypeGroup</code> filter selections that contain matching units, for example: <code>hours</code>.</p>
    UnresolvableUsageUnitException(crate::types::error::UnresolvableUsageUnitException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BillExpirationException(inner) => inner.fmt(f),
            Error::DataUnavailableException(inner) => inner.fmt(f),
            Error::GenerationExistsException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::RequestChangedException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::ServiceQuotaExceededException(inner) => inner.fmt(f),
            Error::TooManyTagsException(inner) => inner.fmt(f),
            Error::UnknownMonitorException(inner) => inner.fmt(f),
            Error::UnknownSubscriptionException(inner) => inner.fmt(f),
            Error::UnresolvableUsageUnitException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError> for Error {
    fn from(err: crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError) -> Self {
        match err {
            crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::create_anomaly_monitor::CreateAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError> for Error {
    fn from(
        err: crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError,
    ) -> Self {
        match err {
            crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::operation::create_anomaly_subscription::CreateAnomalySubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError>
    for Error
{
    fn from(
        err: crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError,
    ) -> Self {
        match err {
            crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::operation::create_cost_category_definition::CreateCostCategoryDefinitionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError> for Error {
    fn from(err: crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError) -> Self {
        match err {
            crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::operation::delete_anomaly_monitor::DeleteAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError> for Error {
    fn from(
        err: crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError,
    ) -> Self {
        match err {
            crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::operation::delete_anomaly_subscription::DeleteAnomalySubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError>
    for Error
{
    fn from(
        err: crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError,
    ) -> Self {
        match err {
            crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::delete_cost_category_definition::DeleteCostCategoryDefinitionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError>
    for Error
{
    fn from(
        err: crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError,
    ) -> Self {
        match err {
            crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::describe_cost_category_definition::DescribeCostCategoryDefinitionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::get_anomalies::GetAnomaliesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_anomalies::GetAnomaliesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_anomalies::GetAnomaliesError> for Error {
    fn from(err: crate::operation::get_anomalies::GetAnomaliesError) -> Self {
        match err {
            crate::operation::get_anomalies::GetAnomaliesError::InvalidNextTokenException(
                inner,
            ) => Error::InvalidNextTokenException(inner),
            crate::operation::get_anomalies::GetAnomaliesError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::operation::get_anomalies::GetAnomaliesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError> for Error {
    fn from(err: crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError) -> Self {
        match err {
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::operation::get_anomaly_monitors::GetAnomalyMonitorsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError> for Error {
    fn from(
        err: crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError,
    ) -> Self {
        match err {
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::operation::get_anomaly_subscriptions::GetAnomalySubscriptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_cost_and_usage::GetCostAndUsageError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_cost_and_usage::GetCostAndUsageError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_cost_and_usage::GetCostAndUsageError> for Error {
    fn from(err: crate::operation::get_cost_and_usage::GetCostAndUsageError) -> Self {
        match err {
            crate::operation::get_cost_and_usage::GetCostAndUsageError::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::operation::get_cost_and_usage::GetCostAndUsageError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_cost_and_usage::GetCostAndUsageError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_cost_and_usage::GetCostAndUsageError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_cost_and_usage::GetCostAndUsageError::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::operation::get_cost_and_usage::GetCostAndUsageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError>
    for Error
{
    fn from(
        err: crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError,
    ) -> Self {
        match err {
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::operation::get_cost_and_usage_with_resources::GetCostAndUsageWithResourcesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_cost_categories::GetCostCategoriesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_cost_categories::GetCostCategoriesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_cost_categories::GetCostCategoriesError> for Error {
    fn from(err: crate::operation::get_cost_categories::GetCostCategoriesError) -> Self {
        match err {
            crate::operation::get_cost_categories::GetCostCategoriesError::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::operation::get_cost_categories::GetCostCategoriesError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_cost_categories::GetCostCategoriesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_cost_categories::GetCostCategoriesError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_cost_categories::GetCostCategoriesError::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::operation::get_cost_categories::GetCostCategoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_cost_forecast::GetCostForecastError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_cost_forecast::GetCostForecastError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_cost_forecast::GetCostForecastError> for Error {
    fn from(err: crate::operation::get_cost_forecast::GetCostForecastError) -> Self {
        match err {
            crate::operation::get_cost_forecast::GetCostForecastError::DataUnavailableException(
                inner,
            ) => Error::DataUnavailableException(inner),
            crate::operation::get_cost_forecast::GetCostForecastError::LimitExceededException(
                inner,
            ) => Error::LimitExceededException(inner),
            crate::operation::get_cost_forecast::GetCostForecastError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_dimension_values::GetDimensionValuesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_dimension_values::GetDimensionValuesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_dimension_values::GetDimensionValuesError> for Error {
    fn from(err: crate::operation::get_dimension_values::GetDimensionValuesError) -> Self {
        match err {
            crate::operation::get_dimension_values::GetDimensionValuesError::BillExpirationException(inner) => Error::BillExpirationException(inner),
            crate::operation::get_dimension_values::GetDimensionValuesError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_dimension_values::GetDimensionValuesError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_dimension_values::GetDimensionValuesError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_dimension_values::GetDimensionValuesError::RequestChangedException(inner) => Error::RequestChangedException(inner),
            crate::operation::get_dimension_values::GetDimensionValuesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_reservation_coverage::GetReservationCoverageError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_reservation_coverage::GetReservationCoverageError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_reservation_coverage::GetReservationCoverageError> for Error {
    fn from(err: crate::operation::get_reservation_coverage::GetReservationCoverageError) -> Self {
        match err {
            crate::operation::get_reservation_coverage::GetReservationCoverageError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_reservation_coverage::GetReservationCoverageError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_reservation_coverage::GetReservationCoverageError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_reservation_coverage::GetReservationCoverageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError> for Error {
    fn from(err: crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError) -> Self {
        match err {
            crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_reservation_purchase_recommendation::GetReservationPurchaseRecommendationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_reservation_utilization::GetReservationUtilizationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_reservation_utilization::GetReservationUtilizationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_reservation_utilization::GetReservationUtilizationError> for Error {
    fn from(
        err: crate::operation::get_reservation_utilization::GetReservationUtilizationError,
    ) -> Self {
        match err {
            crate::operation::get_reservation_utilization::GetReservationUtilizationError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_reservation_utilization::GetReservationUtilizationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_reservation_utilization::GetReservationUtilizationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_reservation_utilization::GetReservationUtilizationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError>
    for Error
{
    fn from(
        err: crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError,
    ) -> Self {
        match err {
            crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_rightsizing_recommendation::GetRightsizingRecommendationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError> for Error {
    fn from(
        err: crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError,
    ) -> Self {
        match err {
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_savings_plans_coverage::GetSavingsPlansCoverageError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError> for Error {
    fn from(err: crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError) -> Self {
        match err {
            crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_savings_plans_purchase_recommendation::GetSavingsPlansPurchaseRecommendationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError>
    for Error
{
    fn from(
        err: crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError,
    ) -> Self {
        match err {
            crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_savings_plans_utilization::GetSavingsPlansUtilizationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError> for Error {
    fn from(err: crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError) -> Self {
        match err {
            crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_savings_plans_utilization_details::GetSavingsPlansUtilizationDetailsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_tags::GetTagsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_tags::GetTagsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_tags::GetTagsError> for Error {
    fn from(err: crate::operation::get_tags::GetTagsError) -> Self {
        match err {
            crate::operation::get_tags::GetTagsError::BillExpirationException(inner) => {
                Error::BillExpirationException(inner)
            }
            crate::operation::get_tags::GetTagsError::DataUnavailableException(inner) => {
                Error::DataUnavailableException(inner)
            }
            crate::operation::get_tags::GetTagsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::operation::get_tags::GetTagsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::operation::get_tags::GetTagsError::RequestChangedException(inner) => {
                Error::RequestChangedException(inner)
            }
            crate::operation::get_tags::GetTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_usage_forecast::GetUsageForecastError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_usage_forecast::GetUsageForecastError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_usage_forecast::GetUsageForecastError> for Error {
    fn from(err: crate::operation::get_usage_forecast::GetUsageForecastError) -> Self {
        match err {
            crate::operation::get_usage_forecast::GetUsageForecastError::DataUnavailableException(inner) => Error::DataUnavailableException(inner),
            crate::operation::get_usage_forecast::GetUsageForecastError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::get_usage_forecast::GetUsageForecastError::UnresolvableUsageUnitException(inner) => Error::UnresolvableUsageUnitException(inner),
            crate::operation::get_usage_forecast::GetUsageForecastError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError> for Error {
    fn from(err: crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError) -> Self {
        match err {
            crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::list_cost_allocation_tags::ListCostAllocationTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError>
    for Error
{
    fn from(
        err: crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError,
    ) -> Self {
        match err {
            crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::list_cost_category_definitions::ListCostCategoryDefinitionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err {
            crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::list_savings_plans_purchase_recommendation_generation::ListSavingsPlansPurchaseRecommendationGenerationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_tags_for_resource::ListTagsForResourceError> for Error {
    fn from(err: crate::operation::list_tags_for_resource::ListTagsForResourceError) -> Self {
        match err {
            crate::operation::list_tags_for_resource::ListTagsForResourceError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError> for Error {
    fn from(err: crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError) -> Self {
        match err {
            crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::provide_anomaly_feedback::ProvideAnomalyFeedbackError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError> for Error {
    fn from(err: crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError) -> Self {
        match err {
            crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError::GenerationExistsException(inner) => Error::GenerationExistsException(inner),
            crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::operation::start_savings_plans_purchase_recommendation_generation::StartSavingsPlansPurchaseRecommendationGenerationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::tag_resource::TagResourceError> for Error {
    fn from(err: crate::operation::tag_resource::TagResourceError) -> Self {
        match err {
            crate::operation::tag_resource::TagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::operation::tag_resource::TagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::operation::tag_resource::TagResourceError::TooManyTagsException(inner) => {
                Error::TooManyTagsException(inner)
            }
            crate::operation::tag_resource::TagResourceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::untag_resource::UntagResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::untag_resource::UntagResourceError> for Error {
    fn from(err: crate::operation::untag_resource::UntagResourceError) -> Self {
        match err {
            crate::operation::untag_resource::UntagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::operation::untag_resource::UntagResourceError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::operation::untag_resource::UntagResourceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError> for Error {
    fn from(err: crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError) -> Self {
        match err {
            crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::operation::update_anomaly_monitor::UpdateAnomalyMonitorError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError> for Error {
    fn from(
        err: crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError,
    ) -> Self {
        match err {
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError::UnknownMonitorException(inner) => Error::UnknownMonitorException(inner),
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError::UnknownSubscriptionException(inner) => Error::UnknownSubscriptionException(inner),
            crate::operation::update_anomaly_subscription::UpdateAnomalySubscriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError>
    for Error
{
    fn from(
        err: crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError,
    ) -> Self {
        match err {
            crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_cost_allocation_tags_status::UpdateCostAllocationTagsStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError>
    for Error
{
    fn from(
        err: crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError,
    ) -> Self {
        match err {
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError::ResourceNotFoundException(inner) => Error::ResourceNotFoundException(inner),
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError::ServiceQuotaExceededException(inner) => Error::ServiceQuotaExceededException(inner),
            crate::operation::update_cost_category_definition::UpdateCostCategoryDefinitionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::BillExpirationException(e) => e.request_id(),
            Self::DataUnavailableException(e) => e.request_id(),
            Self::GenerationExistsException(e) => e.request_id(),
            Self::InvalidNextTokenException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::RequestChangedException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::ServiceQuotaExceededException(e) => e.request_id(),
            Self::TooManyTagsException(e) => e.request_id(),
            Self::UnknownMonitorException(e) => e.request_id(),
            Self::UnknownSubscriptionException(e) => e.request_id(),
            Self::UnresolvableUsageUnitException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
