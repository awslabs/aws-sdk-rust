// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl CreateAnomalyMonitorInput {
    /// Consumes the builder and constructs an Operation<[`CreateAnomalyMonitor`](crate::operation::CreateAnomalyMonitor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAnomalyMonitor,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAnomalyMonitorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAnomalyMonitorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.CreateAnomalyMonitor",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_anomaly_monitor::ser_create_anomaly_monitor_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAnomalyMonitor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAnomalyMonitor",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateAnomalySubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`CreateAnomalySubscription`](crate::operation::CreateAnomalySubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAnomalySubscription,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAnomalySubscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAnomalySubscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.CreateAnomalySubscription",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_anomaly_subscription::ser_create_anomaly_subscription_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAnomalySubscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAnomalySubscription",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateCostCategoryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`CreateCostCategoryDefinition`](crate::operation::CreateCostCategoryDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCostCategoryDefinition,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCostCategoryDefinitionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCostCategoryDefinitionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.CreateCostCategoryDefinition",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_cost_category_definition::ser_create_cost_category_definition_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCostCategoryDefinition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCostCategoryDefinition",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAnomalyMonitorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAnomalyMonitor`](crate::operation::DeleteAnomalyMonitor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAnomalyMonitor,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAnomalyMonitorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAnomalyMonitorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.DeleteAnomalyMonitor",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_anomaly_monitor::ser_delete_anomaly_monitor_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAnomalyMonitor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAnomalyMonitor",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAnomalySubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAnomalySubscription`](crate::operation::DeleteAnomalySubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAnomalySubscription,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAnomalySubscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAnomalySubscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.DeleteAnomalySubscription",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_anomaly_subscription::ser_delete_anomaly_subscription_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAnomalySubscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAnomalySubscription",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteCostCategoryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCostCategoryDefinition`](crate::operation::DeleteCostCategoryDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCostCategoryDefinition,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCostCategoryDefinitionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCostCategoryDefinitionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.DeleteCostCategoryDefinition",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_cost_category_definition::ser_delete_cost_category_definition_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCostCategoryDefinition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCostCategoryDefinition",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeCostCategoryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeCostCategoryDefinition`](crate::operation::DescribeCostCategoryDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeCostCategoryDefinition,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeCostCategoryDefinitionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeCostCategoryDefinitionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.DescribeCostCategoryDefinition",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_describe_cost_category_definition::ser_describe_cost_category_definition_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeCostCategoryDefinition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeCostCategoryDefinition",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAnomaliesInput {
    /// Consumes the builder and constructs an Operation<[`GetAnomalies`](crate::operation::GetAnomalies)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAnomalies,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAnomaliesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAnomaliesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetAnomalies",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_anomalies::ser_get_anomalies_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAnomalies::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAnomalies",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAnomalyMonitorsInput {
    /// Consumes the builder and constructs an Operation<[`GetAnomalyMonitors`](crate::operation::GetAnomalyMonitors)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAnomalyMonitors,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAnomalyMonitorsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAnomalyMonitorsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetAnomalyMonitors",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_anomaly_monitors::ser_get_anomaly_monitors_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAnomalyMonitors::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAnomalyMonitors",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetAnomalySubscriptionsInput {
    /// Consumes the builder and constructs an Operation<[`GetAnomalySubscriptions`](crate::operation::GetAnomalySubscriptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetAnomalySubscriptions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetAnomalySubscriptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetAnomalySubscriptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetAnomalySubscriptions",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_anomaly_subscriptions::ser_get_anomaly_subscriptions_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetAnomalySubscriptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetAnomalySubscriptions",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCostAndUsageInput {
    /// Consumes the builder and constructs an Operation<[`GetCostAndUsage`](crate::operation::GetCostAndUsage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCostAndUsage,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCostAndUsageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCostAndUsageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetCostAndUsage",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_cost_and_usage::ser_get_cost_and_usage_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCostAndUsage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCostAndUsage",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCostAndUsageWithResourcesInput {
    /// Consumes the builder and constructs an Operation<[`GetCostAndUsageWithResources`](crate::operation::GetCostAndUsageWithResources)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCostAndUsageWithResources,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCostAndUsageWithResourcesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCostAndUsageWithResourcesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetCostAndUsageWithResources",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_cost_and_usage_with_resources::ser_get_cost_and_usage_with_resources_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCostAndUsageWithResources::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCostAndUsageWithResources",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCostCategoriesInput {
    /// Consumes the builder and constructs an Operation<[`GetCostCategories`](crate::operation::GetCostCategories)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCostCategories,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCostCategoriesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCostCategoriesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetCostCategories",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_cost_categories::ser_get_cost_categories_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCostCategories::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCostCategories",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCostForecastInput {
    /// Consumes the builder and constructs an Operation<[`GetCostForecast`](crate::operation::GetCostForecast)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCostForecast,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCostForecastInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCostForecastInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetCostForecast",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_cost_forecast::ser_get_cost_forecast_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCostForecast::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCostForecast",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDimensionValuesInput {
    /// Consumes the builder and constructs an Operation<[`GetDimensionValues`](crate::operation::GetDimensionValues)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDimensionValues,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDimensionValuesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDimensionValuesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetDimensionValues",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_dimension_values::ser_get_dimension_values_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDimensionValues::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDimensionValues",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetReservationCoverageInput {
    /// Consumes the builder and constructs an Operation<[`GetReservationCoverage`](crate::operation::GetReservationCoverage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetReservationCoverage,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetReservationCoverageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetReservationCoverageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetReservationCoverage",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_reservation_coverage::ser_get_reservation_coverage_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetReservationCoverage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetReservationCoverage",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetReservationPurchaseRecommendationInput {
    /// Consumes the builder and constructs an Operation<[`GetReservationPurchaseRecommendation`](crate::operation::GetReservationPurchaseRecommendation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetReservationPurchaseRecommendation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetReservationPurchaseRecommendationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetReservationPurchaseRecommendationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetReservationPurchaseRecommendation",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_reservation_purchase_recommendation::ser_get_reservation_purchase_recommendation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetReservationPurchaseRecommendation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetReservationPurchaseRecommendation",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetReservationUtilizationInput {
    /// Consumes the builder and constructs an Operation<[`GetReservationUtilization`](crate::operation::GetReservationUtilization)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetReservationUtilization,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetReservationUtilizationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetReservationUtilizationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetReservationUtilization",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_reservation_utilization::ser_get_reservation_utilization_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetReservationUtilization::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetReservationUtilization",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetRightsizingRecommendationInput {
    /// Consumes the builder and constructs an Operation<[`GetRightsizingRecommendation`](crate::operation::GetRightsizingRecommendation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRightsizingRecommendation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRightsizingRecommendationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRightsizingRecommendationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetRightsizingRecommendation",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_rightsizing_recommendation::ser_get_rightsizing_recommendation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRightsizingRecommendation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRightsizingRecommendation",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSavingsPlansCoverageInput {
    /// Consumes the builder and constructs an Operation<[`GetSavingsPlansCoverage`](crate::operation::GetSavingsPlansCoverage)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSavingsPlansCoverage,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSavingsPlansCoverageInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSavingsPlansCoverageInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetSavingsPlansCoverage",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_savings_plans_coverage::ser_get_savings_plans_coverage_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSavingsPlansCoverage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSavingsPlansCoverage",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSavingsPlansPurchaseRecommendationInput {
    /// Consumes the builder and constructs an Operation<[`GetSavingsPlansPurchaseRecommendation`](crate::operation::GetSavingsPlansPurchaseRecommendation)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSavingsPlansPurchaseRecommendation,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSavingsPlansPurchaseRecommendationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSavingsPlansPurchaseRecommendationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetSavingsPlansPurchaseRecommendation",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_savings_plans_purchase_recommendation::ser_get_savings_plans_purchase_recommendation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSavingsPlansPurchaseRecommendation::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSavingsPlansPurchaseRecommendation",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSavingsPlansUtilizationInput {
    /// Consumes the builder and constructs an Operation<[`GetSavingsPlansUtilization`](crate::operation::GetSavingsPlansUtilization)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSavingsPlansUtilization,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSavingsPlansUtilizationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSavingsPlansUtilizationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetSavingsPlansUtilization",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_savings_plans_utilization::ser_get_savings_plans_utilization_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSavingsPlansUtilization::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSavingsPlansUtilization",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSavingsPlansUtilizationDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GetSavingsPlansUtilizationDetails`](crate::operation::GetSavingsPlansUtilizationDetails)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSavingsPlansUtilizationDetails,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSavingsPlansUtilizationDetailsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSavingsPlansUtilizationDetailsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetSavingsPlansUtilizationDetails",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_savings_plans_utilization_details::ser_get_savings_plans_utilization_details_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSavingsPlansUtilizationDetails::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSavingsPlansUtilizationDetails",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTagsInput {
    /// Consumes the builder and constructs an Operation<[`GetTags`](crate::operation::GetTags)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTags,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTagsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTagsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetTags",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_tags::ser_get_tags_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetTags::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetTags",
                    "costexplorer",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetUsageForecastInput {
    /// Consumes the builder and constructs an Operation<[`GetUsageForecast`](crate::operation::GetUsageForecast)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetUsageForecast,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetUsageForecastInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetUsageForecastInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.GetUsageForecast",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_usage_forecast::ser_get_usage_forecast_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetUsageForecast::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetUsageForecast",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCostAllocationTagsInput {
    /// Consumes the builder and constructs an Operation<[`ListCostAllocationTags`](crate::operation::ListCostAllocationTags)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCostAllocationTags,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCostAllocationTagsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCostAllocationTagsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.ListCostAllocationTags",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_cost_allocation_tags::ser_list_cost_allocation_tags_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCostAllocationTags::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCostAllocationTags",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCostCategoryDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCostCategoryDefinitions`](crate::operation::ListCostCategoryDefinitions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCostCategoryDefinitions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCostCategoryDefinitionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCostCategoryDefinitionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.ListCostCategoryDefinitions",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_cost_category_definitions::ser_list_cost_category_definitions_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCostCategoryDefinitions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCostCategoryDefinitions",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSavingsPlansPurchaseRecommendationGenerationInput {
    /// Consumes the builder and constructs an Operation<[`ListSavingsPlansPurchaseRecommendationGeneration`](crate::operation::ListSavingsPlansPurchaseRecommendationGeneration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSavingsPlansPurchaseRecommendationGeneration,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.ListSavingsPlansPurchaseRecommendationGeneration",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_savings_plans_purchase_recommendation_generation::ser_list_savings_plans_purchase_recommendation_generation_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSavingsPlansPurchaseRecommendationGeneration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSavingsPlansPurchaseRecommendationGeneration",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.ListTagsForResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_tags_for_resource::ser_list_tags_for_resource_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ProvideAnomalyFeedbackInput {
    /// Consumes the builder and constructs an Operation<[`ProvideAnomalyFeedback`](crate::operation::ProvideAnomalyFeedback)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ProvideAnomalyFeedback,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ProvideAnomalyFeedbackInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ProvideAnomalyFeedbackInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.ProvideAnomalyFeedback",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_provide_anomaly_feedback::ser_provide_anomaly_feedback_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ProvideAnomalyFeedback::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ProvideAnomalyFeedback",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartSavingsPlansPurchaseRecommendationGenerationInput {
    /// Consumes the builder and constructs an Operation<[`StartSavingsPlansPurchaseRecommendationGeneration`](crate::operation::StartSavingsPlansPurchaseRecommendationGeneration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartSavingsPlansPurchaseRecommendationGeneration,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.StartSavingsPlansPurchaseRecommendationGeneration",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_start_savings_plans_purchase_recommendation_generation::ser_start_savings_plans_purchase_recommendation_generation_input(&self)?
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartSavingsPlansPurchaseRecommendationGeneration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartSavingsPlansPurchaseRecommendationGeneration",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.TagResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_tag_resource::ser_tag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.UntagResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_untag_resource::ser_untag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAnomalyMonitorInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAnomalyMonitor`](crate::operation::UpdateAnomalyMonitor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAnomalyMonitor,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAnomalyMonitorInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAnomalyMonitorInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.UpdateAnomalyMonitor",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_anomaly_monitor::ser_update_anomaly_monitor_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAnomalyMonitor::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAnomalyMonitor",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateAnomalySubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateAnomalySubscription`](crate::operation::UpdateAnomalySubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateAnomalySubscription,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateAnomalySubscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateAnomalySubscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.UpdateAnomalySubscription",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_anomaly_subscription::ser_update_anomaly_subscription_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateAnomalySubscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateAnomalySubscription",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateCostAllocationTagsStatusInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCostAllocationTagsStatus`](crate::operation::UpdateCostAllocationTagsStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCostAllocationTagsStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCostAllocationTagsStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCostAllocationTagsStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.UpdateCostAllocationTagsStatus",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_cost_allocation_tags_status::ser_update_cost_allocation_tags_status_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCostAllocationTagsStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCostAllocationTagsStatus",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateCostCategoryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCostCategoryDefinition`](crate::operation::UpdateCostCategoryDefinition)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCostCategoryDefinition,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCostCategoryDefinitionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCostCategoryDefinitionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "AWSInsightsIndexService.UpdateCostCategoryDefinition",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_cost_category_definition::ser_update_cost_category_definition_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCostCategoryDefinition::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCostCategoryDefinition",
            "costexplorer",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category.</p>
    #[doc(hidden)]
    pub cost_category_arn: std::option::Option<std::string::String>,
    /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
    #[doc(hidden)]
    pub effective_start: std::option::Option<std::string::String>,
    /// <p>The rule schema version in this particular Cost Category.</p>
    #[doc(hidden)]
    pub rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
    /// <p>The <code>Expression</code> object used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
    #[doc(hidden)]
    pub rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
    /// <p>The default value for the cost category.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
    #[doc(hidden)]
    pub split_charge_rules:
        std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
}
impl UpdateCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category.</p>
    pub fn cost_category_arn(&self) -> std::option::Option<&str> {
        self.cost_category_arn.as_deref()
    }
    /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
    pub fn effective_start(&self) -> std::option::Option<&str> {
        self.effective_start.as_deref()
    }
    /// <p>The rule schema version in this particular Cost Category.</p>
    pub fn rule_version(&self) -> std::option::Option<&crate::model::CostCategoryRuleVersion> {
        self.rule_version.as_ref()
    }
    /// <p>The <code>Expression</code> object used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::CostCategoryRule]> {
        self.rules.as_deref()
    }
    /// <p>The default value for the cost category.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
    pub fn split_charge_rules(
        &self,
    ) -> std::option::Option<&[crate::model::CostCategorySplitChargeRule]> {
        self.split_charge_rules.as_deref()
    }
}
impl UpdateCostCategoryDefinitionInput {
    /// Creates a new builder-style object to manufacture [`UpdateCostCategoryDefinitionInput`](crate::input::UpdateCostCategoryDefinitionInput).
    pub fn builder() -> crate::input::update_cost_category_definition_input::Builder {
        crate::input::update_cost_category_definition_input::Builder::default()
    }
}

/// See [`UpdateCostCategoryDefinitionInput`](crate::input::UpdateCostCategoryDefinitionInput).
pub mod update_cost_category_definition_input {

    /// A builder for [`UpdateCostCategoryDefinitionInput`](crate::input::UpdateCostCategoryDefinitionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_category_arn: std::option::Option<std::string::String>,
        pub(crate) effective_start: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) split_charge_rules:
            std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
    }
    impl Builder {
        /// <p>The unique identifier for your Cost Category.</p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_arn = Some(input.into());
            self
        }
        /// <p>The unique identifier for your Cost Category.</p>
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_arn = input;
            self
        }
        /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
        pub fn effective_start(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_start = Some(input.into());
            self
        }
        /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
        pub fn set_effective_start(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_start = input;
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn rule_version(mut self, input: crate::model::CostCategoryRuleVersion) -> Self {
            self.rule_version = Some(input);
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn set_rule_version(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleVersion>,
        ) -> Self {
            self.rule_version = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The <code>Expression</code> object used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
        pub fn rules(mut self, input: crate::model::CostCategoryRule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The <code>Expression</code> object used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Appends an item to `split_charge_rules`.
        ///
        /// To override the contents of this collection use [`set_split_charge_rules`](Self::set_split_charge_rules).
        ///
        /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
        pub fn split_charge_rules(
            mut self,
            input: crate::model::CostCategorySplitChargeRule,
        ) -> Self {
            let mut v = self.split_charge_rules.unwrap_or_default();
            v.push(input);
            self.split_charge_rules = Some(v);
            self
        }
        /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
        pub fn set_split_charge_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
        ) -> Self {
            self.split_charge_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCostCategoryDefinitionInput`](crate::input::UpdateCostCategoryDefinitionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateCostCategoryDefinitionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateCostCategoryDefinitionInput {
                cost_category_arn: self.cost_category_arn,
                effective_start: self.effective_start,
                rule_version: self.rule_version,
                rules: self.rules,
                default_value: self.default_value,
                split_charge_rules: self.split_charge_rules,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCostAllocationTagsStatusInput {
    /// <p>The list of <code>CostAllocationTagStatusEntry</code> objects that are used to update cost allocation tags status for this request. </p>
    #[doc(hidden)]
    pub cost_allocation_tags_status:
        std::option::Option<std::vec::Vec<crate::model::CostAllocationTagStatusEntry>>,
}
impl UpdateCostAllocationTagsStatusInput {
    /// <p>The list of <code>CostAllocationTagStatusEntry</code> objects that are used to update cost allocation tags status for this request. </p>
    pub fn cost_allocation_tags_status(
        &self,
    ) -> std::option::Option<&[crate::model::CostAllocationTagStatusEntry]> {
        self.cost_allocation_tags_status.as_deref()
    }
}
impl UpdateCostAllocationTagsStatusInput {
    /// Creates a new builder-style object to manufacture [`UpdateCostAllocationTagsStatusInput`](crate::input::UpdateCostAllocationTagsStatusInput).
    pub fn builder() -> crate::input::update_cost_allocation_tags_status_input::Builder {
        crate::input::update_cost_allocation_tags_status_input::Builder::default()
    }
}

/// See [`UpdateCostAllocationTagsStatusInput`](crate::input::UpdateCostAllocationTagsStatusInput).
pub mod update_cost_allocation_tags_status_input {

    /// A builder for [`UpdateCostAllocationTagsStatusInput`](crate::input::UpdateCostAllocationTagsStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_allocation_tags_status:
            std::option::Option<std::vec::Vec<crate::model::CostAllocationTagStatusEntry>>,
    }
    impl Builder {
        /// Appends an item to `cost_allocation_tags_status`.
        ///
        /// To override the contents of this collection use [`set_cost_allocation_tags_status`](Self::set_cost_allocation_tags_status).
        ///
        /// <p>The list of <code>CostAllocationTagStatusEntry</code> objects that are used to update cost allocation tags status for this request. </p>
        pub fn cost_allocation_tags_status(
            mut self,
            input: crate::model::CostAllocationTagStatusEntry,
        ) -> Self {
            let mut v = self.cost_allocation_tags_status.unwrap_or_default();
            v.push(input);
            self.cost_allocation_tags_status = Some(v);
            self
        }
        /// <p>The list of <code>CostAllocationTagStatusEntry</code> objects that are used to update cost allocation tags status for this request. </p>
        pub fn set_cost_allocation_tags_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostAllocationTagStatusEntry>>,
        ) -> Self {
            self.cost_allocation_tags_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCostAllocationTagsStatusInput`](crate::input::UpdateCostAllocationTagsStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateCostAllocationTagsStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateCostAllocationTagsStatusInput {
                cost_allocation_tags_status: self.cost_allocation_tags_status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAnomalySubscriptionInput {
    /// <p>A cost anomaly subscription Amazon Resource Name (ARN). </p>
    #[doc(hidden)]
    pub subscription_arn: std::option::Option<std::string::String>,
    /// <p>(deprecated)</p>
    /// <p>The update to the threshold value for receiving notifications. </p>
    /// <p>This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression.</p>
    #[deprecated(note = "Threshold has been deprecated in favor of ThresholdExpression")]
    #[doc(hidden)]
    pub threshold: std::option::Option<f64>,
    /// <p>The update to the frequency value that subscribers receive notifications. </p>
    #[doc(hidden)]
    pub frequency: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
    /// <p>A list of cost anomaly monitor ARNs. </p>
    #[doc(hidden)]
    pub monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The update to the subscriber list. </p>
    #[doc(hidden)]
    pub subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
    /// <p>The new name of the subscription. </p>
    #[doc(hidden)]
    pub subscription_name: std::option::Option<std::string::String>,
    /// <p>The update to the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are <code>ANOMALY_TOTAL_IMPACT_ABSOLUTE</code> and <code>ANOMALY_TOTAL_IMPACT_PERCENTAGE</code>. The supported nested expression types are <code>AND</code> and <code>OR</code>. The match option <code>GREATER_THAN_OR_EQUAL</code> is required. Values must be numbers between 0 and 10,000,000,000.</p>
    /// <p>The following are examples of valid ThresholdExpressions:</p>
    /// <ul>
    /// <li> <p>Absolute threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
    /// <li> <p>Percentage threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
    /// <li> <p> <code>AND</code> two thresholds together: <code>{ "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
    /// <li> <p> <code>OR</code> two thresholds together: <code>{ "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub threshold_expression: std::option::Option<crate::model::Expression>,
}
impl UpdateAnomalySubscriptionInput {
    /// <p>A cost anomaly subscription Amazon Resource Name (ARN). </p>
    pub fn subscription_arn(&self) -> std::option::Option<&str> {
        self.subscription_arn.as_deref()
    }
    /// <p>(deprecated)</p>
    /// <p>The update to the threshold value for receiving notifications. </p>
    /// <p>This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression.</p>
    #[deprecated(note = "Threshold has been deprecated in favor of ThresholdExpression")]
    pub fn threshold(&self) -> std::option::Option<f64> {
        self.threshold
    }
    /// <p>The update to the frequency value that subscribers receive notifications. </p>
    pub fn frequency(&self) -> std::option::Option<&crate::model::AnomalySubscriptionFrequency> {
        self.frequency.as_ref()
    }
    /// <p>A list of cost anomaly monitor ARNs. </p>
    pub fn monitor_arn_list(&self) -> std::option::Option<&[std::string::String]> {
        self.monitor_arn_list.as_deref()
    }
    /// <p>The update to the subscriber list. </p>
    pub fn subscribers(&self) -> std::option::Option<&[crate::model::Subscriber]> {
        self.subscribers.as_deref()
    }
    /// <p>The new name of the subscription. </p>
    pub fn subscription_name(&self) -> std::option::Option<&str> {
        self.subscription_name.as_deref()
    }
    /// <p>The update to the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are <code>ANOMALY_TOTAL_IMPACT_ABSOLUTE</code> and <code>ANOMALY_TOTAL_IMPACT_PERCENTAGE</code>. The supported nested expression types are <code>AND</code> and <code>OR</code>. The match option <code>GREATER_THAN_OR_EQUAL</code> is required. Values must be numbers between 0 and 10,000,000,000.</p>
    /// <p>The following are examples of valid ThresholdExpressions:</p>
    /// <ul>
    /// <li> <p>Absolute threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
    /// <li> <p>Percentage threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
    /// <li> <p> <code>AND</code> two thresholds together: <code>{ "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
    /// <li> <p> <code>OR</code> two thresholds together: <code>{ "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
    /// </ul>
    pub fn threshold_expression(&self) -> std::option::Option<&crate::model::Expression> {
        self.threshold_expression.as_ref()
    }
}
impl UpdateAnomalySubscriptionInput {
    /// Creates a new builder-style object to manufacture [`UpdateAnomalySubscriptionInput`](crate::input::UpdateAnomalySubscriptionInput).
    pub fn builder() -> crate::input::update_anomaly_subscription_input::Builder {
        crate::input::update_anomaly_subscription_input::Builder::default()
    }
}

/// See [`UpdateAnomalySubscriptionInput`](crate::input::UpdateAnomalySubscriptionInput).
pub mod update_anomaly_subscription_input {

    /// A builder for [`UpdateAnomalySubscriptionInput`](crate::input::UpdateAnomalySubscriptionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_arn: std::option::Option<std::string::String>,
        pub(crate) threshold: std::option::Option<f64>,
        pub(crate) frequency: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
        pub(crate) monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
        pub(crate) subscription_name: std::option::Option<std::string::String>,
        pub(crate) threshold_expression: std::option::Option<crate::model::Expression>,
    }
    impl Builder {
        /// <p>A cost anomaly subscription Amazon Resource Name (ARN). </p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_arn = Some(input.into());
            self
        }
        /// <p>A cost anomaly subscription Amazon Resource Name (ARN). </p>
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_arn = input;
            self
        }
        /// <p>(deprecated)</p>
        /// <p>The update to the threshold value for receiving notifications. </p>
        /// <p>This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression.</p>
        #[deprecated(note = "Threshold has been deprecated in favor of ThresholdExpression")]
        pub fn threshold(mut self, input: f64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>(deprecated)</p>
        /// <p>The update to the threshold value for receiving notifications. </p>
        /// <p>This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression.</p>
        #[deprecated(note = "Threshold has been deprecated in favor of ThresholdExpression")]
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p>The update to the frequency value that subscribers receive notifications. </p>
        pub fn frequency(mut self, input: crate::model::AnomalySubscriptionFrequency) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>The update to the frequency value that subscribers receive notifications. </p>
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::AnomalySubscriptionFrequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// Appends an item to `monitor_arn_list`.
        ///
        /// To override the contents of this collection use [`set_monitor_arn_list`](Self::set_monitor_arn_list).
        ///
        /// <p>A list of cost anomaly monitor ARNs. </p>
        pub fn monitor_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.monitor_arn_list.unwrap_or_default();
            v.push(input.into());
            self.monitor_arn_list = Some(v);
            self
        }
        /// <p>A list of cost anomaly monitor ARNs. </p>
        pub fn set_monitor_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.monitor_arn_list = input;
            self
        }
        /// Appends an item to `subscribers`.
        ///
        /// To override the contents of this collection use [`set_subscribers`](Self::set_subscribers).
        ///
        /// <p>The update to the subscriber list. </p>
        pub fn subscribers(mut self, input: crate::model::Subscriber) -> Self {
            let mut v = self.subscribers.unwrap_or_default();
            v.push(input);
            self.subscribers = Some(v);
            self
        }
        /// <p>The update to the subscriber list. </p>
        pub fn set_subscribers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
        ) -> Self {
            self.subscribers = input;
            self
        }
        /// <p>The new name of the subscription. </p>
        pub fn subscription_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_name = Some(input.into());
            self
        }
        /// <p>The new name of the subscription. </p>
        pub fn set_subscription_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_name = input;
            self
        }
        /// <p>The update to the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are <code>ANOMALY_TOTAL_IMPACT_ABSOLUTE</code> and <code>ANOMALY_TOTAL_IMPACT_PERCENTAGE</code>. The supported nested expression types are <code>AND</code> and <code>OR</code>. The match option <code>GREATER_THAN_OR_EQUAL</code> is required. Values must be numbers between 0 and 10,000,000,000.</p>
        /// <p>The following are examples of valid ThresholdExpressions:</p>
        /// <ul>
        /// <li> <p>Absolute threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
        /// <li> <p>Percentage threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
        /// <li> <p> <code>AND</code> two thresholds together: <code>{ "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
        /// <li> <p> <code>OR</code> two thresholds together: <code>{ "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
        /// </ul>
        pub fn threshold_expression(mut self, input: crate::model::Expression) -> Self {
            self.threshold_expression = Some(input);
            self
        }
        /// <p>The update to the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are <code>ANOMALY_TOTAL_IMPACT_ABSOLUTE</code> and <code>ANOMALY_TOTAL_IMPACT_PERCENTAGE</code>. The supported nested expression types are <code>AND</code> and <code>OR</code>. The match option <code>GREATER_THAN_OR_EQUAL</code> is required. Values must be numbers between 0 and 10,000,000,000.</p>
        /// <p>The following are examples of valid ThresholdExpressions:</p>
        /// <ul>
        /// <li> <p>Absolute threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
        /// <li> <p>Percentage threshold: <code>{ "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }</code> </p> </li>
        /// <li> <p> <code>AND</code> two thresholds together: <code>{ "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
        /// <li> <p> <code>OR</code> two thresholds together: <code>{ "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }</code> </p> </li>
        /// </ul>
        pub fn set_threshold_expression(
            mut self,
            input: std::option::Option<crate::model::Expression>,
        ) -> Self {
            self.threshold_expression = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAnomalySubscriptionInput`](crate::input::UpdateAnomalySubscriptionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAnomalySubscriptionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAnomalySubscriptionInput {
                subscription_arn: self.subscription_arn,
                threshold: self.threshold,
                frequency: self.frequency,
                monitor_arn_list: self.monitor_arn_list,
                subscribers: self.subscribers,
                subscription_name: self.subscription_name,
                threshold_expression: self.threshold_expression,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAnomalyMonitorInput {
    /// <p>Cost anomaly monitor Amazon Resource Names (ARNs). </p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>The new name for the cost anomaly monitor. </p>
    #[doc(hidden)]
    pub monitor_name: std::option::Option<std::string::String>,
}
impl UpdateAnomalyMonitorInput {
    /// <p>Cost anomaly monitor Amazon Resource Names (ARNs). </p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>The new name for the cost anomaly monitor. </p>
    pub fn monitor_name(&self) -> std::option::Option<&str> {
        self.monitor_name.as_deref()
    }
}
impl UpdateAnomalyMonitorInput {
    /// Creates a new builder-style object to manufacture [`UpdateAnomalyMonitorInput`](crate::input::UpdateAnomalyMonitorInput).
    pub fn builder() -> crate::input::update_anomaly_monitor_input::Builder {
        crate::input::update_anomaly_monitor_input::Builder::default()
    }
}

/// See [`UpdateAnomalyMonitorInput`](crate::input::UpdateAnomalyMonitorInput).
pub mod update_anomaly_monitor_input {

    /// A builder for [`UpdateAnomalyMonitorInput`](crate::input::UpdateAnomalyMonitorInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) monitor_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Cost anomaly monitor Amazon Resource Names (ARNs). </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>Cost anomaly monitor Amazon Resource Names (ARNs). </p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>The new name for the cost anomaly monitor. </p>
        pub fn monitor_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_name = Some(input.into());
            self
        }
        /// <p>The new name for the cost anomaly monitor. </p>
        pub fn set_monitor_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_name = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAnomalyMonitorInput`](crate::input::UpdateAnomalyMonitorInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateAnomalyMonitorInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateAnomalyMonitorInput {
                monitor_arn: self.monitor_arn,
                monitor_name: self.monitor_name,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use. </p>
    #[doc(hidden)]
    pub resource_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use. </p>
    pub fn resource_tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.resource_tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) resource_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `resource_tag_keys`.
        ///
        /// To override the contents of this collection use [`set_resource_tag_keys`](Self::set_resource_tag_keys).
        ///
        /// <p>A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use. </p>
        pub fn resource_tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_tag_keys.unwrap_or_default();
            v.push(input.into());
            self.resource_tag_keys = Some(v);
            self
        }
        /// <p>A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use. </p>
        pub fn set_resource_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                resource_tag_keys: self.resource_tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p> A list of tag key-value pairs to be added to the resource.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p> A list of tag key-value pairs to be added to the resource.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p> A list of tag key-value pairs to be added to the resource.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p> A list of tag key-value pairs to be added to the resource.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                resource_tags: self.resource_tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartSavingsPlansPurchaseRecommendationGenerationInput {}
impl StartSavingsPlansPurchaseRecommendationGenerationInput {
    /// Creates a new builder-style object to manufacture [`StartSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput).
    pub fn builder(
    ) -> crate::input::start_savings_plans_purchase_recommendation_generation_input::Builder {
        crate::input::start_savings_plans_purchase_recommendation_generation_input::Builder::default(
        )
    }
}

/// See [`StartSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput).
pub mod start_savings_plans_purchase_recommendation_generation_input {

    /// A builder for [`StartSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StartSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartSavingsPlansPurchaseRecommendationGenerationInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvideAnomalyFeedbackInput {
    /// <p>A cost anomaly ID. </p>
    #[doc(hidden)]
    pub anomaly_id: std::option::Option<std::string::String>,
    /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
    #[doc(hidden)]
    pub feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
}
impl ProvideAnomalyFeedbackInput {
    /// <p>A cost anomaly ID. </p>
    pub fn anomaly_id(&self) -> std::option::Option<&str> {
        self.anomaly_id.as_deref()
    }
    /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
    pub fn feedback(&self) -> std::option::Option<&crate::model::AnomalyFeedbackType> {
        self.feedback.as_ref()
    }
}
impl ProvideAnomalyFeedbackInput {
    /// Creates a new builder-style object to manufacture [`ProvideAnomalyFeedbackInput`](crate::input::ProvideAnomalyFeedbackInput).
    pub fn builder() -> crate::input::provide_anomaly_feedback_input::Builder {
        crate::input::provide_anomaly_feedback_input::Builder::default()
    }
}

/// See [`ProvideAnomalyFeedbackInput`](crate::input::ProvideAnomalyFeedbackInput).
pub mod provide_anomaly_feedback_input {

    /// A builder for [`ProvideAnomalyFeedbackInput`](crate::input::ProvideAnomalyFeedbackInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) anomaly_id: std::option::Option<std::string::String>,
        pub(crate) feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
    }
    impl Builder {
        /// <p>A cost anomaly ID. </p>
        pub fn anomaly_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.anomaly_id = Some(input.into());
            self
        }
        /// <p>A cost anomaly ID. </p>
        pub fn set_anomaly_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.anomaly_id = input;
            self
        }
        /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
        pub fn feedback(mut self, input: crate::model::AnomalyFeedbackType) -> Self {
            self.feedback = Some(input);
            self
        }
        /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
        pub fn set_feedback(
            mut self,
            input: std::option::Option<crate::model::AnomalyFeedbackType>,
        ) -> Self {
            self.feedback = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvideAnomalyFeedbackInput`](crate::input::ProvideAnomalyFeedbackInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ProvideAnomalyFeedbackInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ProvideAnomalyFeedbackInput {
                anomaly_id: self.anomaly_id,
                feedback: self.feedback,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html">ResourceTag</a>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSavingsPlansPurchaseRecommendationGenerationInput {
    /// <p>The status of the recommendation generation.</p>
    #[doc(hidden)]
    pub generation_status: std::option::Option<crate::model::GenerationStatus>,
    /// <p>The IDs for each specific recommendation.</p>
    #[doc(hidden)]
    pub recommendation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    #[doc(hidden)]
    pub page_size: i32,
    /// <p>The token to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl ListSavingsPlansPurchaseRecommendationGenerationInput {
    /// <p>The status of the recommendation generation.</p>
    pub fn generation_status(&self) -> std::option::Option<&crate::model::GenerationStatus> {
        self.generation_status.as_ref()
    }
    /// <p>The IDs for each specific recommendation.</p>
    pub fn recommendation_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.recommendation_ids.as_deref()
    }
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    pub fn page_size(&self) -> i32 {
        self.page_size
    }
    /// <p>The token to retrieve the next set of results.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl ListSavingsPlansPurchaseRecommendationGenerationInput {
    /// Creates a new builder-style object to manufacture [`ListSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput).
    pub fn builder(
    ) -> crate::input::list_savings_plans_purchase_recommendation_generation_input::Builder {
        crate::input::list_savings_plans_purchase_recommendation_generation_input::Builder::default(
        )
    }
}

/// See [`ListSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput).
pub mod list_savings_plans_purchase_recommendation_generation_input {

    /// A builder for [`ListSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) generation_status: std::option::Option<crate::model::GenerationStatus>,
        pub(crate) recommendation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the recommendation generation.</p>
        pub fn generation_status(mut self, input: crate::model::GenerationStatus) -> Self {
            self.generation_status = Some(input);
            self
        }
        /// <p>The status of the recommendation generation.</p>
        pub fn set_generation_status(
            mut self,
            input: std::option::Option<crate::model::GenerationStatus>,
        ) -> Self {
            self.generation_status = input;
            self
        }
        /// Appends an item to `recommendation_ids`.
        ///
        /// To override the contents of this collection use [`set_recommendation_ids`](Self::set_recommendation_ids).
        ///
        /// <p>The IDs for each specific recommendation.</p>
        pub fn recommendation_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.recommendation_ids.unwrap_or_default();
            v.push(input.into());
            self.recommendation_ids = Some(v);
            self
        }
        /// <p>The IDs for each specific recommendation.</p>
        pub fn set_recommendation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.recommendation_ids = input;
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSavingsPlansPurchaseRecommendationGenerationInput`](crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::ListSavingsPlansPurchaseRecommendationGenerationInput {
                    generation_status: self.generation_status,
                    recommendation_ids: self.recommendation_ids,
                    page_size: self.page_size.unwrap_or_default(),
                    next_page_token: self.next_page_token,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCostCategoryDefinitionsInput {
    /// <p>The date when the Cost Category was effective. </p>
    #[doc(hidden)]
    pub effective_on: std::option::Option<std::string::String>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of entries a paginated response contains. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListCostCategoryDefinitionsInput {
    /// <p>The date when the Cost Category was effective. </p>
    pub fn effective_on(&self) -> std::option::Option<&str> {
        self.effective_on.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The number of entries a paginated response contains. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListCostCategoryDefinitionsInput {
    /// Creates a new builder-style object to manufacture [`ListCostCategoryDefinitionsInput`](crate::input::ListCostCategoryDefinitionsInput).
    pub fn builder() -> crate::input::list_cost_category_definitions_input::Builder {
        crate::input::list_cost_category_definitions_input::Builder::default()
    }
}

/// See [`ListCostCategoryDefinitionsInput`](crate::input::ListCostCategoryDefinitionsInput).
pub mod list_cost_category_definitions_input {

    /// A builder for [`ListCostCategoryDefinitionsInput`](crate::input::ListCostCategoryDefinitionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) effective_on: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The date when the Cost Category was effective. </p>
        pub fn effective_on(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_on = Some(input.into());
            self
        }
        /// <p>The date when the Cost Category was effective. </p>
        pub fn set_effective_on(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.effective_on = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCostCategoryDefinitionsInput`](crate::input::ListCostCategoryDefinitionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListCostCategoryDefinitionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListCostCategoryDefinitionsInput {
                effective_on: self.effective_on,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCostAllocationTagsInput {
    /// <p>The status of cost allocation tag keys that are returned for this request. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CostAllocationTagStatus>,
    /// <p>The list of cost allocation tag keys that are returned for this request. </p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The type of <code>CostAllocationTag</code> object that are returned for this request. The <code>AWSGenerated</code> type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The <code>UserDefined</code> type tags are tags that you define, create, and apply to resources. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::CostAllocationTagType>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that are returned for this request. By default, the request returns 100 results. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListCostAllocationTagsInput {
    /// <p>The status of cost allocation tag keys that are returned for this request. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::CostAllocationTagStatus> {
        self.status.as_ref()
    }
    /// <p>The list of cost allocation tag keys that are returned for this request. </p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
    /// <p>The type of <code>CostAllocationTag</code> object that are returned for this request. The <code>AWSGenerated</code> type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The <code>UserDefined</code> type tags are tags that you define, create, and apply to resources. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::CostAllocationTagType> {
        self.r#type.as_ref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of objects that are returned for this request. By default, the request returns 100 results. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListCostAllocationTagsInput {
    /// Creates a new builder-style object to manufacture [`ListCostAllocationTagsInput`](crate::input::ListCostAllocationTagsInput).
    pub fn builder() -> crate::input::list_cost_allocation_tags_input::Builder {
        crate::input::list_cost_allocation_tags_input::Builder::default()
    }
}

/// See [`ListCostAllocationTagsInput`](crate::input::ListCostAllocationTagsInput).
pub mod list_cost_allocation_tags_input {

    /// A builder for [`ListCostAllocationTagsInput`](crate::input::ListCostAllocationTagsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::CostAllocationTagStatus>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) r#type: std::option::Option<crate::model::CostAllocationTagType>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The status of cost allocation tag keys that are returned for this request. </p>
        pub fn status(mut self, input: crate::model::CostAllocationTagStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of cost allocation tag keys that are returned for this request. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CostAllocationTagStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The list of cost allocation tag keys that are returned for this request. </p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The list of cost allocation tag keys that are returned for this request. </p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// <p>The type of <code>CostAllocationTag</code> object that are returned for this request. The <code>AWSGenerated</code> type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The <code>UserDefined</code> type tags are tags that you define, create, and apply to resources. </p>
        pub fn r#type(mut self, input: crate::model::CostAllocationTagType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of <code>CostAllocationTag</code> object that are returned for this request. The <code>AWSGenerated</code> type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The <code>UserDefined</code> type tags are tags that you define, create, and apply to resources. </p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::CostAllocationTagType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of objects that are returned for this request. By default, the request returns 100 results. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of objects that are returned for this request. By default, the request returns 100 results. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCostAllocationTagsInput`](crate::input::ListCostAllocationTagsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListCostAllocationTagsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListCostAllocationTagsInput {
                status: self.status,
                tag_keys: self.tag_keys,
                r#type: self.r#type,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetUsageForecastInput {
    /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Which metric Cost Explorer uses to create your forecast.</p>
    /// <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
    /// <ul>
    /// <li> <p>USAGE_QUANTITY</p> </li>
    /// <li> <p>NORMALIZED_USAGE_AMOUNT</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub metric: std::option::Option<crate::model::Metric>,
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>AZ</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
    /// <li> <p> <code>OPERATION</code> </p> </li>
    /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
    /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
    /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
    /// <li> <p> <code>TENANCY</code> </p> </li>
    /// <li> <p> <code>SCOPE</code> </p> </li>
    /// <li> <p> <code>PLATFORM</code> </p> </li>
    /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
    /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
    /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
    /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    #[doc(hidden)]
    pub prediction_interval_level: std::option::Option<i32>,
}
impl GetUsageForecastInput {
    /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Which metric Cost Explorer uses to create your forecast.</p>
    /// <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
    /// <ul>
    /// <li> <p>USAGE_QUANTITY</p> </li>
    /// <li> <p>NORMALIZED_USAGE_AMOUNT</p> </li>
    /// </ul>
    pub fn metric(&self) -> std::option::Option<&crate::model::Metric> {
        self.metric.as_ref()
    }
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>AZ</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
    /// <li> <p> <code>OPERATION</code> </p> </li>
    /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
    /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
    /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
    /// <li> <p> <code>TENANCY</code> </p> </li>
    /// <li> <p> <code>SCOPE</code> </p> </li>
    /// <li> <p> <code>PLATFORM</code> </p> </li>
    /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
    /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
    /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
    /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// </ul>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    pub fn prediction_interval_level(&self) -> std::option::Option<i32> {
        self.prediction_interval_level
    }
}
impl GetUsageForecastInput {
    /// Creates a new builder-style object to manufacture [`GetUsageForecastInput`](crate::input::GetUsageForecastInput).
    pub fn builder() -> crate::input::get_usage_forecast_input::Builder {
        crate::input::get_usage_forecast_input::Builder::default()
    }
}

/// See [`GetUsageForecastInput`](crate::input::GetUsageForecastInput).
pub mod get_usage_forecast_input {

    /// A builder for [`GetUsageForecastInput`](crate::input::GetUsageForecastInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) metric: std::option::Option<crate::model::Metric>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) prediction_interval_level: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast.</p>
        /// <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
        /// <ul>
        /// <li> <p>USAGE_QUANTITY</p> </li>
        /// <li> <p>NORMALIZED_USAGE_AMOUNT</p> </li>
        /// </ul>
        pub fn metric(mut self, input: crate::model::Metric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast.</p>
        /// <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
        /// <ul>
        /// <li> <p>USAGE_QUANTITY</p> </li>
        /// <li> <p>NORMALIZED_USAGE_AMOUNT</p> </li>
        /// </ul>
        pub fn set_metric(mut self, input: std::option::Option<crate::model::Metric>) -> Self {
            self.metric = input;
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>AZ</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
        /// <li> <p> <code>OPERATION</code> </p> </li>
        /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
        /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
        /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
        /// <li> <p> <code>TENANCY</code> </p> </li>
        /// <li> <p> <code>SCOPE</code> </p> </li>
        /// <li> <p> <code>PLATFORM</code> </p> </li>
        /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
        /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
        /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
        /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// </ul>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>AZ</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
        /// <li> <p> <code>OPERATION</code> </p> </li>
        /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
        /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
        /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
        /// <li> <p> <code>TENANCY</code> </p> </li>
        /// <li> <p> <code>SCOPE</code> </p> </li>
        /// <li> <p> <code>PLATFORM</code> </p> </li>
        /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
        /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
        /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
        /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// </ul>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn prediction_interval_level(mut self, input: i32) -> Self {
            self.prediction_interval_level = Some(input);
            self
        }
        /// <p>Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn set_prediction_interval_level(mut self, input: std::option::Option<i32>) -> Self {
            self.prediction_interval_level = input;
            self
        }
        /// Consumes the builder and constructs a [`GetUsageForecastInput`](crate::input::GetUsageForecastInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetUsageForecastInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetUsageForecastInput {
                time_period: self.time_period,
                metric: self.metric,
                granularity: self.granularity,
                filter: self.filter,
                prediction_interval_level: self.prediction_interval_level,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTagsInput {
    /// <p>The value that you want to search for.</p>
    #[doc(hidden)]
    pub search_string: std::option::Option<std::string::String>,
    /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The key of the tag that you want to return values for.</p>
    #[doc(hidden)]
    pub tag_key: std::option::Option<std::string::String>,
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The key represents cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    /// <p>When you use <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetTags</code>, MaxResults has an upper quota of 1000.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetTagsInput {
    /// <p>The value that you want to search for.</p>
    pub fn search_string(&self) -> std::option::Option<&str> {
        self.search_string.as_deref()
    }
    /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>The key of the tag that you want to return values for.</p>
    pub fn tag_key(&self) -> std::option::Option<&str> {
        self.tag_key.as_deref()
    }
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The key represents cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    /// <p>When you use <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
    pub fn sort_by(&self) -> std::option::Option<&[crate::model::SortDefinition]> {
        self.sort_by.as_deref()
    }
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetTags</code>, MaxResults has an upper quota of 1000.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetTagsInput {
    /// Creates a new builder-style object to manufacture [`GetTagsInput`](crate::input::GetTagsInput).
    pub fn builder() -> crate::input::get_tags_input::Builder {
        crate::input::get_tags_input::Builder::default()
    }
}

/// See [`GetTagsInput`](crate::input::GetTagsInput).
pub mod get_tags_input {

    /// A builder for [`GetTagsInput`](crate::input::GetTagsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) search_string: std::option::Option<std::string::String>,
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) tag_key: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value that you want to search for.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.search_string = Some(input.into());
            self
        }
        /// <p>The value that you want to search for.</p>
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.search_string = input;
            self
        }
        /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>The key of the tag that you want to return values for.</p>
        pub fn tag_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.tag_key = Some(input.into());
            self
        }
        /// <p>The key of the tag that you want to return values for.</p>
        pub fn set_tag_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.tag_key = input;
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `sort_by`.
        ///
        /// To override the contents of this collection use [`set_sort_by`](Self::set_sort_by).
        ///
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        /// <p>When you use <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            let mut v = self.sort_by.unwrap_or_default();
            v.push(input);
            self.sort_by = Some(v);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        /// <p>When you use <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetTags</code>, MaxResults has an upper quota of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetTags</code>, MaxResults has an upper quota of 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTagsInput`](crate::input::GetTagsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetTagsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetTagsInput {
                search_string: self.search_string,
                time_period: self.time_period,
                tag_key: self.tag_key,
                filter: self.filter,
                sort_by: self.sort_by,
                max_results: self.max_results.unwrap_or_default(),
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSavingsPlansUtilizationDetailsInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansUtilizationDetails</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The data type.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<std::vec::Vec<crate::model::SavingsPlansDataType>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>TotalCommitment</code> </p> </li>
    /// <li> <p> <code>UsedCommitment</code> </p> </li>
    /// <li> <p> <code>UnusedCommitment</code> </p> </li>
    /// <li> <p> <code>NetSavings</code> </p> </li>
    /// <li> <p> <code>AmortizedRecurringCommitment</code> </p> </li>
    /// <li> <p> <code>AmortizedUpfrontCommitment</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::SortDefinition>,
}
impl GetSavingsPlansUtilizationDetailsInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansUtilizationDetails</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The data type.</p>
    pub fn data_type(&self) -> std::option::Option<&[crate::model::SavingsPlansDataType]> {
        self.data_type.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>TotalCommitment</code> </p> </li>
    /// <li> <p> <code>UsedCommitment</code> </p> </li>
    /// <li> <p> <code>UnusedCommitment</code> </p> </li>
    /// <li> <p> <code>NetSavings</code> </p> </li>
    /// <li> <p> <code>AmortizedRecurringCommitment</code> </p> </li>
    /// <li> <p> <code>AmortizedUpfrontCommitment</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::SortDefinition> {
        self.sort_by.as_ref()
    }
}
impl GetSavingsPlansUtilizationDetailsInput {
    /// Creates a new builder-style object to manufacture [`GetSavingsPlansUtilizationDetailsInput`](crate::input::GetSavingsPlansUtilizationDetailsInput).
    pub fn builder() -> crate::input::get_savings_plans_utilization_details_input::Builder {
        crate::input::get_savings_plans_utilization_details_input::Builder::default()
    }
}

/// See [`GetSavingsPlansUtilizationDetailsInput`](crate::input::GetSavingsPlansUtilizationDetailsInput).
pub mod get_savings_plans_utilization_details_input {

    /// A builder for [`GetSavingsPlansUtilizationDetailsInput`](crate::input::GetSavingsPlansUtilizationDetailsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) data_type:
            std::option::Option<std::vec::Vec<crate::model::SavingsPlansDataType>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) sort_by: std::option::Option<crate::model::SortDefinition>,
    }
    impl Builder {
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansUtilizationDetails</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansUtilizationDetails</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `data_type`.
        ///
        /// To override the contents of this collection use [`set_data_type`](Self::set_data_type).
        ///
        /// <p>The data type.</p>
        pub fn data_type(mut self, input: crate::model::SavingsPlansDataType) -> Self {
            let mut v = self.data_type.unwrap_or_default();
            v.push(input);
            self.data_type = Some(v);
            self
        }
        /// <p>The data type.</p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SavingsPlansDataType>>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>TotalCommitment</code> </p> </li>
        /// <li> <p> <code>UsedCommitment</code> </p> </li>
        /// <li> <p> <code>UnusedCommitment</code> </p> </li>
        /// <li> <p> <code>NetSavings</code> </p> </li>
        /// <li> <p> <code>AmortizedRecurringCommitment</code> </p> </li>
        /// <li> <p> <code>AmortizedUpfrontCommitment</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>TotalCommitment</code> </p> </li>
        /// <li> <p> <code>UsedCommitment</code> </p> </li>
        /// <li> <p> <code>UnusedCommitment</code> </p> </li>
        /// <li> <p> <code>NetSavings</code> </p> </li>
        /// <li> <p> <code>AmortizedRecurringCommitment</code> </p> </li>
        /// <li> <p> <code>AmortizedUpfrontCommitment</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSavingsPlansUtilizationDetailsInput`](crate::input::GetSavingsPlansUtilizationDetailsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSavingsPlansUtilizationDetailsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSavingsPlansUtilizationDetailsInput {
                time_period: self.time_period,
                filter: self.filter,
                data_type: self.data_type,
                next_token: self.next_token,
                max_results: self.max_results,
                sort_by: self.sort_by,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSavingsPlansUtilizationInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
    /// <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLANS_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>TotalCommitment</code> </p> </li>
    /// <li> <p> <code>UsedCommitment</code> </p> </li>
    /// <li> <p> <code>UnusedCommitment</code> </p> </li>
    /// <li> <p> <code>NetSavings</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::SortDefinition>,
}
impl GetSavingsPlansUtilizationInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
    /// <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLANS_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>TotalCommitment</code> </p> </li>
    /// <li> <p> <code>UsedCommitment</code> </p> </li>
    /// <li> <p> <code>UnusedCommitment</code> </p> </li>
    /// <li> <p> <code>NetSavings</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::SortDefinition> {
        self.sort_by.as_ref()
    }
}
impl GetSavingsPlansUtilizationInput {
    /// Creates a new builder-style object to manufacture [`GetSavingsPlansUtilizationInput`](crate::input::GetSavingsPlansUtilizationInput).
    pub fn builder() -> crate::input::get_savings_plans_utilization_input::Builder {
        crate::input::get_savings_plans_utilization_input::Builder::default()
    }
}

/// See [`GetSavingsPlansUtilizationInput`](crate::input::GetSavingsPlansUtilizationInput).
pub mod get_savings_plans_utilization_input {

    /// A builder for [`GetSavingsPlansUtilizationInput`](crate::input::GetSavingsPlansUtilizationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) sort_by: std::option::Option<crate::model::SortDefinition>,
    }
    impl Builder {
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
        /// <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
        /// <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLANS_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLANS_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>PAYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>TotalCommitment</code> </p> </li>
        /// <li> <p> <code>UsedCommitment</code> </p> </li>
        /// <li> <p> <code>UnusedCommitment</code> </p> </li>
        /// <li> <p> <code>NetSavings</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>TotalCommitment</code> </p> </li>
        /// <li> <p> <code>UsedCommitment</code> </p> </li>
        /// <li> <p> <code>UnusedCommitment</code> </p> </li>
        /// <li> <p> <code>NetSavings</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSavingsPlansUtilizationInput`](crate::input::GetSavingsPlansUtilizationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSavingsPlansUtilizationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSavingsPlansUtilizationInput {
                time_period: self.time_period,
                granularity: self.granularity,
                filter: self.filter,
                sort_by: self.sort_by,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSavingsPlansPurchaseRecommendationInput {
    /// <p>The Savings Plans recommendation type that's requested.</p>
    #[doc(hidden)]
    pub savings_plans_type: std::option::Option<crate::model::SupportedSavingsPlansType>,
    /// <p>The savings plan recommendation term that's used to generate these recommendations.</p>
    #[doc(hidden)]
    pub term_in_years: std::option::Option<crate::model::TermInYears>,
    /// <p>The payment option that's used to generate these recommendations.</p>
    #[doc(hidden)]
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    #[doc(hidden)]
    pub account_scope: std::option::Option<crate::model::AccountScope>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    #[doc(hidden)]
    pub page_size: i32,
    /// <p>The lookback period that's used to generate the recommendation.</p>
    #[doc(hidden)]
    pub lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
    /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code> dimension. To filter your recommendations by Account ID, specify <code>Key</code> as <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for.</p>
    /// <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> doesn't include <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>. With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. <code>AND</code> and <code>OR</code> operators are not supported.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
}
impl GetSavingsPlansPurchaseRecommendationInput {
    /// <p>The Savings Plans recommendation type that's requested.</p>
    pub fn savings_plans_type(
        &self,
    ) -> std::option::Option<&crate::model::SupportedSavingsPlansType> {
        self.savings_plans_type.as_ref()
    }
    /// <p>The savings plan recommendation term that's used to generate these recommendations.</p>
    pub fn term_in_years(&self) -> std::option::Option<&crate::model::TermInYears> {
        self.term_in_years.as_ref()
    }
    /// <p>The payment option that's used to generate these recommendations.</p>
    pub fn payment_option(&self) -> std::option::Option<&crate::model::PaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    pub fn account_scope(&self) -> std::option::Option<&crate::model::AccountScope> {
        self.account_scope.as_ref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    pub fn page_size(&self) -> i32 {
        self.page_size
    }
    /// <p>The lookback period that's used to generate the recommendation.</p>
    pub fn lookback_period_in_days(
        &self,
    ) -> std::option::Option<&crate::model::LookbackPeriodInDays> {
        self.lookback_period_in_days.as_ref()
    }
    /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code> dimension. To filter your recommendations by Account ID, specify <code>Key</code> as <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for.</p>
    /// <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> doesn't include <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>. With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. <code>AND</code> and <code>OR</code> operators are not supported.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
}
impl GetSavingsPlansPurchaseRecommendationInput {
    /// Creates a new builder-style object to manufacture [`GetSavingsPlansPurchaseRecommendationInput`](crate::input::GetSavingsPlansPurchaseRecommendationInput).
    pub fn builder() -> crate::input::get_savings_plans_purchase_recommendation_input::Builder {
        crate::input::get_savings_plans_purchase_recommendation_input::Builder::default()
    }
}

/// See [`GetSavingsPlansPurchaseRecommendationInput`](crate::input::GetSavingsPlansPurchaseRecommendationInput).
pub mod get_savings_plans_purchase_recommendation_input {

    /// A builder for [`GetSavingsPlansPurchaseRecommendationInput`](crate::input::GetSavingsPlansPurchaseRecommendationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) savings_plans_type: std::option::Option<crate::model::SupportedSavingsPlansType>,
        pub(crate) term_in_years: std::option::Option<crate::model::TermInYears>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) account_scope: std::option::Option<crate::model::AccountScope>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
    }
    impl Builder {
        /// <p>The Savings Plans recommendation type that's requested.</p>
        pub fn savings_plans_type(
            mut self,
            input: crate::model::SupportedSavingsPlansType,
        ) -> Self {
            self.savings_plans_type = Some(input);
            self
        }
        /// <p>The Savings Plans recommendation type that's requested.</p>
        pub fn set_savings_plans_type(
            mut self,
            input: std::option::Option<crate::model::SupportedSavingsPlansType>,
        ) -> Self {
            self.savings_plans_type = input;
            self
        }
        /// <p>The savings plan recommendation term that's used to generate these recommendations.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.term_in_years = Some(input);
            self
        }
        /// <p>The savings plan recommendation term that's used to generate these recommendations.</p>
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.term_in_years = input;
            self
        }
        /// <p>The payment option that's used to generate these recommendations.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>The payment option that's used to generate these recommendations.</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.account_scope = Some(input);
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.account_scope = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The lookback period that's used to generate the recommendation.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        /// <p>The lookback period that's used to generate the recommendation.</p>
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.lookback_period_in_days = input;
            self
        }
        /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code> dimension. To filter your recommendations by Account ID, specify <code>Key</code> as <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for.</p>
        /// <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> doesn't include <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>. With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. <code>AND</code> and <code>OR</code> operators are not supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code> dimension. To filter your recommendations by Account ID, specify <code>Key</code> as <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for.</p>
        /// <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> doesn't include <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>. With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. <code>AND</code> and <code>OR</code> operators are not supported.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSavingsPlansPurchaseRecommendationInput`](crate::input::GetSavingsPlansPurchaseRecommendationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSavingsPlansPurchaseRecommendationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSavingsPlansPurchaseRecommendationInput {
                savings_plans_type: self.savings_plans_type,
                term_in_years: self.term_in_years,
                payment_option: self.payment_option,
                account_scope: self.account_scope,
                next_page_token: self.next_page_token,
                page_size: self.page_size.unwrap_or_default(),
                lookback_period_in_days: self.lookback_period_in_days,
                filter: self.filter,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSavingsPlansCoverageInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
    /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
    /// <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
    /// <p>Cost category is also supported.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>SpendCoveredBySavingsPlan</code> </p> </li>
    /// <li> <p> <code>OnDemandCost</code> </p> </li>
    /// <li> <p> <code>CoveragePercentage</code> </p> </li>
    /// <li> <p> <code>TotalCost</code> </p> </li>
    /// <li> <p> <code>InstanceFamily</code> </p> </li>
    /// <li> <p> <code>Region</code> </p> </li>
    /// <li> <p> <code>Service</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::SortDefinition>,
}
impl GetSavingsPlansCoverageInput {
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::GroupDefinition]> {
        self.group_by.as_deref()
    }
    /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
    /// <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_FAMILY</code> </p> </li>
    /// </ul>
    /// <p> <code>GetSavingsPlansCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
    /// <p>Cost category is also supported.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
    pub fn metrics(&self) -> std::option::Option<&[std::string::String]> {
        self.metrics.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>SpendCoveredBySavingsPlan</code> </p> </li>
    /// <li> <p> <code>OnDemandCost</code> </p> </li>
    /// <li> <p> <code>CoveragePercentage</code> </p> </li>
    /// <li> <p> <code>TotalCost</code> </p> </li>
    /// <li> <p> <code>InstanceFamily</code> </p> </li>
    /// <li> <p> <code>Region</code> </p> </li>
    /// <li> <p> <code>Service</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::SortDefinition> {
        self.sort_by.as_ref()
    }
}
impl GetSavingsPlansCoverageInput {
    /// Creates a new builder-style object to manufacture [`GetSavingsPlansCoverageInput`](crate::input::GetSavingsPlansCoverageInput).
    pub fn builder() -> crate::input::get_savings_plans_coverage_input::Builder {
        crate::input::get_savings_plans_coverage_input::Builder::default()
    }
}

/// See [`GetSavingsPlansCoverageInput`](crate::input::GetSavingsPlansCoverageInput).
pub mod get_savings_plans_coverage_input {

    /// A builder for [`GetSavingsPlansCoverageInput`](crate::input::GetSavingsPlansCoverageInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) sort_by: std::option::Option<crate::model::SortDefinition>,
    }
    impl Builder {
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
        pub fn group_by(mut self, input: crate::model::GroupDefinition) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
        /// <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
        /// <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>Cost category is also supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_FAMILY</code> </p> </li>
        /// </ul>
        /// <p> <code>GetSavingsPlansCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>Cost category is also supported.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
        pub fn metrics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>SpendCoveredBySavingsPlan</code> </p> </li>
        /// <li> <p> <code>OnDemandCost</code> </p> </li>
        /// <li> <p> <code>CoveragePercentage</code> </p> </li>
        /// <li> <p> <code>TotalCost</code> </p> </li>
        /// <li> <p> <code>InstanceFamily</code> </p> </li>
        /// <li> <p> <code>Region</code> </p> </li>
        /// <li> <p> <code>Service</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>SpendCoveredBySavingsPlan</code> </p> </li>
        /// <li> <p> <code>OnDemandCost</code> </p> </li>
        /// <li> <p> <code>CoveragePercentage</code> </p> </li>
        /// <li> <p> <code>TotalCost</code> </p> </li>
        /// <li> <p> <code>InstanceFamily</code> </p> </li>
        /// <li> <p> <code>Region</code> </p> </li>
        /// <li> <p> <code>Service</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSavingsPlansCoverageInput`](crate::input::GetSavingsPlansCoverageInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSavingsPlansCoverageInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSavingsPlansCoverageInput {
                time_period: self.time_period,
                group_by: self.group_by,
                granularity: self.granularity,
                filter: self.filter,
                metrics: self.metrics,
                next_token: self.next_token,
                max_results: self.max_results,
                sort_by: self.sort_by,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRightsizingRecommendationInput {
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither. </p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::RightsizingRecommendationConfiguration>,
    /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is "<code>AmazonEC2</code>".</p>
    #[doc(hidden)]
    pub service: std::option::Option<std::string::String>,
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    #[doc(hidden)]
    pub page_size: i32,
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetRightsizingRecommendationInput {
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither. </p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&crate::model::RightsizingRecommendationConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is "<code>AmazonEC2</code>".</p>
    pub fn service(&self) -> std::option::Option<&str> {
        self.service.as_deref()
    }
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    pub fn page_size(&self) -> i32 {
        self.page_size
    }
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetRightsizingRecommendationInput {
    /// Creates a new builder-style object to manufacture [`GetRightsizingRecommendationInput`](crate::input::GetRightsizingRecommendationInput).
    pub fn builder() -> crate::input::get_rightsizing_recommendation_input::Builder {
        crate::input::get_rightsizing_recommendation_input::Builder::default()
    }
}

/// See [`GetRightsizingRecommendationInput`](crate::input::GetRightsizingRecommendationInput).
pub mod get_rightsizing_recommendation_input {

    /// A builder for [`GetRightsizingRecommendationInput`](crate::input::GetRightsizingRecommendationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) configuration:
            std::option::Option<crate::model::RightsizingRecommendationConfiguration>,
        pub(crate) service: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither. </p>
        pub fn configuration(
            mut self,
            input: crate::model::RightsizingRecommendationConfiguration,
        ) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither. </p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::RightsizingRecommendationConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is "<code>AmazonEC2</code>".</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.service = Some(input.into());
            self
        }
        /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is "<code>AmazonEC2</code>".</p>
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service = input;
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRightsizingRecommendationInput`](crate::input::GetRightsizingRecommendationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetRightsizingRecommendationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetRightsizingRecommendationInput {
                filter: self.filter,
                configuration: self.configuration,
                service: self.service,
                page_size: self.page_size.unwrap_or_default(),
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReservationUtilizationInput {
    /// <p>Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
    /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>. If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
    /// <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>SERVICE</p> </li>
    /// <li> <p>SCOPE</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    /// <p> <code>GetReservationUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>UtilizationPercentageInUnits</code> </p> </li>
    /// <li> <p> <code>PurchasedHours</code> </p> </li>
    /// <li> <p> <code>PurchasedUnits</code> </p> </li>
    /// <li> <p> <code>TotalActualHours</code> </p> </li>
    /// <li> <p> <code>TotalActualUnits</code> </p> </li>
    /// <li> <p> <code>UnusedHours</code> </p> </li>
    /// <li> <p> <code>UnusedUnits</code> </p> </li>
    /// <li> <p> <code>OnDemandCostOfRIHoursUsed</code> </p> </li>
    /// <li> <p> <code>NetRISavings</code> </p> </li>
    /// <li> <p> <code>TotalPotentialRISavings</code> </p> </li>
    /// <li> <p> <code>AmortizedUpfrontFee</code> </p> </li>
    /// <li> <p> <code>AmortizedRecurringFee</code> </p> </li>
    /// <li> <p> <code>TotalAmortizedFee</code> </p> </li>
    /// <li> <p> <code>RICostForUnusedHours</code> </p> </li>
    /// <li> <p> <code>RealizedSavings</code> </p> </li>
    /// <li> <p> <code>UnrealizedSavings</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::SortDefinition>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetReservationUtilizationInput {
    /// <p>Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::GroupDefinition]> {
        self.group_by.as_deref()
    }
    /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>. If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
    /// <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>SERVICE</p> </li>
    /// <li> <p>SCOPE</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    /// <p> <code>GetReservationUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
    /// <li> <p> <code>UtilizationPercentageInUnits</code> </p> </li>
    /// <li> <p> <code>PurchasedHours</code> </p> </li>
    /// <li> <p> <code>PurchasedUnits</code> </p> </li>
    /// <li> <p> <code>TotalActualHours</code> </p> </li>
    /// <li> <p> <code>TotalActualUnits</code> </p> </li>
    /// <li> <p> <code>UnusedHours</code> </p> </li>
    /// <li> <p> <code>UnusedUnits</code> </p> </li>
    /// <li> <p> <code>OnDemandCostOfRIHoursUsed</code> </p> </li>
    /// <li> <p> <code>NetRISavings</code> </p> </li>
    /// <li> <p> <code>TotalPotentialRISavings</code> </p> </li>
    /// <li> <p> <code>AmortizedUpfrontFee</code> </p> </li>
    /// <li> <p> <code>AmortizedRecurringFee</code> </p> </li>
    /// <li> <p> <code>TotalAmortizedFee</code> </p> </li>
    /// <li> <p> <code>RICostForUnusedHours</code> </p> </li>
    /// <li> <p> <code>RealizedSavings</code> </p> </li>
    /// <li> <p> <code>UnrealizedSavings</code> </p> </li>
    /// </ul>
    /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::SortDefinition> {
        self.sort_by.as_ref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetReservationUtilizationInput {
    /// Creates a new builder-style object to manufacture [`GetReservationUtilizationInput`](crate::input::GetReservationUtilizationInput).
    pub fn builder() -> crate::input::get_reservation_utilization_input::Builder {
        crate::input::get_reservation_utilization_input::Builder::default()
    }
}

/// See [`GetReservationUtilizationInput`](crate::input::GetReservationUtilizationInput).
pub mod get_reservation_utilization_input {

    /// A builder for [`GetReservationUtilizationInput`](crate::input::GetReservationUtilizationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) sort_by: std::option::Option<crate::model::SortDefinition>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
        pub fn group_by(mut self, input: crate::model::GroupDefinition) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>. If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>. If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>SERVICE</p> </li>
        /// <li> <p>SCOPE</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        /// <p> <code>GetReservationUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>SERVICE</p> </li>
        /// <li> <p>SCOPE</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        /// <p> <code>GetReservationUtilization</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>UtilizationPercentageInUnits</code> </p> </li>
        /// <li> <p> <code>PurchasedHours</code> </p> </li>
        /// <li> <p> <code>PurchasedUnits</code> </p> </li>
        /// <li> <p> <code>TotalActualHours</code> </p> </li>
        /// <li> <p> <code>TotalActualUnits</code> </p> </li>
        /// <li> <p> <code>UnusedHours</code> </p> </li>
        /// <li> <p> <code>UnusedUnits</code> </p> </li>
        /// <li> <p> <code>OnDemandCostOfRIHoursUsed</code> </p> </li>
        /// <li> <p> <code>NetRISavings</code> </p> </li>
        /// <li> <p> <code>TotalPotentialRISavings</code> </p> </li>
        /// <li> <p> <code>AmortizedUpfrontFee</code> </p> </li>
        /// <li> <p> <code>AmortizedRecurringFee</code> </p> </li>
        /// <li> <p> <code>TotalAmortizedFee</code> </p> </li>
        /// <li> <p> <code>RICostForUnusedHours</code> </p> </li>
        /// <li> <p> <code>RealizedSavings</code> </p> </li>
        /// <li> <p> <code>UnrealizedSavings</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>UtilizationPercentage</code> </p> </li>
        /// <li> <p> <code>UtilizationPercentageInUnits</code> </p> </li>
        /// <li> <p> <code>PurchasedHours</code> </p> </li>
        /// <li> <p> <code>PurchasedUnits</code> </p> </li>
        /// <li> <p> <code>TotalActualHours</code> </p> </li>
        /// <li> <p> <code>TotalActualUnits</code> </p> </li>
        /// <li> <p> <code>UnusedHours</code> </p> </li>
        /// <li> <p> <code>UnusedUnits</code> </p> </li>
        /// <li> <p> <code>OnDemandCostOfRIHoursUsed</code> </p> </li>
        /// <li> <p> <code>NetRISavings</code> </p> </li>
        /// <li> <p> <code>TotalPotentialRISavings</code> </p> </li>
        /// <li> <p> <code>AmortizedUpfrontFee</code> </p> </li>
        /// <li> <p> <code>AmortizedRecurringFee</code> </p> </li>
        /// <li> <p> <code>TotalAmortizedFee</code> </p> </li>
        /// <li> <p> <code>RICostForUnusedHours</code> </p> </li>
        /// <li> <p> <code>RealizedSavings</code> </p> </li>
        /// <li> <p> <code>UnrealizedSavings</code> </p> </li>
        /// </ul>
        /// <p>The supported values for <code>SortOrder</code> are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetReservationUtilizationInput`](crate::input::GetReservationUtilizationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetReservationUtilizationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetReservationUtilizationInput {
                time_period: self.time_period,
                group_by: self.group_by,
                granularity: self.granularity,
                filter: self.filter,
                sort_by: self.sort_by,
                next_page_token: self.next_page_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReservationPurchaseRecommendationInput {
    /// <p>The account ID that's associated with the recommendation. </p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The specific service that you want recommendations for.</p>
    #[doc(hidden)]
    pub service: std::option::Option<std::string::String>,
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    #[doc(hidden)]
    pub account_scope: std::option::Option<crate::model::AccountScope>,
    /// <p>The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.</p>
    #[doc(hidden)]
    pub lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
    /// <p>The reservation term that you want recommendations for.</p>
    #[doc(hidden)]
    pub term_in_years: std::option::Option<crate::model::TermInYears>,
    /// <p>The reservation purchase option that you want recommendations for.</p>
    #[doc(hidden)]
    pub payment_option: std::option::Option<crate::model::PaymentOption>,
    /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
    #[doc(hidden)]
    pub service_specification: std::option::Option<crate::model::ServiceSpecification>,
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    #[doc(hidden)]
    pub page_size: i32,
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetReservationPurchaseRecommendationInput {
    /// <p>The account ID that's associated with the recommendation. </p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The specific service that you want recommendations for.</p>
    pub fn service(&self) -> std::option::Option<&str> {
        self.service.as_deref()
    }
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    pub fn account_scope(&self) -> std::option::Option<&crate::model::AccountScope> {
        self.account_scope.as_ref()
    }
    /// <p>The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.</p>
    pub fn lookback_period_in_days(
        &self,
    ) -> std::option::Option<&crate::model::LookbackPeriodInDays> {
        self.lookback_period_in_days.as_ref()
    }
    /// <p>The reservation term that you want recommendations for.</p>
    pub fn term_in_years(&self) -> std::option::Option<&crate::model::TermInYears> {
        self.term_in_years.as_ref()
    }
    /// <p>The reservation purchase option that you want recommendations for.</p>
    pub fn payment_option(&self) -> std::option::Option<&crate::model::PaymentOption> {
        self.payment_option.as_ref()
    }
    /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
    pub fn service_specification(
        &self,
    ) -> std::option::Option<&crate::model::ServiceSpecification> {
        self.service_specification.as_ref()
    }
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    pub fn page_size(&self) -> i32 {
        self.page_size
    }
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetReservationPurchaseRecommendationInput {
    /// Creates a new builder-style object to manufacture [`GetReservationPurchaseRecommendationInput`](crate::input::GetReservationPurchaseRecommendationInput).
    pub fn builder() -> crate::input::get_reservation_purchase_recommendation_input::Builder {
        crate::input::get_reservation_purchase_recommendation_input::Builder::default()
    }
}

/// See [`GetReservationPurchaseRecommendationInput`](crate::input::GetReservationPurchaseRecommendationInput).
pub mod get_reservation_purchase_recommendation_input {

    /// A builder for [`GetReservationPurchaseRecommendationInput`](crate::input::GetReservationPurchaseRecommendationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) service: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) account_scope: std::option::Option<crate::model::AccountScope>,
        pub(crate) lookback_period_in_days: std::option::Option<crate::model::LookbackPeriodInDays>,
        pub(crate) term_in_years: std::option::Option<crate::model::TermInYears>,
        pub(crate) payment_option: std::option::Option<crate::model::PaymentOption>,
        pub(crate) service_specification: std::option::Option<crate::model::ServiceSpecification>,
        pub(crate) page_size: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID that's associated with the recommendation. </p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID that's associated with the recommendation. </p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The specific service that you want recommendations for.</p>
        pub fn service(mut self, input: impl Into<std::string::String>) -> Self {
            self.service = Some(input.into());
            self
        }
        /// <p>The specific service that you want recommendations for.</p>
        pub fn set_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.service = input;
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn account_scope(mut self, input: crate::model::AccountScope) -> Self {
            self.account_scope = Some(input);
            self
        }
        /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
        pub fn set_account_scope(
            mut self,
            input: std::option::Option<crate::model::AccountScope>,
        ) -> Self {
            self.account_scope = input;
            self
        }
        /// <p>The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.</p>
        pub fn lookback_period_in_days(
            mut self,
            input: crate::model::LookbackPeriodInDays,
        ) -> Self {
            self.lookback_period_in_days = Some(input);
            self
        }
        /// <p>The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.</p>
        pub fn set_lookback_period_in_days(
            mut self,
            input: std::option::Option<crate::model::LookbackPeriodInDays>,
        ) -> Self {
            self.lookback_period_in_days = input;
            self
        }
        /// <p>The reservation term that you want recommendations for.</p>
        pub fn term_in_years(mut self, input: crate::model::TermInYears) -> Self {
            self.term_in_years = Some(input);
            self
        }
        /// <p>The reservation term that you want recommendations for.</p>
        pub fn set_term_in_years(
            mut self,
            input: std::option::Option<crate::model::TermInYears>,
        ) -> Self {
            self.term_in_years = input;
            self
        }
        /// <p>The reservation purchase option that you want recommendations for.</p>
        pub fn payment_option(mut self, input: crate::model::PaymentOption) -> Self {
            self.payment_option = Some(input);
            self
        }
        /// <p>The reservation purchase option that you want recommendations for.</p>
        pub fn set_payment_option(
            mut self,
            input: std::option::Option<crate::model::PaymentOption>,
        ) -> Self {
            self.payment_option = input;
            self
        }
        /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
        pub fn service_specification(mut self, input: crate::model::ServiceSpecification) -> Self {
            self.service_specification = Some(input);
            self
        }
        /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
        pub fn set_service_specification(
            mut self,
            input: std::option::Option<crate::model::ServiceSpecification>,
        ) -> Self {
            self.service_specification = input;
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of recommendations that you want returned in a single response object.</p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input;
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetReservationPurchaseRecommendationInput`](crate::input::GetReservationPurchaseRecommendationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetReservationPurchaseRecommendationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetReservationPurchaseRecommendationInput {
                account_id: self.account_id,
                service: self.service,
                filter: self.filter,
                account_scope: self.account_scope,
                lookback_period_in_days: self.lookback_period_in_days,
                term_in_years: self.term_in_years,
                payment_option: self.payment_option,
                service_specification: self.service_specification,
                page_size: self.page_size.unwrap_or_default(),
                next_page_token: self.next_page_token,
            })
        }
    }
}

/// <p>You can use the following request parameters to query for how much of your instance usage a reservation covered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetReservationCoverageInput {
    /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>You can group the data by the following attributes:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DATABASE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>INVOICING_ENTITY</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
    /// <p>The granularity of the Amazon Web Services cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
    /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
    /// <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DATABASE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>SERVICE</p> </li>
    /// <li> <p>TAG</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    /// <p> <code>GetReservationCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
    /// <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
    /// <p>Cost category is also supported.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The measurement that you want your reservation coverage reported in.</p>
    /// <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The value by which you want to sort the data.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>OnDemandCost</code> </p> </li>
    /// <li> <p> <code>CoverageHoursPercentage</code> </p> </li>
    /// <li> <p> <code>OnDemandHours</code> </p> </li>
    /// <li> <p> <code>ReservedHours</code> </p> </li>
    /// <li> <p> <code>TotalRunningHours</code> </p> </li>
    /// <li> <p> <code>CoverageNormalizedUnitsPercentage</code> </p> </li>
    /// <li> <p> <code>OnDemandNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>ReservedNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>TotalRunningNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>Time</code> </p> </li>
    /// </ul>
    /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<crate::model::SortDefinition>,
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetReservationCoverageInput {
    /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>You can group the data by the following attributes:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DATABASE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>INVOICING_ENTITY</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::GroupDefinition]> {
        self.group_by.as_deref()
    }
    /// <p>The granularity of the Amazon Web Services cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
    /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
    /// <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// <ul>
    /// <li> <p>AZ</p> </li>
    /// <li> <p>CACHE_ENGINE</p> </li>
    /// <li> <p>DATABASE_ENGINE</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION</p> </li>
    /// <li> <p>INSTANCE_TYPE</p> </li>
    /// <li> <p>LINKED_ACCOUNT</p> </li>
    /// <li> <p>OPERATING_SYSTEM</p> </li>
    /// <li> <p>PLATFORM</p> </li>
    /// <li> <p>REGION</p> </li>
    /// <li> <p>SERVICE</p> </li>
    /// <li> <p>TAG</p> </li>
    /// <li> <p>TENANCY</p> </li>
    /// </ul>
    /// <p> <code>GetReservationCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
    /// <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
    /// <p>Cost category is also supported.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The measurement that you want your reservation coverage reported in.</p>
    /// <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
    pub fn metrics(&self) -> std::option::Option<&[std::string::String]> {
        self.metrics.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The value by which you want to sort the data.</p>
    /// <p>The following values are supported for <code>Key</code>:</p>
    /// <ul>
    /// <li> <p> <code>OnDemandCost</code> </p> </li>
    /// <li> <p> <code>CoverageHoursPercentage</code> </p> </li>
    /// <li> <p> <code>OnDemandHours</code> </p> </li>
    /// <li> <p> <code>ReservedHours</code> </p> </li>
    /// <li> <p> <code>TotalRunningHours</code> </p> </li>
    /// <li> <p> <code>CoverageNormalizedUnitsPercentage</code> </p> </li>
    /// <li> <p> <code>OnDemandNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>ReservedNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>TotalRunningNormalizedUnits</code> </p> </li>
    /// <li> <p> <code>Time</code> </p> </li>
    /// </ul>
    /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    pub fn sort_by(&self) -> std::option::Option<&crate::model::SortDefinition> {
        self.sort_by.as_ref()
    }
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetReservationCoverageInput {
    /// Creates a new builder-style object to manufacture [`GetReservationCoverageInput`](crate::input::GetReservationCoverageInput).
    pub fn builder() -> crate::input::get_reservation_coverage_input::Builder {
        crate::input::get_reservation_coverage_input::Builder::default()
    }
}

/// See [`GetReservationCoverageInput`](crate::input::GetReservationCoverageInput).
pub mod get_reservation_coverage_input {

    /// A builder for [`GetReservationCoverageInput`](crate::input::GetReservationCoverageInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) sort_by: std::option::Option<crate::model::SortDefinition>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>You can group the data by the following attributes:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DATABASE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>INVOICING_ENTITY</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        pub fn group_by(mut self, input: crate::model::GroupDefinition) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>You can group the data by the following attributes:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DATABASE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>INVOICING_ENTITY</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>The granularity of the Amazon Web Services cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>The granularity of the Amazon Web Services cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
        /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set, the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
        /// <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DATABASE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>SERVICE</p> </li>
        /// <li> <p>TAG</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        /// <p> <code>GetReservationCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
        /// <p>Cost category is also supported.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
        /// <ul>
        /// <li> <p>AZ</p> </li>
        /// <li> <p>CACHE_ENGINE</p> </li>
        /// <li> <p>DATABASE_ENGINE</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION</p> </li>
        /// <li> <p>INSTANCE_TYPE</p> </li>
        /// <li> <p>LINKED_ACCOUNT</p> </li>
        /// <li> <p>OPERATING_SYSTEM</p> </li>
        /// <li> <p>PLATFORM</p> </li>
        /// <li> <p>REGION</p> </li>
        /// <li> <p>SERVICE</p> </li>
        /// <li> <p>TAG</p> </li>
        /// <li> <p>TENANCY</p> </li>
        /// </ul>
        /// <p> <code>GetReservationCoverage</code> uses the same <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
        /// <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
        /// <p>Cost category is also supported.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>The measurement that you want your reservation coverage reported in.</p>
        /// <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
        pub fn metrics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>The measurement that you want your reservation coverage reported in.</p>
        /// <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>OnDemandCost</code> </p> </li>
        /// <li> <p> <code>CoverageHoursPercentage</code> </p> </li>
        /// <li> <p> <code>OnDemandHours</code> </p> </li>
        /// <li> <p> <code>ReservedHours</code> </p> </li>
        /// <li> <p> <code>TotalRunningHours</code> </p> </li>
        /// <li> <p> <code>CoverageNormalizedUnitsPercentage</code> </p> </li>
        /// <li> <p> <code>OnDemandNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>ReservedNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>TotalRunningNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>Time</code> </p> </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            self.sort_by = Some(input);
            self
        }
        /// <p>The value by which you want to sort the data.</p>
        /// <p>The following values are supported for <code>Key</code>:</p>
        /// <ul>
        /// <li> <p> <code>OnDemandCost</code> </p> </li>
        /// <li> <p> <code>CoverageHoursPercentage</code> </p> </li>
        /// <li> <p> <code>OnDemandHours</code> </p> </li>
        /// <li> <p> <code>ReservedHours</code> </p> </li>
        /// <li> <p> <code>TotalRunningHours</code> </p> </li>
        /// <li> <p> <code>CoverageNormalizedUnitsPercentage</code> </p> </li>
        /// <li> <p> <code>OnDemandNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>ReservedNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>TotalRunningNormalizedUnits</code> </p> </li>
        /// <li> <p> <code>Time</code> </p> </li>
        /// </ul>
        /// <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::SortDefinition>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetReservationCoverageInput`](crate::input::GetReservationCoverageInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetReservationCoverageInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetReservationCoverageInput {
                time_period: self.time_period,
                group_by: self.group_by,
                granularity: self.granularity,
                filter: self.filter,
                metrics: self.metrics,
                next_page_token: self.next_page_token,
                sort_by: self.sort_by,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDimensionValuesInput {
    /// <p>The value that you want to search the filter values for.</p>
    #[doc(hidden)]
    pub search_string: std::option::Option<std::string::String>,
    /// <p>The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>. For more information, see <code>Context</code>. <code>LINK_ACCOUNT_NAME</code> and <code>SERVICE_CODE</code> can only be used in <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html">CostCategoryRule</a>. </p>
    #[doc(hidden)]
    pub dimension: std::option::Option<crate::model::Dimension>,
    /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>. The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>, the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
    /// <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
    /// <li> <p>BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following:</p> <p>- Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services.</p> <p>- AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India.</p> <p>- Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.</p> </li>
    /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
    /// <li> <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p> </li>
    /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
    /// <li> <p>INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are <code>Compute Optimized</code> (for example, <code>C4</code>, <code>C5</code>, <code>C6g</code>, and <code>C7g</code>), <code>Memory Optimization</code> (for example, <code>R4</code>, <code>R5n</code>, <code>R5b</code>, and <code>R6g</code>).</p> </li>
    /// <li> <p>INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.</p> </li>
    /// <li> <p>LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p> </li>
    /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.</p> </li>
    /// <li> <p>RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.</p> </li>
    /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
    /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).</p> </li>
    /// <li> <p>SERVICE - The Amazon Web Services service such as Amazon DynamoDB.</p> </li>
    /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
    /// <li> <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation includes a unit attribute. Examples include GB and Hrs.</p> </li>
    /// <li> <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.</p> </li>
    /// <li> <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p> </li>
    /// </ul>
    /// <p>If you set the context to <code>RESERVATIONS</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
    /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
    /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p> </li>
    /// <li> <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p> </li>
    /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
    /// </ul>
    /// <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p> </li>
    /// <li> <p>PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub context: std::option::Option<crate::model::Context>,
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The key represents cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported values for the <code>SortOrder</code> key are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    /// <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetDimensionValuesInput {
    /// <p>The value that you want to search the filter values for.</p>
    pub fn search_string(&self) -> std::option::Option<&str> {
        self.search_string.as_deref()
    }
    /// <p>The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>. For more information, see <code>Context</code>. <code>LINK_ACCOUNT_NAME</code> and <code>SERVICE_CODE</code> can only be used in <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html">CostCategoryRule</a>. </p>
    pub fn dimension(&self) -> std::option::Option<&crate::model::Dimension> {
        self.dimension.as_ref()
    }
    /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>. The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>, the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
    /// <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
    /// <li> <p>BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following:</p> <p>- Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services.</p> <p>- AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India.</p> <p>- Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.</p> </li>
    /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
    /// <li> <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p> </li>
    /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
    /// <li> <p>INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are <code>Compute Optimized</code> (for example, <code>C4</code>, <code>C5</code>, <code>C6g</code>, and <code>C7g</code>), <code>Memory Optimization</code> (for example, <code>R4</code>, <code>R5n</code>, <code>R5b</code>, and <code>R6g</code>).</p> </li>
    /// <li> <p>INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.</p> </li>
    /// <li> <p>LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p> </li>
    /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.</p> </li>
    /// <li> <p>RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.</p> </li>
    /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
    /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).</p> </li>
    /// <li> <p>SERVICE - The Amazon Web Services service such as Amazon DynamoDB.</p> </li>
    /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
    /// <li> <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation includes a unit attribute. Examples include GB and Hrs.</p> </li>
    /// <li> <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.</p> </li>
    /// <li> <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p> </li>
    /// </ul>
    /// <p>If you set the context to <code>RESERVATIONS</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
    /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
    /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p> </li>
    /// <li> <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p> </li>
    /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
    /// </ul>
    /// <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
    /// <ul>
    /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p> </li>
    /// <li> <p>PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)</p> </li>
    /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
    /// <li> <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p> </li>
    /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
    /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
    /// </ul>
    pub fn context(&self) -> std::option::Option<&crate::model::Context> {
        self.context.as_ref()
    }
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The value that you want to sort the data by.</p>
    /// <p>The key represents cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported values for the <code>SortOrder</code> key are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    /// <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
    pub fn sort_by(&self) -> std::option::Option<&[crate::model::SortDefinition]> {
        self.sort_by.as_deref()
    }
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetDimensionValuesInput {
    /// Creates a new builder-style object to manufacture [`GetDimensionValuesInput`](crate::input::GetDimensionValuesInput).
    pub fn builder() -> crate::input::get_dimension_values_input::Builder {
        crate::input::get_dimension_values_input::Builder::default()
    }
}

/// See [`GetDimensionValuesInput`](crate::input::GetDimensionValuesInput).
pub mod get_dimension_values_input {

    /// A builder for [`GetDimensionValuesInput`](crate::input::GetDimensionValuesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) search_string: std::option::Option<std::string::String>,
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) dimension: std::option::Option<crate::model::Dimension>,
        pub(crate) context: std::option::Option<crate::model::Context>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value that you want to search the filter values for.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.search_string = Some(input.into());
            self
        }
        /// <p>The value that you want to search the filter values for.</p>
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.search_string = input;
            self
        }
        /// <p>The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>. For more information, see <code>Context</code>. <code>LINK_ACCOUNT_NAME</code> and <code>SERVICE_CODE</code> can only be used in <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html">CostCategoryRule</a>. </p>
        pub fn dimension(mut self, input: crate::model::Dimension) -> Self {
            self.dimension = Some(input);
            self
        }
        /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>. For more information, see <code>Context</code>. <code>LINK_ACCOUNT_NAME</code> and <code>SERVICE_CODE</code> can only be used in <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html">CostCategoryRule</a>. </p>
        pub fn set_dimension(
            mut self,
            input: std::option::Option<crate::model::Dimension>,
        ) -> Self {
            self.dimension = input;
            self
        }
        /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>. The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>, the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
        /// <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
        /// <li> <p>BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following:</p> <p>- Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services.</p> <p>- AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India.</p> <p>- Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.</p> </li>
        /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
        /// <li> <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p> </li>
        /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
        /// <li> <p>INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are <code>Compute Optimized</code> (for example, <code>C4</code>, <code>C5</code>, <code>C6g</code>, and <code>C7g</code>), <code>Memory Optimization</code> (for example, <code>R4</code>, <code>R5n</code>, <code>R5b</code>, and <code>R6g</code>).</p> </li>
        /// <li> <p>INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.</p> </li>
        /// <li> <p>LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p> </li>
        /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.</p> </li>
        /// <li> <p>RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.</p> </li>
        /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
        /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).</p> </li>
        /// <li> <p>SERVICE - The Amazon Web Services service such as Amazon DynamoDB.</p> </li>
        /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
        /// <li> <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation includes a unit attribute. Examples include GB and Hrs.</p> </li>
        /// <li> <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.</p> </li>
        /// <li> <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p> </li>
        /// </ul>
        /// <p>If you set the context to <code>RESERVATIONS</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
        /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
        /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p> </li>
        /// <li> <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p> </li>
        /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
        /// </ul>
        /// <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p> </li>
        /// <li> <p>PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
        /// </ul>
        pub fn context(mut self, input: crate::model::Context) -> Self {
            self.context = Some(input);
            self
        }
        /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>. The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>, the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
        /// <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
        /// <li> <p>BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following:</p> <p>- Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services.</p> <p>- AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India.</p> <p>- Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.</p> </li>
        /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
        /// <li> <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p> </li>
        /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
        /// <li> <p>INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are <code>Compute Optimized</code> (for example, <code>C4</code>, <code>C5</code>, <code>C6g</code>, and <code>C7g</code>), <code>Memory Optimization</code> (for example, <code>R4</code>, <code>R5n</code>, <code>R5b</code>, and <code>R6g</code>).</p> </li>
        /// <li> <p>INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.</p> </li>
        /// <li> <p>LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p> </li>
        /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.</p> </li>
        /// <li> <p>RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.</p> </li>
        /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
        /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).</p> </li>
        /// <li> <p>SERVICE - The Amazon Web Services service such as Amazon DynamoDB.</p> </li>
        /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
        /// <li> <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation includes a unit attribute. Examples include GB and Hrs.</p> </li>
        /// <li> <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.</p> </li>
        /// <li> <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p> </li>
        /// </ul>
        /// <p>If you set the context to <code>RESERVATIONS</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p> </li>
        /// <li> <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p> </li>
        /// <li> <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p> </li>
        /// <li> <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p> </li>
        /// <li> <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p> </li>
        /// </ul>
        /// <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
        /// <ul>
        /// <li> <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p> </li>
        /// <li> <p>PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)</p> </li>
        /// <li> <p>REGION - The Amazon Web Services Region.</p> </li>
        /// <li> <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p> </li>
        /// <li> <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.</p> </li>
        /// <li> <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.</p> </li>
        /// </ul>
        pub fn set_context(mut self, input: std::option::Option<crate::model::Context>) -> Self {
            self.context = input;
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `sort_by`.
        ///
        /// To override the contents of this collection use [`set_sort_by`](Self::set_sort_by).
        ///
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported values for the <code>SortOrder</code> key are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            let mut v = self.sort_by.unwrap_or_default();
            v.push(input);
            self.sort_by = Some(v);
            self
        }
        /// <p>The value that you want to sort the data by.</p>
        /// <p>The key represents cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported values for the <code>SortOrder</code> key are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
        /// <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> aren't supported.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDimensionValuesInput`](crate::input::GetDimensionValuesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetDimensionValuesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetDimensionValuesInput {
                search_string: self.search_string,
                time_period: self.time_period,
                dimension: self.dimension,
                context: self.context,
                filter: self.filter,
                sort_by: self.sort_by,
                max_results: self.max_results.unwrap_or_default(),
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCostForecastInput {
    /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
    /// <ul>
    /// <li> <p>AMORTIZED_COST</p> </li>
    /// <li> <p>BLENDED_COST</p> </li>
    /// <li> <p>NET_AMORTIZED_COST</p> </li>
    /// <li> <p>NET_UNBLENDED_COST</p> </li>
    /// <li> <p>UNBLENDED_COST</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub metric: std::option::Option<crate::model::Metric>,
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>AZ</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
    /// <li> <p> <code>OPERATION</code> </p> </li>
    /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
    /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
    /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
    /// <li> <p> <code>TENANCY</code> </p> </li>
    /// <li> <p> <code>SCOPE</code> </p> </li>
    /// <li> <p> <code>PLATFORM</code> </p> </li>
    /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
    /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
    /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
    /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    #[doc(hidden)]
    pub prediction_interval_level: std::option::Option<i32>,
}
impl GetCostForecastInput {
    /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
    /// <ul>
    /// <li> <p>AMORTIZED_COST</p> </li>
    /// <li> <p>BLENDED_COST</p> </li>
    /// <li> <p>NET_AMORTIZED_COST</p> </li>
    /// <li> <p>NET_UNBLENDED_COST</p> </li>
    /// <li> <p>UNBLENDED_COST</p> </li>
    /// </ul>
    pub fn metric(&self) -> std::option::Option<&crate::model::Metric> {
        self.metric.as_ref()
    }
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
    /// <ul>
    /// <li> <p> <code>AZ</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
    /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
    /// <li> <p> <code>OPERATION</code> </p> </li>
    /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
    /// <li> <p> <code>REGION</code> </p> </li>
    /// <li> <p> <code>SERVICE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
    /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
    /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
    /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
    /// <li> <p> <code>TENANCY</code> </p> </li>
    /// <li> <p> <code>SCOPE</code> </p> </li>
    /// <li> <p> <code>PLATFORM</code> </p> </li>
    /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
    /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
    /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
    /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
    /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
    /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
    /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
    /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
    /// </ul>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    pub fn prediction_interval_level(&self) -> std::option::Option<i32> {
        self.prediction_interval_level
    }
}
impl GetCostForecastInput {
    /// Creates a new builder-style object to manufacture [`GetCostForecastInput`](crate::input::GetCostForecastInput).
    pub fn builder() -> crate::input::get_cost_forecast_input::Builder {
        crate::input::get_cost_forecast_input::Builder::default()
    }
}

/// See [`GetCostForecastInput`](crate::input::GetCostForecastInput).
pub mod get_cost_forecast_input {

    /// A builder for [`GetCostForecastInput`](crate::input::GetCostForecastInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) metric: std::option::Option<crate::model::Metric>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) prediction_interval_level: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
        /// <ul>
        /// <li> <p>AMORTIZED_COST</p> </li>
        /// <li> <p>BLENDED_COST</p> </li>
        /// <li> <p>NET_AMORTIZED_COST</p> </li>
        /// <li> <p>NET_UNBLENDED_COST</p> </li>
        /// <li> <p>UNBLENDED_COST</p> </li>
        /// </ul>
        pub fn metric(mut self, input: crate::model::Metric) -> Self {
            self.metric = Some(input);
            self
        }
        /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
        /// <ul>
        /// <li> <p>AMORTIZED_COST</p> </li>
        /// <li> <p>BLENDED_COST</p> </li>
        /// <li> <p>NET_AMORTIZED_COST</p> </li>
        /// <li> <p>NET_UNBLENDED_COST</p> </li>
        /// <li> <p>UNBLENDED_COST</p> </li>
        /// </ul>
        pub fn set_metric(mut self, input: std::option::Option<crate::model::Metric>) -> Self {
            self.metric = input;
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
        /// <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>AZ</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
        /// <li> <p> <code>OPERATION</code> </p> </li>
        /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
        /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
        /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
        /// <li> <p> <code>TENANCY</code> </p> </li>
        /// <li> <p> <code>SCOPE</code> </p> </li>
        /// <li> <p> <code>PLATFORM</code> </p> </li>
        /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
        /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
        /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
        /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// </ul>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
        /// <ul>
        /// <li> <p> <code>AZ</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT</code> </p> </li>
        /// <li> <p> <code>LINKED_ACCOUNT_NAME</code> </p> </li>
        /// <li> <p> <code>OPERATION</code> </p> </li>
        /// <li> <p> <code>PURCHASE_TYPE</code> </p> </li>
        /// <li> <p> <code>REGION</code> </p> </li>
        /// <li> <p> <code>SERVICE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE</code> </p> </li>
        /// <li> <p> <code>USAGE_TYPE_GROUP</code> </p> </li>
        /// <li> <p> <code>RECORD_TYPE</code> </p> </li>
        /// <li> <p> <code>OPERATING_SYSTEM</code> </p> </li>
        /// <li> <p> <code>TENANCY</code> </p> </li>
        /// <li> <p> <code>SCOPE</code> </p> </li>
        /// <li> <p> <code>PLATFORM</code> </p> </li>
        /// <li> <p> <code>SUBSCRIPTION_ID</code> </p> </li>
        /// <li> <p> <code>LEGAL_ENTITY_NAME</code> </p> </li>
        /// <li> <p> <code>DEPLOYMENT_OPTION</code> </p> </li>
        /// <li> <p> <code>DATABASE_ENGINE</code> </p> </li>
        /// <li> <p> <code>INSTANCE_TYPE_FAMILY</code> </p> </li>
        /// <li> <p> <code>BILLING_ENTITY</code> </p> </li>
        /// <li> <p> <code>RESERVATION_ID</code> </p> </li>
        /// <li> <p> <code>SAVINGS_PLAN_ARN</code> </p> </li>
        /// </ul>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn prediction_interval_level(mut self, input: i32) -> Self {
            self.prediction_interval_level = Some(input);
            self
        }
        /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
        pub fn set_prediction_interval_level(mut self, input: std::option::Option<i32>) -> Self {
            self.prediction_interval_level = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCostForecastInput`](crate::input::GetCostForecastInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetCostForecastInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetCostForecastInput {
                time_period: self.time_period,
                metric: self.metric,
                granularity: self.granularity,
                filter: self.filter,
                prediction_interval_level: self.prediction_interval_level,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCostCategoriesInput {
    /// <p>The value that you want to search the filter values for.</p>
    /// <p>If you don't specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category names that match the <code>SearchString</code> pattern. If you specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
    #[doc(hidden)]
    pub search_string: std::option::Option<std::string::String>,
    /// <p>The time period of the request. </p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>The unique name of the Cost Category.</p>
    #[doc(hidden)]
    pub cost_category_name: std::option::Option<std::string::String>,
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>The value that you sort the data by.</p>
    /// <p>The key represents the cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported key values for the <code>SortOrder</code> value are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    /// <p>When you use the <code>SortBy</code> value, the <code>NextPageToken</code> and <code>SearchString</code> key values aren't supported.</p>
    #[doc(hidden)]
    pub sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
    /// <p>This field is only used when the <code>SortBy</code> value is provided in the request.</p>
    /// <p>The maximum number of objects that are returned for this request. If <code>MaxResults</code> isn't specified with the <code>SortBy</code> value, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetCostCategories</code>, MaxResults has an upper quota of 1000.</p>
    #[doc(hidden)]
    pub max_results: i32,
    /// <p>If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetCostCategoriesInput {
    /// <p>The value that you want to search the filter values for.</p>
    /// <p>If you don't specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category names that match the <code>SearchString</code> pattern. If you specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
    pub fn search_string(&self) -> std::option::Option<&str> {
        self.search_string.as_deref()
    }
    /// <p>The time period of the request. </p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>The unique name of the Cost Category.</p>
    pub fn cost_category_name(&self) -> std::option::Option<&str> {
        self.cost_category_name.as_deref()
    }
    /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
    /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
    /// <p>There are two patterns:</p>
    /// <ul>
    /// <li> <p>Simple dimension values.</p>
    /// <ul>
    /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
    /// <ul>
    /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
    /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
    /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
    /// </ul> </li>
    /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
    /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
    /// </ul> </li>
    /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
    /// <ul>
    /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
    /// <ul>
    /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
    /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
    /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
    /// </ul> <note>
    /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
    /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
    /// </note> </li>
    /// </ul> <note>
    /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
    /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// </note>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>The value that you sort the data by.</p>
    /// <p>The key represents the cost and usage metrics. The following values are supported:</p>
    /// <ul>
    /// <li> <p> <code>BlendedCost</code> </p> </li>
    /// <li> <p> <code>UnblendedCost</code> </p> </li>
    /// <li> <p> <code>AmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
    /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
    /// <li> <p> <code>UsageQuantity</code> </p> </li>
    /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
    /// </ul>
    /// <p>The supported key values for the <code>SortOrder</code> value are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
    /// <p>When you use the <code>SortBy</code> value, the <code>NextPageToken</code> and <code>SearchString</code> key values aren't supported.</p>
    pub fn sort_by(&self) -> std::option::Option<&[crate::model::SortDefinition]> {
        self.sort_by.as_deref()
    }
    /// <p>This field is only used when the <code>SortBy</code> value is provided in the request.</p>
    /// <p>The maximum number of objects that are returned for this request. If <code>MaxResults</code> isn't specified with the <code>SortBy</code> value, the request returns 1000 results as the default value for this parameter.</p>
    /// <p>For <code>GetCostCategories</code>, MaxResults has an upper quota of 1000.</p>
    pub fn max_results(&self) -> i32 {
        self.max_results
    }
    /// <p>If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetCostCategoriesInput {
    /// Creates a new builder-style object to manufacture [`GetCostCategoriesInput`](crate::input::GetCostCategoriesInput).
    pub fn builder() -> crate::input::get_cost_categories_input::Builder {
        crate::input::get_cost_categories_input::Builder::default()
    }
}

/// See [`GetCostCategoriesInput`](crate::input::GetCostCategoriesInput).
pub mod get_cost_categories_input {

    /// A builder for [`GetCostCategoriesInput`](crate::input::GetCostCategoriesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) search_string: std::option::Option<std::string::String>,
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) cost_category_name: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) sort_by: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The value that you want to search the filter values for.</p>
        /// <p>If you don't specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category names that match the <code>SearchString</code> pattern. If you specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
        pub fn search_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.search_string = Some(input.into());
            self
        }
        /// <p>The value that you want to search the filter values for.</p>
        /// <p>If you don't specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category names that match the <code>SearchString</code> pattern. If you specify a <code>CostCategoryName</code>, <code>SearchString</code> is used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
        pub fn set_search_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.search_string = input;
            self
        }
        /// <p>The time period of the request. </p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The time period of the request. </p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn cost_category_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_name = Some(input.into());
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn set_cost_category_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_name = input;
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Use <code>Expression</code> to filter in various Cost Explorer APIs.</p>
        /// <p>Not all <code>Expression</code> types are supported in each API. Refer to the documentation for each specific API to see what is supported.</p>
        /// <p>There are two patterns:</p>
        /// <ul>
        /// <li> <p>Simple dimension values.</p>
        /// <ul>
        /// <li> <p>There are three types of simple dimension values: <code>CostCategories</code>, <code>Tags</code>, and <code>Dimensions</code>.</p>
        /// <ul>
        /// <li> <p>Specify the <code>CostCategories</code> field to define a filter that acts on Cost Categories.</p> </li>
        /// <li> <p>Specify the <code>Tags</code> field to define a filter that acts on Cost Allocation Tags.</p> </li>
        /// <li> <p>Specify the <code>Dimensions</code> field to define a filter that acts on the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html"> <code>DimensionValues</code> </a>.</p> </li>
        /// </ul> </li>
        /// <li> <p>For each filter type, you can set the dimension name and values for the filters that you plan to use.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } }</code> </p> </li>
        /// <li> <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when applying the filter.</p> </li>
        /// </ul> </li>
        /// <li> <p>You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.</p>
        /// <ul>
        /// <li> <p>For example, you can filter for linked account names that start with “a”.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }</code> </p> </li>
        /// </ul> </li>
        /// </ul> </li>
        /// <li> <p>Compound <code>Expression</code> types with logical operations.</p>
        /// <ul>
        /// <li> <p>You can use multiple <code>Expression</code> types and the logical operators <code>AND/OR/NOT</code> to create a list of one or more <code>Expression</code> objects. By doing this, you can filter by more advanced options.</p> </li>
        /// <li> <p>For example, you can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer)</code>.</p> </li>
        /// <li> <p>The corresponding <code>Expression</code> for this example is as follows: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] } </code> </p> </li>
        /// </ul> <note>
        /// <p>Because each <code>Expression</code> can have only one operator, the service returns an error if more than one is specified. The following example shows an <code>Expression</code> object that creates an error: <code> { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } } </code> </p>
        /// <p>The following is an example of the corresponding error message: <code>"Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"</code> </p>
        /// </note> </li>
        /// </ul> <note>
        /// <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or <code>RIGHTSIZING_TYPE</code>.</p>
        /// <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
        /// </note>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `sort_by`.
        ///
        /// To override the contents of this collection use [`set_sort_by`](Self::set_sort_by).
        ///
        /// <p>The value that you sort the data by.</p>
        /// <p>The key represents the cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported key values for the <code>SortOrder</code> value are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        /// <p>When you use the <code>SortBy</code> value, the <code>NextPageToken</code> and <code>SearchString</code> key values aren't supported.</p>
        pub fn sort_by(mut self, input: crate::model::SortDefinition) -> Self {
            let mut v = self.sort_by.unwrap_or_default();
            v.push(input);
            self.sort_by = Some(v);
            self
        }
        /// <p>The value that you sort the data by.</p>
        /// <p>The key represents the cost and usage metrics. The following values are supported:</p>
        /// <ul>
        /// <li> <p> <code>BlendedCost</code> </p> </li>
        /// <li> <p> <code>UnblendedCost</code> </p> </li>
        /// <li> <p> <code>AmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetAmortizedCost</code> </p> </li>
        /// <li> <p> <code>NetUnblendedCost</code> </p> </li>
        /// <li> <p> <code>UsageQuantity</code> </p> </li>
        /// <li> <p> <code>NormalizedUsageAmount</code> </p> </li>
        /// </ul>
        /// <p>The supported key values for the <code>SortOrder</code> value are <code>ASCENDING</code> and <code>DESCENDING</code>.</p>
        /// <p>When you use the <code>SortBy</code> value, the <code>NextPageToken</code> and <code>SearchString</code> key values aren't supported.</p>
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SortDefinition>>,
        ) -> Self {
            self.sort_by = input;
            self
        }
        /// <p>This field is only used when the <code>SortBy</code> value is provided in the request.</p>
        /// <p>The maximum number of objects that are returned for this request. If <code>MaxResults</code> isn't specified with the <code>SortBy</code> value, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetCostCategories</code>, MaxResults has an upper quota of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>This field is only used when the <code>SortBy</code> value is provided in the request.</p>
        /// <p>The maximum number of objects that are returned for this request. If <code>MaxResults</code> isn't specified with the <code>SortBy</code> value, the request returns 1000 results as the default value for this parameter.</p>
        /// <p>For <code>GetCostCategories</code>, MaxResults has an upper quota of 1000.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCostCategoriesInput`](crate::input::GetCostCategoriesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCostCategoriesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCostCategoriesInput {
                search_string: self.search_string,
                time_period: self.time_period,
                cost_category_name: self.cost_category_name,
                filter: self.filter,
                sort_by: self.sort_by,
                max_results: self.max_results.unwrap_or_default(),
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCostAndUsageWithResourcesInput {
    /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    /// <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
    /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
    /// </note>
    /// <p> <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetCostAndUsageWithResourcesInput {
    /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    /// <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
    /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
    /// </note>
    /// <p> <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
    pub fn metrics(&self) -> std::option::Option<&[std::string::String]> {
        self.metrics.as_deref()
    }
    /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::GroupDefinition]> {
        self.group_by.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetCostAndUsageWithResourcesInput {
    /// Creates a new builder-style object to manufacture [`GetCostAndUsageWithResourcesInput`](crate::input::GetCostAndUsageWithResourcesInput).
    pub fn builder() -> crate::input::get_cost_and_usage_with_resources_input::Builder {
        crate::input::get_cost_and_usage_with_resources_input::Builder::default()
    }
}

/// See [`GetCostAndUsageWithResourcesInput`](crate::input::GetCostAndUsageWithResourcesInput).
pub mod get_cost_and_usage_with_resources_input {

    /// A builder for [`GetCostAndUsageWithResourcesInput`](crate::input::GetCostAndUsageWithResourcesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        /// <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        /// <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p> <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
        pub fn metrics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p> <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
        pub fn group_by(mut self, input: crate::model::GroupDefinition) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCostAndUsageWithResourcesInput`](crate::input::GetCostAndUsageWithResourcesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCostAndUsageWithResourcesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCostAndUsageWithResourcesInput {
                time_period: self.time_period,
                granularity: self.granularity,
                filter: self.filter,
                metrics: self.metrics,
                group_by: self.group_by,
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCostAndUsageInput {
    /// <p>Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::DateInterval>,
    /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
    #[doc(hidden)]
    pub granularity: std::option::Option<crate::model::Granularity>,
    /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::Expression>,
    /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
    /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
    /// </note>
    /// <p> <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
    #[doc(hidden)]
    pub metrics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types.</p>
    /// <p>Valid values for the <code>DIMENSION</code> type are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>INVOICING_ENTITY</code>, <code>LINKED_ACCOUNT</code>, <code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
    /// <p>When you group by the <code>TAG</code> type and include a valid tag key, you get all tag values, including empty strings.</p>
    #[doc(hidden)]
    pub group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
}
impl GetCostAndUsageInput {
    /// <p>Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    pub fn time_period(&self) -> std::option::Option<&crate::model::DateInterval> {
        self.time_period.as_ref()
    }
    /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
    pub fn granularity(&self) -> std::option::Option<&crate::model::Granularity> {
        self.granularity.as_ref()
    }
    /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::Expression> {
        self.filter.as_ref()
    }
    /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
    /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
    /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
    /// </note>
    /// <p> <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
    pub fn metrics(&self) -> std::option::Option<&[std::string::String]> {
        self.metrics.as_deref()
    }
    /// <p>You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types.</p>
    /// <p>Valid values for the <code>DIMENSION</code> type are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>INVOICING_ENTITY</code>, <code>LINKED_ACCOUNT</code>, <code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
    /// <p>When you group by the <code>TAG</code> type and include a valid tag key, you get all tag values, including empty strings.</p>
    pub fn group_by(&self) -> std::option::Option<&[crate::model::GroupDefinition]> {
        self.group_by.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
}
impl GetCostAndUsageInput {
    /// Creates a new builder-style object to manufacture [`GetCostAndUsageInput`](crate::input::GetCostAndUsageInput).
    pub fn builder() -> crate::input::get_cost_and_usage_input::Builder {
        crate::input::get_cost_and_usage_input::Builder::default()
    }
}

/// See [`GetCostAndUsageInput`](crate::input::GetCostAndUsageInput).
pub mod get_cost_and_usage_input {

    /// A builder for [`GetCostAndUsageInput`](crate::input::GetCostAndUsageInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_period: std::option::Option<crate::model::DateInterval>,
        pub(crate) granularity: std::option::Option<crate::model::Granularity>,
        pub(crate) filter: std::option::Option<crate::model::Expression>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) group_by: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn time_period(mut self, input: crate::model::DateInterval) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
        pub fn set_time_period(
            mut self,
            input: std::option::Option<crate::model::DateInterval>,
        ) -> Self {
            self.time_period = input;
            self
        }
        /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn granularity(mut self, input: crate::model::Granularity) -> Self {
            self.granularity = Some(input);
            self
        }
        /// <p>Sets the Amazon Web Services cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set, the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
        pub fn set_granularity(
            mut self,
            input: std::option::Option<crate::model::Granularity>,
        ) -> Self {
            self.granularity = input;
            self
        }
        /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        pub fn filter(mut self, input: crate::model::Expression) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects to define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>Dimensions</code> are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        /// <p>Valid values for <code>MatchOptions</code> for <code>CostCategories</code> and <code>Tags</code> are <code>EQUALS</code>, <code>ABSENT</code>, and <code>CASE_SENSITIVE</code>. Default values are <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::Expression>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p> <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
        pub fn metrics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation appear on some line items in my bill?</a>. </p>
        /// <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p> <note>
        /// <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
        /// </note>
        /// <p> <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Appends an item to `group_by`.
        ///
        /// To override the contents of this collection use [`set_group_by`](Self::set_group_by).
        ///
        /// <p>You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types.</p>
        /// <p>Valid values for the <code>DIMENSION</code> type are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>INVOICING_ENTITY</code>, <code>LINKED_ACCOUNT</code>, <code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
        /// <p>When you group by the <code>TAG</code> type and include a valid tag key, you get all tag values, including empty strings.</p>
        pub fn group_by(mut self, input: crate::model::GroupDefinition) -> Self {
            let mut v = self.group_by.unwrap_or_default();
            v.push(input);
            self.group_by = Some(v);
            self
        }
        /// <p>You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types.</p>
        /// <p>Valid values for the <code>DIMENSION</code> type are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>INVOICING_ENTITY</code>, <code>LINKED_ACCOUNT</code>, <code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
        /// <p>When you group by the <code>TAG</code> type and include a valid tag key, you get all tag values, including empty strings.</p>
        pub fn set_group_by(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GroupDefinition>>,
        ) -> Self {
            self.group_by = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCostAndUsageInput`](crate::input::GetCostAndUsageInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetCostAndUsageInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetCostAndUsageInput {
                time_period: self.time_period,
                granularity: self.granularity,
                filter: self.filter,
                metrics: self.metrics,
                group_by: self.group_by,
                next_page_token: self.next_page_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAnomalySubscriptionsInput {
    /// <p>A list of cost anomaly subscription ARNs. </p>
    #[doc(hidden)]
    pub subscription_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Cost anomaly monitor ARNs. </p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The number of entries a paginated response contains. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetAnomalySubscriptionsInput {
    /// <p>A list of cost anomaly subscription ARNs. </p>
    pub fn subscription_arn_list(&self) -> std::option::Option<&[std::string::String]> {
        self.subscription_arn_list.as_deref()
    }
    /// <p>Cost anomaly monitor ARNs. </p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The number of entries a paginated response contains. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetAnomalySubscriptionsInput {
    /// Creates a new builder-style object to manufacture [`GetAnomalySubscriptionsInput`](crate::input::GetAnomalySubscriptionsInput).
    pub fn builder() -> crate::input::get_anomaly_subscriptions_input::Builder {
        crate::input::get_anomaly_subscriptions_input::Builder::default()
    }
}

/// See [`GetAnomalySubscriptionsInput`](crate::input::GetAnomalySubscriptionsInput).
pub mod get_anomaly_subscriptions_input {

    /// A builder for [`GetAnomalySubscriptionsInput`](crate::input::GetAnomalySubscriptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `subscription_arn_list`.
        ///
        /// To override the contents of this collection use [`set_subscription_arn_list`](Self::set_subscription_arn_list).
        ///
        /// <p>A list of cost anomaly subscription ARNs. </p>
        pub fn subscription_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subscription_arn_list.unwrap_or_default();
            v.push(input.into());
            self.subscription_arn_list = Some(v);
            self
        }
        /// <p>A list of cost anomaly subscription ARNs. </p>
        pub fn set_subscription_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subscription_arn_list = input;
            self
        }
        /// <p>Cost anomaly monitor ARNs. </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>Cost anomaly monitor ARNs. </p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAnomalySubscriptionsInput`](crate::input::GetAnomalySubscriptionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAnomalySubscriptionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAnomalySubscriptionsInput {
                subscription_arn_list: self.subscription_arn_list,
                monitor_arn: self.monitor_arn,
                next_page_token: self.next_page_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAnomalyMonitorsInput {
    /// <p>A list of cost anomaly monitor ARNs. </p>
    #[doc(hidden)]
    pub monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The number of entries that a paginated response contains. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetAnomalyMonitorsInput {
    /// <p>A list of cost anomaly monitor ARNs. </p>
    pub fn monitor_arn_list(&self) -> std::option::Option<&[std::string::String]> {
        self.monitor_arn_list.as_deref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The number of entries that a paginated response contains. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetAnomalyMonitorsInput {
    /// Creates a new builder-style object to manufacture [`GetAnomalyMonitorsInput`](crate::input::GetAnomalyMonitorsInput).
    pub fn builder() -> crate::input::get_anomaly_monitors_input::Builder {
        crate::input::get_anomaly_monitors_input::Builder::default()
    }
}

/// See [`GetAnomalyMonitorsInput`](crate::input::GetAnomalyMonitorsInput).
pub mod get_anomaly_monitors_input {

    /// A builder for [`GetAnomalyMonitorsInput`](crate::input::GetAnomalyMonitorsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn_list: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `monitor_arn_list`.
        ///
        /// To override the contents of this collection use [`set_monitor_arn_list`](Self::set_monitor_arn_list).
        ///
        /// <p>A list of cost anomaly monitor ARNs. </p>
        pub fn monitor_arn_list(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.monitor_arn_list.unwrap_or_default();
            v.push(input.into());
            self.monitor_arn_list = Some(v);
            self
        }
        /// <p>A list of cost anomaly monitor ARNs. </p>
        pub fn set_monitor_arn_list(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.monitor_arn_list = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The number of entries that a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of entries that a paginated response contains. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAnomalyMonitorsInput`](crate::input::GetAnomalyMonitorsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetAnomalyMonitorsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetAnomalyMonitorsInput {
                monitor_arn_list: self.monitor_arn_list,
                next_page_token: self.next_page_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetAnomaliesInput {
    /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN). </p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
    /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an <code>AnomalyEndDate</code> in the specified time range. </p>
    #[doc(hidden)]
    pub date_interval: std::option::Option<crate::model::AnomalyDateInterval>,
    /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
    #[doc(hidden)]
    pub feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
    /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated dollar impact greater than 200. </p>
    #[doc(hidden)]
    pub total_impact: std::option::Option<crate::model::TotalImpactFilter>,
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    #[doc(hidden)]
    pub next_page_token: std::option::Option<std::string::String>,
    /// <p>The number of entries a paginated response contains. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl GetAnomaliesInput {
    /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN). </p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
    /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an <code>AnomalyEndDate</code> in the specified time range. </p>
    pub fn date_interval(&self) -> std::option::Option<&crate::model::AnomalyDateInterval> {
        self.date_interval.as_ref()
    }
    /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
    pub fn feedback(&self) -> std::option::Option<&crate::model::AnomalyFeedbackType> {
        self.feedback.as_ref()
    }
    /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated dollar impact greater than 200. </p>
    pub fn total_impact(&self) -> std::option::Option<&crate::model::TotalImpactFilter> {
        self.total_impact.as_ref()
    }
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
    pub fn next_page_token(&self) -> std::option::Option<&str> {
        self.next_page_token.as_deref()
    }
    /// <p>The number of entries a paginated response contains. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl GetAnomaliesInput {
    /// Creates a new builder-style object to manufacture [`GetAnomaliesInput`](crate::input::GetAnomaliesInput).
    pub fn builder() -> crate::input::get_anomalies_input::Builder {
        crate::input::get_anomalies_input::Builder::default()
    }
}

/// See [`GetAnomaliesInput`](crate::input::GetAnomaliesInput).
pub mod get_anomalies_input {

    /// A builder for [`GetAnomaliesInput`](crate::input::GetAnomaliesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
        pub(crate) date_interval: std::option::Option<crate::model::AnomalyDateInterval>,
        pub(crate) feedback: std::option::Option<crate::model::AnomalyFeedbackType>,
        pub(crate) total_impact: std::option::Option<crate::model::TotalImpactFilter>,
        pub(crate) next_page_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN). </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN). </p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an <code>AnomalyEndDate</code> in the specified time range. </p>
        pub fn date_interval(mut self, input: crate::model::AnomalyDateInterval) -> Self {
            self.date_interval = Some(input);
            self
        }
        /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an <code>AnomalyEndDate</code> in the specified time range. </p>
        pub fn set_date_interval(
            mut self,
            input: std::option::Option<crate::model::AnomalyDateInterval>,
        ) -> Self {
            self.date_interval = input;
            self
        }
        /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
        pub fn feedback(mut self, input: crate::model::AnomalyFeedbackType) -> Self {
            self.feedback = Some(input);
            self
        }
        /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
        pub fn set_feedback(
            mut self,
            input: std::option::Option<crate::model::AnomalyFeedbackType>,
        ) -> Self {
            self.feedback = input;
            self
        }
        /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated dollar impact greater than 200. </p>
        pub fn total_impact(mut self, input: crate::model::TotalImpactFilter) -> Self {
            self.total_impact = Some(input);
            self
        }
        /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated dollar impact greater than 200. </p>
        pub fn set_total_impact(
            mut self,
            input: std::option::Option<crate::model::TotalImpactFilter>,
        ) -> Self {
            self.total_impact = input;
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn next_page_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_page_token = Some(input.into());
            self
        }
        /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size. </p>
        pub fn set_next_page_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_page_token = input;
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The number of entries a paginated response contains. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAnomaliesInput`](crate::input::GetAnomaliesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetAnomaliesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetAnomaliesInput {
                monitor_arn: self.monitor_arn,
                date_interval: self.date_interval,
                feedback: self.feedback,
                total_impact: self.total_impact,
                next_page_token: self.next_page_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category. </p>
    #[doc(hidden)]
    pub cost_category_arn: std::option::Option<std::string::String>,
    /// <p>The date when the Cost Category was effective. </p>
    #[doc(hidden)]
    pub effective_on: std::option::Option<std::string::String>,
}
impl DescribeCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category. </p>
    pub fn cost_category_arn(&self) -> std::option::Option<&str> {
        self.cost_category_arn.as_deref()
    }
    /// <p>The date when the Cost Category was effective. </p>
    pub fn effective_on(&self) -> std::option::Option<&str> {
        self.effective_on.as_deref()
    }
}
impl DescribeCostCategoryDefinitionInput {
    /// Creates a new builder-style object to manufacture [`DescribeCostCategoryDefinitionInput`](crate::input::DescribeCostCategoryDefinitionInput).
    pub fn builder() -> crate::input::describe_cost_category_definition_input::Builder {
        crate::input::describe_cost_category_definition_input::Builder::default()
    }
}

/// See [`DescribeCostCategoryDefinitionInput`](crate::input::DescribeCostCategoryDefinitionInput).
pub mod describe_cost_category_definition_input {

    /// A builder for [`DescribeCostCategoryDefinitionInput`](crate::input::DescribeCostCategoryDefinitionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_category_arn: std::option::Option<std::string::String>,
        pub(crate) effective_on: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for your Cost Category. </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_arn = Some(input.into());
            self
        }
        /// <p>The unique identifier for your Cost Category. </p>
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_arn = input;
            self
        }
        /// <p>The date when the Cost Category was effective. </p>
        pub fn effective_on(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_on = Some(input.into());
            self
        }
        /// <p>The date when the Cost Category was effective. </p>
        pub fn set_effective_on(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.effective_on = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeCostCategoryDefinitionInput`](crate::input::DescribeCostCategoryDefinitionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeCostCategoryDefinitionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeCostCategoryDefinitionInput {
                cost_category_arn: self.cost_category_arn,
                effective_on: self.effective_on,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category. </p>
    #[doc(hidden)]
    pub cost_category_arn: std::option::Option<std::string::String>,
}
impl DeleteCostCategoryDefinitionInput {
    /// <p>The unique identifier for your Cost Category. </p>
    pub fn cost_category_arn(&self) -> std::option::Option<&str> {
        self.cost_category_arn.as_deref()
    }
}
impl DeleteCostCategoryDefinitionInput {
    /// Creates a new builder-style object to manufacture [`DeleteCostCategoryDefinitionInput`](crate::input::DeleteCostCategoryDefinitionInput).
    pub fn builder() -> crate::input::delete_cost_category_definition_input::Builder {
        crate::input::delete_cost_category_definition_input::Builder::default()
    }
}

/// See [`DeleteCostCategoryDefinitionInput`](crate::input::DeleteCostCategoryDefinitionInput).
pub mod delete_cost_category_definition_input {

    /// A builder for [`DeleteCostCategoryDefinitionInput`](crate::input::DeleteCostCategoryDefinitionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cost_category_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for your Cost Category. </p>
        pub fn cost_category_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.cost_category_arn = Some(input.into());
            self
        }
        /// <p>The unique identifier for your Cost Category. </p>
        pub fn set_cost_category_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cost_category_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCostCategoryDefinitionInput`](crate::input::DeleteCostCategoryDefinitionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteCostCategoryDefinitionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteCostCategoryDefinitionInput {
                cost_category_arn: self.cost_category_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAnomalySubscriptionInput {
    /// <p>The unique identifier of the cost anomaly subscription that you want to delete. </p>
    #[doc(hidden)]
    pub subscription_arn: std::option::Option<std::string::String>,
}
impl DeleteAnomalySubscriptionInput {
    /// <p>The unique identifier of the cost anomaly subscription that you want to delete. </p>
    pub fn subscription_arn(&self) -> std::option::Option<&str> {
        self.subscription_arn.as_deref()
    }
}
impl DeleteAnomalySubscriptionInput {
    /// Creates a new builder-style object to manufacture [`DeleteAnomalySubscriptionInput`](crate::input::DeleteAnomalySubscriptionInput).
    pub fn builder() -> crate::input::delete_anomaly_subscription_input::Builder {
        crate::input::delete_anomaly_subscription_input::Builder::default()
    }
}

/// See [`DeleteAnomalySubscriptionInput`](crate::input::DeleteAnomalySubscriptionInput).
pub mod delete_anomaly_subscription_input {

    /// A builder for [`DeleteAnomalySubscriptionInput`](crate::input::DeleteAnomalySubscriptionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subscription_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the cost anomaly subscription that you want to delete. </p>
        pub fn subscription_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subscription_arn = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cost anomaly subscription that you want to delete. </p>
        pub fn set_subscription_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.subscription_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAnomalySubscriptionInput`](crate::input::DeleteAnomalySubscriptionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAnomalySubscriptionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAnomalySubscriptionInput {
                subscription_arn: self.subscription_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAnomalyMonitorInput {
    /// <p>The unique identifier of the cost anomaly monitor that you want to delete. </p>
    #[doc(hidden)]
    pub monitor_arn: std::option::Option<std::string::String>,
}
impl DeleteAnomalyMonitorInput {
    /// <p>The unique identifier of the cost anomaly monitor that you want to delete. </p>
    pub fn monitor_arn(&self) -> std::option::Option<&str> {
        self.monitor_arn.as_deref()
    }
}
impl DeleteAnomalyMonitorInput {
    /// Creates a new builder-style object to manufacture [`DeleteAnomalyMonitorInput`](crate::input::DeleteAnomalyMonitorInput).
    pub fn builder() -> crate::input::delete_anomaly_monitor_input::Builder {
        crate::input::delete_anomaly_monitor_input::Builder::default()
    }
}

/// See [`DeleteAnomalyMonitorInput`](crate::input::DeleteAnomalyMonitorInput).
pub mod delete_anomaly_monitor_input {

    /// A builder for [`DeleteAnomalyMonitorInput`](crate::input::DeleteAnomalyMonitorInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) monitor_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the cost anomaly monitor that you want to delete. </p>
        pub fn monitor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.monitor_arn = Some(input.into());
            self
        }
        /// <p>The unique identifier of the cost anomaly monitor that you want to delete. </p>
        pub fn set_monitor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.monitor_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAnomalyMonitorInput`](crate::input::DeleteAnomalyMonitorInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAnomalyMonitorInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAnomalyMonitorInput {
                monitor_arn: self.monitor_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCostCategoryDefinitionInput {
    /// <p>The unique name of the Cost Category.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
    #[doc(hidden)]
    pub effective_start: std::option::Option<std::string::String>,
    /// <p>The rule schema version in this particular Cost Category.</p>
    #[doc(hidden)]
    pub rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
    /// <p>The Cost Category rules used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
    #[doc(hidden)]
    pub rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
    /// <p>The default value for the cost category.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
    #[doc(hidden)]
    pub split_charge_rules:
        std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html"> <code>CostCategory</code> </a>. You can use resource tags to control access to your <code>cost category</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
}
impl CreateCostCategoryDefinitionInput {
    /// <p>The unique name of the Cost Category.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
    pub fn effective_start(&self) -> std::option::Option<&str> {
        self.effective_start.as_deref()
    }
    /// <p>The rule schema version in this particular Cost Category.</p>
    pub fn rule_version(&self) -> std::option::Option<&crate::model::CostCategoryRuleVersion> {
        self.rule_version.as_ref()
    }
    /// <p>The Cost Category rules used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
    pub fn rules(&self) -> std::option::Option<&[crate::model::CostCategoryRule]> {
        self.rules.as_deref()
    }
    /// <p>The default value for the cost category.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
    pub fn split_charge_rules(
        &self,
    ) -> std::option::Option<&[crate::model::CostCategorySplitChargeRule]> {
        self.split_charge_rules.as_deref()
    }
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html"> <code>CostCategory</code> </a>. You can use resource tags to control access to your <code>cost category</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
}
impl CreateCostCategoryDefinitionInput {
    /// Creates a new builder-style object to manufacture [`CreateCostCategoryDefinitionInput`](crate::input::CreateCostCategoryDefinitionInput).
    pub fn builder() -> crate::input::create_cost_category_definition_input::Builder {
        crate::input::create_cost_category_definition_input::Builder::default()
    }
}

/// See [`CreateCostCategoryDefinitionInput`](crate::input::CreateCostCategoryDefinitionInput).
pub mod create_cost_category_definition_input {

    /// A builder for [`CreateCostCategoryDefinitionInput`](crate::input::CreateCostCategoryDefinitionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) effective_start: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<crate::model::CostCategoryRuleVersion>,
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) split_charge_rules:
            std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    }
    impl Builder {
        /// <p>The unique name of the Cost Category.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The unique name of the Cost Category.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
        pub fn effective_start(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_start = Some(input.into());
            self
        }
        /// <p>The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.</p>
        pub fn set_effective_start(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_start = input;
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn rule_version(mut self, input: crate::model::CostCategoryRuleVersion) -> Self {
            self.rule_version = Some(input);
            self
        }
        /// <p>The rule schema version in this particular Cost Category.</p>
        pub fn set_rule_version(
            mut self,
            input: std::option::Option<crate::model::CostCategoryRuleVersion>,
        ) -> Self {
            self.rule_version = input;
            self
        }
        /// Appends an item to `rules`.
        ///
        /// To override the contents of this collection use [`set_rules`](Self::set_rules).
        ///
        /// <p>The Cost Category rules used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
        pub fn rules(mut self, input: crate::model::CostCategoryRule) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input);
            self.rules = Some(v);
            self
        }
        /// <p>The Cost Category rules used to categorize costs. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategoryRule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value for the cost category.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Appends an item to `split_charge_rules`.
        ///
        /// To override the contents of this collection use [`set_split_charge_rules`](Self::set_split_charge_rules).
        ///
        /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
        pub fn split_charge_rules(
            mut self,
            input: crate::model::CostCategorySplitChargeRule,
        ) -> Self {
            let mut v = self.split_charge_rules.unwrap_or_default();
            v.push(input);
            self.split_charge_rules = Some(v);
            self
        }
        /// <p> The split charge rules used to allocate your charges between your Cost Category values. </p>
        pub fn set_split_charge_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CostCategorySplitChargeRule>>,
        ) -> Self {
            self.split_charge_rules = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html"> <code>CostCategory</code> </a>. You can use resource tags to control access to your <code>cost category</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html"> <code>CostCategory</code> </a>. You can use resource tags to control access to your <code>cost category</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCostCategoryDefinitionInput`](crate::input::CreateCostCategoryDefinitionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateCostCategoryDefinitionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateCostCategoryDefinitionInput {
                name: self.name,
                effective_start: self.effective_start,
                rule_version: self.rule_version,
                rules: self.rules,
                default_value: self.default_value,
                split_charge_rules: self.split_charge_rules,
                resource_tags: self.resource_tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAnomalySubscriptionInput {
    /// <p>The cost anomaly subscription object that you want to create. </p>
    #[doc(hidden)]
    pub anomaly_subscription: std::option::Option<crate::model::AnomalySubscription>,
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html"> <code>AnomalySubscription</code> </a>. You can use resource tags to control access to your <code>subscription</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
}
impl CreateAnomalySubscriptionInput {
    /// <p>The cost anomaly subscription object that you want to create. </p>
    pub fn anomaly_subscription(&self) -> std::option::Option<&crate::model::AnomalySubscription> {
        self.anomaly_subscription.as_ref()
    }
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html"> <code>AnomalySubscription</code> </a>. You can use resource tags to control access to your <code>subscription</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
}
impl CreateAnomalySubscriptionInput {
    /// Creates a new builder-style object to manufacture [`CreateAnomalySubscriptionInput`](crate::input::CreateAnomalySubscriptionInput).
    pub fn builder() -> crate::input::create_anomaly_subscription_input::Builder {
        crate::input::create_anomaly_subscription_input::Builder::default()
    }
}

/// See [`CreateAnomalySubscriptionInput`](crate::input::CreateAnomalySubscriptionInput).
pub mod create_anomaly_subscription_input {

    /// A builder for [`CreateAnomalySubscriptionInput`](crate::input::CreateAnomalySubscriptionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) anomaly_subscription: std::option::Option<crate::model::AnomalySubscription>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    }
    impl Builder {
        /// <p>The cost anomaly subscription object that you want to create. </p>
        pub fn anomaly_subscription(mut self, input: crate::model::AnomalySubscription) -> Self {
            self.anomaly_subscription = Some(input);
            self
        }
        /// <p>The cost anomaly subscription object that you want to create. </p>
        pub fn set_anomaly_subscription(
            mut self,
            input: std::option::Option<crate::model::AnomalySubscription>,
        ) -> Self {
            self.anomaly_subscription = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html"> <code>AnomalySubscription</code> </a>. You can use resource tags to control access to your <code>subscription</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html"> <code>AnomalySubscription</code> </a>. You can use resource tags to control access to your <code>subscription</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAnomalySubscriptionInput`](crate::input::CreateAnomalySubscriptionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAnomalySubscriptionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAnomalySubscriptionInput {
                anomaly_subscription: self.anomaly_subscription,
                resource_tags: self.resource_tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAnomalyMonitorInput {
    /// <p>The cost anomaly detection monitor object that you want to create.</p>
    #[doc(hidden)]
    pub anomaly_monitor: std::option::Option<crate::model::AnomalyMonitor>,
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html"> <code>AnomalyMonitor</code> </a>. You can use resource tags to control access to your <code>monitor</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
}
impl CreateAnomalyMonitorInput {
    /// <p>The cost anomaly detection monitor object that you want to create.</p>
    pub fn anomaly_monitor(&self) -> std::option::Option<&crate::model::AnomalyMonitor> {
        self.anomaly_monitor.as_ref()
    }
    /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html"> <code>AnomalyMonitor</code> </a>. You can use resource tags to control access to your <code>monitor</code> using IAM policies.</p>
    /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
    /// <ul>
    /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
    /// <li> <p>The maximum length of a key is 128 characters</p> </li>
    /// <li> <p>The maximum length of a value is 256 characters</p> </li>
    /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
    /// <li> <p>Keys and values are case sensitive</p> </li>
    /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
    /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
    /// </ul>
    pub fn resource_tags(&self) -> std::option::Option<&[crate::model::ResourceTag]> {
        self.resource_tags.as_deref()
    }
}
impl CreateAnomalyMonitorInput {
    /// Creates a new builder-style object to manufacture [`CreateAnomalyMonitorInput`](crate::input::CreateAnomalyMonitorInput).
    pub fn builder() -> crate::input::create_anomaly_monitor_input::Builder {
        crate::input::create_anomaly_monitor_input::Builder::default()
    }
}

/// See [`CreateAnomalyMonitorInput`](crate::input::CreateAnomalyMonitorInput).
pub mod create_anomaly_monitor_input {

    /// A builder for [`CreateAnomalyMonitorInput`](crate::input::CreateAnomalyMonitorInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) anomaly_monitor: std::option::Option<crate::model::AnomalyMonitor>,
        pub(crate) resource_tags: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
    }
    impl Builder {
        /// <p>The cost anomaly detection monitor object that you want to create.</p>
        pub fn anomaly_monitor(mut self, input: crate::model::AnomalyMonitor) -> Self {
            self.anomaly_monitor = Some(input);
            self
        }
        /// <p>The cost anomaly detection monitor object that you want to create.</p>
        pub fn set_anomaly_monitor(
            mut self,
            input: std::option::Option<crate::model::AnomalyMonitor>,
        ) -> Self {
            self.anomaly_monitor = input;
            self
        }
        /// Appends an item to `resource_tags`.
        ///
        /// To override the contents of this collection use [`set_resource_tags`](Self::set_resource_tags).
        ///
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html"> <code>AnomalyMonitor</code> </a>. You can use resource tags to control access to your <code>monitor</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn resource_tags(mut self, input: crate::model::ResourceTag) -> Self {
            let mut v = self.resource_tags.unwrap_or_default();
            v.push(input);
            self.resource_tags = Some(v);
            self
        }
        /// <p>An optional list of tags to associate with the specified <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html"> <code>AnomalyMonitor</code> </a>. You can use resource tags to control access to your <code>monitor</code> using IAM policies.</p>
        /// <p>Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:</p>
        /// <ul>
        /// <li> <p>Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use</p> </li>
        /// <li> <p>The maximum length of a key is 128 characters</p> </li>
        /// <li> <p>The maximum length of a value is 256 characters</p> </li>
        /// <li> <p>Keys and values can only contain alphanumeric characters, spaces, and any of the following: <code>_.:/=+@-</code> </p> </li>
        /// <li> <p>Keys and values are case sensitive</p> </li>
        /// <li> <p>Keys and values are trimmed for any leading or trailing whitespaces</p> </li>
        /// <li> <p>Don’t use <code>aws:</code> as a prefix for your keys. This prefix is reserved for Amazon Web Services use</p> </li>
        /// </ul>
        pub fn set_resource_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceTag>>,
        ) -> Self {
            self.resource_tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAnomalyMonitorInput`](crate::input::CreateAnomalyMonitorInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAnomalyMonitorInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAnomalyMonitorInput {
                anomaly_monitor: self.anomaly_monitor,
                resource_tags: self.resource_tags,
            })
        }
    }
}
