// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The details about a composite alarm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CompositeAlarm  {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state.</p>
    #[doc(hidden)]
    pub actions_enabled: std::option::Option<bool>,
    /// <p>The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    #[doc(hidden)]
    pub alarm_arn: std::option::Option<std::string::String>,
    /// <p>The time stamp of the last update to the alarm configuration.</p>
    #[doc(hidden)]
    pub alarm_configuration_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The description of the alarm.</p>
    #[doc(hidden)]
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>The name of the alarm.</p>
    #[doc(hidden)]
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The rule that this alarm uses to evaluate its alarm state.</p>
    #[doc(hidden)]
    pub alarm_rule: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    #[doc(hidden)]
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An explanation for the alarm state, in text format.</p>
    #[doc(hidden)]
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>An explanation for the alarm state, in JSON format.</p>
    #[doc(hidden)]
    pub state_reason_data: std::option::Option<std::string::String>,
    /// <p>Tracks the timestamp of any state update, even if <code>StateValue</code> doesn't change.</p>
    #[doc(hidden)]
    pub state_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state value for the alarm.</p>
    #[doc(hidden)]
    pub state_value: std::option::Option<crate::types::StateValue>,
    /// <p> The timestamp of the last change to the alarm's <code>StateValue</code>. </p>
    #[doc(hidden)]
    pub state_transitioned_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> When the value is <code>ALARM</code>, it means that the actions are suppressed because the suppressor alarm is in <code>ALARM</code> When the value is <code>WaitPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting for the suppressor alarm to go into into the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorWaitPeriod</code>. After this time, the composite alarm performs its actions. When the value is <code>ExtensionPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting after the suppressor alarm went out of the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorExtensionPeriod</code>. After this time, the composite alarm performs its actions. </p>
    #[doc(hidden)]
    pub actions_suppressed_by: std::option::Option<crate::types::ActionsSuppressedBy>,
    /// <p> Captures the reason for action suppression. </p>
    #[doc(hidden)]
    pub actions_suppressed_reason: std::option::Option<std::string::String>,
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    #[doc(hidden)]
    pub actions_suppressor: std::option::Option<std::string::String>,
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    #[doc(hidden)]
    pub actions_suppressor_wait_period: std::option::Option<i32>,
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    #[doc(hidden)]
    pub actions_suppressor_extension_period: std::option::Option<i32>,
}
impl CompositeAlarm {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state.</p>
    pub fn actions_enabled(&self) -> std::option::Option<bool> {
        self.actions_enabled
    }
    /// <p>The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn alarm_actions(&self) -> std::option::Option<& [std::string::String]> {
        self.alarm_actions.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    pub fn alarm_arn(&self) -> std::option::Option<& str> {
        self.alarm_arn.as_deref()
    }
    /// <p>The time stamp of the last update to the alarm configuration.</p>
    pub fn alarm_configuration_updated_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.alarm_configuration_updated_timestamp.as_ref()
    }
    /// <p>The description of the alarm.</p>
    pub fn alarm_description(&self) -> std::option::Option<& str> {
        self.alarm_description.as_deref()
    }
    /// <p>The name of the alarm.</p>
    pub fn alarm_name(&self) -> std::option::Option<& str> {
        self.alarm_name.as_deref()
    }
    /// <p>The rule that this alarm uses to evaluate its alarm state.</p>
    pub fn alarm_rule(&self) -> std::option::Option<& str> {
        self.alarm_rule.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn insufficient_data_actions(&self) -> std::option::Option<& [std::string::String]> {
        self.insufficient_data_actions.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn ok_actions(&self) -> std::option::Option<& [std::string::String]> {
        self.ok_actions.as_deref()
    }
    /// <p>An explanation for the alarm state, in text format.</p>
    pub fn state_reason(&self) -> std::option::Option<& str> {
        self.state_reason.as_deref()
    }
    /// <p>An explanation for the alarm state, in JSON format.</p>
    pub fn state_reason_data(&self) -> std::option::Option<& str> {
        self.state_reason_data.as_deref()
    }
    /// <p>Tracks the timestamp of any state update, even if <code>StateValue</code> doesn't change.</p>
    pub fn state_updated_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.state_updated_timestamp.as_ref()
    }
    /// <p>The state value for the alarm.</p>
    pub fn state_value(&self) -> std::option::Option<& crate::types::StateValue> {
        self.state_value.as_ref()
    }
    /// <p> The timestamp of the last change to the alarm's <code>StateValue</code>. </p>
    pub fn state_transitioned_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.state_transitioned_timestamp.as_ref()
    }
    /// <p> When the value is <code>ALARM</code>, it means that the actions are suppressed because the suppressor alarm is in <code>ALARM</code> When the value is <code>WaitPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting for the suppressor alarm to go into into the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorWaitPeriod</code>. After this time, the composite alarm performs its actions. When the value is <code>ExtensionPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting after the suppressor alarm went out of the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorExtensionPeriod</code>. After this time, the composite alarm performs its actions. </p>
    pub fn actions_suppressed_by(&self) -> std::option::Option<& crate::types::ActionsSuppressedBy> {
        self.actions_suppressed_by.as_ref()
    }
    /// <p> Captures the reason for action suppression. </p>
    pub fn actions_suppressed_reason(&self) -> std::option::Option<& str> {
        self.actions_suppressed_reason.as_deref()
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn actions_suppressor(&self) -> std::option::Option<& str> {
        self.actions_suppressor.as_deref()
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn actions_suppressor_wait_period(&self) -> std::option::Option<i32> {
        self.actions_suppressor_wait_period
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn actions_suppressor_extension_period(&self) -> std::option::Option<i32> {
        self.actions_suppressor_extension_period
    }
}
impl CompositeAlarm {
    /// Creates a new builder-style object to manufacture [`CompositeAlarm`](crate::types::CompositeAlarm).
    pub fn builder() -> crate::types::builders::CompositeAlarmBuilder {
        crate::types::builders::CompositeAlarmBuilder::default()
    }
}

/// A builder for [`CompositeAlarm`](crate::types::CompositeAlarm).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CompositeAlarmBuilder {
    pub(crate) actions_enabled: std::option::Option<bool>,
    pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) alarm_arn: std::option::Option<std::string::String>,
    pub(crate) alarm_configuration_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) alarm_description: std::option::Option<std::string::String>,
    pub(crate) alarm_name: std::option::Option<std::string::String>,
    pub(crate) alarm_rule: std::option::Option<std::string::String>,
    pub(crate) insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) state_reason: std::option::Option<std::string::String>,
    pub(crate) state_reason_data: std::option::Option<std::string::String>,
    pub(crate) state_updated_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) state_value: std::option::Option<crate::types::StateValue>,
    pub(crate) state_transitioned_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) actions_suppressed_by: std::option::Option<crate::types::ActionsSuppressedBy>,
    pub(crate) actions_suppressed_reason: std::option::Option<std::string::String>,
    pub(crate) actions_suppressor: std::option::Option<std::string::String>,
    pub(crate) actions_suppressor_wait_period: std::option::Option<i32>,
    pub(crate) actions_suppressor_extension_period: std::option::Option<i32>,
}
impl CompositeAlarmBuilder {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state.</p>
    pub fn actions_enabled(mut self, input: bool) -> Self {
        self.actions_enabled = Some(input);
        self
    }
    /// <p>Indicates whether actions should be executed during any changes to the alarm state.</p>
    pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.actions_enabled = input; self
    }
    /// Appends an item to `alarm_actions`.
    ///
    /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.alarm_actions.unwrap_or_default();
                        v.push(input.into());
                        self.alarm_actions = Some(v);
                        self
    }
    /// <p>The actions to execute when this alarm transitions to the ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn set_alarm_actions(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.alarm_actions = input; self
    }
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    pub fn alarm_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    pub fn set_alarm_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_arn = input; self
    }
    /// <p>The time stamp of the last update to the alarm configuration.</p>
    pub fn alarm_configuration_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.alarm_configuration_updated_timestamp = Some(input);
        self
    }
    /// <p>The time stamp of the last update to the alarm configuration.</p>
    pub fn set_alarm_configuration_updated_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.alarm_configuration_updated_timestamp = input; self
    }
    /// <p>The description of the alarm.</p>
    pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_description = Some(input.into());
        self
    }
    /// <p>The description of the alarm.</p>
    pub fn set_alarm_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_description = input; self
    }
    /// <p>The name of the alarm.</p>
    pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_name = Some(input.into());
        self
    }
    /// <p>The name of the alarm.</p>
    pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_name = input; self
    }
    /// <p>The rule that this alarm uses to evaluate its alarm state.</p>
    pub fn alarm_rule(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_rule = Some(input.into());
        self
    }
    /// <p>The rule that this alarm uses to evaluate its alarm state.</p>
    pub fn set_alarm_rule(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_rule = input; self
    }
    /// Appends an item to `insufficient_data_actions`.
    ///
    /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.insufficient_data_actions.unwrap_or_default();
                        v.push(input.into());
                        self.insufficient_data_actions = Some(v);
                        self
    }
    /// <p>The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn set_insufficient_data_actions(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.insufficient_data_actions = input; self
    }
    /// Appends an item to `ok_actions`.
    ///
    /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.ok_actions.unwrap_or_default();
                        v.push(input.into());
                        self.ok_actions = Some(v);
                        self
    }
    /// <p>The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    pub fn set_ok_actions(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.ok_actions = input; self
    }
    /// <p>An explanation for the alarm state, in text format.</p>
    pub fn state_reason(mut self, input: impl Into<std::string::String>) -> Self {
        self.state_reason = Some(input.into());
        self
    }
    /// <p>An explanation for the alarm state, in text format.</p>
    pub fn set_state_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.state_reason = input; self
    }
    /// <p>An explanation for the alarm state, in JSON format.</p>
    pub fn state_reason_data(mut self, input: impl Into<std::string::String>) -> Self {
        self.state_reason_data = Some(input.into());
        self
    }
    /// <p>An explanation for the alarm state, in JSON format.</p>
    pub fn set_state_reason_data(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.state_reason_data = input; self
    }
    /// <p>Tracks the timestamp of any state update, even if <code>StateValue</code> doesn't change.</p>
    pub fn state_updated_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.state_updated_timestamp = Some(input);
        self
    }
    /// <p>Tracks the timestamp of any state update, even if <code>StateValue</code> doesn't change.</p>
    pub fn set_state_updated_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.state_updated_timestamp = input; self
    }
    /// <p>The state value for the alarm.</p>
    pub fn state_value(mut self, input: crate::types::StateValue) -> Self {
        self.state_value = Some(input);
        self
    }
    /// <p>The state value for the alarm.</p>
    pub fn set_state_value(mut self, input: std::option::Option<crate::types::StateValue>) -> Self {
        self.state_value = input; self
    }
    /// <p> The timestamp of the last change to the alarm's <code>StateValue</code>. </p>
    pub fn state_transitioned_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.state_transitioned_timestamp = Some(input);
        self
    }
    /// <p> The timestamp of the last change to the alarm's <code>StateValue</code>. </p>
    pub fn set_state_transitioned_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.state_transitioned_timestamp = input; self
    }
    /// <p> When the value is <code>ALARM</code>, it means that the actions are suppressed because the suppressor alarm is in <code>ALARM</code> When the value is <code>WaitPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting for the suppressor alarm to go into into the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorWaitPeriod</code>. After this time, the composite alarm performs its actions. When the value is <code>ExtensionPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting after the suppressor alarm went out of the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorExtensionPeriod</code>. After this time, the composite alarm performs its actions. </p>
    pub fn actions_suppressed_by(mut self, input: crate::types::ActionsSuppressedBy) -> Self {
        self.actions_suppressed_by = Some(input);
        self
    }
    /// <p> When the value is <code>ALARM</code>, it means that the actions are suppressed because the suppressor alarm is in <code>ALARM</code> When the value is <code>WaitPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting for the suppressor alarm to go into into the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorWaitPeriod</code>. After this time, the composite alarm performs its actions. When the value is <code>ExtensionPeriod</code>, it means that the actions are suppressed because the composite alarm is waiting after the suppressor alarm went out of the <code>ALARM</code> state. The maximum waiting time is as specified in <code>ActionsSuppressorExtensionPeriod</code>. After this time, the composite alarm performs its actions. </p>
    pub fn set_actions_suppressed_by(mut self, input: std::option::Option<crate::types::ActionsSuppressedBy>) -> Self {
        self.actions_suppressed_by = input; self
    }
    /// <p> Captures the reason for action suppression. </p>
    pub fn actions_suppressed_reason(mut self, input: impl Into<std::string::String>) -> Self {
        self.actions_suppressed_reason = Some(input.into());
        self
    }
    /// <p> Captures the reason for action suppression. </p>
    pub fn set_actions_suppressed_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.actions_suppressed_reason = input; self
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn actions_suppressor(mut self, input: impl Into<std::string::String>) -> Self {
        self.actions_suppressor = Some(input.into());
        self
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn set_actions_suppressor(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.actions_suppressor = input; self
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn actions_suppressor_wait_period(mut self, input: i32) -> Self {
        self.actions_suppressor_wait_period = Some(input);
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn set_actions_suppressor_wait_period(mut self, input: std::option::Option<i32>) -> Self {
        self.actions_suppressor_wait_period = input; self
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn actions_suppressor_extension_period(mut self, input: i32) -> Self {
        self.actions_suppressor_extension_period = Some(input);
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important> 
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p> 
    /// </important>
    pub fn set_actions_suppressor_extension_period(mut self, input: std::option::Option<i32>) -> Self {
        self.actions_suppressor_extension_period = input; self
    }
    /// Consumes the builder and constructs a [`CompositeAlarm`](crate::types::CompositeAlarm).
    pub fn build(self) -> crate::types::CompositeAlarm {
        crate::types::CompositeAlarm {
            actions_enabled: self.actions_enabled
            ,
            alarm_actions: self.alarm_actions
            ,
            alarm_arn: self.alarm_arn
            ,
            alarm_configuration_updated_timestamp: self.alarm_configuration_updated_timestamp
            ,
            alarm_description: self.alarm_description
            ,
            alarm_name: self.alarm_name
            ,
            alarm_rule: self.alarm_rule
            ,
            insufficient_data_actions: self.insufficient_data_actions
            ,
            ok_actions: self.ok_actions
            ,
            state_reason: self.state_reason
            ,
            state_reason_data: self.state_reason_data
            ,
            state_updated_timestamp: self.state_updated_timestamp
            ,
            state_value: self.state_value
            ,
            state_transitioned_timestamp: self.state_transitioned_timestamp
            ,
            actions_suppressed_by: self.actions_suppressed_by
            ,
            actions_suppressed_reason: self.actions_suppressed_reason
            ,
            actions_suppressor: self.actions_suppressor
            ,
            actions_suppressor_wait_period: self.actions_suppressor_wait_period
            ,
            actions_suppressor_extension_period: self.actions_suppressor_extension_period
            ,
        }
    }
}

