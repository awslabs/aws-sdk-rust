// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutCompositeAlarmInput {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is <code>TRUE</code>.</p>
    #[doc(hidden)]
    pub actions_enabled: std::option::Option<bool>,
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i> </code> </p>
    #[doc(hidden)]
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The description for the composite alarm.</p>
    #[doc(hidden)]
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
    #[doc(hidden)]
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression.</p>
    /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
    /// <p>Functions can include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in ALARM state.</p> </li>
    /// <li> <p> <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in OK state.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in INSUFFICIENT_DATA state.</p> </li>
    /// <li> <p> <code>TRUE</code> always evaluates to TRUE.</p> </li>
    /// <li> <p> <code>FALSE</code> always evaluates to FALSE.</p> </li>
    /// </ul>
    /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and for testing your alarm actions.</p>
    /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
    /// <p>The following are some examples of <code>AlarmRule</code>:</p>
    /// <ul>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p> </li>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code> specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state and DeploymentInProgress is not in ALARM state. This example reduces alarm noise during a known deployment window.</p> </li>
    /// <li> <p> <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state. This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an alarm action on high CPU or disk usage if a known network problem is also occurring.</p> </li>
    /// </ul>
    /// <p>The <code>AlarmRule</code> can specify as many as 100 "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements are child alarms, TRUE or FALSE statements, and parentheses.</p>
    #[doc(hidden)]
    pub alarm_rule: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    #[doc(hidden)]
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    #[doc(hidden)]
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    #[doc(hidden)]
    pub actions_suppressor: std::option::Option<std::string::String>,
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    #[doc(hidden)]
    pub actions_suppressor_wait_period: std::option::Option<i32>,
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    #[doc(hidden)]
    pub actions_suppressor_extension_period: std::option::Option<i32>,
}
impl PutCompositeAlarmInput {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is <code>TRUE</code>.</p>
    pub fn actions_enabled(&self) -> std::option::Option<bool> {
        self.actions_enabled
    }
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i> </code> </p>
    pub fn alarm_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.alarm_actions.as_deref()
    }
    /// <p>The description for the composite alarm.</p>
    pub fn alarm_description(&self) -> std::option::Option<&str> {
        self.alarm_description.as_deref()
    }
    /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
    pub fn alarm_name(&self) -> std::option::Option<&str> {
        self.alarm_name.as_deref()
    }
    /// <p>An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression.</p>
    /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
    /// <p>Functions can include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in ALARM state.</p> </li>
    /// <li> <p> <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in OK state.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in INSUFFICIENT_DATA state.</p> </li>
    /// <li> <p> <code>TRUE</code> always evaluates to TRUE.</p> </li>
    /// <li> <p> <code>FALSE</code> always evaluates to FALSE.</p> </li>
    /// </ul>
    /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and for testing your alarm actions.</p>
    /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
    /// <p>The following are some examples of <code>AlarmRule</code>:</p>
    /// <ul>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p> </li>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code> specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state and DeploymentInProgress is not in ALARM state. This example reduces alarm noise during a known deployment window.</p> </li>
    /// <li> <p> <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state. This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an alarm action on high CPU or disk usage if a known network problem is also occurring.</p> </li>
    /// </ul>
    /// <p>The <code>AlarmRule</code> can specify as many as 100 "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements are child alarms, TRUE or FALSE statements, and parentheses.</p>
    pub fn alarm_rule(&self) -> std::option::Option<&str> {
        self.alarm_rule.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn insufficient_data_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.insufficient_data_actions.as_deref()
    }
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn ok_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.ok_actions.as_deref()
    }
    /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn actions_suppressor(&self) -> std::option::Option<&str> {
        self.actions_suppressor.as_deref()
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn actions_suppressor_wait_period(&self) -> std::option::Option<i32> {
        self.actions_suppressor_wait_period
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn actions_suppressor_extension_period(&self) -> std::option::Option<i32> {
        self.actions_suppressor_extension_period
    }
}
impl PutCompositeAlarmInput {
    /// Creates a new builder-style object to manufacture [`PutCompositeAlarmInput`](crate::operation::put_composite_alarm::PutCompositeAlarmInput).
    pub fn builder(
    ) -> crate::operation::put_composite_alarm::builders::PutCompositeAlarmInputBuilder {
        crate::operation::put_composite_alarm::builders::PutCompositeAlarmInputBuilder::default()
    }
}

/// A builder for [`PutCompositeAlarmInput`](crate::operation::put_composite_alarm::PutCompositeAlarmInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PutCompositeAlarmInputBuilder {
    pub(crate) actions_enabled: std::option::Option<bool>,
    pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) alarm_description: std::option::Option<std::string::String>,
    pub(crate) alarm_name: std::option::Option<std::string::String>,
    pub(crate) alarm_rule: std::option::Option<std::string::String>,
    pub(crate) insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    pub(crate) actions_suppressor: std::option::Option<std::string::String>,
    pub(crate) actions_suppressor_wait_period: std::option::Option<i32>,
    pub(crate) actions_suppressor_extension_period: std::option::Option<i32>,
}
impl PutCompositeAlarmInputBuilder {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is <code>TRUE</code>.</p>
    pub fn actions_enabled(mut self, input: bool) -> Self {
        self.actions_enabled = Some(input);
        self
    }
    /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is <code>TRUE</code>.</p>
    pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.actions_enabled = input;
        self
    }
    /// Appends an item to `alarm_actions`.
    ///
    /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i> </code> </p>
    pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.alarm_actions.unwrap_or_default();
        v.push(input.into());
        self.alarm_actions = Some(v);
        self
    }
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i> </code> </p>
    pub fn set_alarm_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.alarm_actions = input;
        self
    }
    /// <p>The description for the composite alarm.</p>
    pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_description = Some(input.into());
        self
    }
    /// <p>The description for the composite alarm.</p>
    pub fn set_alarm_description(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.alarm_description = input;
        self
    }
    /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
    pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_name = Some(input.into());
        self
    }
    /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
    pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_name = input;
        self
    }
    /// <p>An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression.</p>
    /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
    /// <p>Functions can include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in ALARM state.</p> </li>
    /// <li> <p> <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in OK state.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in INSUFFICIENT_DATA state.</p> </li>
    /// <li> <p> <code>TRUE</code> always evaluates to TRUE.</p> </li>
    /// <li> <p> <code>FALSE</code> always evaluates to FALSE.</p> </li>
    /// </ul>
    /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and for testing your alarm actions.</p>
    /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
    /// <p>The following are some examples of <code>AlarmRule</code>:</p>
    /// <ul>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p> </li>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code> specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state and DeploymentInProgress is not in ALARM state. This example reduces alarm noise during a known deployment window.</p> </li>
    /// <li> <p> <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state. This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an alarm action on high CPU or disk usage if a known network problem is also occurring.</p> </li>
    /// </ul>
    /// <p>The <code>AlarmRule</code> can specify as many as 100 "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements are child alarms, TRUE or FALSE statements, and parentheses.</p>
    pub fn alarm_rule(mut self, input: impl Into<std::string::String>) -> Self {
        self.alarm_rule = Some(input.into());
        self
    }
    /// <p>An expression that specifies which other alarms are to be evaluated to determine this composite alarm's state. For each alarm that you reference, you designate a function that specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the functions in your expression.</p>
    /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
    /// <p>Functions can include the following:</p>
    /// <ul>
    /// <li> <p> <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in ALARM state.</p> </li>
    /// <li> <p> <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in OK state.</p> </li>
    /// <li> <p> <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named alarm is in INSUFFICIENT_DATA state.</p> </li>
    /// <li> <p> <code>TRUE</code> always evaluates to TRUE.</p> </li>
    /// <li> <p> <code>FALSE</code> always evaluates to FALSE.</p> </li>
    /// </ul>
    /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and for testing your alarm actions.</p>
    /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
    /// <p>The following are some examples of <code>AlarmRule</code>:</p>
    /// <ul>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p> </li>
    /// <li> <p> <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code> specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state and DeploymentInProgress is not in ALARM state. This example reduces alarm noise during a known deployment window.</p> </li>
    /// <li> <p> <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state. This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an alarm action on high CPU or disk usage if a known network problem is also occurring.</p> </li>
    /// </ul>
    /// <p>The <code>AlarmRule</code> can specify as many as 100 "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements are child alarms, TRUE or FALSE statements, and parentheses.</p>
    pub fn set_alarm_rule(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.alarm_rule = input;
        self
    }
    /// Appends an item to `insufficient_data_actions`.
    ///
    /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.insufficient_data_actions.unwrap_or_default();
        v.push(input.into());
        self.insufficient_data_actions = Some(v);
        self
    }
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn set_insufficient_data_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.insufficient_data_actions = input;
        self
    }
    /// Appends an item to `ok_actions`.
    ///
    /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
    ///
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.ok_actions.unwrap_or_default();
        v.push(input.into());
        self.ok_actions = Some(v);
        self
    }
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i> </code> </p>
    pub fn set_ok_actions(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.ok_actions = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn actions_suppressor(mut self, input: impl Into<std::string::String>) -> Self {
        self.actions_suppressor = Some(input.into());
        self
    }
    /// <p> Actions will be suppressed if the suppressor alarm is in the <code>ALARM</code> state. <code>ActionsSuppressor</code> can be an AlarmName or an Amazon Resource Name (ARN) from an existing alarm. </p>
    pub fn set_actions_suppressor(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.actions_suppressor = input;
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn actions_suppressor_wait_period(mut self, input: i32) -> Self {
        self.actions_suppressor_wait_period = Some(input);
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits for the suppressor alarm to go into the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>WaitPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn set_actions_suppressor_wait_period(mut self, input: std::option::Option<i32>) -> Self {
        self.actions_suppressor_wait_period = input;
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn actions_suppressor_extension_period(mut self, input: i32) -> Self {
        self.actions_suppressor_extension_period = Some(input);
        self
    }
    /// <p> The maximum time in seconds that the composite alarm waits after suppressor alarm goes out of the <code>ALARM</code> state. After this time, the composite alarm performs its actions. </p> <important>
    /// <p> <code>ExtensionPeriod</code> is required only when <code>ActionsSuppressor</code> is specified. </p>
    /// </important>
    pub fn set_actions_suppressor_extension_period(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.actions_suppressor_extension_period = input;
        self
    }
    /// Consumes the builder and constructs a [`PutCompositeAlarmInput`](crate::operation::put_composite_alarm::PutCompositeAlarmInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::put_composite_alarm::PutCompositeAlarmInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::put_composite_alarm::PutCompositeAlarmInput {
                actions_enabled: self.actions_enabled,
                alarm_actions: self.alarm_actions,
                alarm_description: self.alarm_description,
                alarm_name: self.alarm_name,
                alarm_rule: self.alarm_rule,
                insufficient_data_actions: self.insufficient_data_actions,
                ok_actions: self.ok_actions,
                tags: self.tags,
                actions_suppressor: self.actions_suppressor,
                actions_suppressor_wait_period: self.actions_suppressor_wait_period,
                actions_suppressor_extension_period: self.actions_suppressor_extension_period,
            },
        )
    }
}
