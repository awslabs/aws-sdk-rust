// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`DeleteAlarmsInput`](crate::input::DeleteAlarmsInput)
pub mod delete_alarms_input {
    /// A builder for [`DeleteAlarmsInput`](crate::input::DeleteAlarmsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `alarm_names`.
        ///
        /// To override the contents of this collection use [`set_alarm_names`](Self::set_alarm_names).
        ///
        /// <p>The alarms to be deleted.</p>
        pub fn alarm_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_names.unwrap_or_default();
            v.push(input.into());
            self.alarm_names = Some(v);
            self
        }
        /// <p>The alarms to be deleted.</p>
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAlarmsInput`](crate::input::DeleteAlarmsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAlarmsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAlarmsInput {
                alarm_names: self.alarm_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAlarmsInputOperationOutputAlias = crate::operation::DeleteAlarms;
#[doc(hidden)]
pub type DeleteAlarmsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAlarmsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAlarms`](crate::operation::DeleteAlarms)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAlarms,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteAlarmsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteAlarmsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteAlarmsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_delete_alarms(&self)
            .map_err(|err| {
            aws_smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAlarms::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAlarms",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAlarmsInput`](crate::input::DeleteAlarmsInput)
    pub fn builder() -> crate::input::delete_alarms_input::Builder {
        crate::input::delete_alarms_input::Builder::default()
    }
}

/// See [`DeleteAnomalyDetectorInput`](crate::input::DeleteAnomalyDetectorInput)
pub mod delete_anomaly_detector_input {
    /// A builder for [`DeleteAnomalyDetectorInput`](crate::input::DeleteAnomalyDetectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) stat: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The namespace associated with the anomaly detection model to delete.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace associated with the anomaly detection model to delete.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The metric name associated with the anomaly detection model to delete.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The metric name associated with the anomaly detection model to delete.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The metric dimensions associated with the anomaly detection model to delete.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The metric dimensions associated with the anomaly detection model to delete.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The statistic associated with the anomaly detection model to delete.</p>
        pub fn stat(mut self, input: impl Into<std::string::String>) -> Self {
            self.stat = Some(input.into());
            self
        }
        /// <p>The statistic associated with the anomaly detection model to delete.</p>
        pub fn set_stat(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stat = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAnomalyDetectorInput`](crate::input::DeleteAnomalyDetectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAnomalyDetectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAnomalyDetectorInput {
                namespace: self.namespace,
                metric_name: self.metric_name,
                dimensions: self.dimensions,
                stat: self.stat,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAnomalyDetectorInputOperationOutputAlias = crate::operation::DeleteAnomalyDetector;
#[doc(hidden)]
pub type DeleteAnomalyDetectorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteAnomalyDetectorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAnomalyDetector`](crate::operation::DeleteAnomalyDetector)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAnomalyDetector,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteAnomalyDetectorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteAnomalyDetectorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteAnomalyDetectorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_anomaly_detector(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAnomalyDetector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAnomalyDetector",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAnomalyDetectorInput`](crate::input::DeleteAnomalyDetectorInput)
    pub fn builder() -> crate::input::delete_anomaly_detector_input::Builder {
        crate::input::delete_anomaly_detector_input::Builder::default()
    }
}

/// See [`DeleteDashboardsInput`](crate::input::DeleteDashboardsInput)
pub mod delete_dashboards_input {
    /// A builder for [`DeleteDashboardsInput`](crate::input::DeleteDashboardsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `dashboard_names`.
        ///
        /// To override the contents of this collection use [`set_dashboard_names`](Self::set_dashboard_names).
        ///
        /// <p>The dashboards to be deleted. This parameter is required.</p>
        pub fn dashboard_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dashboard_names.unwrap_or_default();
            v.push(input.into());
            self.dashboard_names = Some(v);
            self
        }
        /// <p>The dashboards to be deleted. This parameter is required.</p>
        pub fn set_dashboard_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dashboard_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDashboardsInput`](crate::input::DeleteDashboardsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDashboardsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDashboardsInput {
                dashboard_names: self.dashboard_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDashboardsInputOperationOutputAlias = crate::operation::DeleteDashboards;
#[doc(hidden)]
pub type DeleteDashboardsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDashboardsInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDashboards`](crate::operation::DeleteDashboards)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDashboards,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDashboardsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDashboardsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDashboardsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_dashboards(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDashboards::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDashboards",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDashboardsInput`](crate::input::DeleteDashboardsInput)
    pub fn builder() -> crate::input::delete_dashboards_input::Builder {
        crate::input::delete_dashboards_input::Builder::default()
    }
}

/// See [`DeleteInsightRulesInput`](crate::input::DeleteInsightRulesInput)
pub mod delete_insight_rules_input {
    /// A builder for [`DeleteInsightRulesInput`](crate::input::DeleteInsightRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `rule_names`.
        ///
        /// To override the contents of this collection use [`set_rule_names`](Self::set_rule_names).
        ///
        /// <p>An array of the rule names to delete. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rule_names.unwrap_or_default();
            v.push(input.into());
            self.rule_names = Some(v);
            self
        }
        /// <p>An array of the rule names to delete. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rule_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteInsightRulesInput`](crate::input::DeleteInsightRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteInsightRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteInsightRulesInput {
                rule_names: self.rule_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteInsightRulesInputOperationOutputAlias = crate::operation::DeleteInsightRules;
#[doc(hidden)]
pub type DeleteInsightRulesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteInsightRulesInput {
    /// Consumes the builder and constructs an Operation<[`DeleteInsightRules`](crate::operation::DeleteInsightRules)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteInsightRules,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteInsightRulesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteInsightRulesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteInsightRulesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_insight_rules(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteInsightRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteInsightRules",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteInsightRulesInput`](crate::input::DeleteInsightRulesInput)
    pub fn builder() -> crate::input::delete_insight_rules_input::Builder {
        crate::input::delete_insight_rules_input::Builder::default()
    }
}

/// See [`DeleteMetricStreamInput`](crate::input::DeleteMetricStreamInput)
pub mod delete_metric_stream_input {
    /// A builder for [`DeleteMetricStreamInput`](crate::input::DeleteMetricStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric stream to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the metric stream to delete.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMetricStreamInput`](crate::input::DeleteMetricStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMetricStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMetricStreamInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type DeleteMetricStreamInputOperationOutputAlias = crate::operation::DeleteMetricStream;
#[doc(hidden)]
pub type DeleteMetricStreamInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteMetricStreamInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMetricStream`](crate::operation::DeleteMetricStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteMetricStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteMetricStreamInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteMetricStreamInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteMetricStreamInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_delete_metric_stream(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteMetricStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteMetricStream",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteMetricStreamInput`](crate::input::DeleteMetricStreamInput)
    pub fn builder() -> crate::input::delete_metric_stream_input::Builder {
        crate::input::delete_metric_stream_input::Builder::default()
    }
}

/// See [`DescribeAlarmHistoryInput`](crate::input::DescribeAlarmHistoryInput)
pub mod describe_alarm_history_input {
    /// A builder for [`DescribeAlarmHistoryInput`](crate::input::DescribeAlarmHistoryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) alarm_types: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        pub(crate) history_item_type: std::option::Option<crate::model::HistoryItemType>,
        pub(crate) start_date: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_date: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) max_records: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) scan_by: std::option::Option<crate::model::ScanBy>,
    }
    impl Builder {
        /// <p>The name of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// Appends an item to `alarm_types`.
        ///
        /// To override the contents of this collection use [`set_alarm_types`](Self::set_alarm_types).
        ///
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn alarm_types(mut self, input: impl Into<crate::model::AlarmType>) -> Self {
            let mut v = self.alarm_types.unwrap_or_default();
            v.push(input.into());
            self.alarm_types = Some(v);
            self
        }
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn set_alarm_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        ) -> Self {
            self.alarm_types = input;
            self
        }
        /// <p>The type of alarm histories to retrieve.</p>
        pub fn history_item_type(mut self, input: crate::model::HistoryItemType) -> Self {
            self.history_item_type = Some(input);
            self
        }
        /// <p>The type of alarm histories to retrieve.</p>
        pub fn set_history_item_type(
            mut self,
            input: std::option::Option<crate::model::HistoryItemType>,
        ) -> Self {
            self.history_item_type = input;
            self
        }
        /// <p>The starting date to retrieve alarm history.</p>
        pub fn start_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_date = Some(input);
            self
        }
        /// <p>The starting date to retrieve alarm history.</p>
        pub fn set_start_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_date = input;
            self
        }
        /// <p>The ending date to retrieve alarm history.</p>
        pub fn end_date(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_date = Some(input);
            self
        }
        /// <p>The ending date to retrieve alarm history.</p>
        pub fn set_end_date(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_date = input;
            self
        }
        /// <p>The maximum number of alarm history records to retrieve.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.max_records = Some(input);
            self
        }
        /// <p>The maximum number of alarm history records to retrieve.</p>
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.max_records = input;
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>Specified whether to return the newest or oldest alarm history first. Specify <code>TimestampDescending</code> to have the newest
        /// event history returned first, and specify <code>TimestampAscending</code> to have the oldest history returned first.</p>
        pub fn scan_by(mut self, input: crate::model::ScanBy) -> Self {
            self.scan_by = Some(input);
            self
        }
        /// <p>Specified whether to return the newest or oldest alarm history first. Specify <code>TimestampDescending</code> to have the newest
        /// event history returned first, and specify <code>TimestampAscending</code> to have the oldest history returned first.</p>
        pub fn set_scan_by(mut self, input: std::option::Option<crate::model::ScanBy>) -> Self {
            self.scan_by = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAlarmHistoryInput`](crate::input::DescribeAlarmHistoryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAlarmHistoryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAlarmHistoryInput {
                alarm_name: self.alarm_name,
                alarm_types: self.alarm_types,
                history_item_type: self.history_item_type,
                start_date: self.start_date,
                end_date: self.end_date,
                max_records: self.max_records,
                next_token: self.next_token,
                scan_by: self.scan_by,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAlarmHistoryInputOperationOutputAlias = crate::operation::DescribeAlarmHistory;
#[doc(hidden)]
pub type DescribeAlarmHistoryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAlarmHistoryInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAlarmHistory`](crate::operation::DescribeAlarmHistory)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAlarmHistory,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAlarmHistoryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAlarmHistoryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAlarmHistoryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_alarm_history(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAlarmHistory::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAlarmHistory",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAlarmHistoryInput`](crate::input::DescribeAlarmHistoryInput)
    pub fn builder() -> crate::input::describe_alarm_history_input::Builder {
        crate::input::describe_alarm_history_input::Builder::default()
    }
}

/// See [`DescribeAlarmsInput`](crate::input::DescribeAlarmsInput)
pub mod describe_alarms_input {
    /// A builder for [`DescribeAlarmsInput`](crate::input::DescribeAlarmsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) alarm_name_prefix: std::option::Option<std::string::String>,
        pub(crate) alarm_types: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        pub(crate) children_of_alarm_name: std::option::Option<std::string::String>,
        pub(crate) parents_of_alarm_name: std::option::Option<std::string::String>,
        pub(crate) state_value: std::option::Option<crate::model::StateValue>,
        pub(crate) action_prefix: std::option::Option<std::string::String>,
        pub(crate) max_records: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `alarm_names`.
        ///
        /// To override the contents of this collection use [`set_alarm_names`](Self::set_alarm_names).
        ///
        /// <p>The names of the alarms to retrieve information about.</p>
        pub fn alarm_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_names.unwrap_or_default();
            v.push(input.into());
            self.alarm_names = Some(v);
            self
        }
        /// <p>The names of the alarms to retrieve information about.</p>
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_names = input;
            self
        }
        /// <p>An alarm name prefix. If you specify this parameter, you receive information about all alarms that have names
        /// that start with this prefix.</p>
        /// <p>If this parameter
        /// is specified, you cannot specify <code>AlarmNames</code>.</p>
        pub fn alarm_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name_prefix = Some(input.into());
            self
        }
        /// <p>An alarm name prefix. If you specify this parameter, you receive information about all alarms that have names
        /// that start with this prefix.</p>
        /// <p>If this parameter
        /// is specified, you cannot specify <code>AlarmNames</code>.</p>
        pub fn set_alarm_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_name_prefix = input;
            self
        }
        /// Appends an item to `alarm_types`.
        ///
        /// To override the contents of this collection use [`set_alarm_types`](Self::set_alarm_types).
        ///
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn alarm_types(mut self, input: impl Into<crate::model::AlarmType>) -> Self {
            let mut v = self.alarm_types.unwrap_or_default();
            v.push(input.into());
            self.alarm_types = Some(v);
            self
        }
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn set_alarm_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        ) -> Self {
            self.alarm_types = input;
            self
        }
        /// <p>If you use this parameter and specify the name of a composite alarm, the operation returns
        /// information about the "children" alarms
        /// of the alarm you specify. These are the metric alarms and composite alarms referenced in the
        /// <code>AlarmRule</code> field of the composite alarm that you specify in
        /// <code>ChildrenOfAlarmName</code>. Information about the composite alarm that you name in
        /// <code>ChildrenOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ChildrenOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you
        /// receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the <code>Alarm Name</code>, <code>ARN</code>, <code>StateValue</code> (OK/ALARM/INSUFFICIENT_DATA), and <code>StateUpdatedTimestamp</code>
        /// information are returned by this operation
        /// when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn children_of_alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.children_of_alarm_name = Some(input.into());
            self
        }
        /// <p>If you use this parameter and specify the name of a composite alarm, the operation returns
        /// information about the "children" alarms
        /// of the alarm you specify. These are the metric alarms and composite alarms referenced in the
        /// <code>AlarmRule</code> field of the composite alarm that you specify in
        /// <code>ChildrenOfAlarmName</code>. Information about the composite alarm that you name in
        /// <code>ChildrenOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ChildrenOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you
        /// receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the <code>Alarm Name</code>, <code>ARN</code>, <code>StateValue</code> (OK/ALARM/INSUFFICIENT_DATA), and <code>StateUpdatedTimestamp</code>
        /// information are returned by this operation
        /// when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn set_children_of_alarm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.children_of_alarm_name = input;
            self
        }
        /// <p>If you use this parameter and specify the name of a metric or composite alarm, the operation returns
        /// information about the "parent" alarms
        /// of the alarm you specify. These are the composite alarms that have <code>AlarmRule</code>
        /// parameters that reference
        /// the alarm named in <code>ParentsOfAlarmName</code>. Information about the alarm that you specify in
        /// <code>ParentsOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ParentsOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the Alarm Name and ARN are returned by this operation when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn parents_of_alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.parents_of_alarm_name = Some(input.into());
            self
        }
        /// <p>If you use this parameter and specify the name of a metric or composite alarm, the operation returns
        /// information about the "parent" alarms
        /// of the alarm you specify. These are the composite alarms that have <code>AlarmRule</code>
        /// parameters that reference
        /// the alarm named in <code>ParentsOfAlarmName</code>. Information about the alarm that you specify in
        /// <code>ParentsOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ParentsOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the Alarm Name and ARN are returned by this operation when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn set_parents_of_alarm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parents_of_alarm_name = input;
            self
        }
        /// <p>Specify this parameter to receive information only about alarms that are currently in the state that you specify.</p>
        pub fn state_value(mut self, input: crate::model::StateValue) -> Self {
            self.state_value = Some(input);
            self
        }
        /// <p>Specify this parameter to receive information only about alarms that are currently in the state that you specify.</p>
        pub fn set_state_value(
            mut self,
            input: std::option::Option<crate::model::StateValue>,
        ) -> Self {
            self.state_value = input;
            self
        }
        /// <p>Use this parameter to filter the results of the operation to only those alarms that
        /// use a certain alarm action. For example, you could specify the ARN of an SNS topic to find all
        /// alarms that send notifications to that topic.</p>
        pub fn action_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_prefix = Some(input.into());
            self
        }
        /// <p>Use this parameter to filter the results of the operation to only those alarms that
        /// use a certain alarm action. For example, you could specify the ARN of an SNS topic to find all
        /// alarms that send notifications to that topic.</p>
        pub fn set_action_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.action_prefix = input;
            self
        }
        /// <p>The maximum number of alarm descriptions to retrieve.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.max_records = Some(input);
            self
        }
        /// <p>The maximum number of alarm descriptions to retrieve.</p>
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.max_records = input;
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAlarmsInput`](crate::input::DescribeAlarmsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAlarmsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAlarmsInput {
                alarm_names: self.alarm_names,
                alarm_name_prefix: self.alarm_name_prefix,
                alarm_types: self.alarm_types,
                children_of_alarm_name: self.children_of_alarm_name,
                parents_of_alarm_name: self.parents_of_alarm_name,
                state_value: self.state_value,
                action_prefix: self.action_prefix,
                max_records: self.max_records,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAlarmsInputOperationOutputAlias = crate::operation::DescribeAlarms;
#[doc(hidden)]
pub type DescribeAlarmsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAlarmsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAlarms`](crate::operation::DescribeAlarms)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAlarms,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAlarmsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAlarmsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAlarmsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_describe_alarms(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAlarms::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAlarms",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAlarmsInput`](crate::input::DescribeAlarmsInput)
    pub fn builder() -> crate::input::describe_alarms_input::Builder {
        crate::input::describe_alarms_input::Builder::default()
    }
}

/// See [`DescribeAlarmsForMetricInput`](crate::input::DescribeAlarmsForMetricInput)
pub mod describe_alarms_for_metric_input {
    /// A builder for [`DescribeAlarmsForMetricInput`](crate::input::DescribeAlarmsForMetricInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) statistic: std::option::Option<crate::model::Statistic>,
        pub(crate) extended_statistic: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) unit: std::option::Option<crate::model::StandardUnit>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The statistic for the metric, other than percentiles.
        /// For percentile statistics, use <code>ExtendedStatistics</code>.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic for the metric, other than percentiles.
        /// For percentile statistics, use <code>ExtendedStatistics</code>.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The percentile statistic for the metric. Specify a value between
        /// p0.0 and p100.</p>
        pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.extended_statistic = Some(input.into());
            self
        }
        /// <p>The percentile statistic for the metric. Specify a value between
        /// p0.0 and p100.</p>
        pub fn set_extended_statistic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extended_statistic = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions associated with the metric. If the metric has any associated
        /// dimensions, you must specify them in order for the call to succeed.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions associated with the metric. If the metric has any associated
        /// dimensions, you must specify them in order for the call to succeed.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The period, in seconds, over which the statistic is applied.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The period, in seconds, over which the statistic is applied.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAlarmsForMetricInput`](crate::input::DescribeAlarmsForMetricInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAlarmsForMetricInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAlarmsForMetricInput {
                metric_name: self.metric_name,
                namespace: self.namespace,
                statistic: self.statistic,
                extended_statistic: self.extended_statistic,
                dimensions: self.dimensions,
                period: self.period,
                unit: self.unit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAlarmsForMetricInputOperationOutputAlias =
    crate::operation::DescribeAlarmsForMetric;
#[doc(hidden)]
pub type DescribeAlarmsForMetricInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAlarmsForMetricInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAlarmsForMetric`](crate::operation::DescribeAlarmsForMetric)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAlarmsForMetric,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAlarmsForMetricInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAlarmsForMetricInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAlarmsForMetricInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_alarms_for_metric(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAlarmsForMetric::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAlarmsForMetric",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAlarmsForMetricInput`](crate::input::DescribeAlarmsForMetricInput)
    pub fn builder() -> crate::input::describe_alarms_for_metric_input::Builder {
        crate::input::describe_alarms_for_metric_input::Builder::default()
    }
}

/// See [`DescribeAnomalyDetectorsInput`](crate::input::DescribeAnomalyDetectorsInput)
pub mod describe_anomaly_detectors_input {
    /// A builder for [`DescribeAnomalyDetectorsInput`](crate::input::DescribeAnomalyDetectorsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    }
    impl Builder {
        /// <p>Use the token returned by the previous operation to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Use the token returned by the previous operation to request the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in one operation. The maximum
        /// value that you can specify is 100.</p>
        /// <p>To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in one operation. The maximum
        /// value that you can specify is 100.</p>
        /// <p>To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Limits the results to only the anomaly detection models that
        /// are associated with the specified namespace.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>Limits the results to only the anomaly detection models that
        /// are associated with the specified namespace.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric name. If there are multiple metrics with this name in different
        /// namespaces that have anomaly detection models, they're all returned.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric name. If there are multiple metrics with this name in different
        /// namespaces that have anomaly detection models, they're all returned.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric dimensions. If there are multiple metrics that have these dimensions
        /// and have anomaly detection models associated, they're all returned.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric dimensions. If there are multiple metrics that have these dimensions
        /// and have anomaly detection models associated, they're all returned.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeAnomalyDetectorsInput`](crate::input::DescribeAnomalyDetectorsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeAnomalyDetectorsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeAnomalyDetectorsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                namespace: self.namespace,
                metric_name: self.metric_name,
                dimensions: self.dimensions,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeAnomalyDetectorsInputOperationOutputAlias =
    crate::operation::DescribeAnomalyDetectors;
#[doc(hidden)]
pub type DescribeAnomalyDetectorsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeAnomalyDetectorsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeAnomalyDetectors`](crate::operation::DescribeAnomalyDetectors)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeAnomalyDetectors,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeAnomalyDetectorsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeAnomalyDetectorsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeAnomalyDetectorsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_anomaly_detectors(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeAnomalyDetectors::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeAnomalyDetectors",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeAnomalyDetectorsInput`](crate::input::DescribeAnomalyDetectorsInput)
    pub fn builder() -> crate::input::describe_anomaly_detectors_input::Builder {
        crate::input::describe_anomaly_detectors_input::Builder::default()
    }
}

/// See [`DescribeInsightRulesInput`](crate::input::DescribeInsightRulesInput)
pub mod describe_insight_rules_input {
    /// A builder for [`DescribeInsightRulesInput`](crate::input::DescribeInsightRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Include this value, if it was returned by the previous operation, to get the next set of rules.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Include this value, if it was returned by the previous operation, to get the next set of rules.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in one operation. If you omit this
        /// parameter, the default of 500 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in one operation. If you omit this
        /// parameter, the default of 500 is used.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeInsightRulesInput`](crate::input::DescribeInsightRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeInsightRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeInsightRulesInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeInsightRulesInputOperationOutputAlias = crate::operation::DescribeInsightRules;
#[doc(hidden)]
pub type DescribeInsightRulesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeInsightRulesInput {
    /// Consumes the builder and constructs an Operation<[`DescribeInsightRules`](crate::operation::DescribeInsightRules)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeInsightRules,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeInsightRulesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeInsightRulesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeInsightRulesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_describe_insight_rules(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeInsightRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeInsightRules",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeInsightRulesInput`](crate::input::DescribeInsightRulesInput)
    pub fn builder() -> crate::input::describe_insight_rules_input::Builder {
        crate::input::describe_insight_rules_input::Builder::default()
    }
}

/// See [`DisableAlarmActionsInput`](crate::input::DisableAlarmActionsInput)
pub mod disable_alarm_actions_input {
    /// A builder for [`DisableAlarmActionsInput`](crate::input::DisableAlarmActionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `alarm_names`.
        ///
        /// To override the contents of this collection use [`set_alarm_names`](Self::set_alarm_names).
        ///
        /// <p>The names of the alarms.</p>
        pub fn alarm_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_names.unwrap_or_default();
            v.push(input.into());
            self.alarm_names = Some(v);
            self
        }
        /// <p>The names of the alarms.</p>
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableAlarmActionsInput`](crate::input::DisableAlarmActionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisableAlarmActionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisableAlarmActionsInput {
                alarm_names: self.alarm_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DisableAlarmActionsInputOperationOutputAlias = crate::operation::DisableAlarmActions;
#[doc(hidden)]
pub type DisableAlarmActionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisableAlarmActionsInput {
    /// Consumes the builder and constructs an Operation<[`DisableAlarmActions`](crate::operation::DisableAlarmActions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisableAlarmActions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisableAlarmActionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisableAlarmActionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisableAlarmActionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disable_alarm_actions(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisableAlarmActions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisableAlarmActions",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisableAlarmActionsInput`](crate::input::DisableAlarmActionsInput)
    pub fn builder() -> crate::input::disable_alarm_actions_input::Builder {
        crate::input::disable_alarm_actions_input::Builder::default()
    }
}

/// See [`DisableInsightRulesInput`](crate::input::DisableInsightRulesInput)
pub mod disable_insight_rules_input {
    /// A builder for [`DisableInsightRulesInput`](crate::input::DisableInsightRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `rule_names`.
        ///
        /// To override the contents of this collection use [`set_rule_names`](Self::set_rule_names).
        ///
        /// <p>An array of the rule names to disable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rule_names.unwrap_or_default();
            v.push(input.into());
            self.rule_names = Some(v);
            self
        }
        /// <p>An array of the rule names to disable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rule_names = input;
            self
        }
        /// Consumes the builder and constructs a [`DisableInsightRulesInput`](crate::input::DisableInsightRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisableInsightRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisableInsightRulesInput {
                rule_names: self.rule_names,
            })
        }
    }
}
#[doc(hidden)]
pub type DisableInsightRulesInputOperationOutputAlias = crate::operation::DisableInsightRules;
#[doc(hidden)]
pub type DisableInsightRulesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisableInsightRulesInput {
    /// Consumes the builder and constructs an Operation<[`DisableInsightRules`](crate::operation::DisableInsightRules)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisableInsightRules,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisableInsightRulesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisableInsightRulesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisableInsightRulesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_disable_insight_rules(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisableInsightRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisableInsightRules",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisableInsightRulesInput`](crate::input::DisableInsightRulesInput)
    pub fn builder() -> crate::input::disable_insight_rules_input::Builder {
        crate::input::disable_insight_rules_input::Builder::default()
    }
}

/// See [`EnableAlarmActionsInput`](crate::input::EnableAlarmActionsInput)
pub mod enable_alarm_actions_input {
    /// A builder for [`EnableAlarmActionsInput`](crate::input::EnableAlarmActionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `alarm_names`.
        ///
        /// To override the contents of this collection use [`set_alarm_names`](Self::set_alarm_names).
        ///
        /// <p>The names of the alarms.</p>
        pub fn alarm_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_names.unwrap_or_default();
            v.push(input.into());
            self.alarm_names = Some(v);
            self
        }
        /// <p>The names of the alarms.</p>
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_names = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableAlarmActionsInput`](crate::input::EnableAlarmActionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::EnableAlarmActionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::EnableAlarmActionsInput {
                alarm_names: self.alarm_names,
            })
        }
    }
}
#[doc(hidden)]
pub type EnableAlarmActionsInputOperationOutputAlias = crate::operation::EnableAlarmActions;
#[doc(hidden)]
pub type EnableAlarmActionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl EnableAlarmActionsInput {
    /// Consumes the builder and constructs an Operation<[`EnableAlarmActions`](crate::operation::EnableAlarmActions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::EnableAlarmActions,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::EnableAlarmActionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::EnableAlarmActionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::EnableAlarmActionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_enable_alarm_actions(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::EnableAlarmActions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "EnableAlarmActions",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`EnableAlarmActionsInput`](crate::input::EnableAlarmActionsInput)
    pub fn builder() -> crate::input::enable_alarm_actions_input::Builder {
        crate::input::enable_alarm_actions_input::Builder::default()
    }
}

/// See [`EnableInsightRulesInput`](crate::input::EnableInsightRulesInput)
pub mod enable_insight_rules_input {
    /// A builder for [`EnableInsightRulesInput`](crate::input::EnableInsightRulesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `rule_names`.
        ///
        /// To override the contents of this collection use [`set_rule_names`](Self::set_rule_names).
        ///
        /// <p>An array of the rule names to enable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.rule_names.unwrap_or_default();
            v.push(input.into());
            self.rule_names = Some(v);
            self
        }
        /// <p>An array of the rule names to enable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.rule_names = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableInsightRulesInput`](crate::input::EnableInsightRulesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::EnableInsightRulesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::EnableInsightRulesInput {
                rule_names: self.rule_names,
            })
        }
    }
}
#[doc(hidden)]
pub type EnableInsightRulesInputOperationOutputAlias = crate::operation::EnableInsightRules;
#[doc(hidden)]
pub type EnableInsightRulesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl EnableInsightRulesInput {
    /// Consumes the builder and constructs an Operation<[`EnableInsightRules`](crate::operation::EnableInsightRules)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::EnableInsightRules,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::EnableInsightRulesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::EnableInsightRulesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::EnableInsightRulesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_enable_insight_rules(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::EnableInsightRules::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "EnableInsightRules",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`EnableInsightRulesInput`](crate::input::EnableInsightRulesInput)
    pub fn builder() -> crate::input::enable_insight_rules_input::Builder {
        crate::input::enable_insight_rules_input::Builder::default()
    }
}

/// See [`GetDashboardInput`](crate::input::GetDashboardInput)
pub mod get_dashboard_input {
    /// A builder for [`GetDashboardInput`](crate::input::GetDashboardInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the dashboard to be described.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_name = Some(input.into());
            self
        }
        /// <p>The name of the dashboard to be described.</p>
        pub fn set_dashboard_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dashboard_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDashboardInput`](crate::input::GetDashboardInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDashboardInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDashboardInput {
                dashboard_name: self.dashboard_name,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDashboardInputOperationOutputAlias = crate::operation::GetDashboard;
#[doc(hidden)]
pub type GetDashboardInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetDashboardInput {
    /// Consumes the builder and constructs an Operation<[`GetDashboard`](crate::operation::GetDashboard)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDashboard,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDashboardInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDashboardInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDashboardInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_dashboard(&self)
            .map_err(|err| {
            aws_smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDashboard::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDashboard",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDashboardInput`](crate::input::GetDashboardInput)
    pub fn builder() -> crate::input::get_dashboard_input::Builder {
        crate::input::get_dashboard_input::Builder::default()
    }
}

/// See [`GetInsightRuleReportInput`](crate::input::GetInsightRuleReportInput)
pub mod get_insight_rule_report_input {
    /// A builder for [`GetInsightRuleReportInput`](crate::input::GetInsightRuleReportInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) max_contributor_count: std::option::Option<i32>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) order_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the rule that you want to see data from.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>The name of the rule that you want to see data from.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// <p>The start time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The start time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The end time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The period, in seconds, to use for the statistics in the <code>InsightRuleMetricDatapoint</code> results.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The period, in seconds, to use for the statistics in the <code>InsightRuleMetricDatapoint</code> results.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The maximum number of contributors to include in the report. The range is 1 to 100. If you omit this, the default of 10 is used.</p>
        pub fn max_contributor_count(mut self, input: i32) -> Self {
            self.max_contributor_count = Some(input);
            self
        }
        /// <p>The maximum number of contributors to include in the report. The range is 1 to 100. If you omit this, the default of 10 is used.</p>
        pub fn set_max_contributor_count(mut self, input: std::option::Option<i32>) -> Self {
            self.max_contributor_count = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>Specifies which metrics to use for aggregation of contributor values for the report. You can specify one or more
        /// of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UniqueContributors</code> -- the number of unique contributors for each data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MaxContributorValue</code> -- the value of the top contributor for each data point. The identity of the
        /// contributor might change for each data point in the graph.</p>
        /// <p>If this rule aggregates by COUNT, the top contributor for each data point is the contributor with the
        /// most occurrences in that period. If the rule aggregates by SUM, the top contributor is the contributor with the highest sum in the log field specified
        /// by the rule's <code>Value</code>, during that period.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> -- the number of data points matched by the rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> -- the sum of the values from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Minimum</code> -- the minimum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> -- the maximum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> -- the average value from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// </ul>
        pub fn metrics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>Specifies which metrics to use for aggregation of contributor values for the report. You can specify one or more
        /// of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UniqueContributors</code> -- the number of unique contributors for each data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MaxContributorValue</code> -- the value of the top contributor for each data point. The identity of the
        /// contributor might change for each data point in the graph.</p>
        /// <p>If this rule aggregates by COUNT, the top contributor for each data point is the contributor with the
        /// most occurrences in that period. If the rule aggregates by SUM, the top contributor is the contributor with the highest sum in the log field specified
        /// by the rule's <code>Value</code>, during that period.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> -- the number of data points matched by the rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> -- the sum of the values from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Minimum</code> -- the minimum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> -- the maximum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> -- the average value from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// </ul>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Determines what statistic to use to rank the contributors. Valid values are SUM and MAXIMUM.</p>
        pub fn order_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.order_by = Some(input.into());
            self
        }
        /// <p>Determines what statistic to use to rank the contributors. Valid values are SUM and MAXIMUM.</p>
        pub fn set_order_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.order_by = input;
            self
        }
        /// Consumes the builder and constructs a [`GetInsightRuleReportInput`](crate::input::GetInsightRuleReportInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetInsightRuleReportInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetInsightRuleReportInput {
                rule_name: self.rule_name,
                start_time: self.start_time,
                end_time: self.end_time,
                period: self.period,
                max_contributor_count: self.max_contributor_count,
                metrics: self.metrics,
                order_by: self.order_by,
            })
        }
    }
}
#[doc(hidden)]
pub type GetInsightRuleReportInputOperationOutputAlias = crate::operation::GetInsightRuleReport;
#[doc(hidden)]
pub type GetInsightRuleReportInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetInsightRuleReportInput {
    /// Consumes the builder and constructs an Operation<[`GetInsightRuleReport`](crate::operation::GetInsightRuleReport)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetInsightRuleReport,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetInsightRuleReportInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetInsightRuleReportInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetInsightRuleReportInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_insight_rule_report(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetInsightRuleReport::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetInsightRuleReport",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetInsightRuleReportInput`](crate::input::GetInsightRuleReportInput)
    pub fn builder() -> crate::input::get_insight_rule_report_input::Builder {
        crate::input::get_insight_rule_report_input::Builder::default()
    }
}

/// See [`GetMetricDataInput`](crate::input::GetMetricDataInput)
pub mod get_metric_data_input {
    /// A builder for [`GetMetricDataInput`](crate::input::GetMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_data_queries:
            std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) scan_by: std::option::Option<crate::model::ScanBy>,
        pub(crate) max_datapoints: std::option::Option<i32>,
        pub(crate) label_options: std::option::Option<crate::model::LabelOptions>,
    }
    impl Builder {
        /// Appends an item to `metric_data_queries`.
        ///
        /// To override the contents of this collection use [`set_metric_data_queries`](Self::set_metric_data_queries).
        ///
        /// <p>The metric queries to be returned. A single <code>GetMetricData</code> call can include as many as 500 <code>MetricDataQuery</code>
        /// structures. Each of these structures can specify either a metric to retrieve, or a math expression to perform on retrieved data. </p>
        pub fn metric_data_queries(
            mut self,
            input: impl Into<crate::model::MetricDataQuery>,
        ) -> Self {
            let mut v = self.metric_data_queries.unwrap_or_default();
            v.push(input.into());
            self.metric_data_queries = Some(v);
            self
        }
        /// <p>The metric queries to be returned. A single <code>GetMetricData</code> call can include as many as 500 <code>MetricDataQuery</code>
        /// structures. Each of these structures can specify either a metric to retrieve, or a math expression to perform on retrieved data. </p>
        pub fn set_metric_data_queries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        ) -> Self {
            self.metric_data_queries = input;
            self
        }
        /// <p>The time stamp indicating the earliest data to be returned.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp. </p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>StartTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>StartTime</code>.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time stamp indicating the earliest data to be returned.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp. </p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>StartTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>StartTime</code>.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time stamp indicating the latest data to be returned.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.</p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>EndTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>EndTime</code>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time stamp indicating the latest data to be returned.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.</p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>EndTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>EndTime</code>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>Include this value, if it was returned by the previous <code>GetMetricData</code> operation,
        /// to get the next set of data points.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Include this value, if it was returned by the previous <code>GetMetricData</code> operation,
        /// to get the next set of data points.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The order in which data points should be returned. <code>TimestampDescending</code> returns the newest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached. <code>TimestampAscending</code> returns the oldest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached.</p>
        pub fn scan_by(mut self, input: crate::model::ScanBy) -> Self {
            self.scan_by = Some(input);
            self
        }
        /// <p>The order in which data points should be returned. <code>TimestampDescending</code> returns the newest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached. <code>TimestampAscending</code> returns the oldest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached.</p>
        pub fn set_scan_by(mut self, input: std::option::Option<crate::model::ScanBy>) -> Self {
            self.scan_by = input;
            self
        }
        /// <p>The maximum number of data points the request should return before paginating. If you omit
        /// this, the default of 100,800 is used.</p>
        pub fn max_datapoints(mut self, input: i32) -> Self {
            self.max_datapoints = Some(input);
            self
        }
        /// <p>The maximum number of data points the request should return before paginating. If you omit
        /// this, the default of 100,800 is used.</p>
        pub fn set_max_datapoints(mut self, input: std::option::Option<i32>) -> Self {
            self.max_datapoints = input;
            self
        }
        /// <p>This structure includes the <code>Timezone</code> parameter, which you can use
        /// to specify your time zone so that the labels of returned data display the
        /// correct time
        /// for your time zone. </p>
        pub fn label_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.label_options = Some(input);
            self
        }
        /// <p>This structure includes the <code>Timezone</code> parameter, which you can use
        /// to specify your time zone so that the labels of returned data display the
        /// correct time
        /// for your time zone. </p>
        pub fn set_label_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.label_options = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMetricDataInput`](crate::input::GetMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMetricDataInput {
                metric_data_queries: self.metric_data_queries,
                start_time: self.start_time,
                end_time: self.end_time,
                next_token: self.next_token,
                scan_by: self.scan_by,
                max_datapoints: self.max_datapoints,
                label_options: self.label_options,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMetricDataInputOperationOutputAlias = crate::operation::GetMetricData;
#[doc(hidden)]
pub type GetMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`GetMetricData`](crate::operation::GetMetricData)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_get_metric_data(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMetricData",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMetricDataInput`](crate::input::GetMetricDataInput)
    pub fn builder() -> crate::input::get_metric_data_input::Builder {
        crate::input::get_metric_data_input::Builder::default()
    }
}

/// See [`GetMetricStatisticsInput`](crate::input::GetMetricStatisticsInput)
pub mod get_metric_statistics_input {
    /// A builder for [`GetMetricStatisticsInput`](crate::input::GetMetricStatisticsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) statistics: std::option::Option<std::vec::Vec<crate::model::Statistic>>,
        pub(crate) extended_statistics: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) unit: std::option::Option<crate::model::StandardUnit>,
    }
    impl Builder {
        /// <p>The namespace of the metric, with or without spaces.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric, with or without spaces.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the metric, with or without spaces.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric, with or without spaces.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension.
        /// CloudWatch treats each unique combination of dimensions as a separate metric.
        /// If a specific combination of dimensions was not published, you can't retrieve statistics for it.
        /// You must specify the same dimensions that were used when the metrics were created. For an example,
        /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#dimension-combinations">Dimension Combinations</a> in the <i>Amazon CloudWatch User Guide</i>. For more information about specifying dimensions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publishing Metrics</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension.
        /// CloudWatch treats each unique combination of dimensions as a separate metric.
        /// If a specific combination of dimensions was not published, you can't retrieve statistics for it.
        /// You must specify the same dimensions that were used when the metrics were created. For an example,
        /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#dimension-combinations">Dimension Combinations</a> in the <i>Amazon CloudWatch User Guide</i>. For more information about specifying dimensions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publishing Metrics</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The time stamp that determines the first data point to return. Start times are
        /// evaluated relative to the time that CloudWatch receives the request.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z).</p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The time stamp that determines the first data point to return. Start times are
        /// evaluated relative to the time that CloudWatch receives the request.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z).</p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time stamp that determines the last data point to return.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z).</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time stamp that determines the last data point to return.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z).</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can
        /// be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected
        /// at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics
        /// are those metrics stored by a <code>PutMetricData</code> call that includes a <code>StorageResolution</code> of 1 second.</p>
        /// <p>If the <code>StartTime</code> parameter specifies a time stamp that is greater than
        /// 3 hours ago, you must specify the period as follows or no data points in that time range is returned:</p>
        /// <ul>
        /// <li>
        /// <p>Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).</p>
        /// </li>
        /// </ul>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can
        /// be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected
        /// at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics
        /// are those metrics stored by a <code>PutMetricData</code> call that includes a <code>StorageResolution</code> of 1 second.</p>
        /// <p>If the <code>StartTime</code> parameter specifies a time stamp that is greater than
        /// 3 hours ago, you must specify the period as follows or no data points in that time range is returned:</p>
        /// <ul>
        /// <li>
        /// <p>Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).</p>
        /// </li>
        /// </ul>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// Appends an item to `statistics`.
        ///
        /// To override the contents of this collection use [`set_statistics`](Self::set_statistics).
        ///
        /// <p>The metric statistics, other than percentile. For percentile statistics,
        /// use <code>ExtendedStatistics</code>. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both.</p>
        pub fn statistics(mut self, input: impl Into<crate::model::Statistic>) -> Self {
            let mut v = self.statistics.unwrap_or_default();
            v.push(input.into());
            self.statistics = Some(v);
            self
        }
        /// <p>The metric statistics, other than percentile. For percentile statistics,
        /// use <code>ExtendedStatistics</code>. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both.</p>
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Statistic>>,
        ) -> Self {
            self.statistics = input;
            self
        }
        /// Appends an item to `extended_statistics`.
        ///
        /// To override the contents of this collection use [`set_extended_statistics`](Self::set_extended_statistics).
        ///
        /// <p>The percentile statistics. Specify values between p0.0 and p100. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both. Percentile statistics are not
        /// available for metrics when any of the metric values are negative numbers.</p>
        pub fn extended_statistics(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.extended_statistics.unwrap_or_default();
            v.push(input.into());
            self.extended_statistics = Some(v);
            self
        }
        /// <p>The percentile statistics. Specify values between p0.0 and p100. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both. Percentile statistics are not
        /// available for metrics when any of the metric values are negative numbers.</p>
        pub fn set_extended_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.extended_statistics = input;
            self
        }
        /// <p>The unit for a given metric.
        /// If you omit <code>Unit</code>, all data that was collected with any unit is returned, along with the corresponding units that were specified
        /// when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified.
        /// If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit for a given metric.
        /// If you omit <code>Unit</code>, all data that was collected with any unit is returned, along with the corresponding units that were specified
        /// when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified.
        /// If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMetricStatisticsInput`](crate::input::GetMetricStatisticsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMetricStatisticsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMetricStatisticsInput {
                namespace: self.namespace,
                metric_name: self.metric_name,
                dimensions: self.dimensions,
                start_time: self.start_time,
                end_time: self.end_time,
                period: self.period,
                statistics: self.statistics,
                extended_statistics: self.extended_statistics,
                unit: self.unit,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMetricStatisticsInputOperationOutputAlias = crate::operation::GetMetricStatistics;
#[doc(hidden)]
pub type GetMetricStatisticsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMetricStatisticsInput {
    /// Consumes the builder and constructs an Operation<[`GetMetricStatistics`](crate::operation::GetMetricStatistics)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMetricStatistics,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMetricStatisticsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMetricStatisticsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMetricStatisticsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_metric_statistics(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMetricStatistics::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMetricStatistics",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMetricStatisticsInput`](crate::input::GetMetricStatisticsInput)
    pub fn builder() -> crate::input::get_metric_statistics_input::Builder {
        crate::input::get_metric_statistics_input::Builder::default()
    }
}

/// See [`GetMetricStreamInput`](crate::input::GetMetricStreamInput)
pub mod get_metric_stream_input {
    /// A builder for [`GetMetricStreamInput`](crate::input::GetMetricStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric stream to retrieve information about.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the metric stream to retrieve information about.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMetricStreamInput`](crate::input::GetMetricStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMetricStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMetricStreamInput { name: self.name })
        }
    }
}
#[doc(hidden)]
pub type GetMetricStreamInputOperationOutputAlias = crate::operation::GetMetricStream;
#[doc(hidden)]
pub type GetMetricStreamInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMetricStreamInput {
    /// Consumes the builder and constructs an Operation<[`GetMetricStream`](crate::operation::GetMetricStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMetricStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMetricStreamInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMetricStreamInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMetricStreamInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_metric_stream(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMetricStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMetricStream",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMetricStreamInput`](crate::input::GetMetricStreamInput)
    pub fn builder() -> crate::input::get_metric_stream_input::Builder {
        crate::input::get_metric_stream_input::Builder::default()
    }
}

/// See [`GetMetricWidgetImageInput`](crate::input::GetMetricWidgetImageInput)
pub mod get_metric_widget_image_input {
    /// A builder for [`GetMetricWidgetImageInput`](crate::input::GetMetricWidgetImageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_widget: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A JSON string that defines the bitmap graph to be retrieved. The string includes the
        /// metrics to include in the graph, statistics, annotations, title, axis limits, and so on.
        /// You can include only one <code>MetricWidget</code> parameter in each <code>GetMetricWidgetImage</code> call.</p>
        /// <p>For more information about the syntax of <code>MetricWidget</code> see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Metric-Widget-Structure.html">GetMetricWidgetImage: Metric Widget Structure and Syntax</a>.</p>
        ///
        /// <p>If any metric on the graph could not load all the requested data points, an orange triangle with an exclamation
        /// point appears next to the graph legend.</p>
        pub fn metric_widget(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_widget = Some(input.into());
            self
        }
        /// <p>A JSON string that defines the bitmap graph to be retrieved. The string includes the
        /// metrics to include in the graph, statistics, annotations, title, axis limits, and so on.
        /// You can include only one <code>MetricWidget</code> parameter in each <code>GetMetricWidgetImage</code> call.</p>
        /// <p>For more information about the syntax of <code>MetricWidget</code> see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Metric-Widget-Structure.html">GetMetricWidgetImage: Metric Widget Structure and Syntax</a>.</p>
        ///
        /// <p>If any metric on the graph could not load all the requested data points, an orange triangle with an exclamation
        /// point appears next to the graph legend.</p>
        pub fn set_metric_widget(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_widget = input;
            self
        }
        /// <p>The format of the resulting image. Only PNG images are supported.</p>
        ///
        /// <p>The default is <code>png</code>. If you specify <code>png</code>, the API returns an HTTP response with the
        /// content-type set to <code>text/xml</code>. The image data is in a <code>MetricWidgetImage</code>
        /// field. For example:</p>
        ///
        /// <p>
        /// <code>
        /// <GetMetricWidgetImageResponse xmlns=<URLstring>></code>
        /// </p>
        /// <p>
        /// <code>  <GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>    <MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>       iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQEAYAAAAip...</code>
        /// </p>
        /// <p>
        /// <code>    </MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>  </GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>  <ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code>    <RequestId>6f0d4192-4d42-11e8-82c1-f539a07e0e3b</RequestId></code>
        /// </p>
        /// <p>
        /// <code>  </ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code></GetMetricWidgetImageResponse></code>
        /// </p>
        ///
        /// <p>The <code>image/png</code> setting is intended only for custom HTTP requests. For most
        /// use cases, and all actions using an Amazon Web Services SDK, you should use <code>png</code>. If you specify
        /// <code>image/png</code>, the HTTP response has a content-type set to <code>image/png</code>,
        /// and the body of the response is a PNG image. </p>
        pub fn output_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_format = Some(input.into());
            self
        }
        /// <p>The format of the resulting image. Only PNG images are supported.</p>
        ///
        /// <p>The default is <code>png</code>. If you specify <code>png</code>, the API returns an HTTP response with the
        /// content-type set to <code>text/xml</code>. The image data is in a <code>MetricWidgetImage</code>
        /// field. For example:</p>
        ///
        /// <p>
        /// <code>
        /// <GetMetricWidgetImageResponse xmlns=<URLstring>></code>
        /// </p>
        /// <p>
        /// <code>  <GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>    <MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>       iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQEAYAAAAip...</code>
        /// </p>
        /// <p>
        /// <code>    </MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>  </GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>  <ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code>    <RequestId>6f0d4192-4d42-11e8-82c1-f539a07e0e3b</RequestId></code>
        /// </p>
        /// <p>
        /// <code>  </ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code></GetMetricWidgetImageResponse></code>
        /// </p>
        ///
        /// <p>The <code>image/png</code> setting is intended only for custom HTTP requests. For most
        /// use cases, and all actions using an Amazon Web Services SDK, you should use <code>png</code>. If you specify
        /// <code>image/png</code>, the HTTP response has a content-type set to <code>image/png</code>,
        /// and the body of the response is a PNG image. </p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMetricWidgetImageInput`](crate::input::GetMetricWidgetImageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetMetricWidgetImageInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetMetricWidgetImageInput {
                metric_widget: self.metric_widget,
                output_format: self.output_format,
            })
        }
    }
}
#[doc(hidden)]
pub type GetMetricWidgetImageInputOperationOutputAlias = crate::operation::GetMetricWidgetImage;
#[doc(hidden)]
pub type GetMetricWidgetImageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetMetricWidgetImageInput {
    /// Consumes the builder and constructs an Operation<[`GetMetricWidgetImage`](crate::operation::GetMetricWidgetImage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetMetricWidgetImage,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetMetricWidgetImageInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetMetricWidgetImageInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetMetricWidgetImageInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_metric_widget_image(
                &self,
            )
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetMetricWidgetImage::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetMetricWidgetImage",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetMetricWidgetImageInput`](crate::input::GetMetricWidgetImageInput)
    pub fn builder() -> crate::input::get_metric_widget_image_input::Builder {
        crate::input::get_metric_widget_image_input::Builder::default()
    }
}

/// See [`ListDashboardsInput`](crate::input::ListDashboardsInput)
pub mod list_dashboards_input {
    /// A builder for [`ListDashboardsInput`](crate::input::ListDashboardsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>If you specify this parameter, only
        /// the dashboards with names starting with the specified string are listed. The maximum length is 255, and
        /// valid characters are A-Z, a-z, 0-9, ".", "-", and "_".
        ///
        /// </p>
        pub fn dashboard_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_name_prefix = Some(input.into());
            self
        }
        /// <p>If you specify this parameter, only
        /// the dashboards with names starting with the specified string are listed. The maximum length is 255, and
        /// valid characters are A-Z, a-z, 0-9, ".", "-", and "_".
        ///
        /// </p>
        pub fn set_dashboard_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dashboard_name_prefix = input;
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data available.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDashboardsInput`](crate::input::ListDashboardsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListDashboardsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListDashboardsInput {
                dashboard_name_prefix: self.dashboard_name_prefix,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListDashboardsInputOperationOutputAlias = crate::operation::ListDashboards;
#[doc(hidden)]
pub type ListDashboardsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListDashboardsInput {
    /// Consumes the builder and constructs an Operation<[`ListDashboards`](crate::operation::ListDashboards)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDashboards,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListDashboardsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListDashboardsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListDashboardsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_dashboards(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDashboards::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDashboards",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListDashboardsInput`](crate::input::ListDashboardsInput)
    pub fn builder() -> crate::input::list_dashboards_input::Builder {
        crate::input::list_dashboards_input::Builder::default()
    }
}

/// See [`ListMetricsInput`](crate::input::ListMetricsInput)
pub mod list_metrics_input {
    /// A builder for [`ListMetricsInput`](crate::input::ListMetricsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::DimensionFilter>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) recently_active: std::option::Option<crate::model::RecentlyActive>,
    }
    impl Builder {
        /// <p>The metric namespace to filter against. Only the namespace that matches exactly
        /// will be returned.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The metric namespace to filter against. Only the namespace that matches exactly
        /// will be returned.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the metric to filter against.  Only the metrics with names that match exactly
        /// will be returned.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric to filter against.  Only the metrics with names that match exactly
        /// will be returned.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions to filter against.  Only the dimensions that match exactly
        /// will be returned.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::DimensionFilter>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions to filter against.  Only the dimensions that match exactly
        /// will be returned.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionFilter>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>To filter the results to show only metrics that have had data points published
        /// in the past three hours, specify this parameter
        /// with a value of <code>PT3H</code>. This is the only valid value
        /// for this parameter.</p>
        /// <p>The results that are returned are an approximation of the value you specify. There
        /// is a low probability that the returned results include metrics with last published
        /// data as much as 40 minutes more than the specified time interval.</p>
        pub fn recently_active(mut self, input: crate::model::RecentlyActive) -> Self {
            self.recently_active = Some(input);
            self
        }
        /// <p>To filter the results to show only metrics that have had data points published
        /// in the past three hours, specify this parameter
        /// with a value of <code>PT3H</code>. This is the only valid value
        /// for this parameter.</p>
        /// <p>The results that are returned are an approximation of the value you specify. There
        /// is a low probability that the returned results include metrics with last published
        /// data as much as 40 minutes more than the specified time interval.</p>
        pub fn set_recently_active(
            mut self,
            input: std::option::Option<crate::model::RecentlyActive>,
        ) -> Self {
            self.recently_active = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMetricsInput`](crate::input::ListMetricsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMetricsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMetricsInput {
                namespace: self.namespace,
                metric_name: self.metric_name,
                dimensions: self.dimensions,
                next_token: self.next_token,
                recently_active: self.recently_active,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMetricsInputOperationOutputAlias = crate::operation::ListMetrics;
#[doc(hidden)]
pub type ListMetricsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMetricsInput {
    /// Consumes the builder and constructs an Operation<[`ListMetrics`](crate::operation::ListMetrics)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMetrics,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListMetricsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListMetricsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListMetricsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_list_metrics(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMetrics::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMetrics",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMetricsInput`](crate::input::ListMetricsInput)
    pub fn builder() -> crate::input::list_metrics_input::Builder {
        crate::input::list_metrics_input::Builder::default()
    }
}

/// See [`ListMetricStreamsInput`](crate::input::ListMetricStreamsInput)
pub mod list_metric_streams_input {
    /// A builder for [`ListMetricStreamsInput`](crate::input::ListMetricStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Include this value, if it was returned by the previous call, to get the next set of metric streams.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Include this value, if it was returned by the previous call, to get the next set of metric streams.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to return in one operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return in one operation.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMetricStreamsInput`](crate::input::ListMetricStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListMetricStreamsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListMetricStreamsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
#[doc(hidden)]
pub type ListMetricStreamsInputOperationOutputAlias = crate::operation::ListMetricStreams;
#[doc(hidden)]
pub type ListMetricStreamsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListMetricStreamsInput {
    /// Consumes the builder and constructs an Operation<[`ListMetricStreams`](crate::operation::ListMetricStreams)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListMetricStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListMetricStreamsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListMetricStreamsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListMetricStreamsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_metric_streams(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListMetricStreams::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListMetricStreams",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListMetricStreamsInput`](crate::input::ListMetricStreamsInput)
    pub fn builder() -> crate::input::list_metric_streams_input::Builder {
        crate::input::list_metric_streams_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch resource that you want to view tags for.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch resource that you want to view tags for.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_list_tags_for_resource(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`PutAnomalyDetectorInput`](crate::input::PutAnomalyDetectorInput)
pub mod put_anomaly_detector_input {
    /// A builder for [`PutAnomalyDetectorInput`](crate::input::PutAnomalyDetectorInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) stat: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<crate::model::AnomalyDetectorConfiguration>,
    }
    impl Builder {
        /// <p>The namespace of the metric to create the anomaly detection model for.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace of the metric to create the anomaly detection model for.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The name of the metric to create the anomaly detection model for.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the metric to create the anomaly detection model for.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The metric dimensions to create the anomaly detection model for.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The metric dimensions to create the anomaly detection model for.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The statistic to use for the metric and the anomaly detection model.</p>
        pub fn stat(mut self, input: impl Into<std::string::String>) -> Self {
            self.stat = Some(input.into());
            self
        }
        /// <p>The statistic to use for the metric and the anomaly detection model.</p>
        pub fn set_stat(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stat = input;
            self
        }
        /// <p>The configuration specifies details about how the
        /// anomaly detection model is to be trained, including
        /// time ranges to exclude when training and updating the model.
        /// You can specify as many as 10 time ranges.</p>
        /// <p>The configuration can also include the time zone to use for
        /// the metric.</p>
        pub fn configuration(mut self, input: crate::model::AnomalyDetectorConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration specifies details about how the
        /// anomaly detection model is to be trained, including
        /// time ranges to exclude when training and updating the model.
        /// You can specify as many as 10 time ranges.</p>
        /// <p>The configuration can also include the time zone to use for
        /// the metric.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::AnomalyDetectorConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`PutAnomalyDetectorInput`](crate::input::PutAnomalyDetectorInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutAnomalyDetectorInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutAnomalyDetectorInput {
                namespace: self.namespace,
                metric_name: self.metric_name,
                dimensions: self.dimensions,
                stat: self.stat,
                configuration: self.configuration,
            })
        }
    }
}
#[doc(hidden)]
pub type PutAnomalyDetectorInputOperationOutputAlias = crate::operation::PutAnomalyDetector;
#[doc(hidden)]
pub type PutAnomalyDetectorInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutAnomalyDetectorInput {
    /// Consumes the builder and constructs an Operation<[`PutAnomalyDetector`](crate::operation::PutAnomalyDetector)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutAnomalyDetector,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutAnomalyDetectorInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutAnomalyDetectorInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutAnomalyDetectorInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_anomaly_detector(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutAnomalyDetector::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutAnomalyDetector",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutAnomalyDetectorInput`](crate::input::PutAnomalyDetectorInput)
    pub fn builder() -> crate::input::put_anomaly_detector_input::Builder {
        crate::input::put_anomaly_detector_input::Builder::default()
    }
}

/// See [`PutCompositeAlarmInput`](crate::input::PutCompositeAlarmInput)
pub mod put_composite_alarm_input {
    /// A builder for [`PutCompositeAlarmInput`](crate::input::PutCompositeAlarmInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) actions_enabled: std::option::Option<bool>,
        pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) alarm_description: std::option::Option<std::string::String>,
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) alarm_rule: std::option::Option<std::string::String>,
        pub(crate) insufficient_data_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is
        /// <code>TRUE</code>.</p>
        pub fn actions_enabled(mut self, input: bool) -> Self {
            self.actions_enabled = Some(input);
            self
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is
        /// <code>TRUE</code>.</p>
        pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.actions_enabled = input;
            self
        }
        /// Appends an item to `alarm_actions`.
        ///
        /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// </p>
        pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_actions.unwrap_or_default();
            v.push(input.into());
            self.alarm_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// </p>
        pub fn set_alarm_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_actions = input;
            self
        }
        /// <p>The description for the composite alarm.</p>
        pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_description = Some(input.into());
            self
        }
        /// <p>The description for the composite alarm.</p>
        pub fn set_alarm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_description = input;
            self
        }
        /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>An expression that specifies which other alarms are to be evaluated to determine this
        /// composite alarm's state. For each alarm that you reference, you
        /// designate a function that
        /// specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You
        /// can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the
        /// functions in your expression.</p>
        /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
        /// <p>Functions can include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in OK state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in INSUFFICIENT_DATA state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRUE</code> always evaluates to TRUE.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FALSE</code> always evaluates to FALSE.</p>
        /// </li>
        /// </ul>
        /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and
        /// for testing your alarm actions.</p>
        /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
        /// <p>The following
        /// are some examples of <code>AlarmRule</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only
        /// if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code>
        /// specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state
        /// and DeploymentInProgress is not in ALARM state. This example reduces
        /// alarm noise during a known deployment window.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM
        /// state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state.
        /// This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an
        /// alarm action on high CPU or disk usage if a known network problem is also occurring.</p>
        /// </li>
        /// </ul>
        /// <p>The <code>AlarmRule</code> can specify as many as 100
        /// "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements
        /// are child alarms, TRUE or FALSE statements, and
        /// parentheses.</p>
        pub fn alarm_rule(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_rule = Some(input.into());
            self
        }
        /// <p>An expression that specifies which other alarms are to be evaluated to determine this
        /// composite alarm's state. For each alarm that you reference, you
        /// designate a function that
        /// specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You
        /// can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the
        /// functions in your expression.</p>
        /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
        /// <p>Functions can include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in OK state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in INSUFFICIENT_DATA state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRUE</code> always evaluates to TRUE.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FALSE</code> always evaluates to FALSE.</p>
        /// </li>
        /// </ul>
        /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and
        /// for testing your alarm actions.</p>
        /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
        /// <p>The following
        /// are some examples of <code>AlarmRule</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only
        /// if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code>
        /// specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state
        /// and DeploymentInProgress is not in ALARM state. This example reduces
        /// alarm noise during a known deployment window.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM
        /// state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state.
        /// This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an
        /// alarm action on high CPU or disk usage if a known network problem is also occurring.</p>
        /// </li>
        /// </ul>
        /// <p>The <code>AlarmRule</code> can specify as many as 100
        /// "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements
        /// are child alarms, TRUE or FALSE statements, and
        /// parentheses.</p>
        pub fn set_alarm_rule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_rule = input;
            self
        }
        /// Appends an item to `insufficient_data_actions`.
        ///
        /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.insufficient_data_actions.unwrap_or_default();
            v.push(input.into());
            self.insufficient_data_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn set_insufficient_data_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.insufficient_data_actions = input;
            self
        }
        /// Appends an item to `ok_actions`.
        ///
        /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ok_actions.unwrap_or_default();
            v.push(input.into());
            self.ok_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        ///
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn set_ok_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ok_actions = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with
        /// certain tag values.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with
        /// certain tag values.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PutCompositeAlarmInput`](crate::input::PutCompositeAlarmInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutCompositeAlarmInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutCompositeAlarmInput {
                actions_enabled: self.actions_enabled,
                alarm_actions: self.alarm_actions,
                alarm_description: self.alarm_description,
                alarm_name: self.alarm_name,
                alarm_rule: self.alarm_rule,
                insufficient_data_actions: self.insufficient_data_actions,
                ok_actions: self.ok_actions,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type PutCompositeAlarmInputOperationOutputAlias = crate::operation::PutCompositeAlarm;
#[doc(hidden)]
pub type PutCompositeAlarmInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutCompositeAlarmInput {
    /// Consumes the builder and constructs an Operation<[`PutCompositeAlarm`](crate::operation::PutCompositeAlarm)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutCompositeAlarm,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutCompositeAlarmInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutCompositeAlarmInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutCompositeAlarmInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_composite_alarm(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutCompositeAlarm::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutCompositeAlarm",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutCompositeAlarmInput`](crate::input::PutCompositeAlarmInput)
    pub fn builder() -> crate::input::put_composite_alarm_input::Builder {
        crate::input::put_composite_alarm_input::Builder::default()
    }
}

/// See [`PutDashboardInput`](crate::input::PutDashboardInput)
pub mod put_dashboard_input {
    /// A builder for [`PutDashboardInput`](crate::input::PutDashboardInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dashboard_name: std::option::Option<std::string::String>,
        pub(crate) dashboard_body: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the dashboard. If a dashboard with this name already exists, this call modifies that dashboard, replacing
        /// its current contents. Otherwise, a new dashboard is created. The maximum length is 255, and valid characters are
        /// A-Z, a-z, 0-9, "-", and "_".  This parameter is required.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_name = Some(input.into());
            self
        }
        /// <p>The name of the dashboard. If a dashboard with this name already exists, this call modifies that dashboard, replacing
        /// its current contents. Otherwise, a new dashboard is created. The maximum length is 255, and valid characters are
        /// A-Z, a-z, 0-9, "-", and "_".  This parameter is required.</p>
        pub fn set_dashboard_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dashboard_name = input;
            self
        }
        /// <p>The detailed information about the dashboard in JSON format, including the widgets to include and their location
        /// on the dashboard.  This parameter is required.</p>
        /// <p>For more information about the syntax,
        /// see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html">Dashboard Body Structure and Syntax</a>.</p>
        pub fn dashboard_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.dashboard_body = Some(input.into());
            self
        }
        /// <p>The detailed information about the dashboard in JSON format, including the widgets to include and their location
        /// on the dashboard.  This parameter is required.</p>
        /// <p>For more information about the syntax,
        /// see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html">Dashboard Body Structure and Syntax</a>.</p>
        pub fn set_dashboard_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dashboard_body = input;
            self
        }
        /// Consumes the builder and constructs a [`PutDashboardInput`](crate::input::PutDashboardInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutDashboardInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutDashboardInput {
                dashboard_name: self.dashboard_name,
                dashboard_body: self.dashboard_body,
            })
        }
    }
}
#[doc(hidden)]
pub type PutDashboardInputOperationOutputAlias = crate::operation::PutDashboard;
#[doc(hidden)]
pub type PutDashboardInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutDashboardInput {
    /// Consumes the builder and constructs an Operation<[`PutDashboard`](crate::operation::PutDashboard)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutDashboard,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutDashboardInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutDashboardInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutDashboardInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_put_dashboard(&self)
            .map_err(|err| {
            aws_smithy_http::operation::BuildError::SerializationError(err.into())
        })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutDashboard::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutDashboard",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutDashboardInput`](crate::input::PutDashboardInput)
    pub fn builder() -> crate::input::put_dashboard_input::Builder {
        crate::input::put_dashboard_input::Builder::default()
    }
}

/// See [`PutInsightRuleInput`](crate::input::PutInsightRuleInput)
pub mod put_insight_rule_input {
    /// A builder for [`PutInsightRuleInput`](crate::input::PutInsightRuleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_name: std::option::Option<std::string::String>,
        pub(crate) rule_state: std::option::Option<std::string::String>,
        pub(crate) rule_definition: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A unique name for the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_name = Some(input.into());
            self
        }
        /// <p>A unique name for the rule.</p>
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_name = input;
            self
        }
        /// <p>The state of the rule. Valid values are ENABLED and DISABLED.</p>
        pub fn rule_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_state = Some(input.into());
            self
        }
        /// <p>The state of the rule. Valid values are ENABLED and DISABLED.</p>
        pub fn set_rule_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_state = input;
            self
        }
        /// <p>The definition of the rule, as a JSON object. For details on the valid syntax, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html">Contributor Insights
        /// Rule Syntax</a>.</p>
        pub fn rule_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_definition = Some(input.into());
            self
        }
        /// <p>The definition of the rule, as a JSON object. For details on the valid syntax, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html">Contributor Insights
        /// Rule Syntax</a>.</p>
        pub fn set_rule_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.rule_definition = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs to associate with the Contributor Insights rule.
        /// You can associate as many as 50 tags with a rule.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by
        /// granting a user permission to access or change only the resources that have
        /// certain tag values.</p>
        /// <p>To be able to associate tags with a rule, you must have the <code>cloudwatch:TagResource</code>
        /// permission in addition to the <code>cloudwatch:PutInsightRule</code> permission.</p>
        /// <p>If you are using this operation to update an existing Contributor Insights rule, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing rule, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of key-value pairs to associate with the Contributor Insights rule.
        /// You can associate as many as 50 tags with a rule.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by
        /// granting a user permission to access or change only the resources that have
        /// certain tag values.</p>
        /// <p>To be able to associate tags with a rule, you must have the <code>cloudwatch:TagResource</code>
        /// permission in addition to the <code>cloudwatch:PutInsightRule</code> permission.</p>
        /// <p>If you are using this operation to update an existing Contributor Insights rule, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing rule, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PutInsightRuleInput`](crate::input::PutInsightRuleInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutInsightRuleInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutInsightRuleInput {
                rule_name: self.rule_name,
                rule_state: self.rule_state,
                rule_definition: self.rule_definition,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type PutInsightRuleInputOperationOutputAlias = crate::operation::PutInsightRule;
#[doc(hidden)]
pub type PutInsightRuleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutInsightRuleInput {
    /// Consumes the builder and constructs an Operation<[`PutInsightRule`](crate::operation::PutInsightRule)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutInsightRule,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutInsightRuleInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutInsightRuleInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutInsightRuleInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_insight_rule(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutInsightRule::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutInsightRule",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutInsightRuleInput`](crate::input::PutInsightRuleInput)
    pub fn builder() -> crate::input::put_insight_rule_input::Builder {
        crate::input::put_insight_rule_input::Builder::default()
    }
}

/// See [`PutMetricAlarmInput`](crate::input::PutMetricAlarmInput)
pub mod put_metric_alarm_input {
    /// A builder for [`PutMetricAlarmInput`](crate::input::PutMetricAlarmInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) alarm_description: std::option::Option<std::string::String>,
        pub(crate) actions_enabled: std::option::Option<bool>,
        pub(crate) ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) insufficient_data_actions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) statistic: std::option::Option<crate::model::Statistic>,
        pub(crate) extended_statistic: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        pub(crate) period: std::option::Option<i32>,
        pub(crate) unit: std::option::Option<crate::model::StandardUnit>,
        pub(crate) evaluation_periods: std::option::Option<i32>,
        pub(crate) datapoints_to_alarm: std::option::Option<i32>,
        pub(crate) threshold: std::option::Option<f64>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) treat_missing_data: std::option::Option<std::string::String>,
        pub(crate) evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
        pub(crate) metrics: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) threshold_metric_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for the alarm. This name must be unique within the Region.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name for the alarm. This name must be unique within the Region.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The description for the alarm.</p>
        pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_description = Some(input.into());
            self
        }
        /// <p>The description for the alarm.</p>
        pub fn set_alarm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.alarm_description = input;
            self
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state. The default is
        /// <code>TRUE</code>.</p>
        pub fn actions_enabled(mut self, input: bool) -> Self {
            self.actions_enabled = Some(input);
            self
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state. The default is
        /// <code>TRUE</code>.</p>
        pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.actions_enabled = input;
            self
        }
        /// Appends an item to `ok_actions`.
        ///
        /// To override the contents of this collection use [`set_ok_actions`](Self::set_ok_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
        /// </p>
        pub fn ok_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ok_actions.unwrap_or_default();
            v.push(input.into());
            self.ok_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
        /// </p>
        pub fn set_ok_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ok_actions = input;
            self
        }
        /// Appends an item to `alarm_actions`.
        ///
        /// To override the contents of this collection use [`set_alarm_actions`](Self::set_alarm_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// | <code>arn:aws:ssm-incidents::<i>account-id</i>:response-plan:<i>response-plan-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
        /// </p>
        pub fn alarm_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.alarm_actions.unwrap_or_default();
            v.push(input.into());
            self.alarm_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// | <code>arn:aws:ssm-incidents::<i>account-id</i>:response-plan:<i>response-plan-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
        /// </p>
        pub fn set_alarm_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.alarm_actions = input;
            self
        }
        /// Appends an item to `insufficient_data_actions`.
        ///
        /// To override the contents of this collection use [`set_insufficient_data_actions`](Self::set_insufficient_data_actions).
        ///
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code>
        /// </p>
        pub fn insufficient_data_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.insufficient_data_actions.unwrap_or_default();
            v.push(input.into());
            self.insufficient_data_actions = Some(v);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        ///
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        ///
        /// <p>Valid Values (for use with IAM roles):
        /// <code>>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code>
        /// </p>
        pub fn set_insufficient_data_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.insufficient_data_actions = input;
            self
        }
        /// <p>The name for the metric associated with the alarm. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>If you are creating an alarm based on a math expression, you cannot specify this parameter, or any of the
        /// <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters. Instead, you specify
        /// all this information in the <code>Metrics</code> array.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name for the metric associated with the alarm. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>If you are creating an alarm based on a math expression, you cannot specify this parameter, or any of the
        /// <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters. Instead, you specify
        /// all this information in the <code>Metrics</code> array.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace for the metric associated specified in <code>MetricName</code>.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace for the metric associated specified in <code>MetricName</code>.</p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// <p>The statistic for the metric specified in <code>MetricName</code>, other than percentile.
        /// For percentile statistics, use <code>ExtendedStatistic</code>. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.statistic = Some(input);
            self
        }
        /// <p>The statistic for the metric specified in <code>MetricName</code>, other than percentile.
        /// For percentile statistics, use <code>ExtendedStatistic</code>. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The percentile statistic for the metric specified in <code>MetricName</code>. Specify a value
        /// between p0.0 and p100. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.extended_statistic = Some(input.into());
            self
        }
        /// <p>The percentile statistic for the metric specified in <code>MetricName</code>. Specify a value
        /// between p0.0 and p100. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn set_extended_statistic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.extended_statistic = input;
            self
        }
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The dimensions for the metric specified in <code>MetricName</code>.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::Dimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>The dimensions for the metric specified in <code>MetricName</code>.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The length, in seconds, used each time the metric specified in <code>MetricName</code> is
        /// evaluated. Valid values are 10, 30, and any multiple of 60.</p>
        /// <p>
        /// <code>Period</code> is required for alarms based on static thresholds. If
        /// you are creating an alarm based on a metric math expression, you specify the
        /// period for each metric within the objects in the <code>Metrics</code> array.</p>
        /// <p>Be sure to specify 10 or 30 only for metrics that are stored by a <code>PutMetricData</code> call with a
        /// <code>StorageResolution</code> of 1. If you specify a period of 10 or 30 for a metric that does not have
        /// sub-minute resolution, the alarm still attempts to gather data at the period rate that you specify. In this case,
        /// it does not receive data for the attempts that do not correspond to a one-minute data resolution, and the alarm
        /// might often lapse into INSUFFICENT_DATA status. Specifying 10 or 30 also sets this alarm as a high-resolution alarm,
        /// which has a higher charge than other alarms. For more information about pricing, see <a href="https://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so <code>Period</code> multiplied by <code>EvaluationPeriods</code> cannot be more than 86,400 seconds.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The length, in seconds, used each time the metric specified in <code>MetricName</code> is
        /// evaluated. Valid values are 10, 30, and any multiple of 60.</p>
        /// <p>
        /// <code>Period</code> is required for alarms based on static thresholds. If
        /// you are creating an alarm based on a metric math expression, you specify the
        /// period for each metric within the objects in the <code>Metrics</code> array.</p>
        /// <p>Be sure to specify 10 or 30 only for metrics that are stored by a <code>PutMetricData</code> call with a
        /// <code>StorageResolution</code> of 1. If you specify a period of 10 or 30 for a metric that does not have
        /// sub-minute resolution, the alarm still attempts to gather data at the period rate that you specify. In this case,
        /// it does not receive data for the attempts that do not correspond to a one-minute data resolution, and the alarm
        /// might often lapse into INSUFFICENT_DATA status. Specifying 10 or 30 also sets this alarm as a high-resolution alarm,
        /// which has a higher charge than other alarms. For more information about pricing, see <a href="https://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so <code>Period</code> multiplied by <code>EvaluationPeriods</code> cannot be more than 86,400 seconds.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// <p>The unit of measure for the statistic. For example, the units for the Amazon EC2
        /// NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance
        /// receives on all network interfaces. You can also specify a unit when you create a custom
        /// metric. Units help provide conceptual meaning to your data. Metric data points that
        /// specify a unit of measure, such as Percent, are aggregated separately.</p>
        /// <p>If you don't specify <code>Unit</code>, CloudWatch retrieves all unit types that have been published for the
        /// metric and attempts to evaluate the alarm.
        /// Usually, metrics are
        /// published with only one unit, so the alarm
        /// works as intended.</p>
        /// <p>However, if the metric is published with multiple types of units and you don't specify a unit, the alarm's
        /// behavior is not defined and
        /// it behaves predictably.</p>
        /// <p>We recommend omitting <code>Unit</code> so that you don't inadvertently
        /// specify an incorrect unit that is not published for this metric. Doing so
        /// causes the alarm to be stuck in the <code>INSUFFICIENT DATA</code> state.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit of measure for the statistic. For example, the units for the Amazon EC2
        /// NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance
        /// receives on all network interfaces. You can also specify a unit when you create a custom
        /// metric. Units help provide conceptual meaning to your data. Metric data points that
        /// specify a unit of measure, such as Percent, are aggregated separately.</p>
        /// <p>If you don't specify <code>Unit</code>, CloudWatch retrieves all unit types that have been published for the
        /// metric and attempts to evaluate the alarm.
        /// Usually, metrics are
        /// published with only one unit, so the alarm
        /// works as intended.</p>
        /// <p>However, if the metric is published with multiple types of units and you don't specify a unit, the alarm's
        /// behavior is not defined and
        /// it behaves predictably.</p>
        /// <p>We recommend omitting <code>Unit</code> so that you don't inadvertently
        /// specify an incorrect unit that is not published for this metric. Doing so
        /// causes the alarm to be stuck in the <code>INSUFFICIENT DATA</code> state.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.unit = input;
            self
        }
        /// <p>The number of periods over which data is compared to the specified threshold. If you are
        /// setting an alarm that requires that a number of consecutive data points be breaching to
        /// trigger the alarm, this value specifies that number. If you are setting an "M out of N"
        /// alarm, this value is the N.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so this number multiplied by <code>Period</code> cannot be more than 86,400 seconds.</p>
        pub fn evaluation_periods(mut self, input: i32) -> Self {
            self.evaluation_periods = Some(input);
            self
        }
        /// <p>The number of periods over which data is compared to the specified threshold. If you are
        /// setting an alarm that requires that a number of consecutive data points be breaching to
        /// trigger the alarm, this value specifies that number. If you are setting an "M out of N"
        /// alarm, this value is the N.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so this number multiplied by <code>Period</code> cannot be more than 86,400 seconds.</p>
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.evaluation_periods = input;
            self
        }
        /// <p>The number of data points that must be breaching to trigger the alarm. This is used only if you are setting
        /// an "M out of N" alarm. In that case, this value is the M. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation">Evaluating an Alarm</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
            self.datapoints_to_alarm = Some(input);
            self
        }
        /// <p>The number of data points that must be breaching to trigger the alarm. This is used only if you are setting
        /// an "M out of N" alarm. In that case, this value is the M. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation">Evaluating an Alarm</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
            self.datapoints_to_alarm = input;
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        /// <p>This parameter is required for alarms based on static thresholds, but should
        /// not be used for alarms based on anomaly detection models.</p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        /// <p>This parameter is required for alarms based on static thresholds, but should
        /// not be used for alarms based on anomaly detection models.</p>
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.threshold = input;
            self
        }
        /// <p> The arithmetic operation to use when comparing the specified statistic and
        /// threshold. The specified statistic value is used as the first operand.</p>
        /// <p>The values <code>LessThanLowerOrGreaterThanUpperThreshold</code>,
        /// <code>LessThanLowerThreshold</code>, and <code>GreaterThanUpperThreshold</code>
        /// are used only for alarms based on anomaly detection models.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(input);
            self
        }
        /// <p> The arithmetic operation to use when comparing the specified statistic and
        /// threshold. The specified statistic value is used as the first operand.</p>
        /// <p>The values <code>LessThanLowerOrGreaterThanUpperThreshold</code>,
        /// <code>LessThanLowerThreshold</code>, and <code>GreaterThanUpperThreshold</code>
        /// are used only for alarms based on anomaly detection models.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p> Sets how this alarm is to handle missing data points. If <code>TreatMissingData</code> is omitted, the default behavior of <code>missing</code> is used.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data">Configuring How CloudWatch
        /// Alarms Treats Missing Data</a>.</p>
        /// <p>Valid Values: <code>breaching | notBreaching | ignore | missing</code>
        /// </p>
        pub fn treat_missing_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.treat_missing_data = Some(input.into());
            self
        }
        /// <p> Sets how this alarm is to handle missing data points. If <code>TreatMissingData</code> is omitted, the default behavior of <code>missing</code> is used.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data">Configuring How CloudWatch
        /// Alarms Treats Missing Data</a>.</p>
        /// <p>Valid Values: <code>breaching | notBreaching | ignore | missing</code>
        /// </p>
        pub fn set_treat_missing_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treat_missing_data = input;
            self
        }
        /// <p> Used only for alarms based on percentiles. If you specify <code>ignore</code>, the alarm state does not change during periods with too few data points to be
        /// statistically significant. If you specify <code>evaluate</code> or omit this parameter, the alarm is always evaluated and possibly changes state
        /// no matter how many data points are available. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#percentiles-with-low-samples">Percentile-Based CloudWatch Alarms and Low Data Samples</a>.</p>
        /// <p>Valid Values: <code>evaluate | ignore</code>
        /// </p>
        pub fn evaluate_low_sample_count_percentile(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.evaluate_low_sample_count_percentile = Some(input.into());
            self
        }
        /// <p> Used only for alarms based on percentiles. If you specify <code>ignore</code>, the alarm state does not change during periods with too few data points to be
        /// statistically significant. If you specify <code>evaluate</code> or omit this parameter, the alarm is always evaluated and possibly changes state
        /// no matter how many data points are available. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#percentiles-with-low-samples">Percentile-Based CloudWatch Alarms and Low Data Samples</a>.</p>
        /// <p>Valid Values: <code>evaluate | ignore</code>
        /// </p>
        pub fn set_evaluate_low_sample_count_percentile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluate_low_sample_count_percentile = input;
            self
        }
        /// Appends an item to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>An array of <code>MetricDataQuery</code> structures that enable you to create an alarm based on the result of a
        /// metric math expression. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>Each item in the <code>Metrics</code> array either retrieves a metric or performs a math expression.</p>
        /// <p>One item in the <code>Metrics</code> array is the expression that the alarm watches. You designate this expression
        /// by setting <code>ReturnData</code> to true for this object in the array. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDataQuery.html">MetricDataQuery</a>.</p>
        /// <p>If you use the <code>Metrics</code> parameter, you cannot include the <code>MetricName</code>, <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters of <code>PutMetricAlarm</code> in the same operation.
        /// Instead, you retrieve
        /// the metrics you are using in your math expression as part of the <code>Metrics</code> array.</p>
        pub fn metrics(mut self, input: impl Into<crate::model::MetricDataQuery>) -> Self {
            let mut v = self.metrics.unwrap_or_default();
            v.push(input.into());
            self.metrics = Some(v);
            self
        }
        /// <p>An array of <code>MetricDataQuery</code> structures that enable you to create an alarm based on the result of a
        /// metric math expression. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>Each item in the <code>Metrics</code> array either retrieves a metric or performs a math expression.</p>
        /// <p>One item in the <code>Metrics</code> array is the expression that the alarm watches. You designate this expression
        /// by setting <code>ReturnData</code> to true for this object in the array. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDataQuery.html">MetricDataQuery</a>.</p>
        /// <p>If you use the <code>Metrics</code> parameter, you cannot include the <code>MetricName</code>, <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters of <code>PutMetricAlarm</code> in the same operation.
        /// Instead, you retrieve
        /// the metrics you are using in your math expression as part of the <code>Metrics</code> array.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs to associate with the alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        /// <p>If you are using this operation to update an existing alarm, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing alarm, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
        /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of key-value pairs to associate with the alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        /// <p>If you are using this operation to update an existing alarm, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing alarm, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
        /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>If this is an alarm based on an anomaly detection model, make this value match
        /// the ID of
        /// the <code>ANOMALY_DETECTION_BAND</code> function.</p>
        /// <p>For an example of how to use this parameter, see the
        /// <b>Anomaly Detection
        /// Model Alarm</b> example on this page.</p>
        /// <p>If your alarm uses this parameter, it cannot have Auto Scaling actions.</p>
        pub fn threshold_metric_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.threshold_metric_id = Some(input.into());
            self
        }
        /// <p>If this is an alarm based on an anomaly detection model, make this value match
        /// the ID of
        /// the <code>ANOMALY_DETECTION_BAND</code> function.</p>
        /// <p>For an example of how to use this parameter, see the
        /// <b>Anomaly Detection
        /// Model Alarm</b> example on this page.</p>
        /// <p>If your alarm uses this parameter, it cannot have Auto Scaling actions.</p>
        pub fn set_threshold_metric_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.threshold_metric_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PutMetricAlarmInput`](crate::input::PutMetricAlarmInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutMetricAlarmInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutMetricAlarmInput {
                alarm_name: self.alarm_name,
                alarm_description: self.alarm_description,
                actions_enabled: self.actions_enabled,
                ok_actions: self.ok_actions,
                alarm_actions: self.alarm_actions,
                insufficient_data_actions: self.insufficient_data_actions,
                metric_name: self.metric_name,
                namespace: self.namespace,
                statistic: self.statistic,
                extended_statistic: self.extended_statistic,
                dimensions: self.dimensions,
                period: self.period,
                unit: self.unit,
                evaluation_periods: self.evaluation_periods,
                datapoints_to_alarm: self.datapoints_to_alarm,
                threshold: self.threshold,
                comparison_operator: self.comparison_operator,
                treat_missing_data: self.treat_missing_data,
                evaluate_low_sample_count_percentile: self.evaluate_low_sample_count_percentile,
                metrics: self.metrics,
                tags: self.tags,
                threshold_metric_id: self.threshold_metric_id,
            })
        }
    }
}
#[doc(hidden)]
pub type PutMetricAlarmInputOperationOutputAlias = crate::operation::PutMetricAlarm;
#[doc(hidden)]
pub type PutMetricAlarmInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutMetricAlarmInput {
    /// Consumes the builder and constructs an Operation<[`PutMetricAlarm`](crate::operation::PutMetricAlarm)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutMetricAlarm,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutMetricAlarmInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutMetricAlarmInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutMetricAlarmInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_metric_alarm(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutMetricAlarm::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutMetricAlarm",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutMetricAlarmInput`](crate::input::PutMetricAlarmInput)
    pub fn builder() -> crate::input::put_metric_alarm_input::Builder {
        crate::input::put_metric_alarm_input::Builder::default()
    }
}

/// See [`PutMetricDataInput`](crate::input::PutMetricDataInput)
pub mod put_metric_data_input {
    /// A builder for [`PutMetricDataInput`](crate::input::PutMetricDataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) metric_data: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
    }
    impl Builder {
        /// <p>The namespace for the metric data.</p>
        /// <p>To avoid conflicts
        /// with Amazon Web Services service namespaces, you should not specify a namespace that begins with <code>AWS/</code>
        /// </p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        /// <p>The namespace for the metric data.</p>
        /// <p>To avoid conflicts
        /// with Amazon Web Services service namespaces, you should not specify a namespace that begins with <code>AWS/</code>
        /// </p>
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        /// Appends an item to `metric_data`.
        ///
        /// To override the contents of this collection use [`set_metric_data`](Self::set_metric_data).
        ///
        /// <p>The data for the metric. The array can include no more than 20 metrics per call.</p>
        pub fn metric_data(mut self, input: impl Into<crate::model::MetricDatum>) -> Self {
            let mut v = self.metric_data.unwrap_or_default();
            v.push(input.into());
            self.metric_data = Some(v);
            self
        }
        /// <p>The data for the metric. The array can include no more than 20 metrics per call.</p>
        pub fn set_metric_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
        ) -> Self {
            self.metric_data = input;
            self
        }
        /// Consumes the builder and constructs a [`PutMetricDataInput`](crate::input::PutMetricDataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutMetricDataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutMetricDataInput {
                namespace: self.namespace,
                metric_data: self.metric_data,
            })
        }
    }
}
#[doc(hidden)]
pub type PutMetricDataInputOperationOutputAlias = crate::operation::PutMetricData;
#[doc(hidden)]
pub type PutMetricDataInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutMetricDataInput {
    /// Consumes the builder and constructs an Operation<[`PutMetricData`](crate::operation::PutMetricData)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutMetricData,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutMetricDataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutMetricDataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutMetricDataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_put_metric_data(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutMetricData::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutMetricData",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutMetricDataInput`](crate::input::PutMetricDataInput)
    pub fn builder() -> crate::input::put_metric_data_input::Builder {
        crate::input::put_metric_data_input::Builder::default()
    }
}

/// See [`PutMetricStreamInput`](crate::input::PutMetricStreamInput)
pub mod put_metric_stream_input {
    /// A builder for [`PutMetricStreamInput`](crate::input::PutMetricStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) include_filters:
            std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        pub(crate) exclude_filters:
            std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        pub(crate) firehose_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) output_format: std::option::Option<crate::model::MetricStreamOutputFormat>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>If you are creating a new metric stream, this is the name for the new stream. The name
        /// must be different than the names of other metric streams in this account and Region.</p>
        /// <p>If you are updating a metric stream, specify the name of that stream here.</p>
        /// <p>Valid characters are A-Z, a-z, 0-9, "-" and "_".</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>If you are creating a new metric stream, this is the name for the new stream. The name
        /// must be different than the names of other metric streams in this account and Region.</p>
        /// <p>If you are updating a metric stream, specify the name of that stream here.</p>
        /// <p>Valid characters are A-Z, a-z, 0-9, "-" and "_".</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `include_filters`.
        ///
        /// To override the contents of this collection use [`set_include_filters`](Self::set_include_filters).
        ///
        /// <p>If you specify this parameter, the stream sends only the
        /// metrics from the metric namespaces that you specify here.</p>
        /// <p>You cannot include <code>IncludeFilters</code> and <code>ExcludeFilters</code>
        /// in the same operation.</p>
        pub fn include_filters(
            mut self,
            input: impl Into<crate::model::MetricStreamFilter>,
        ) -> Self {
            let mut v = self.include_filters.unwrap_or_default();
            v.push(input.into());
            self.include_filters = Some(v);
            self
        }
        /// <p>If you specify this parameter, the stream sends only the
        /// metrics from the metric namespaces that you specify here.</p>
        /// <p>You cannot include <code>IncludeFilters</code> and <code>ExcludeFilters</code>
        /// in the same operation.</p>
        pub fn set_include_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        ) -> Self {
            self.include_filters = input;
            self
        }
        /// Appends an item to `exclude_filters`.
        ///
        /// To override the contents of this collection use [`set_exclude_filters`](Self::set_exclude_filters).
        ///
        /// <p>If you specify this parameter, the stream sends metrics from all
        /// metric namespaces except for the namespaces that you specify here.</p>
        /// <p>You cannot include <code>ExcludeFilters</code> and <code>IncludeFilters</code> in
        /// the same operation.</p>
        pub fn exclude_filters(
            mut self,
            input: impl Into<crate::model::MetricStreamFilter>,
        ) -> Self {
            let mut v = self.exclude_filters.unwrap_or_default();
            v.push(input.into());
            self.exclude_filters = Some(v);
            self
        }
        /// <p>If you specify this parameter, the stream sends metrics from all
        /// metric namespaces except for the namespaces that you specify here.</p>
        /// <p>You cannot include <code>ExcludeFilters</code> and <code>IncludeFilters</code> in
        /// the same operation.</p>
        pub fn set_exclude_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        ) -> Self {
            self.exclude_filters = input;
            self
        }
        /// <p>The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream.
        /// This Amazon Kinesis Firehose delivery stream must already exist and must be in the same
        /// account as the metric stream.</p>
        pub fn firehose_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.firehose_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream.
        /// This Amazon Kinesis Firehose delivery stream must already exist and must be in the same
        /// account as the metric stream.</p>
        pub fn set_firehose_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.firehose_arn = input;
            self
        }
        /// <p>The ARN of an IAM role that this metric stream will use to access
        /// Amazon Kinesis Firehose resources. This IAM role must already
        /// exist and must be in the same account as the metric stream. This IAM role must include the following permissions:</p>
        /// <ul>
        /// <li>
        /// <p>firehose:PutRecord</p>
        /// </li>
        /// <li>
        /// <p>firehose:PutRecordBatch</p>
        /// </li>
        /// </ul>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of an IAM role that this metric stream will use to access
        /// Amazon Kinesis Firehose resources. This IAM role must already
        /// exist and must be in the same account as the metric stream. This IAM role must include the following permissions:</p>
        /// <ul>
        /// <li>
        /// <p>firehose:PutRecord</p>
        /// </li>
        /// <li>
        /// <p>firehose:PutRecordBatch</p>
        /// </li>
        /// </ul>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The output format for the stream. Valid values are <code>json</code>
        /// and <code>opentelemetry0.7</code>. For more information about metric stream
        /// output formats, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html">
        /// Metric streams output formats</a>.</p>
        pub fn output_format(mut self, input: crate::model::MetricStreamOutputFormat) -> Self {
            self.output_format = Some(input);
            self
        }
        /// <p>The output format for the stream. Valid values are <code>json</code>
        /// and <code>opentelemetry0.7</code>. For more information about metric stream
        /// output formats, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html">
        /// Metric streams output formats</a>.</p>
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::MetricStreamOutputFormat>,
        ) -> Self {
            self.output_format = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of key-value pairs to associate with the metric stream. You can associate as
        /// many as 50 tags with a metric stream.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        /// <p>You can use this parameter only when you are creating a new metric stream. If you are using this operation to update an existing metric stream, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing metric stream, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
        /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>A list of key-value pairs to associate with the metric stream. You can associate as
        /// many as 50 tags with a metric stream.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        /// <p>You can use this parameter only when you are creating a new metric stream. If you are using this operation to update an existing metric stream, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing metric stream, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
        /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`PutMetricStreamInput`](crate::input::PutMetricStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutMetricStreamInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutMetricStreamInput {
                name: self.name,
                include_filters: self.include_filters,
                exclude_filters: self.exclude_filters,
                firehose_arn: self.firehose_arn,
                role_arn: self.role_arn,
                output_format: self.output_format,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type PutMetricStreamInputOperationOutputAlias = crate::operation::PutMetricStream;
#[doc(hidden)]
pub type PutMetricStreamInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutMetricStreamInput {
    /// Consumes the builder and constructs an Operation<[`PutMetricStream`](crate::operation::PutMetricStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutMetricStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutMetricStreamInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutMetricStreamInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutMetricStreamInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_metric_stream(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutMetricStream::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutMetricStream",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutMetricStreamInput`](crate::input::PutMetricStreamInput)
    pub fn builder() -> crate::input::put_metric_stream_input::Builder {
        crate::input::put_metric_stream_input::Builder::default()
    }
}

/// See [`SetAlarmStateInput`](crate::input::SetAlarmStateInput)
pub mod set_alarm_state_input {
    /// A builder for [`SetAlarmStateInput`](crate::input::SetAlarmStateInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) state_value: std::option::Option<crate::model::StateValue>,
        pub(crate) state_reason: std::option::Option<std::string::String>,
        pub(crate) state_reason_data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        /// <p>The name of the alarm.</p>
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The value of the state.</p>
        pub fn state_value(mut self, input: crate::model::StateValue) -> Self {
            self.state_value = Some(input);
            self
        }
        /// <p>The value of the state.</p>
        pub fn set_state_value(
            mut self,
            input: std::option::Option<crate::model::StateValue>,
        ) -> Self {
            self.state_value = input;
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in text format.</p>
        pub fn state_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_reason = Some(input.into());
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in text format.</p>
        pub fn set_state_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state_reason = input;
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in JSON format.</p>
        /// <p>For SNS or EC2 alarm actions, this is just informational. But for EC2 Auto Scaling or application Auto Scaling
        /// alarm actions, the Auto Scaling policy uses the information in this field to take the correct action.</p>
        pub fn state_reason_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_reason_data = Some(input.into());
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in JSON format.</p>
        /// <p>For SNS or EC2 alarm actions, this is just informational. But for EC2 Auto Scaling or application Auto Scaling
        /// alarm actions, the Auto Scaling policy uses the information in this field to take the correct action.</p>
        pub fn set_state_reason_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_reason_data = input;
            self
        }
        /// Consumes the builder and constructs a [`SetAlarmStateInput`](crate::input::SetAlarmStateInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::SetAlarmStateInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::SetAlarmStateInput {
                alarm_name: self.alarm_name,
                state_value: self.state_value,
                state_reason: self.state_reason,
                state_reason_data: self.state_reason_data,
            })
        }
    }
}
#[doc(hidden)]
pub type SetAlarmStateInputOperationOutputAlias = crate::operation::SetAlarmState;
#[doc(hidden)]
pub type SetAlarmStateInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl SetAlarmStateInput {
    /// Consumes the builder and constructs an Operation<[`SetAlarmState`](crate::operation::SetAlarmState)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SetAlarmState,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::SetAlarmStateInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::SetAlarmStateInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::SetAlarmStateInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_set_alarm_state(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SetAlarmState::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SetAlarmState",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`SetAlarmStateInput`](crate::input::SetAlarmStateInput)
    pub fn builder() -> crate::input::set_alarm_state_input::Builder {
        crate::input::set_alarm_state_input::Builder::default()
    }
}

/// See [`StartMetricStreamsInput`](crate::input::StartMetricStreamsInput)
pub mod start_metric_streams_input {
    /// A builder for [`StartMetricStreamsInput`](crate::input::StartMetricStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        ///
        /// <p>The array of the names of metric streams to start streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will start streaming.</p>
        pub fn names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.names.unwrap_or_default();
            v.push(input.into());
            self.names = Some(v);
            self
        }
        /// <p>The array of the names of metric streams to start streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will start streaming.</p>
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.names = input;
            self
        }
        /// Consumes the builder and constructs a [`StartMetricStreamsInput`](crate::input::StartMetricStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartMetricStreamsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartMetricStreamsInput { names: self.names })
        }
    }
}
#[doc(hidden)]
pub type StartMetricStreamsInputOperationOutputAlias = crate::operation::StartMetricStreams;
#[doc(hidden)]
pub type StartMetricStreamsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartMetricStreamsInput {
    /// Consumes the builder and constructs an Operation<[`StartMetricStreams`](crate::operation::StartMetricStreams)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartMetricStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartMetricStreamsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartMetricStreamsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartMetricStreamsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_metric_streams(&self)
                .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartMetricStreams::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartMetricStreams",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartMetricStreamsInput`](crate::input::StartMetricStreamsInput)
    pub fn builder() -> crate::input::start_metric_streams_input::Builder {
        crate::input::start_metric_streams_input::Builder::default()
    }
}

/// See [`StopMetricStreamsInput`](crate::input::StopMetricStreamsInput)
pub mod stop_metric_streams_input {
    /// A builder for [`StopMetricStreamsInput`](crate::input::StopMetricStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        ///
        /// <p>The array of the names of metric streams to stop streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will stop streaming.</p>
        pub fn names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.names.unwrap_or_default();
            v.push(input.into());
            self.names = Some(v);
            self
        }
        /// <p>The array of the names of metric streams to stop streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will stop streaming.</p>
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.names = input;
            self
        }
        /// Consumes the builder and constructs a [`StopMetricStreamsInput`](crate::input::StopMetricStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StopMetricStreamsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StopMetricStreamsInput { names: self.names })
        }
    }
}
#[doc(hidden)]
pub type StopMetricStreamsInputOperationOutputAlias = crate::operation::StopMetricStreams;
#[doc(hidden)]
pub type StopMetricStreamsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopMetricStreamsInput {
    /// Consumes the builder and constructs an Operation<[`StopMetricStreams`](crate::operation::StopMetricStreams)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopMetricStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StopMetricStreamsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StopMetricStreamsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StopMetricStreamsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_stop_metric_streams(&self)
                .map_err(|err| {
                    aws_smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopMetricStreams::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopMetricStreams",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopMetricStreamsInput`](crate::input::StopMetricStreamsInput)
    pub fn builder() -> crate::input::stop_metric_streams_input::Builder {
        crate::input::stop_metric_streams_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch resource that you're adding tags to.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch resource that you're adding tags to.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value pairs to associate with the alarm.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>The list of key-value pairs to associate with the alarm.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the CloudWatch resource that you're removing tags from.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the CloudWatch resource that you're removing tags from.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The list of tag keys to remove from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The list of tag keys to remove from the resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/x-www-form-urlencoded",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)
            .map_err(|err| {
                aws_smithy_http::operation::BuildError::SerializationError(err.into())
            })?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        request
            .properties_mut()
            .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                crate::API_METADATA.clone(),
            ));
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "cloudwatch",
        ));
        let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The ARN of the CloudWatch resource that you're removing tags from.</p>
    /// <p>The ARN format of an alarm is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
    /// </code>
    /// </p>
    /// <p>The ARN format of a Contributor Insights rule is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
    /// </code>
    /// </p>
    /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
    /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
    /// Reference</i>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The list of tag keys to remove from the resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The ARN of the CloudWatch resource that you're adding tags to.</p>
    /// <p>The ARN format of an alarm is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
    /// </code>
    /// </p>
    /// <p>The ARN format of a Contributor Insights rule is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
    /// </code>
    /// </p>
    /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
    /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
    /// Reference</i>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The list of key-value pairs to associate with the alarm.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopMetricStreamsInput {
    /// <p>The array of the names of metric streams to stop streaming.</p>
    /// <p>This is an "all or nothing" operation. If you do not have
    /// permission to access all of the metric streams that you list here, then none of the streams that you list
    /// in the operation will stop streaming.</p>
    pub names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StopMetricStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopMetricStreamsInput");
        formatter.field("names", &self.names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMetricStreamsInput {
    /// <p>The array of the names of metric streams to start streaming.</p>
    /// <p>This is an "all or nothing" operation. If you do not have
    /// permission to access all of the metric streams that you list here, then none of the streams that you list
    /// in the operation will start streaming.</p>
    pub names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StartMetricStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMetricStreamsInput");
        formatter.field("names", &self.names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetAlarmStateInput {
    /// <p>The name of the alarm.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The value of the state.</p>
    pub state_value: std::option::Option<crate::model::StateValue>,
    /// <p>The reason that this alarm is set to this specific state, in text format.</p>
    pub state_reason: std::option::Option<std::string::String>,
    /// <p>The reason that this alarm is set to this specific state, in JSON format.</p>
    /// <p>For SNS or EC2 alarm actions, this is just informational. But for EC2 Auto Scaling or application Auto Scaling
    /// alarm actions, the Auto Scaling policy uses the information in this field to take the correct action.</p>
    pub state_reason_data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SetAlarmStateInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetAlarmStateInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("state_value", &self.state_value);
        formatter.field("state_reason", &self.state_reason);
        formatter.field("state_reason_data", &self.state_reason_data);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutMetricStreamInput {
    /// <p>If you are creating a new metric stream, this is the name for the new stream. The name
    /// must be different than the names of other metric streams in this account and Region.</p>
    /// <p>If you are updating a metric stream, specify the name of that stream here.</p>
    /// <p>Valid characters are A-Z, a-z, 0-9, "-" and "_".</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If you specify this parameter, the stream sends only the
    /// metrics from the metric namespaces that you specify here.</p>
    /// <p>You cannot include <code>IncludeFilters</code> and <code>ExcludeFilters</code>
    /// in the same operation.</p>
    pub include_filters: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
    /// <p>If you specify this parameter, the stream sends metrics from all
    /// metric namespaces except for the namespaces that you specify here.</p>
    /// <p>You cannot include <code>ExcludeFilters</code> and <code>IncludeFilters</code> in
    /// the same operation.</p>
    pub exclude_filters: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
    /// <p>The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream.
    /// This Amazon Kinesis Firehose delivery stream must already exist and must be in the same
    /// account as the metric stream.</p>
    pub firehose_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of an IAM role that this metric stream will use to access
    /// Amazon Kinesis Firehose resources. This IAM role must already
    /// exist and must be in the same account as the metric stream. This IAM role must include the following permissions:</p>
    /// <ul>
    /// <li>
    /// <p>firehose:PutRecord</p>
    /// </li>
    /// <li>
    /// <p>firehose:PutRecordBatch</p>
    /// </li>
    /// </ul>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The output format for the stream. Valid values are <code>json</code>
    /// and <code>opentelemetry0.7</code>. For more information about metric stream
    /// output formats, see
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html">
    /// Metric streams output formats</a>.</p>
    pub output_format: std::option::Option<crate::model::MetricStreamOutputFormat>,
    /// <p>A list of key-value pairs to associate with the metric stream. You can associate as
    /// many as 50 tags with a metric stream.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
    /// permissions by granting a user
    /// permission to access or change only resources with certain tag values.</p>
    /// <p>You can use this parameter only when you are creating a new metric stream. If you are using this operation to update an existing metric stream, any tags
    /// you specify in this parameter are ignored. To change the tags of an existing metric stream, use
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
    /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for PutMetricStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutMetricStreamInput");
        formatter.field("name", &self.name);
        formatter.field("include_filters", &self.include_filters);
        formatter.field("exclude_filters", &self.exclude_filters);
        formatter.field("firehose_arn", &self.firehose_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("output_format", &self.output_format);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutMetricDataInput {
    /// <p>The namespace for the metric data.</p>
    /// <p>To avoid conflicts
    /// with Amazon Web Services service namespaces, you should not specify a namespace that begins with <code>AWS/</code>
    /// </p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The data for the metric. The array can include no more than 20 metrics per call.</p>
    pub metric_data: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
}
impl std::fmt::Debug for PutMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutMetricDataInput");
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_data", &self.metric_data);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutMetricAlarmInput {
    /// <p>The name for the alarm. This name must be unique within the Region.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The description for the alarm.</p>
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>Indicates whether actions should be executed during any changes to the alarm state. The default is
    /// <code>TRUE</code>.</p>
    pub actions_enabled: std::option::Option<bool>,
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
    /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
    /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code> |
    /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
    /// </code>
    /// </p>
    ///
    /// <p>Valid Values (for use with IAM roles):
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
    /// </p>
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
    /// Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
    /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code> |
    /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
    /// </code>
    /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
    /// </code>
    /// | <code>arn:aws:ssm-incidents::<i>account-id</i>:response-plan:<i>response-plan-name</i>
    /// </code>
    /// </p>
    ///
    /// <p>Valid Values (for use with IAM roles):
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
    /// </p>
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
    /// Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
    /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
    /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code> |
    /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
    /// </code>
    /// </p>
    ///
    /// <p>Valid Values (for use with IAM roles):
    /// <code>>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
    /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code>
    /// </p>
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name for the metric associated with the alarm. For each <code>PutMetricAlarm</code>
    /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
    /// <p>If you are creating an alarm based on a math expression, you cannot specify this parameter, or any of the
    /// <code>Dimensions</code>, <code>Period</code>,
    /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters. Instead, you specify
    /// all this information in the <code>Metrics</code> array.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace for the metric associated specified in <code>MetricName</code>.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The statistic for the metric specified in <code>MetricName</code>, other than percentile.
    /// For percentile statistics, use <code>ExtendedStatistic</code>. When you call <code>PutMetricAlarm</code> and specify
    /// a <code>MetricName</code>, you must
    /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
    pub statistic: std::option::Option<crate::model::Statistic>,
    /// <p>The percentile statistic for the metric specified in <code>MetricName</code>. Specify a value
    /// between p0.0 and p100. When you call <code>PutMetricAlarm</code> and specify
    /// a <code>MetricName</code>, you must
    /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
    pub extended_statistic: std::option::Option<std::string::String>,
    /// <p>The dimensions for the metric specified in <code>MetricName</code>.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>The length, in seconds, used each time the metric specified in <code>MetricName</code> is
    /// evaluated. Valid values are 10, 30, and any multiple of 60.</p>
    /// <p>
    /// <code>Period</code> is required for alarms based on static thresholds. If
    /// you are creating an alarm based on a metric math expression, you specify the
    /// period for each metric within the objects in the <code>Metrics</code> array.</p>
    /// <p>Be sure to specify 10 or 30 only for metrics that are stored by a <code>PutMetricData</code> call with a
    /// <code>StorageResolution</code> of 1. If you specify a period of 10 or 30 for a metric that does not have
    /// sub-minute resolution, the alarm still attempts to gather data at the period rate that you specify. In this case,
    /// it does not receive data for the attempts that do not correspond to a one-minute data resolution, and the alarm
    /// might often lapse into INSUFFICENT_DATA status. Specifying 10 or 30 also sets this alarm as a high-resolution alarm,
    /// which has a higher charge than other alarms. For more information about pricing, see <a href="https://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
    /// <p>An alarm's total current evaluation period can
    /// be no longer than one day, so <code>Period</code> multiplied by <code>EvaluationPeriods</code> cannot be more than 86,400 seconds.</p>
    pub period: std::option::Option<i32>,
    /// <p>The unit of measure for the statistic. For example, the units for the Amazon EC2
    /// NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance
    /// receives on all network interfaces. You can also specify a unit when you create a custom
    /// metric. Units help provide conceptual meaning to your data. Metric data points that
    /// specify a unit of measure, such as Percent, are aggregated separately.</p>
    /// <p>If you don't specify <code>Unit</code>, CloudWatch retrieves all unit types that have been published for the
    /// metric and attempts to evaluate the alarm.
    /// Usually, metrics are
    /// published with only one unit, so the alarm
    /// works as intended.</p>
    /// <p>However, if the metric is published with multiple types of units and you don't specify a unit, the alarm's
    /// behavior is not defined and
    /// it behaves predictably.</p>
    /// <p>We recommend omitting <code>Unit</code> so that you don't inadvertently
    /// specify an incorrect unit that is not published for this metric. Doing so
    /// causes the alarm to be stuck in the <code>INSUFFICIENT DATA</code> state.</p>
    pub unit: std::option::Option<crate::model::StandardUnit>,
    /// <p>The number of periods over which data is compared to the specified threshold. If you are
    /// setting an alarm that requires that a number of consecutive data points be breaching to
    /// trigger the alarm, this value specifies that number. If you are setting an "M out of N"
    /// alarm, this value is the N.</p>
    /// <p>An alarm's total current evaluation period can
    /// be no longer than one day, so this number multiplied by <code>Period</code> cannot be more than 86,400 seconds.</p>
    pub evaluation_periods: std::option::Option<i32>,
    /// <p>The number of data points that must be breaching to trigger the alarm. This is used only if you are setting
    /// an "M out of N" alarm. In that case, this value is the M. For more information, see
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation">Evaluating an Alarm</a> in the
    /// <i>Amazon CloudWatch User Guide</i>.</p>
    pub datapoints_to_alarm: std::option::Option<i32>,
    /// <p>The value against which the specified statistic is compared.</p>
    /// <p>This parameter is required for alarms based on static thresholds, but should
    /// not be used for alarms based on anomaly detection models.</p>
    pub threshold: std::option::Option<f64>,
    /// <p> The arithmetic operation to use when comparing the specified statistic and
    /// threshold. The specified statistic value is used as the first operand.</p>
    /// <p>The values <code>LessThanLowerOrGreaterThanUpperThreshold</code>,
    /// <code>LessThanLowerThreshold</code>, and <code>GreaterThanUpperThreshold</code>
    /// are used only for alarms based on anomaly detection models.</p>
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p> Sets how this alarm is to handle missing data points. If <code>TreatMissingData</code> is omitted, the default behavior of <code>missing</code> is used.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data">Configuring How CloudWatch
    /// Alarms Treats Missing Data</a>.</p>
    /// <p>Valid Values: <code>breaching | notBreaching | ignore | missing</code>
    /// </p>
    pub treat_missing_data: std::option::Option<std::string::String>,
    /// <p> Used only for alarms based on percentiles. If you specify <code>ignore</code>, the alarm state does not change during periods with too few data points to be
    /// statistically significant. If you specify <code>evaluate</code> or omit this parameter, the alarm is always evaluated and possibly changes state
    /// no matter how many data points are available. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#percentiles-with-low-samples">Percentile-Based CloudWatch Alarms and Low Data Samples</a>.</p>
    /// <p>Valid Values: <code>evaluate | ignore</code>
    /// </p>
    pub evaluate_low_sample_count_percentile: std::option::Option<std::string::String>,
    /// <p>An array of <code>MetricDataQuery</code> structures that enable you to create an alarm based on the result of a
    /// metric math expression. For each <code>PutMetricAlarm</code>
    /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
    /// <p>Each item in the <code>Metrics</code> array either retrieves a metric or performs a math expression.</p>
    /// <p>One item in the <code>Metrics</code> array is the expression that the alarm watches. You designate this expression
    /// by setting <code>ReturnData</code> to true for this object in the array. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDataQuery.html">MetricDataQuery</a>.</p>
    /// <p>If you use the <code>Metrics</code> parameter, you cannot include the <code>MetricName</code>, <code>Dimensions</code>, <code>Period</code>,
    /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters of <code>PutMetricAlarm</code> in the same operation.
    /// Instead, you retrieve
    /// the metrics you are using in your math expression as part of the <code>Metrics</code> array.</p>
    pub metrics: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
    /// <p>A list of key-value pairs to associate with the alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
    /// permissions by granting a user
    /// permission to access or change only resources with certain tag values.</p>
    /// <p>If you are using this operation to update an existing alarm, any tags
    /// you specify in this parameter are ignored. To change the tags of an existing alarm, use
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
    /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>If this is an alarm based on an anomaly detection model, make this value match
    /// the ID of
    /// the <code>ANOMALY_DETECTION_BAND</code> function.</p>
    /// <p>For an example of how to use this parameter, see the
    /// <b>Anomaly Detection
    /// Model Alarm</b> example on this page.</p>
    /// <p>If your alarm uses this parameter, it cannot have Auto Scaling actions.</p>
    pub threshold_metric_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutMetricAlarmInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutMetricAlarmInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("alarm_description", &self.alarm_description);
        formatter.field("actions_enabled", &self.actions_enabled);
        formatter.field("ok_actions", &self.ok_actions);
        formatter.field("alarm_actions", &self.alarm_actions);
        formatter.field("insufficient_data_actions", &self.insufficient_data_actions);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("statistic", &self.statistic);
        formatter.field("extended_statistic", &self.extended_statistic);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("period", &self.period);
        formatter.field("unit", &self.unit);
        formatter.field("evaluation_periods", &self.evaluation_periods);
        formatter.field("datapoints_to_alarm", &self.datapoints_to_alarm);
        formatter.field("threshold", &self.threshold);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("treat_missing_data", &self.treat_missing_data);
        formatter.field(
            "evaluate_low_sample_count_percentile",
            &self.evaluate_low_sample_count_percentile,
        );
        formatter.field("metrics", &self.metrics);
        formatter.field("tags", &self.tags);
        formatter.field("threshold_metric_id", &self.threshold_metric_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutInsightRuleInput {
    /// <p>A unique name for the rule.</p>
    pub rule_name: std::option::Option<std::string::String>,
    /// <p>The state of the rule. Valid values are ENABLED and DISABLED.</p>
    pub rule_state: std::option::Option<std::string::String>,
    /// <p>The definition of the rule, as a JSON object. For details on the valid syntax, see
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html">Contributor Insights
    /// Rule Syntax</a>.</p>
    pub rule_definition: std::option::Option<std::string::String>,
    /// <p>A list of key-value pairs to associate with the Contributor Insights rule.
    /// You can associate as many as 50 tags with a rule.</p>
    /// <p>Tags can help you organize and categorize your
    /// resources. You can also use them to scope user permissions, by
    /// granting a user permission to access or change only the resources that have
    /// certain tag values.</p>
    /// <p>To be able to associate tags with a rule, you must have the <code>cloudwatch:TagResource</code>
    /// permission in addition to the <code>cloudwatch:PutInsightRule</code> permission.</p>
    /// <p>If you are using this operation to update an existing Contributor Insights rule, any tags
    /// you specify in this parameter are ignored. To change the tags of an existing rule, use
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for PutInsightRuleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutInsightRuleInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.field("rule_state", &self.rule_state);
        formatter.field("rule_definition", &self.rule_definition);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDashboardInput {
    /// <p>The name of the dashboard. If a dashboard with this name already exists, this call modifies that dashboard, replacing
    /// its current contents. Otherwise, a new dashboard is created. The maximum length is 255, and valid characters are
    /// A-Z, a-z, 0-9, "-", and "_".  This parameter is required.</p>
    pub dashboard_name: std::option::Option<std::string::String>,
    /// <p>The detailed information about the dashboard in JSON format, including the widgets to include and their location
    /// on the dashboard.  This parameter is required.</p>
    /// <p>For more information about the syntax,
    /// see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html">Dashboard Body Structure and Syntax</a>.</p>
    pub dashboard_body: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutDashboardInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDashboardInput");
        formatter.field("dashboard_name", &self.dashboard_name);
        formatter.field("dashboard_body", &self.dashboard_body);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutCompositeAlarmInput {
    /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is
    /// <code>TRUE</code>.</p>
    pub actions_enabled: std::option::Option<bool>,
    /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
    /// Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code>
    /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
    /// </code>
    /// </p>
    pub alarm_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The description for the composite alarm.</p>
    pub alarm_description: std::option::Option<std::string::String>,
    /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>An expression that specifies which other alarms are to be evaluated to determine this
    /// composite alarm's state. For each alarm that you reference, you
    /// designate a function that
    /// specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You
    /// can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the
    /// functions in your expression.</p>
    /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
    /// <p>Functions can include the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
    /// alarm is in ALARM state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
    /// alarm is in OK state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
    /// alarm is in INSUFFICIENT_DATA state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TRUE</code> always evaluates to TRUE.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FALSE</code> always evaluates to FALSE.</p>
    /// </li>
    /// </ul>
    /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and
    /// for testing your alarm actions.</p>
    /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
    /// <p>The following
    /// are some examples of <code>AlarmRule</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only
    /// if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code>
    /// specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state
    /// and DeploymentInProgress is not in ALARM state. This example reduces
    /// alarm noise during a known deployment window.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM
    /// state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state.
    /// This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an
    /// alarm action on high CPU or disk usage if a known network problem is also occurring.</p>
    /// </li>
    /// </ul>
    /// <p>The <code>AlarmRule</code> can specify as many as 100
    /// "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements
    /// are child alarms, TRUE or FALSE statements, and
    /// parentheses.</p>
    pub alarm_rule: std::option::Option<std::string::String>,
    /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
    /// Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code>
    /// </p>
    pub insufficient_data_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
    /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
    ///
    ///
    /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
    /// </code>
    /// </p>
    pub ok_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
    /// <p>Tags can help you organize and categorize your
    /// resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with
    /// certain tag values.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for PutCompositeAlarmInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutCompositeAlarmInput");
        formatter.field("actions_enabled", &self.actions_enabled);
        formatter.field("alarm_actions", &self.alarm_actions);
        formatter.field("alarm_description", &self.alarm_description);
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("alarm_rule", &self.alarm_rule);
        formatter.field("insufficient_data_actions", &self.insufficient_data_actions);
        formatter.field("ok_actions", &self.ok_actions);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAnomalyDetectorInput {
    /// <p>The namespace of the metric to create the anomaly detection model for.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the metric to create the anomaly detection model for.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The metric dimensions to create the anomaly detection model for.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>The statistic to use for the metric and the anomaly detection model.</p>
    pub stat: std::option::Option<std::string::String>,
    /// <p>The configuration specifies details about how the
    /// anomaly detection model is to be trained, including
    /// time ranges to exclude when training and updating the model.
    /// You can specify as many as 10 time ranges.</p>
    /// <p>The configuration can also include the time zone to use for
    /// the metric.</p>
    pub configuration: std::option::Option<crate::model::AnomalyDetectorConfiguration>,
}
impl std::fmt::Debug for PutAnomalyDetectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAnomalyDetectorInput");
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("stat", &self.stat);
        formatter.field("configuration", &self.configuration);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN of the CloudWatch resource that you want to view tags for.</p>
    /// <p>The ARN format of an alarm is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
    /// </code>
    /// </p>
    /// <p>The ARN format of a Contributor Insights rule is
    /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
    /// </code>
    /// </p>
    /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
    /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
    /// Reference</i>.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMetricStreamsInput {
    /// <p>Include this value, if it was returned by the previous call, to get the next set of metric streams.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in one operation.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for ListMetricStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMetricStreamsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMetricsInput {
    /// <p>The metric namespace to filter against. Only the namespace that matches exactly
    /// will be returned.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the metric to filter against.  Only the metrics with names that match exactly
    /// will be returned.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The dimensions to filter against.  Only the dimensions that match exactly
    /// will be returned.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::DimensionFilter>>,
    /// <p>The token returned by a previous call to indicate that there is more data
    /// available.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>To filter the results to show only metrics that have had data points published
    /// in the past three hours, specify this parameter
    /// with a value of <code>PT3H</code>. This is the only valid value
    /// for this parameter.</p>
    /// <p>The results that are returned are an approximation of the value you specify. There
    /// is a low probability that the returned results include metrics with last published
    /// data as much as 40 minutes more than the specified time interval.</p>
    pub recently_active: std::option::Option<crate::model::RecentlyActive>,
}
impl std::fmt::Debug for ListMetricsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMetricsInput");
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("next_token", &self.next_token);
        formatter.field("recently_active", &self.recently_active);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDashboardsInput {
    /// <p>If you specify this parameter, only
    /// the dashboards with names starting with the specified string are listed. The maximum length is 255, and
    /// valid characters are A-Z, a-z, 0-9, ".", "-", and "_".
    ///
    /// </p>
    pub dashboard_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token returned by a previous call to indicate that there is more data available.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDashboardsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDashboardsInput");
        formatter.field("dashboard_name_prefix", &self.dashboard_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMetricWidgetImageInput {
    /// <p>A JSON string that defines the bitmap graph to be retrieved. The string includes the
    /// metrics to include in the graph, statistics, annotations, title, axis limits, and so on.
    /// You can include only one <code>MetricWidget</code> parameter in each <code>GetMetricWidgetImage</code> call.</p>
    /// <p>For more information about the syntax of <code>MetricWidget</code> see
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Metric-Widget-Structure.html">GetMetricWidgetImage: Metric Widget Structure and Syntax</a>.</p>
    ///
    /// <p>If any metric on the graph could not load all the requested data points, an orange triangle with an exclamation
    /// point appears next to the graph legend.</p>
    pub metric_widget: std::option::Option<std::string::String>,
    /// <p>The format of the resulting image. Only PNG images are supported.</p>
    ///
    /// <p>The default is <code>png</code>. If you specify <code>png</code>, the API returns an HTTP response with the
    /// content-type set to <code>text/xml</code>. The image data is in a <code>MetricWidgetImage</code>
    /// field. For example:</p>
    ///
    /// <p>
    /// <code>
    /// <GetMetricWidgetImageResponse xmlns=<URLstring>></code>
    /// </p>
    /// <p>
    /// <code>  <GetMetricWidgetImageResult></code>
    /// </p>
    /// <p>
    /// <code>    <MetricWidgetImage></code>
    /// </p>
    /// <p>
    /// <code>       iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQEAYAAAAip...</code>
    /// </p>
    /// <p>
    /// <code>    </MetricWidgetImage></code>
    /// </p>
    /// <p>
    /// <code>  </GetMetricWidgetImageResult></code>
    /// </p>
    /// <p>
    /// <code>  <ResponseMetadata></code>
    /// </p>
    /// <p>
    /// <code>    <RequestId>6f0d4192-4d42-11e8-82c1-f539a07e0e3b</RequestId></code>
    /// </p>
    /// <p>
    /// <code>  </ResponseMetadata></code>
    /// </p>
    /// <p>
    /// <code></GetMetricWidgetImageResponse></code>
    /// </p>
    ///
    /// <p>The <code>image/png</code> setting is intended only for custom HTTP requests. For most
    /// use cases, and all actions using an Amazon Web Services SDK, you should use <code>png</code>. If you specify
    /// <code>image/png</code>, the HTTP response has a content-type set to <code>image/png</code>,
    /// and the body of the response is a PNG image. </p>
    pub output_format: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMetricWidgetImageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMetricWidgetImageInput");
        formatter.field("metric_widget", &self.metric_widget);
        formatter.field("output_format", &self.output_format);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMetricStreamInput {
    /// <p>The name of the metric stream to retrieve information about.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMetricStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMetricStreamInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMetricStatisticsInput {
    /// <p>The namespace of the metric, with or without spaces.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The name of the metric, with or without spaces.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension.
    /// CloudWatch treats each unique combination of dimensions as a separate metric.
    /// If a specific combination of dimensions was not published, you can't retrieve statistics for it.
    /// You must specify the same dimensions that were used when the metrics were created. For an example,
    /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#dimension-combinations">Dimension Combinations</a> in the <i>Amazon CloudWatch User Guide</i>. For more information about specifying dimensions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publishing Metrics</a> in the
    /// <i>Amazon CloudWatch User Guide</i>.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>The time stamp that determines the first data point to return. Start times are
    /// evaluated relative to the time that CloudWatch receives the request.</p>
    /// <p>The value specified is inclusive; results include data points with the specified time stamp.
    /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z).</p>
    /// <p>CloudWatch rounds the specified time stamp as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
    /// For example, 12:32:34 is rounded down to 12:32:00.</p>
    /// </li>
    /// <li>
    /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
    /// For example, 12:32:34 is rounded down to 12:30:00.</p>
    /// </li>
    /// <li>
    /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
    /// For example, 12:32:34 is rounded down to 12:00:00.</p>
    /// </li>
    /// </ul>
    /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
    /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
    /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
    /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
    /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
    /// period of 5 seconds, you receive data
    /// timestamped between 15:02:15 and 15:07:15.
    /// </p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time stamp that determines the last data point to return.</p>
    /// <p>The value specified is exclusive; results include data points up to the specified time stamp.
    /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z).</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can
    /// be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected
    /// at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics
    /// are those metrics stored by a <code>PutMetricData</code> call that includes a <code>StorageResolution</code> of 1 second.</p>
    /// <p>If the <code>StartTime</code> parameter specifies a time stamp that is greater than
    /// 3 hours ago, you must specify the period as follows or no data points in that time range is returned:</p>
    /// <ul>
    /// <li>
    /// <p>Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).</p>
    /// </li>
    /// <li>
    /// <p>Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).</p>
    /// </li>
    /// <li>
    /// <p>Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).</p>
    /// </li>
    /// </ul>
    pub period: std::option::Option<i32>,
    /// <p>The metric statistics, other than percentile. For percentile statistics,
    /// use <code>ExtendedStatistics</code>. When calling <code>GetMetricStatistics</code>, you must
    /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both.</p>
    pub statistics: std::option::Option<std::vec::Vec<crate::model::Statistic>>,
    /// <p>The percentile statistics. Specify values between p0.0 and p100. When calling <code>GetMetricStatistics</code>, you must
    /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both. Percentile statistics are not
    /// available for metrics when any of the metric values are negative numbers.</p>
    pub extended_statistics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unit for a given metric.
    /// If you omit <code>Unit</code>, all data that was collected with any unit is returned, along with the corresponding units that were specified
    /// when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified.
    /// If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.</p>
    pub unit: std::option::Option<crate::model::StandardUnit>,
}
impl std::fmt::Debug for GetMetricStatisticsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMetricStatisticsInput");
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("period", &self.period);
        formatter.field("statistics", &self.statistics);
        formatter.field("extended_statistics", &self.extended_statistics);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMetricDataInput {
    /// <p>The metric queries to be returned. A single <code>GetMetricData</code> call can include as many as 500 <code>MetricDataQuery</code>
    /// structures. Each of these structures can specify either a metric to retrieve, or a math expression to perform on retrieved data. </p>
    pub metric_data_queries: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
    /// <p>The time stamp indicating the earliest data to be returned.</p>
    /// <p>The value specified is inclusive; results include data points with the specified time stamp. </p>
    /// <p>CloudWatch rounds the specified time stamp as follows:</p>
    /// <ul>
    /// <li>
    /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
    /// For example, 12:32:34 is rounded down to 12:32:00.</p>
    /// </li>
    /// <li>
    /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
    /// For example, 12:32:34 is rounded down to 12:30:00.</p>
    /// </li>
    /// <li>
    /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
    /// For example, 12:32:34 is rounded down to 12:00:00.</p>
    /// </li>
    /// </ul>
    /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
    /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
    /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
    /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
    /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
    /// period of 5 seconds, you receive data
    /// timestamped between 15:02:15 and 15:07:15.
    /// </p>
    /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
    /// values that align with the value of the metric's <code>Period</code> and sync up with
    /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
    /// is 5 minutes, specifying 12:05 or 12:30 as <code>StartTime</code> can get a faster response
    /// from CloudWatch than setting 12:07 or 12:29 as the <code>StartTime</code>.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The time stamp indicating the latest data to be returned.</p>
    /// <p>The value specified is exclusive; results include data points up to the specified time stamp.</p>
    /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
    /// values that align with the value of the metric's <code>Period</code> and sync up with
    /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
    /// is 5 minutes, specifying 12:05 or 12:30 as <code>EndTime</code> can get a faster response
    /// from CloudWatch than setting 12:07 or 12:29 as the <code>EndTime</code>.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>Include this value, if it was returned by the previous <code>GetMetricData</code> operation,
    /// to get the next set of data points.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The order in which data points should be returned. <code>TimestampDescending</code> returns the newest data first and paginates
    /// when the <code>MaxDatapoints</code> limit is reached. <code>TimestampAscending</code> returns the oldest data first and paginates
    /// when the <code>MaxDatapoints</code> limit is reached.</p>
    pub scan_by: std::option::Option<crate::model::ScanBy>,
    /// <p>The maximum number of data points the request should return before paginating. If you omit
    /// this, the default of 100,800 is used.</p>
    pub max_datapoints: std::option::Option<i32>,
    /// <p>This structure includes the <code>Timezone</code> parameter, which you can use
    /// to specify your time zone so that the labels of returned data display the
    /// correct time
    /// for your time zone. </p>
    pub label_options: std::option::Option<crate::model::LabelOptions>,
}
impl std::fmt::Debug for GetMetricDataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMetricDataInput");
        formatter.field("metric_data_queries", &self.metric_data_queries);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("next_token", &self.next_token);
        formatter.field("scan_by", &self.scan_by);
        formatter.field("max_datapoints", &self.max_datapoints);
        formatter.field("label_options", &self.label_options);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetInsightRuleReportInput {
    /// <p>The name of the rule that you want to see data from.</p>
    pub rule_name: std::option::Option<std::string::String>,
    /// <p>The start time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
    /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
    /// <code>2019-07-01T23:59:59</code>.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The end time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
    /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
    /// <code>2019-07-01T23:59:59</code>.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The period, in seconds, to use for the statistics in the <code>InsightRuleMetricDatapoint</code> results.</p>
    pub period: std::option::Option<i32>,
    /// <p>The maximum number of contributors to include in the report. The range is 1 to 100. If you omit this, the default of 10 is used.</p>
    pub max_contributor_count: std::option::Option<i32>,
    /// <p>Specifies which metrics to use for aggregation of contributor values for the report. You can specify one or more
    /// of the following metrics:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>UniqueContributors</code> -- the number of unique contributors for each data point.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MaxContributorValue</code> -- the value of the top contributor for each data point. The identity of the
    /// contributor might change for each data point in the graph.</p>
    /// <p>If this rule aggregates by COUNT, the top contributor for each data point is the contributor with the
    /// most occurrences in that period. If the rule aggregates by SUM, the top contributor is the contributor with the highest sum in the log field specified
    /// by the rule's <code>Value</code>, during that period.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SampleCount</code> -- the number of data points matched by the rule.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Sum</code> -- the sum of the values from all contributors during the time period represented by that data point.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Minimum</code> -- the minimum value from a single observation during the time period represented by that data point.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Maximum</code> -- the maximum value from a single observation during the time period represented by that data point.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Average</code> -- the average value from all contributors during the time period represented by that data point.</p>
    /// </li>
    /// </ul>
    pub metrics: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Determines what statistic to use to rank the contributors. Valid values are SUM and MAXIMUM.</p>
    pub order_by: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetInsightRuleReportInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetInsightRuleReportInput");
        formatter.field("rule_name", &self.rule_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("period", &self.period);
        formatter.field("max_contributor_count", &self.max_contributor_count);
        formatter.field("metrics", &self.metrics);
        formatter.field("order_by", &self.order_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDashboardInput {
    /// <p>The name of the dashboard to be described.</p>
    pub dashboard_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetDashboardInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDashboardInput");
        formatter.field("dashboard_name", &self.dashboard_name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableInsightRulesInput {
    /// <p>An array of the rule names to enable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
    pub rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for EnableInsightRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableInsightRulesInput");
        formatter.field("rule_names", &self.rule_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableAlarmActionsInput {
    /// <p>The names of the alarms.</p>
    pub alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for EnableAlarmActionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableAlarmActionsInput");
        formatter.field("alarm_names", &self.alarm_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableInsightRulesInput {
    /// <p>An array of the rule names to disable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
    pub rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DisableInsightRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableInsightRulesInput");
        formatter.field("rule_names", &self.rule_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisableAlarmActionsInput {
    /// <p>The names of the alarms.</p>
    pub alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DisableAlarmActionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisableAlarmActionsInput");
        formatter.field("alarm_names", &self.alarm_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeInsightRulesInput {
    /// <p>Include this value, if it was returned by the previous operation, to get the next set of rules.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in one operation. If you omit this
    /// parameter, the default of 500 is used.</p>
    pub max_results: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeInsightRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeInsightRulesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAnomalyDetectorsInput {
    /// <p>Use the token returned by the previous operation to request the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return in one operation. The maximum
    /// value that you can specify is 100.</p>
    /// <p>To retrieve the remaining results, make another call with the returned
    /// <code>NextToken</code> value. </p>
    pub max_results: std::option::Option<i32>,
    /// <p>Limits the results to only the anomaly detection models that
    /// are associated with the specified namespace.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>Limits the results to only the anomaly detection models that are associated with the
    /// specified metric name. If there are multiple metrics with this name in different
    /// namespaces that have anomaly detection models, they're all returned.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>Limits the results to only the anomaly detection models that are associated with the
    /// specified metric dimensions. If there are multiple metrics that have these dimensions
    /// and have anomaly detection models associated, they're all returned.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
}
impl std::fmt::Debug for DescribeAnomalyDetectorsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAnomalyDetectorsInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("max_results", &self.max_results);
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimensions", &self.dimensions);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAlarmsForMetricInput {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The statistic for the metric, other than percentiles.
    /// For percentile statistics, use <code>ExtendedStatistics</code>.</p>
    pub statistic: std::option::Option<crate::model::Statistic>,
    /// <p>The percentile statistic for the metric. Specify a value between
    /// p0.0 and p100.</p>
    pub extended_statistic: std::option::Option<std::string::String>,
    /// <p>The dimensions associated with the metric. If the metric has any associated
    /// dimensions, you must specify them in order for the call to succeed.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>The period, in seconds, over which the statistic is applied.</p>
    pub period: std::option::Option<i32>,
    /// <p>The unit for the metric.</p>
    pub unit: std::option::Option<crate::model::StandardUnit>,
}
impl std::fmt::Debug for DescribeAlarmsForMetricInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAlarmsForMetricInput");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("statistic", &self.statistic);
        formatter.field("extended_statistic", &self.extended_statistic);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("period", &self.period);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAlarmsInput {
    /// <p>The names of the alarms to retrieve information about.</p>
    pub alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>An alarm name prefix. If you specify this parameter, you receive information about all alarms that have names
    /// that start with this prefix.</p>
    /// <p>If this parameter
    /// is specified, you cannot specify <code>AlarmNames</code>.</p>
    pub alarm_name_prefix: std::option::Option<std::string::String>,
    /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
    /// only metric alarms are returned.</p>
    pub alarm_types: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
    /// <p>If you use this parameter and specify the name of a composite alarm, the operation returns
    /// information about the "children" alarms
    /// of the alarm you specify. These are the metric alarms and composite alarms referenced in the
    /// <code>AlarmRule</code> field of the composite alarm that you specify in
    /// <code>ChildrenOfAlarmName</code>. Information about the composite alarm that you name in
    /// <code>ChildrenOfAlarmName</code> is not returned.</p>
    /// <p>If you specify <code>ChildrenOfAlarmName</code>, you cannot specify any other parameters in the request except
    /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you
    /// receive a validation
    /// error.</p>
    /// <note>
    /// <p>Only the <code>Alarm Name</code>, <code>ARN</code>, <code>StateValue</code> (OK/ALARM/INSUFFICIENT_DATA), and <code>StateUpdatedTimestamp</code>
    /// information are returned by this operation
    /// when you use this parameter. To get complete information about
    /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
    /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
    /// </note>
    pub children_of_alarm_name: std::option::Option<std::string::String>,
    /// <p>If you use this parameter and specify the name of a metric or composite alarm, the operation returns
    /// information about the "parent" alarms
    /// of the alarm you specify. These are the composite alarms that have <code>AlarmRule</code>
    /// parameters that reference
    /// the alarm named in <code>ParentsOfAlarmName</code>. Information about the alarm that you specify in
    /// <code>ParentsOfAlarmName</code> is not returned.</p>
    /// <p>If you specify <code>ParentsOfAlarmName</code>, you cannot specify any other parameters in the request except
    /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you receive a validation
    /// error.</p>
    /// <note>
    /// <p>Only the Alarm Name and ARN are returned by this operation when you use this parameter. To get complete information about
    /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
    /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
    /// </note>
    pub parents_of_alarm_name: std::option::Option<std::string::String>,
    /// <p>Specify this parameter to receive information only about alarms that are currently in the state that you specify.</p>
    pub state_value: std::option::Option<crate::model::StateValue>,
    /// <p>Use this parameter to filter the results of the operation to only those alarms that
    /// use a certain alarm action. For example, you could specify the ARN of an SNS topic to find all
    /// alarms that send notifications to that topic.</p>
    pub action_prefix: std::option::Option<std::string::String>,
    /// <p>The maximum number of alarm descriptions to retrieve.</p>
    pub max_records: std::option::Option<i32>,
    /// <p>The token returned by a previous call to indicate that there is more data
    /// available.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeAlarmsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAlarmsInput");
        formatter.field("alarm_names", &self.alarm_names);
        formatter.field("alarm_name_prefix", &self.alarm_name_prefix);
        formatter.field("alarm_types", &self.alarm_types);
        formatter.field("children_of_alarm_name", &self.children_of_alarm_name);
        formatter.field("parents_of_alarm_name", &self.parents_of_alarm_name);
        formatter.field("state_value", &self.state_value);
        formatter.field("action_prefix", &self.action_prefix);
        formatter.field("max_records", &self.max_records);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeAlarmHistoryInput {
    /// <p>The name of the alarm.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
    /// only metric alarms are returned.</p>
    pub alarm_types: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
    /// <p>The type of alarm histories to retrieve.</p>
    pub history_item_type: std::option::Option<crate::model::HistoryItemType>,
    /// <p>The starting date to retrieve alarm history.</p>
    pub start_date: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The ending date to retrieve alarm history.</p>
    pub end_date: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The maximum number of alarm history records to retrieve.</p>
    pub max_records: std::option::Option<i32>,
    /// <p>The token returned by a previous call to indicate that there is more data
    /// available.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Specified whether to return the newest or oldest alarm history first. Specify <code>TimestampDescending</code> to have the newest
    /// event history returned first, and specify <code>TimestampAscending</code> to have the oldest history returned first.</p>
    pub scan_by: std::option::Option<crate::model::ScanBy>,
}
impl std::fmt::Debug for DescribeAlarmHistoryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeAlarmHistoryInput");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("alarm_types", &self.alarm_types);
        formatter.field("history_item_type", &self.history_item_type);
        formatter.field("start_date", &self.start_date);
        formatter.field("end_date", &self.end_date);
        formatter.field("max_records", &self.max_records);
        formatter.field("next_token", &self.next_token);
        formatter.field("scan_by", &self.scan_by);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMetricStreamInput {
    /// <p>The name of the metric stream to delete.</p>
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMetricStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMetricStreamInput");
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteInsightRulesInput {
    /// <p>An array of the rule names to delete. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
    pub rule_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeleteInsightRulesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteInsightRulesInput");
        formatter.field("rule_names", &self.rule_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDashboardsInput {
    /// <p>The dashboards to be deleted. This parameter is required.</p>
    pub dashboard_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeleteDashboardsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDashboardsInput");
        formatter.field("dashboard_names", &self.dashboard_names);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAnomalyDetectorInput {
    /// <p>The namespace associated with the anomaly detection model to delete.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The metric name associated with the anomaly detection model to delete.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The metric dimensions associated with the anomaly detection model to delete.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
    /// <p>The statistic associated with the anomaly detection model to delete.</p>
    pub stat: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteAnomalyDetectorInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAnomalyDetectorInput");
        formatter.field("namespace", &self.namespace);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("stat", &self.stat);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAlarmsInput {
    /// <p>The alarms to be deleted.</p>
    pub alarm_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeleteAlarmsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAlarmsInput");
        formatter.field("alarm_names", &self.alarm_names);
        formatter.finish()
    }
}
