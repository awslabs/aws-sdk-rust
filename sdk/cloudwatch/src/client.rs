// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn delete_alarms(&self) -> fluent_builders::DeleteAlarms<C> {
        fluent_builders::DeleteAlarms::new(self.handle.clone())
    }
    pub fn delete_anomaly_detector(&self) -> fluent_builders::DeleteAnomalyDetector<C> {
        fluent_builders::DeleteAnomalyDetector::new(self.handle.clone())
    }
    pub fn delete_dashboards(&self) -> fluent_builders::DeleteDashboards<C> {
        fluent_builders::DeleteDashboards::new(self.handle.clone())
    }
    pub fn delete_insight_rules(&self) -> fluent_builders::DeleteInsightRules<C> {
        fluent_builders::DeleteInsightRules::new(self.handle.clone())
    }
    pub fn delete_metric_stream(&self) -> fluent_builders::DeleteMetricStream<C> {
        fluent_builders::DeleteMetricStream::new(self.handle.clone())
    }
    pub fn describe_alarm_history(&self) -> fluent_builders::DescribeAlarmHistory<C> {
        fluent_builders::DescribeAlarmHistory::new(self.handle.clone())
    }
    pub fn describe_alarms(&self) -> fluent_builders::DescribeAlarms<C> {
        fluent_builders::DescribeAlarms::new(self.handle.clone())
    }
    pub fn describe_alarms_for_metric(&self) -> fluent_builders::DescribeAlarmsForMetric<C> {
        fluent_builders::DescribeAlarmsForMetric::new(self.handle.clone())
    }
    pub fn describe_anomaly_detectors(&self) -> fluent_builders::DescribeAnomalyDetectors<C> {
        fluent_builders::DescribeAnomalyDetectors::new(self.handle.clone())
    }
    pub fn describe_insight_rules(&self) -> fluent_builders::DescribeInsightRules<C> {
        fluent_builders::DescribeInsightRules::new(self.handle.clone())
    }
    pub fn disable_alarm_actions(&self) -> fluent_builders::DisableAlarmActions<C> {
        fluent_builders::DisableAlarmActions::new(self.handle.clone())
    }
    pub fn disable_insight_rules(&self) -> fluent_builders::DisableInsightRules<C> {
        fluent_builders::DisableInsightRules::new(self.handle.clone())
    }
    pub fn enable_alarm_actions(&self) -> fluent_builders::EnableAlarmActions<C> {
        fluent_builders::EnableAlarmActions::new(self.handle.clone())
    }
    pub fn enable_insight_rules(&self) -> fluent_builders::EnableInsightRules<C> {
        fluent_builders::EnableInsightRules::new(self.handle.clone())
    }
    pub fn get_dashboard(&self) -> fluent_builders::GetDashboard<C> {
        fluent_builders::GetDashboard::new(self.handle.clone())
    }
    pub fn get_insight_rule_report(&self) -> fluent_builders::GetInsightRuleReport<C> {
        fluent_builders::GetInsightRuleReport::new(self.handle.clone())
    }
    pub fn get_metric_data(&self) -> fluent_builders::GetMetricData<C> {
        fluent_builders::GetMetricData::new(self.handle.clone())
    }
    pub fn get_metric_statistics(&self) -> fluent_builders::GetMetricStatistics<C> {
        fluent_builders::GetMetricStatistics::new(self.handle.clone())
    }
    pub fn get_metric_stream(&self) -> fluent_builders::GetMetricStream<C> {
        fluent_builders::GetMetricStream::new(self.handle.clone())
    }
    pub fn get_metric_widget_image(&self) -> fluent_builders::GetMetricWidgetImage<C> {
        fluent_builders::GetMetricWidgetImage::new(self.handle.clone())
    }
    pub fn list_dashboards(&self) -> fluent_builders::ListDashboards<C> {
        fluent_builders::ListDashboards::new(self.handle.clone())
    }
    pub fn list_metrics(&self) -> fluent_builders::ListMetrics<C> {
        fluent_builders::ListMetrics::new(self.handle.clone())
    }
    pub fn list_metric_streams(&self) -> fluent_builders::ListMetricStreams<C> {
        fluent_builders::ListMetricStreams::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_anomaly_detector(&self) -> fluent_builders::PutAnomalyDetector<C> {
        fluent_builders::PutAnomalyDetector::new(self.handle.clone())
    }
    pub fn put_composite_alarm(&self) -> fluent_builders::PutCompositeAlarm<C> {
        fluent_builders::PutCompositeAlarm::new(self.handle.clone())
    }
    pub fn put_dashboard(&self) -> fluent_builders::PutDashboard<C> {
        fluent_builders::PutDashboard::new(self.handle.clone())
    }
    pub fn put_insight_rule(&self) -> fluent_builders::PutInsightRule<C> {
        fluent_builders::PutInsightRule::new(self.handle.clone())
    }
    pub fn put_metric_alarm(&self) -> fluent_builders::PutMetricAlarm<C> {
        fluent_builders::PutMetricAlarm::new(self.handle.clone())
    }
    pub fn put_metric_data(&self) -> fluent_builders::PutMetricData<C> {
        fluent_builders::PutMetricData::new(self.handle.clone())
    }
    pub fn put_metric_stream(&self) -> fluent_builders::PutMetricStream<C> {
        fluent_builders::PutMetricStream::new(self.handle.clone())
    }
    pub fn set_alarm_state(&self) -> fluent_builders::SetAlarmState<C> {
        fluent_builders::SetAlarmState::new(self.handle.clone())
    }
    pub fn start_metric_streams(&self) -> fluent_builders::StartMetricStreams<C> {
        fluent_builders::StartMetricStreams::new(self.handle.clone())
    }
    pub fn stop_metric_streams(&self) -> fluent_builders::StopMetricStreams<C> {
        fluent_builders::StopMetricStreams::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct DeleteAlarms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_alarms_input::Builder,
    }
    impl<C> DeleteAlarms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAlarmsOutput,
            smithy_http::result::SdkError<crate::error::DeleteAlarmsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The alarms to be deleted.</p>
        pub fn alarm_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_names(inp);
            self
        }
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAnomalyDetector<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_anomaly_detector_input::Builder,
    }
    impl<C> DeleteAnomalyDetector<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAnomalyDetectorOutput,
            smithy_http::result::SdkError<crate::error::DeleteAnomalyDetectorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace associated with the anomaly detection model to delete.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The metric name associated with the anomaly detection model to delete.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The metric dimensions associated with the anomaly detection model to delete.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The statistic associated with the anomaly detection model to delete.</p>
        pub fn stat(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stat(input);
            self
        }
        pub fn set_stat(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stat(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDashboards<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dashboards_input::Builder,
    }
    impl<C> DeleteDashboards<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDashboardsOutput,
            smithy_http::result::SdkError<crate::error::DeleteDashboardsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The dashboards to be deleted. This parameter is required.</p>
        pub fn dashboard_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dashboard_names(inp);
            self
        }
        pub fn set_dashboard_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dashboard_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInsightRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_insight_rules_input::Builder,
    }
    impl<C> DeleteInsightRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInsightRulesOutput,
            smithy_http::result::SdkError<crate::error::DeleteInsightRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of the rule names to delete. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_names(inp);
            self
        }
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMetricStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_metric_stream_input::Builder,
    }
    impl<C> DeleteMetricStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMetricStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteMetricStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the metric stream to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAlarmHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_alarm_history_input::Builder,
    }
    impl<C> DescribeAlarmHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAlarmHistoryOutput,
            smithy_http::result::SdkError<crate::error::DescribeAlarmHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn alarm_types(mut self, inp: impl Into<crate::model::AlarmType>) -> Self {
            self.inner = self.inner.alarm_types(inp);
            self
        }
        pub fn set_alarm_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_types(input);
            self
        }
        /// <p>The type of alarm histories to retrieve.</p>
        pub fn history_item_type(mut self, input: crate::model::HistoryItemType) -> Self {
            self.inner = self.inner.history_item_type(input);
            self
        }
        pub fn set_history_item_type(
            mut self,
            input: std::option::Option<crate::model::HistoryItemType>,
        ) -> Self {
            self.inner = self.inner.set_history_item_type(input);
            self
        }
        /// <p>The starting date to retrieve alarm history.</p>
        pub fn start_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_date(input);
            self
        }
        pub fn set_start_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_date(input);
            self
        }
        /// <p>The ending date to retrieve alarm history.</p>
        pub fn end_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_date(input);
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_date(input);
            self
        }
        /// <p>The maximum number of alarm history records to retrieve.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Specified whether to return the newest or oldest alarm history first. Specify <code>TimestampDescending</code> to have the newest
        /// event history returned first, and specify <code>TimestampAscending</code> to have the oldest history returned first.</p>
        pub fn scan_by(mut self, input: crate::model::ScanBy) -> Self {
            self.inner = self.inner.scan_by(input);
            self
        }
        pub fn set_scan_by(mut self, input: std::option::Option<crate::model::ScanBy>) -> Self {
            self.inner = self.inner.set_scan_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAlarms<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_alarms_input::Builder,
    }
    impl<C> DescribeAlarms<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAlarmsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAlarmsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the alarms to retrieve information about.</p>
        pub fn alarm_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_names(inp);
            self
        }
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_names(input);
            self
        }
        /// <p>An alarm name prefix. If you specify this parameter, you receive information about all alarms that have names
        /// that start with this prefix.</p>
        /// <p>If this parameter
        /// is specified, you cannot specify <code>AlarmNames</code>.</p>
        pub fn alarm_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name_prefix(input);
            self
        }
        pub fn set_alarm_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_alarm_name_prefix(input);
            self
        }
        /// <p>Use this parameter to specify whether you want the operation to return metric alarms or composite alarms. If you omit this parameter,
        /// only metric alarms are returned.</p>
        pub fn alarm_types(mut self, inp: impl Into<crate::model::AlarmType>) -> Self {
            self.inner = self.inner.alarm_types(inp);
            self
        }
        pub fn set_alarm_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AlarmType>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_types(input);
            self
        }
        /// <p>If you use this parameter and specify the name of a composite alarm, the operation returns
        /// information about the "children" alarms
        /// of the alarm you specify. These are the metric alarms and composite alarms referenced in the
        /// <code>AlarmRule</code> field of the composite alarm that you specify in
        /// <code>ChildrenOfAlarmName</code>. Information about the composite alarm that you name in
        /// <code>ChildrenOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ChildrenOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you
        /// receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the <code>Alarm Name</code>, <code>ARN</code>, <code>StateValue</code> (OK/ALARM/INSUFFICIENT_DATA), and <code>StateUpdatedTimestamp</code>
        /// information are returned by this operation
        /// when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn children_of_alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.children_of_alarm_name(input);
            self
        }
        pub fn set_children_of_alarm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_children_of_alarm_name(input);
            self
        }
        /// <p>If you use this parameter and specify the name of a metric or composite alarm, the operation returns
        /// information about the "parent" alarms
        /// of the alarm you specify. These are the composite alarms that have <code>AlarmRule</code>
        /// parameters that reference
        /// the alarm named in <code>ParentsOfAlarmName</code>. Information about the alarm that you specify in
        /// <code>ParentsOfAlarmName</code> is not returned.</p>
        /// <p>If you specify <code>ParentsOfAlarmName</code>, you cannot specify any other parameters in the request except
        /// for <code>MaxRecords</code> and <code>NextToken</code>. If you do so, you receive a validation
        /// error.</p>
        /// <note>
        /// <p>Only the Alarm Name and ARN are returned by this operation when you use this parameter. To get complete information about
        /// these alarms, perform another <code>DescribeAlarms</code> operation and specify
        /// the parent alarm names in the <code>AlarmNames</code> parameter.</p>
        /// </note>
        pub fn parents_of_alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parents_of_alarm_name(input);
            self
        }
        pub fn set_parents_of_alarm_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parents_of_alarm_name(input);
            self
        }
        /// <p>Specify this parameter to receive information only about alarms that are currently in the state that you specify.</p>
        pub fn state_value(mut self, input: crate::model::StateValue) -> Self {
            self.inner = self.inner.state_value(input);
            self
        }
        pub fn set_state_value(
            mut self,
            input: std::option::Option<crate::model::StateValue>,
        ) -> Self {
            self.inner = self.inner.set_state_value(input);
            self
        }
        /// <p>Use this parameter to filter the results of the operation to only those alarms that
        /// use a certain alarm action. For example, you could specify the ARN of an SNS topic to find all
        /// alarms that send notifications to that topic.</p>
        pub fn action_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.action_prefix(input);
            self
        }
        pub fn set_action_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_action_prefix(input);
            self
        }
        /// <p>The maximum number of alarm descriptions to retrieve.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAlarmsForMetric<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_alarms_for_metric_input::Builder,
    }
    impl<C> DescribeAlarmsForMetric<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAlarmsForMetricOutput,
            smithy_http::result::SdkError<crate::error::DescribeAlarmsForMetricError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The statistic for the metric, other than percentiles.
        /// For percentile statistics, use <code>ExtendedStatistics</code>.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.inner = self.inner.statistic(input);
            self
        }
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.inner = self.inner.set_statistic(input);
            self
        }
        /// <p>The percentile statistic for the metric. Specify a value between
        /// p0.0 and p100.</p>
        pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.extended_statistic(input);
            self
        }
        pub fn set_extended_statistic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extended_statistic(input);
            self
        }
        /// <p>The dimensions associated with the metric. If the metric has any associated
        /// dimensions, you must specify them in order for the call to succeed.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The period, in seconds, over which the statistic is applied.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The unit for the metric.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAnomalyDetectors<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_anomaly_detectors_input::Builder,
    }
    impl<C> DescribeAnomalyDetectors<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAnomalyDetectorsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAnomalyDetectorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use the token returned by the previous operation to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in one operation. The maximum
        /// value that you can specify is 100.</p>
        /// <p>To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Limits the results to only the anomaly detection models that
        /// are associated with the specified namespace.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric name. If there are multiple metrics with this name in different
        /// namespaces that have anomaly detection models, they're all returned.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>Limits the results to only the anomaly detection models that are associated with the
        /// specified metric dimensions. If there are multiple metrics that have these dimensions
        /// and have anomaly detection models associated, they're all returned.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInsightRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_insight_rules_input::Builder,
    }
    impl<C> DescribeInsightRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInsightRulesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInsightRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Include this value, if it was returned by the previous operation, to get the next set of rules.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in one operation. If you omit this
        /// parameter, the default of 500 is used.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableAlarmActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_alarm_actions_input::Builder,
    }
    impl<C> DisableAlarmActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableAlarmActionsOutput,
            smithy_http::result::SdkError<crate::error::DisableAlarmActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the alarms.</p>
        pub fn alarm_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_names(inp);
            self
        }
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableInsightRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_insight_rules_input::Builder,
    }
    impl<C> DisableInsightRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableInsightRulesOutput,
            smithy_http::result::SdkError<crate::error::DisableInsightRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of the rule names to disable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_names(inp);
            self
        }
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableAlarmActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_alarm_actions_input::Builder,
    }
    impl<C> EnableAlarmActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableAlarmActionsOutput,
            smithy_http::result::SdkError<crate::error::EnableAlarmActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the alarms.</p>
        pub fn alarm_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_names(inp);
            self
        }
        pub fn set_alarm_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableInsightRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_insight_rules_input::Builder,
    }
    impl<C> EnableInsightRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableInsightRulesOutput,
            smithy_http::result::SdkError<crate::error::EnableInsightRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An array of the rule names to enable. If you need to find out the names of your rules, use <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeInsightRules.html">DescribeInsightRules</a>.</p>
        pub fn rule_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_names(inp);
            self
        }
        pub fn set_rule_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDashboard<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_dashboard_input::Builder,
    }
    impl<C> GetDashboard<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDashboardOutput,
            smithy_http::result::SdkError<crate::error::GetDashboardError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dashboard to be described.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dashboard_name(input);
            self
        }
        pub fn set_dashboard_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dashboard_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetInsightRuleReport<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_insight_rule_report_input::Builder,
    }
    impl<C> GetInsightRuleReport<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetInsightRuleReportOutput,
            smithy_http::result::SdkError<crate::error::GetInsightRuleReportError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the rule that you want to see data from.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
        /// <p>The start time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end time of the data to use in the report. When used in a raw HTTP Query API, it is formatted as
        /// <code>yyyy-MM-dd'T'HH:mm:ss</code>. For example,
        /// <code>2019-07-01T23:59:59</code>.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The period, in seconds, to use for the statistics in the <code>InsightRuleMetricDatapoint</code> results.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The maximum number of contributors to include in the report. The range is 1 to 100. If you omit this, the default of 10 is used.</p>
        pub fn max_contributor_count(mut self, input: i32) -> Self {
            self.inner = self.inner.max_contributor_count(input);
            self
        }
        pub fn set_max_contributor_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_contributor_count(input);
            self
        }
        /// <p>Specifies which metrics to use for aggregation of contributor values for the report. You can specify one or more
        /// of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>UniqueContributors</code> -- the number of unique contributors for each data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MaxContributorValue</code> -- the value of the top contributor for each data point. The identity of the
        /// contributor might change for each data point in the graph.</p>
        /// <p>If this rule aggregates by COUNT, the top contributor for each data point is the contributor with the
        /// most occurrences in that period. If the rule aggregates by SUM, the top contributor is the contributor with the highest sum in the log field specified
        /// by the rule's <code>Value</code>, during that period.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SampleCount</code> -- the number of data points matched by the rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sum</code> -- the sum of the values from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Minimum</code> -- the minimum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Maximum</code> -- the maximum value from a single observation during the time period represented by that data point.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Average</code> -- the average value from all contributors during the time period represented by that data point.</p>
        /// </li>
        /// </ul>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>Determines what statistic to use to rank the contributors. Valid values are SUM and MAXIMUM.</p>
        pub fn order_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.order_by(input);
            self
        }
        pub fn set_order_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_order_by(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_metric_data_input::Builder,
    }
    impl<C> GetMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMetricDataOutput,
            smithy_http::result::SdkError<crate::error::GetMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The metric queries to be returned. A single <code>GetMetricData</code> call can include as many as 500 <code>MetricDataQuery</code>
        /// structures. Each of these structures can specify either a metric to retrieve, or a math expression to perform on retrieved data. </p>
        pub fn metric_data_queries(
            mut self,
            inp: impl Into<crate::model::MetricDataQuery>,
        ) -> Self {
            self.inner = self.inner.metric_data_queries(inp);
            self
        }
        pub fn set_metric_data_queries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        ) -> Self {
            self.inner = self.inner.set_metric_data_queries(input);
            self
        }
        /// <p>The time stamp indicating the earliest data to be returned.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp. </p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>StartTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>StartTime</code>.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The time stamp indicating the latest data to be returned.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.</p>
        /// <p>For better performance, specify <code>StartTime</code> and <code>EndTime</code>
        /// values that align with the value of the metric's <code>Period</code> and sync up with
        /// the beginning and end of an hour. For example, if the <code>Period</code> of a metric
        /// is 5 minutes, specifying 12:05 or 12:30 as <code>EndTime</code> can get a faster response
        /// from CloudWatch than setting 12:07 or 12:29 as the <code>EndTime</code>.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>Include this value, if it was returned by the previous <code>GetMetricData</code> operation,
        /// to get the next set of data points.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The order in which data points should be returned. <code>TimestampDescending</code> returns the newest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached. <code>TimestampAscending</code> returns the oldest data first and paginates
        /// when the <code>MaxDatapoints</code> limit is reached.</p>
        pub fn scan_by(mut self, input: crate::model::ScanBy) -> Self {
            self.inner = self.inner.scan_by(input);
            self
        }
        pub fn set_scan_by(mut self, input: std::option::Option<crate::model::ScanBy>) -> Self {
            self.inner = self.inner.set_scan_by(input);
            self
        }
        /// <p>The maximum number of data points the request should return before paginating. If you omit
        /// this, the default of 100,800 is used.</p>
        pub fn max_datapoints(mut self, input: i32) -> Self {
            self.inner = self.inner.max_datapoints(input);
            self
        }
        pub fn set_max_datapoints(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_datapoints(input);
            self
        }
        /// <p>This structure includes the <code>Timezone</code> parameter, which you can use
        /// to specify your time zone so that the labels of returned data display the
        /// correct time
        /// for your time zone. </p>
        pub fn label_options(mut self, input: crate::model::LabelOptions) -> Self {
            self.inner = self.inner.label_options(input);
            self
        }
        pub fn set_label_options(
            mut self,
            input: std::option::Option<crate::model::LabelOptions>,
        ) -> Self {
            self.inner = self.inner.set_label_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMetricStatistics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_metric_statistics_input::Builder,
    }
    impl<C> GetMetricStatistics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMetricStatisticsOutput,
            smithy_http::result::SdkError<crate::error::GetMetricStatisticsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the metric, with or without spaces.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The name of the metric, with or without spaces.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The dimensions. If the metric contains multiple dimensions, you must include a value for each dimension. CloudWatch treats each unique combination of dimensions as a separate metric.
        /// If a specific combination of dimensions was not published, you can't retrieve statistics for it.
        /// You must specify the same dimensions that were used when the metrics were created. For an example,
        /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#dimension-combinations">Dimension Combinations</a> in the <i>Amazon CloudWatch User Guide</i>. For more information about specifying dimensions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publishing Metrics</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The time stamp that determines the first data point to return. Start times are
        /// evaluated relative to the time that CloudWatch receives the request.</p>
        /// <p>The value specified is inclusive; results include data points with the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-03T23:00:00Z).</p>
        /// <p>CloudWatch rounds the specified time stamp as follows:</p>
        /// <ul>
        /// <li>
        /// <p>Start time less than 15 days ago - Round down to the nearest whole minute.
        /// For example, 12:32:34 is rounded down to 12:32:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Round down to the nearest 5-minute clock interval.
        /// For example, 12:32:34 is rounded down to 12:30:00.</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Round down to the nearest 1-hour clock interval.
        /// For example, 12:32:34 is rounded down to 12:00:00.</p>
        /// </li>
        /// </ul>
        /// <p>If you set <code>Period</code> to 5, 10, or 30, the start time of your request is
        /// rounded down to the nearest time that corresponds to even 5-, 10-, or 30-second divisions
        /// of a minute. For example, if you make a query at (HH:mm:ss) 01:05:23 for the previous
        /// 10-second period, the start time of your request is rounded down and you receive data from 01:05:10 to
        /// 01:05:20. If you make a query at 15:07:17 for the previous 5 minutes of data, using a
        /// period of 5 seconds, you receive data
        /// timestamped between 15:02:15 and 15:07:15.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The time stamp that determines the last data point to return.</p>
        /// <p>The value specified is exclusive; results include data points up to the specified time stamp.
        /// In a raw HTTP query, the time stamp must be in ISO 8601 UTC format (for example, 2016-10-10T23:00:00Z).</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can
        /// be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected
        /// at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics
        /// are those metrics stored by a <code>PutMetricData</code> call that includes a <code>StorageResolution</code> of 1 second.</p>
        /// <p>If the <code>StartTime</code> parameter specifies a time stamp that is greater than
        /// 3 hours ago, you must specify the period as follows or no data points in that time range is returned:</p>
        /// <ul>
        /// <li>
        /// <p>Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).</p>
        /// </li>
        /// <li>
        /// <p>Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).</p>
        /// </li>
        /// <li>
        /// <p>Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).</p>
        /// </li>
        /// </ul>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The metric statistics, other than percentile. For percentile statistics,
        /// use <code>ExtendedStatistics</code>. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both.</p>
        pub fn statistics(mut self, inp: impl Into<crate::model::Statistic>) -> Self {
            self.inner = self.inner.statistics(inp);
            self
        }
        pub fn set_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Statistic>>,
        ) -> Self {
            self.inner = self.inner.set_statistics(input);
            self
        }
        /// <p>The percentile statistics. Specify values between p0.0 and p100. When calling <code>GetMetricStatistics</code>, you must
        /// specify either <code>Statistics</code> or <code>ExtendedStatistics</code>, but not both. Percentile statistics are not
        /// available for metrics when any of the metric values are negative numbers.</p>
        pub fn extended_statistics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.extended_statistics(inp);
            self
        }
        pub fn set_extended_statistics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_extended_statistics(input);
            self
        }
        /// <p>The unit for a given metric.
        /// If you omit <code>Unit</code>, all data that was collected with any unit is returned, along with the corresponding units that were specified
        /// when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified.
        /// If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMetricStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_metric_stream_input::Builder,
    }
    impl<C> GetMetricStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMetricStreamOutput,
            smithy_http::result::SdkError<crate::error::GetMetricStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the metric stream to retrieve information about.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMetricWidgetImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_metric_widget_image_input::Builder,
    }
    impl<C> GetMetricWidgetImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMetricWidgetImageOutput,
            smithy_http::result::SdkError<crate::error::GetMetricWidgetImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A JSON string that defines the bitmap graph to be retrieved. The string includes the
        /// metrics to include in the graph, statistics, annotations, title, axis limits, and so on.
        /// You can include only one <code>MetricWidget</code> parameter in each <code>GetMetricWidgetImage</code> call.</p>
        /// <p>For more information about the syntax of <code>MetricWidget</code> see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Metric-Widget-Structure.html">GetMetricWidgetImage: Metric Widget Structure and Syntax</a>.</p>
        /// <p>If any metric on the graph could not load all the requested data points, an orange triangle with an exclamation
        /// point appears next to the graph legend.</p>
        pub fn metric_widget(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_widget(input);
            self
        }
        pub fn set_metric_widget(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_metric_widget(input);
            self
        }
        /// <p>The format of the resulting image. Only PNG images are supported.</p>
        /// <p>The default is <code>png</code>. If you specify <code>png</code>, the API returns an HTTP response with the
        /// content-type set to <code>text/xml</code>. The image data is in a <code>MetricWidgetImage</code>
        /// field. For example:</p>
        /// <p>
        /// <code>
        /// <GetMetricWidgetImageResponse xmlns=<URLstring>></code>
        /// </p>
        /// <p>
        /// <code>  <GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>    <MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>       iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQEAYAAAAip...</code>
        /// </p>
        /// <p>
        /// <code>    </MetricWidgetImage></code>
        /// </p>
        /// <p>
        /// <code>  </GetMetricWidgetImageResult></code>
        /// </p>
        /// <p>
        /// <code>  <ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code>    <RequestId>6f0d4192-4d42-11e8-82c1-f539a07e0e3b</RequestId></code>
        /// </p>
        /// <p>
        /// <code>  </ResponseMetadata></code>
        /// </p>
        /// <p>
        /// <code></GetMetricWidgetImageResponse></code>
        /// </p>
        /// <p>The <code>image/png</code> setting is intended only for custom HTTP requests. For most
        /// use cases, and all actions using an AWS SDK, you should use <code>png</code>. If you specify
        /// <code>image/png</code>, the HTTP response has a content-type set to <code>image/png</code>,
        /// and the body of the response is a PNG image. </p>
        pub fn output_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.output_format(input);
            self
        }
        pub fn set_output_format(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_output_format(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDashboards<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_dashboards_input::Builder,
    }
    impl<C> ListDashboards<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDashboardsOutput,
            smithy_http::result::SdkError<crate::error::ListDashboardsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If you specify this parameter, only
        /// the dashboards with names starting with the specified string are listed. The maximum length is 255, and
        /// valid characters are A-Z, a-z, 0-9, ".", "-", and "_".
        /// </p>
        pub fn dashboard_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dashboard_name_prefix(input);
            self
        }
        pub fn set_dashboard_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dashboard_name_prefix(input);
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMetrics<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_metrics_input::Builder,
    }
    impl<C> ListMetrics<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMetricsOutput,
            smithy_http::result::SdkError<crate::error::ListMetricsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The metric namespace to filter against. Only the namespace that matches exactly
        /// will be returned.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The name of the metric to filter against.  Only the metrics with names that match exactly
        /// will be returned.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The dimensions to filter against.  Only the dimensions that match exactly
        /// will be returned.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::DimensionFilter>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DimensionFilter>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The token returned by a previous call to indicate that there is more data
        /// available.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>To filter the results to show only metrics that have had data points published
        /// in the past three hours, specify this parameter
        /// with a value of <code>PT3H</code>. This is the only valid value
        /// for this parameter.</p>
        /// <p>The results that are returned are an approximation of the value you specify. There
        /// is a low probability that the returned results include metrics with last published
        /// data as much as 40 minutes more than the specified time interval.</p>
        pub fn recently_active(mut self, input: crate::model::RecentlyActive) -> Self {
            self.inner = self.inner.recently_active(input);
            self
        }
        pub fn set_recently_active(
            mut self,
            input: std::option::Option<crate::model::RecentlyActive>,
        ) -> Self {
            self.inner = self.inner.set_recently_active(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListMetricStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_metric_streams_input::Builder,
    }
    impl<C> ListMetricStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListMetricStreamsOutput,
            smithy_http::result::SdkError<crate::error::ListMetricStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Include this value, if it was returned by the previous call, to get the next set of metric streams.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in one operation.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the CloudWatch resource that you want to view tags for.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAnomalyDetector<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_anomaly_detector_input::Builder,
    }
    impl<C> PutAnomalyDetector<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAnomalyDetectorOutput,
            smithy_http::result::SdkError<crate::error::PutAnomalyDetectorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace of the metric to create the anomaly detection model for.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The name of the metric to create the anomaly detection model for.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The metric dimensions to create the anomaly detection model for.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The statistic to use for the metric and the anomaly detection model.</p>
        pub fn stat(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stat(input);
            self
        }
        pub fn set_stat(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stat(input);
            self
        }
        /// <p>The configuration specifies details about how the
        /// anomaly detection model is to be trained, including
        /// time ranges to exclude when training and updating the model.
        /// You can specify as many as 10 time ranges.</p>
        /// <p>The configuration can also include the time zone to use for
        /// the metric.</p>
        pub fn configuration(mut self, input: crate::model::AnomalyDetectorConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::AnomalyDetectorConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutCompositeAlarm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_composite_alarm_input::Builder,
    }
    impl<C> PutCompositeAlarm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutCompositeAlarmOutput,
            smithy_http::result::SdkError<crate::error::PutCompositeAlarmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state of the composite alarm. The default is
        /// <code>TRUE</code>.</p>
        pub fn actions_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.actions_enabled(input);
            self
        }
        pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_actions_enabled(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// </p>
        pub fn alarm_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_actions(inp);
            self
        }
        pub fn set_alarm_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_actions(input);
            self
        }
        /// <p>The description for the composite alarm.</p>
        pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_description(input);
            self
        }
        pub fn set_alarm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_alarm_description(input);
            self
        }
        /// <p>The name for the composite alarm. This name must be unique within the Region.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>An expression that specifies which other alarms are to be evaluated to determine this
        /// composite alarm's state. For each alarm that you reference, you
        /// designate a function that
        /// specifies whether that alarm needs to be in ALARM state, OK state, or INSUFFICIENT_DATA state. You
        /// can use operators (AND, OR and NOT) to combine multiple functions in a single expression. You can use parenthesis to logically group the
        /// functions in your expression.</p>
        /// <p>You can use either alarm names or ARNs to reference the other alarms that are to be evaluated.</p>
        /// <p>Functions can include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OK("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in OK state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INSUFFICIENT_DATA("<i>alarm-name</i> or <i>alarm-ARN</i>")</code> is TRUE if the named
        /// alarm is in INSUFFICIENT_DATA state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>TRUE</code> always evaluates to TRUE.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FALSE</code> always evaluates to FALSE.</p>
        /// </li>
        /// </ul>
        /// <p>TRUE and FALSE are useful for testing a complex <code>AlarmRule</code> structure, and
        /// for testing your alarm actions.</p>
        /// <p>Alarm names specified in <code>AlarmRule</code> can be surrounded with double-quotes ("), but do not have to be.</p>
        /// <p>The following
        /// are some examples of <code>AlarmRule</code>:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND ALARM(DiskReadOpsTooHigh)</code> specifies that the composite alarm goes into ALARM state only
        /// if both CPUUtilizationTooHigh and DiskReadOpsTooHigh alarms are in ALARM state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALARM(CPUUtilizationTooHigh) AND NOT ALARM(DeploymentInProgress)</code>
        /// specifies that the alarm goes to ALARM state if CPUUtilizationTooHigh is in ALARM state
        /// and DeploymentInProgress is not in ALARM state. This example reduces
        /// alarm noise during a known deployment window.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>(ALARM(CPUUtilizationTooHigh) OR ALARM(DiskReadOpsTooHigh)) AND OK(NetworkOutTooHigh)</code> goes into ALARM
        /// state if CPUUtilizationTooHigh OR DiskReadOpsTooHigh is in ALARM state, and if NetworkOutTooHigh is in OK state.
        /// This provides another example of using a composite alarm to prevent noise. This rule ensures that you are not notified with an
        /// alarm action on high CPU or disk usage if a known network problem is also occurring.</p>
        /// </li>
        /// </ul>
        /// <p>The <code>AlarmRule</code> can specify as many as 100
        /// "children" alarms. The <code>AlarmRule</code> expression can have as many as 500 elements. Elements
        /// are child alarms, TRUE or FALSE statements, and
        /// parentheses.</p>
        pub fn alarm_rule(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_rule(input);
            self
        }
        pub fn set_alarm_rule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_rule(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn insufficient_data_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.insufficient_data_actions(inp);
            self
        }
        pub fn set_insufficient_data_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_insufficient_data_actions(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code>
        /// </p>
        pub fn ok_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ok_actions(inp);
            self
        }
        pub fn set_ok_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ok_actions(input);
            self
        }
        /// <p>A list of key-value pairs to associate with the composite alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by granting a user permission to access or change only resources with
        /// certain tag values.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDashboard<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_dashboard_input::Builder,
    }
    impl<C> PutDashboard<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDashboardOutput,
            smithy_http::result::SdkError<crate::error::PutDashboardError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the dashboard. If a dashboard with this name already exists, this call modifies that dashboard, replacing
        /// its current contents. Otherwise, a new dashboard is created. The maximum length is 255, and valid characters are
        /// A-Z, a-z, 0-9, "-", and "_".  This parameter is required.</p>
        pub fn dashboard_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dashboard_name(input);
            self
        }
        pub fn set_dashboard_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dashboard_name(input);
            self
        }
        /// <p>The detailed information about the dashboard in JSON format, including the widgets to include and their location
        /// on the dashboard.  This parameter is required.</p>
        /// <p>For more information about the syntax,
        /// see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/CloudWatch-Dashboard-Body-Structure.html">Dashboard Body Structure and Syntax</a>.</p>
        pub fn dashboard_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dashboard_body(input);
            self
        }
        pub fn set_dashboard_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dashboard_body(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutInsightRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_insight_rule_input::Builder,
    }
    impl<C> PutInsightRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutInsightRuleOutput,
            smithy_http::result::SdkError<crate::error::PutInsightRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique name for the rule.</p>
        pub fn rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_name(input);
            self
        }
        pub fn set_rule_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_name(input);
            self
        }
        /// <p>The state of the rule. Valid values are ENABLED and DISABLED.</p>
        pub fn rule_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_state(input);
            self
        }
        pub fn set_rule_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_state(input);
            self
        }
        /// <p>The definition of the rule, as a JSON object. For details on the valid syntax, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContributorInsights-RuleSyntax.html">Contributor Insights
        /// Rule Syntax</a>.</p>
        pub fn rule_definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_definition(input);
            self
        }
        pub fn set_rule_definition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rule_definition(input);
            self
        }
        /// <p>A list of key-value pairs to associate with the Contributor Insights rule.
        /// You can associate as many as 50 tags with a rule.</p>
        /// <p>Tags can help you organize and categorize your
        /// resources. You can also use them to scope user permissions, by
        /// granting a user permission to access or change only the resources that have
        /// certain tag values.</p>
        /// <p>To be able to associate tags with a rule, you must have the <code>cloudwatch:TagResource</code>
        /// permission in addition to the <code>cloudwatch:PutInsightRule</code> permission.</p>
        /// <p>If you are using this operation to update an existing Contributor Insights rule, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing rule, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutMetricAlarm<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_metric_alarm_input::Builder,
    }
    impl<C> PutMetricAlarm<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutMetricAlarmOutput,
            smithy_http::result::SdkError<crate::error::PutMetricAlarmError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the alarm. This name must be unique within the Region.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>The description for the alarm.</p>
        pub fn alarm_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_description(input);
            self
        }
        pub fn set_alarm_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_alarm_description(input);
            self
        }
        /// <p>Indicates whether actions should be executed during any changes to the alarm state. The default is
        /// <code>TRUE</code>.</p>
        pub fn actions_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.actions_enabled(input);
            self
        }
        pub fn set_actions_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_actions_enabled(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to an <code>OK</code> state
        /// from any other state. Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Recover/1.0</code>
        /// </p>
        pub fn ok_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ok_actions(inp);
            self
        }
        pub fn set_ok_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ok_actions(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>ALARM</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// | <code>arn:aws:ssm:<i>region</i>:<i>account-id</i>:opsitem:<i>severity</i>
        /// </code>
        /// </p>
        /// <p>Valid Values (for use with IAM roles):
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code>
        /// </p>
        pub fn alarm_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_actions(inp);
            self
        }
        pub fn set_alarm_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alarm_actions(input);
            self
        }
        /// <p>The actions to execute when this alarm transitions to the <code>INSUFFICIENT_DATA</code> state from any other state.
        /// Each action is specified as an Amazon Resource Name (ARN).</p>
        /// <p>Valid Values: <code>arn:aws:automate:<i>region</i>:ec2:stop</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:terminate</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:recover</code> |
        /// <code>arn:aws:automate:<i>region</i>:ec2:reboot</code> |
        /// <code>arn:aws:sns:<i>region</i>:<i>account-id</i>:<i>sns-topic-name</i>
        /// </code> |
        /// <code>arn:aws:autoscaling:<i>region</i>:<i>account-id</i>:scalingPolicy:<i>policy-id</i>:autoScalingGroupName/<i>group-friendly-name</i>:policyName/<i>policy-friendly-name</i>
        /// </code>
        /// </p>
        /// <p>Valid Values (for use with IAM roles):
        /// <code>>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Stop/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Terminate/1.0</code> |
        /// <code>arn:aws:swf:<i>region</i>:<i>account-id</i>:action/actions/AWS_EC2.InstanceId.Reboot/1.0</code>
        /// </p>
        pub fn insufficient_data_actions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.insufficient_data_actions(inp);
            self
        }
        pub fn set_insufficient_data_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_insufficient_data_actions(input);
            self
        }
        /// <p>The name for the metric associated with the alarm. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>If you are creating an alarm based on a math expression, you cannot specify this parameter, or any of the
        /// <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters. Instead, you specify
        /// all this information in the <code>Metrics</code> array.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>The namespace for the metric associated specified in <code>MetricName</code>.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The statistic for the metric specified in <code>MetricName</code>, other than percentile.
        /// For percentile statistics, use <code>ExtendedStatistic</code>. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn statistic(mut self, input: crate::model::Statistic) -> Self {
            self.inner = self.inner.statistic(input);
            self
        }
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::Statistic>,
        ) -> Self {
            self.inner = self.inner.set_statistic(input);
            self
        }
        /// <p>The percentile statistic for the metric specified in <code>MetricName</code>. Specify a value
        /// between p0.0 and p100. When you call <code>PutMetricAlarm</code> and specify
        /// a <code>MetricName</code>, you must
        /// specify either <code>Statistic</code> or <code>ExtendedStatistic,</code> but not both.</p>
        pub fn extended_statistic(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.extended_statistic(input);
            self
        }
        pub fn set_extended_statistic(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_extended_statistic(input);
            self
        }
        /// <p>The dimensions for the metric specified in <code>MetricName</code>.</p>
        pub fn dimensions(mut self, inp: impl Into<crate::model::Dimension>) -> Self {
            self.inner = self.inner.dimensions(inp);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Dimension>>,
        ) -> Self {
            self.inner = self.inner.set_dimensions(input);
            self
        }
        /// <p>The length, in seconds, used each time the metric specified in <code>MetricName</code> is
        /// evaluated. Valid values are 10, 30, and any multiple of 60.</p>
        /// <p>
        /// <code>Period</code> is required for alarms based on static thresholds. If
        /// you are creating an alarm based on a metric math expression, you specify the
        /// period for each metric within the objects in the <code>Metrics</code> array.</p>
        /// <p>Be sure to specify 10 or 30 only for metrics that are stored by a <code>PutMetricData</code> call with a
        /// <code>StorageResolution</code> of 1. If you specify a period of 10 or 30 for a metric that does not have
        /// sub-minute resolution, the alarm still attempts to gather data at the period rate that you specify. In this case,
        /// it does not receive data for the attempts that do not correspond to a one-minute data resolution, and the alarm
        /// might often lapse into INSUFFICENT_DATA status. Specifying 10 or 30 also sets this alarm as a high-resolution alarm,
        /// which has a higher charge than other alarms. For more information about pricing, see <a href="https://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so <code>Period</code> multiplied by <code>EvaluationPeriods</code> cannot be more than 86,400 seconds.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.inner = self.inner.period(input);
            self
        }
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_period(input);
            self
        }
        /// <p>The unit of measure for the statistic. For example, the units for the Amazon EC2
        /// NetworkIn metric are Bytes because NetworkIn tracks the number of bytes that an instance
        /// receives on all network interfaces. You can also specify a unit when you create a custom
        /// metric. Units help provide conceptual meaning to your data. Metric data points that
        /// specify a unit of measure, such as Percent, are aggregated separately.</p>
        /// <p>If you don't specify <code>Unit</code>, CloudWatch retrieves all unit types that have been published for the
        /// metric and attempts to evaluate the alarm.
        /// Usually, metrics are
        /// published with only one unit, so the alarm
        /// works as intended.</p>
        /// <p>However, if the metric is published with multiple types of units and you don't specify a unit, the alarm's
        /// behavior is not defined and
        /// it behaves predictably.</p>
        /// <p>We recommend omitting <code>Unit</code> so that you don't inadvertently
        /// specify an incorrect unit that is not published for this metric. Doing so
        /// causes the alarm to be stuck in the <code>INSUFFICIENT DATA</code> state.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.inner = self.inner.unit(input);
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.inner = self.inner.set_unit(input);
            self
        }
        /// <p>The number of periods over which data is compared to the specified threshold. If you are
        /// setting an alarm that requires that a number of consecutive data points be breaching to
        /// trigger the alarm, this value specifies that number. If you are setting an "M out of N"
        /// alarm, this value is the N.</p>
        /// <p>An alarm's total current evaluation period can
        /// be no longer than one day, so this number multiplied by <code>Period</code> cannot be more than 86,400 seconds.</p>
        pub fn evaluation_periods(mut self, input: i32) -> Self {
            self.inner = self.inner.evaluation_periods(input);
            self
        }
        pub fn set_evaluation_periods(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_evaluation_periods(input);
            self
        }
        /// <p>The number of data points that must be breaching to trigger the alarm. This is used only if you are setting
        /// an "M out of N" alarm. In that case, this value is the M. For more information, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation">Evaluating an Alarm</a> in the
        /// <i>Amazon CloudWatch User Guide</i>.</p>
        pub fn datapoints_to_alarm(mut self, input: i32) -> Self {
            self.inner = self.inner.datapoints_to_alarm(input);
            self
        }
        pub fn set_datapoints_to_alarm(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_datapoints_to_alarm(input);
            self
        }
        /// <p>The value against which the specified statistic is compared.</p>
        /// <p>This parameter is required for alarms based on static thresholds, but should
        /// not be used for alarms based on anomaly detection models.</p>
        pub fn threshold(mut self, input: f64) -> Self {
            self.inner = self.inner.threshold(input);
            self
        }
        pub fn set_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_threshold(input);
            self
        }
        /// <p> The arithmetic operation to use when comparing the specified statistic and
        /// threshold. The specified statistic value is used as the first operand.</p>
        /// <p>The values <code>LessThanLowerOrGreaterThanUpperThreshold</code>,
        /// <code>LessThanLowerThreshold</code>, and <code>GreaterThanUpperThreshold</code>
        /// are used only for alarms based on anomaly detection models.</p>
        pub fn comparison_operator(mut self, input: crate::model::ComparisonOperator) -> Self {
            self.inner = self.inner.comparison_operator(input);
            self
        }
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.inner = self.inner.set_comparison_operator(input);
            self
        }
        /// <p> Sets how this alarm is to handle missing data points. If <code>TreatMissingData</code> is omitted, the default behavior of <code>missing</code> is used.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data">Configuring How CloudWatch
        /// Alarms Treats Missing Data</a>.</p>
        /// <p>Valid Values: <code>breaching | notBreaching | ignore | missing</code>
        /// </p>
        pub fn treat_missing_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.treat_missing_data(input);
            self
        }
        pub fn set_treat_missing_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_treat_missing_data(input);
            self
        }
        /// <p> Used only for alarms based on percentiles. If you specify <code>ignore</code>, the alarm state does not change during periods with too few data points to be
        /// statistically significant. If you specify <code>evaluate</code> or omit this parameter, the alarm is always evaluated and possibly changes state
        /// no matter how many data points are available. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#percentiles-with-low-samples">Percentile-Based CloudWatch Alarms and Low Data Samples</a>.</p>
        /// <p>Valid Values: <code>evaluate | ignore</code>
        /// </p>
        pub fn evaluate_low_sample_count_percentile(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.evaluate_low_sample_count_percentile(input);
            self
        }
        pub fn set_evaluate_low_sample_count_percentile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_evaluate_low_sample_count_percentile(input);
            self
        }
        /// <p>An array of <code>MetricDataQuery</code> structures that enable you to create an alarm based on the result of a
        /// metric math expression. For each <code>PutMetricAlarm</code>
        /// operation, you must specify either <code>MetricName</code> or a <code>Metrics</code> array.</p>
        /// <p>Each item in the <code>Metrics</code> array either retrieves a metric or performs a math expression.</p>
        /// <p>One item in the <code>Metrics</code> array is the expression that the alarm watches. You designate this expression
        /// by setting <code>ReturnData</code> to true for this object in the array. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDataQuery.html">MetricDataQuery</a>.</p>
        /// <p>If you use the <code>Metrics</code> parameter, you cannot include the <code>MetricName</code>, <code>Dimensions</code>, <code>Period</code>,
        /// <code>Namespace</code>, <code>Statistic</code>, or <code>ExtendedStatistic</code> parameters of <code>PutMetricAlarm</code> in the same operation.
        /// Instead, you retrieve
        /// the metrics you are using in your math expression as part of the <code>Metrics</code> array.</p>
        pub fn metrics(mut self, inp: impl Into<crate::model::MetricDataQuery>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDataQuery>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>A list of key-value pairs to associate with the alarm. You can associate as many as 50 tags with an alarm.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        /// <p>If you are using this operation to update an existing alarm, any tags
        /// you specify in this parameter are ignored. To change the tags of an existing alarm, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_TagResource.html">TagResource</a>
        /// or <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_UntagResource.html">UntagResource</a>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>If this is an alarm based on an anomaly detection model, make this value match
        /// the ID of
        /// the <code>ANOMALY_DETECTION_BAND</code> function.</p>
        /// <p>For an example of how to use this parameter, see the
        /// <b>Anomaly Detection
        /// Model Alarm</b> example on this page.</p>
        /// <p>If your alarm uses this parameter, it cannot have Auto Scaling actions.</p>
        pub fn threshold_metric_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.threshold_metric_id(input);
            self
        }
        pub fn set_threshold_metric_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_threshold_metric_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutMetricData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_metric_data_input::Builder,
    }
    impl<C> PutMetricData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutMetricDataOutput,
            smithy_http::result::SdkError<crate::error::PutMetricDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The namespace for the metric data.</p>
        /// <p>To avoid conflicts
        /// with AWS service namespaces, you should not specify a namespace that begins with <code>AWS/</code>
        /// </p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.namespace(input);
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_namespace(input);
            self
        }
        /// <p>The data for the metric. The array can include no more than 20 metrics per call.</p>
        pub fn metric_data(mut self, inp: impl Into<crate::model::MetricDatum>) -> Self {
            self.inner = self.inner.metric_data(inp);
            self
        }
        pub fn set_metric_data(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDatum>>,
        ) -> Self {
            self.inner = self.inner.set_metric_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutMetricStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_metric_stream_input::Builder,
    }
    impl<C> PutMetricStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutMetricStreamOutput,
            smithy_http::result::SdkError<crate::error::PutMetricStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>If you are creating a new metric stream, this is the name for the new stream. The name
        /// must be different than the names of other metric streams in this account and Region.</p>
        /// <p>If you are updating a metric stream, specify the name of that stream here.</p>
        /// <p>Valid characters are A-Z, a-z, 0-9, "-" and "_".</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>If you specify this parameter, the stream sends only the
        /// metrics from the metric namespaces that you specify here.</p>
        /// <p>You cannot include <code>IncludeFilters</code> and <code>ExcludeFilters</code>
        /// in the same operation.</p>
        pub fn include_filters(mut self, inp: impl Into<crate::model::MetricStreamFilter>) -> Self {
            self.inner = self.inner.include_filters(inp);
            self
        }
        pub fn set_include_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        ) -> Self {
            self.inner = self.inner.set_include_filters(input);
            self
        }
        /// <p>If you specify this parameter, the stream sends metrics from all
        /// metric namespaces except for the namespaces that you specify here.</p>
        /// <p>You cannot include <code>ExcludeFilters</code> and <code>IncludeFilters</code> in
        /// the same operation.</p>
        pub fn exclude_filters(mut self, inp: impl Into<crate::model::MetricStreamFilter>) -> Self {
            self.inner = self.inner.exclude_filters(inp);
            self
        }
        pub fn set_exclude_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricStreamFilter>>,
        ) -> Self {
            self.inner = self.inner.set_exclude_filters(input);
            self
        }
        /// <p>The ARN of the Amazon Kinesis Firehose delivery stream to use for this metric stream.
        /// This Amazon Kinesis Firehose delivery stream must already exist and must be in the same
        /// account as the metric stream.</p>
        pub fn firehose_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.firehose_arn(input);
            self
        }
        pub fn set_firehose_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_firehose_arn(input);
            self
        }
        /// <p>The ARN of an IAM role that this metric stream will use to access
        /// Amazon Kinesis Firehose resources. This IAM role must already
        /// exist and must be in the same account as the metric stream. This IAM role must include the following permissions:</p>
        /// <ul>
        /// <li>
        /// <p>firehose:PutRecord</p>
        /// </li>
        /// <li>
        /// <p>firehose:PutRecordBatch</p>
        /// </li>
        /// </ul>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The output format for the stream. Valid values are <code>json</code>
        /// and <code>opentelemetry0.7</code>. For more information about metric stream
        /// output formats, see
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-metric-streams-formats.html">
        /// Metric streams output formats</a>.</p>
        pub fn output_format(mut self, input: crate::model::MetricStreamOutputFormat) -> Self {
            self.inner = self.inner.output_format(input);
            self
        }
        pub fn set_output_format(
            mut self,
            input: std::option::Option<crate::model::MetricStreamOutputFormat>,
        ) -> Self {
            self.inner = self.inner.set_output_format(input);
            self
        }
        /// <p>A list of key-value pairs to associate with the metric stream. You can associate as
        /// many as 50 tags with a metric stream.</p>
        /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user
        /// permissions by granting a user
        /// permission to access or change only resources with certain tag values.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetAlarmState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_alarm_state_input::Builder,
    }
    impl<C> SetAlarmState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetAlarmStateOutput,
            smithy_http::result::SdkError<crate::error::SetAlarmStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alarm_name(input);
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_alarm_name(input);
            self
        }
        /// <p>The value of the state.</p>
        pub fn state_value(mut self, input: crate::model::StateValue) -> Self {
            self.inner = self.inner.state_value(input);
            self
        }
        pub fn set_state_value(
            mut self,
            input: std::option::Option<crate::model::StateValue>,
        ) -> Self {
            self.inner = self.inner.set_state_value(input);
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in text format.</p>
        pub fn state_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.state_reason(input);
            self
        }
        pub fn set_state_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_state_reason(input);
            self
        }
        /// <p>The reason that this alarm is set to this specific state, in JSON format.</p>
        /// <p>For SNS or EC2 alarm actions, this is just informational. But for EC2 Auto Scaling or application Auto Scaling
        /// alarm actions, the Auto Scaling policy uses the information in this field to take the correct action.</p>
        pub fn state_reason_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.state_reason_data(input);
            self
        }
        pub fn set_state_reason_data(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_state_reason_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartMetricStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_metric_streams_input::Builder,
    }
    impl<C> StartMetricStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartMetricStreamsOutput,
            smithy_http::result::SdkError<crate::error::StartMetricStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The array of the names of metric streams to start streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will start streaming.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopMetricStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_metric_streams_input::Builder,
    }
    impl<C> StopMetricStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopMetricStreamsOutput,
            smithy_http::result::SdkError<crate::error::StopMetricStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The array of the names of metric streams to stop streaming.</p>
        /// <p>This is an "all or nothing" operation. If you do not have
        /// permission to access all of the metric streams that you list here, then none of the streams that you list
        /// in the operation will stop streaming.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the CloudWatch resource that you're adding tags to.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of key-value pairs to associate with the alarm.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the CloudWatch resource that you're removing tags from.</p>
        /// <p>The ARN format of an alarm is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:alarm:<i>alarm-name</i>
        /// </code>
        /// </p>
        /// <p>The ARN format of a Contributor Insights rule is
        /// <code>arn:aws:cloudwatch:<i>Region</i>:<i>account-id</i>:insight-rule:<i>insight-rule-name</i>
        /// </code>
        /// </p>
        /// <p>For more information about ARN format, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies"> Resource
        /// Types Defined by Amazon CloudWatch</a> in the <i>Amazon Web Services General
        /// Reference</i>.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The list of tag keys to remove from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
}
