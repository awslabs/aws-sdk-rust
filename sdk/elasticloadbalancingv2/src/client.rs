// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_listener_certificates(&self) -> fluent_builders::AddListenerCertificates<C> {
        fluent_builders::AddListenerCertificates::new(self.handle.clone())
    }
    pub fn add_tags(&self) -> fluent_builders::AddTags<C> {
        fluent_builders::AddTags::new(self.handle.clone())
    }
    pub fn create_listener(&self) -> fluent_builders::CreateListener<C> {
        fluent_builders::CreateListener::new(self.handle.clone())
    }
    pub fn create_load_balancer(&self) -> fluent_builders::CreateLoadBalancer<C> {
        fluent_builders::CreateLoadBalancer::new(self.handle.clone())
    }
    pub fn create_rule(&self) -> fluent_builders::CreateRule<C> {
        fluent_builders::CreateRule::new(self.handle.clone())
    }
    pub fn create_target_group(&self) -> fluent_builders::CreateTargetGroup<C> {
        fluent_builders::CreateTargetGroup::new(self.handle.clone())
    }
    pub fn delete_listener(&self) -> fluent_builders::DeleteListener<C> {
        fluent_builders::DeleteListener::new(self.handle.clone())
    }
    pub fn delete_load_balancer(&self) -> fluent_builders::DeleteLoadBalancer<C> {
        fluent_builders::DeleteLoadBalancer::new(self.handle.clone())
    }
    pub fn delete_rule(&self) -> fluent_builders::DeleteRule<C> {
        fluent_builders::DeleteRule::new(self.handle.clone())
    }
    pub fn delete_target_group(&self) -> fluent_builders::DeleteTargetGroup<C> {
        fluent_builders::DeleteTargetGroup::new(self.handle.clone())
    }
    pub fn deregister_targets(&self) -> fluent_builders::DeregisterTargets<C> {
        fluent_builders::DeregisterTargets::new(self.handle.clone())
    }
    pub fn describe_account_limits(&self) -> fluent_builders::DescribeAccountLimits<C> {
        fluent_builders::DescribeAccountLimits::new(self.handle.clone())
    }
    pub fn describe_listener_certificates(
        &self,
    ) -> fluent_builders::DescribeListenerCertificates<C> {
        fluent_builders::DescribeListenerCertificates::new(self.handle.clone())
    }
    pub fn describe_listeners(&self) -> fluent_builders::DescribeListeners<C> {
        fluent_builders::DescribeListeners::new(self.handle.clone())
    }
    pub fn describe_load_balancer_attributes(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerAttributes<C> {
        fluent_builders::DescribeLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn describe_load_balancers(&self) -> fluent_builders::DescribeLoadBalancers<C> {
        fluent_builders::DescribeLoadBalancers::new(self.handle.clone())
    }
    pub fn describe_rules(&self) -> fluent_builders::DescribeRules<C> {
        fluent_builders::DescribeRules::new(self.handle.clone())
    }
    pub fn describe_ssl_policies(&self) -> fluent_builders::DescribeSSLPolicies<C> {
        fluent_builders::DescribeSSLPolicies::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn describe_target_group_attributes(
        &self,
    ) -> fluent_builders::DescribeTargetGroupAttributes<C> {
        fluent_builders::DescribeTargetGroupAttributes::new(self.handle.clone())
    }
    pub fn describe_target_groups(&self) -> fluent_builders::DescribeTargetGroups<C> {
        fluent_builders::DescribeTargetGroups::new(self.handle.clone())
    }
    pub fn describe_target_health(&self) -> fluent_builders::DescribeTargetHealth<C> {
        fluent_builders::DescribeTargetHealth::new(self.handle.clone())
    }
    pub fn modify_listener(&self) -> fluent_builders::ModifyListener<C> {
        fluent_builders::ModifyListener::new(self.handle.clone())
    }
    pub fn modify_load_balancer_attributes(
        &self,
    ) -> fluent_builders::ModifyLoadBalancerAttributes<C> {
        fluent_builders::ModifyLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn modify_rule(&self) -> fluent_builders::ModifyRule<C> {
        fluent_builders::ModifyRule::new(self.handle.clone())
    }
    pub fn modify_target_group(&self) -> fluent_builders::ModifyTargetGroup<C> {
        fluent_builders::ModifyTargetGroup::new(self.handle.clone())
    }
    pub fn modify_target_group_attributes(
        &self,
    ) -> fluent_builders::ModifyTargetGroupAttributes<C> {
        fluent_builders::ModifyTargetGroupAttributes::new(self.handle.clone())
    }
    pub fn register_targets(&self) -> fluent_builders::RegisterTargets<C> {
        fluent_builders::RegisterTargets::new(self.handle.clone())
    }
    pub fn remove_listener_certificates(&self) -> fluent_builders::RemoveListenerCertificates<C> {
        fluent_builders::RemoveListenerCertificates::new(self.handle.clone())
    }
    pub fn remove_tags(&self) -> fluent_builders::RemoveTags<C> {
        fluent_builders::RemoveTags::new(self.handle.clone())
    }
    pub fn set_ip_address_type(&self) -> fluent_builders::SetIpAddressType<C> {
        fluent_builders::SetIpAddressType::new(self.handle.clone())
    }
    pub fn set_rule_priorities(&self) -> fluent_builders::SetRulePriorities<C> {
        fluent_builders::SetRulePriorities::new(self.handle.clone())
    }
    pub fn set_security_groups(&self) -> fluent_builders::SetSecurityGroups<C> {
        fluent_builders::SetSecurityGroups::new(self.handle.clone())
    }
    pub fn set_subnets(&self) -> fluent_builders::SetSubnets<C> {
        fluent_builders::SetSubnets::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddListenerCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_listener_certificates_input::Builder,
    }
    impl<C> AddListenerCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::AddListenerCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The certificate to add. You can specify one certificate per call. Set
        /// <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_input::Builder,
    }
    impl<C> AddTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsOutput,
            smithy_http::result::SdkError<crate::error::AddTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
        /// <p>The tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateListener<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_listener_input::Builder,
    }
    impl<C> CreateListener<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateListenerOutput,
            smithy_http::result::SdkError<crate::error::CreateListenerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The protocol for connections from clients to the load balancer. For Application Load
        /// Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the
        /// supported protocols are TCP, TLS, UDP, and TCP_UDP. You canâ€™t specify the UDP or TCP_UDP
        /// protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load
        /// Balancer.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The port on which the load balancer is listening. You cannot specify a port for a Gateway
        /// Load Balancer.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.inner = self.inner.port(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
        /// supported.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> and
        /// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn ssl_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssl_policy(input);
            self
        }
        pub fn set_ssl_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssl_policy(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
        /// exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
        /// <p>The actions for the default rule.</p>
        pub fn default_actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.default_actions(inp);
            self
        }
        pub fn set_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_default_actions(input);
            self
        }
        /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
        /// can specify one policy name. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HTTP1Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Optional</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Preferred</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>None</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
        /// policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn alpn_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alpn_policy(inp);
            self
        }
        pub fn set_alpn_policy(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alpn_policy(input);
            self
        }
        /// <p>The tags to assign to the listener.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_load_balancer_input::Builder,
    }
    impl<C> CreateLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        /// <p>This name must be unique per region per account, can have a maximum of 32 characters, must
        /// contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must
        /// not begin with "internal-".</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        /// <p>[Gateway Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones. You cannot specify Elastic IP addresses for your subnets.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// can specify one Elastic IP address per subnet if you need static IP addresses for your
        /// internet-facing load balancer. For internal load balancers, you can specify one private IP
        /// address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
        /// can specify one IPv6 address per subnet.</p>
        /// <p>[Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// cannot specify Elastic IP addresses for your subnets.</p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
        /// <p>[Application Load Balancers] The IDs of the security groups for the load balancer.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
        /// Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
        /// Therefore, Internet-facing load balancers can route requests from clients over the
        /// internet.</p>
        /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
        /// internal load balancer is publicly resolvable to the private IP addresses of the nodes.
        /// Therefore, internal load balancers can route requests only from clients with access to the VPC
        /// for the load balancer.</p>
        /// <p>The default is an Internet-facing load balancer.</p>
        /// <p>You cannot specify a scheme for a Gateway Load Balancer.</p>
        pub fn scheme(mut self, input: crate::model::LoadBalancerSchemeEnum) -> Self {
            self.inner = self.inner.scheme(input);
            self
        }
        pub fn set_scheme(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerSchemeEnum>,
        ) -> Self {
            self.inner = self.inner.set_scheme(input);
            self
        }
        /// <p>The tags to assign to the load balancer.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The type of load balancer. The default is <code>application</code>.</p>
        pub fn r#type(mut self, input: crate::model::LoadBalancerTypeEnum) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
        /// are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
        /// addresses). Internal load balancers must use <code>ipv4</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
        /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool (CoIP
        /// pool).</p>
        pub fn customer_owned_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_owned_ipv4_pool(input);
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_owned_ipv4_pool(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_rule_input::Builder,
    }
    impl<C> CreateRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The conditions.</p>
        pub fn conditions(mut self, inp: impl Into<crate::model::RuleCondition>) -> Self {
            self.inner = self.inner.conditions(inp);
            self
        }
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleCondition>>,
        ) -> Self {
            self.inner = self.inner.set_conditions(input);
            self
        }
        /// <p>The rule priority. A listener can't have multiple rules with the same priority.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>The actions.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// <p>The tags to assign to the rule.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTargetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_target_group_input::Builder,
    }
    impl<C> CreateTargetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateTargetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the target group.</p>
        /// <p>This name must be unique per region per account, can have a maximum of 32 characters, must
        /// contain only alphanumeric characters or hyphens, and must not begin or end with a
        /// hyphen.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The protocol to use for routing traffic to the targets. For Application Load Balancers,
        /// the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported
        /// protocols are TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is
        /// GENEVE. A TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a
        /// Lambda function, this parameter does not apply.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>[HTTP/HTTPS protocol] The protocol version. Specify <code>GRPC</code> to send requests to
        /// targets using gRPC. Specify <code>HTTP2</code> to send requests to targets using HTTP/2. The
        /// default is <code>HTTP1</code>, which sends requests to targets using HTTP/1.1.</p>
        pub fn protocol_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.protocol_version(input);
            self
        }
        pub fn set_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_protocol_version(input);
            self
        }
        /// <p>The port on which the targets receive traffic. This port is used unless you specify a port
        /// override when registering the target. If the target is a Lambda function, this parameter does
        /// not apply. If the protocol is GENEVE, the supported port is 6081.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.inner = self.inner.port(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
        /// this parameter does not apply. Otherwise, this parameter is required.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The protocol the load balancer uses when performing health checks on targets. For
        /// Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
        /// Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
        /// protocol of the target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are
        /// not supported for health checks.</p>
        pub fn health_check_protocol(mut self, input: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.health_check_protocol(input);
            self
        }
        pub fn set_health_check_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_health_check_protocol(input);
            self
        }
        /// <p>The port the load balancer uses when performing health checks on targets. If the protocol
        /// is HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is <code>traffic-port</code>, which is
        /// the port on which each target receives traffic from the load balancer. If the protocol is
        /// GENEVE, the default is port 80.</p>
        pub fn health_check_port(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_port(input);
            self
        }
        pub fn set_health_check_port(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_port(input);
            self
        }
        /// <p>Indicates whether health checks are enabled. If the target type is <code>lambda</code>,
        /// health checks are disabled by default but can be enabled. If the target type is
        /// <code>instance</code> or <code>ip</code>, health checks are always enabled and cannot be
        /// disabled.</p>
        pub fn health_check_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.health_check_enabled(input);
            self
        }
        pub fn set_health_check_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_health_check_enabled(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
        /// <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
        /// <p>[GRPC protocol version] The path of a custom health check method with the format
        /// /package.service/method. The default is /Amazon Web Services.ALB/healthcheck.</p>
        pub fn health_check_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_path(input);
            self
        }
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_path(input);
            self
        }
        /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
        /// If the target group protocol is TCP, TLS, UDP, or TCP_UDP, the supported values are 10 and 30
        /// seconds. If the target group protocol is HTTP or HTTPS, the default is 30 seconds. If the
        /// target group protocol is GENEVE, the default is 10 seconds. If the target type is
        /// <code>lambda</code>, the default is 35 seconds.</p>
        pub fn health_check_interval_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_interval_seconds(input);
            self
        }
        pub fn set_health_check_interval_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_interval_seconds(input);
            self
        }
        /// <p>The amount of time, in seconds, during which no response from a target means a failed
        /// health check. For target groups with a protocol of HTTP, HTTPS, or GENEVE, the default is 5
        /// seconds. For target groups with a protocol of TCP or TLS, this value must be 6 seconds for
        /// HTTP health checks and 10 seconds for TCP and HTTPS health checks. If the target type is
        /// <code>lambda</code>, the default is 30 seconds.</p>
        pub fn health_check_timeout_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_timeout_seconds(input);
            self
        }
        pub fn set_health_check_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_timeout_seconds(input);
            self
        }
        /// <p>The number of consecutive health checks successes required before considering an unhealthy
        /// target healthy. For target groups with a protocol of HTTP or HTTPS, the default is 5. For
        /// target groups with a protocol of TCP, TLS, or GENEVE, the default is 3. If the target type is
        /// <code>lambda</code>, the default is 5.</p>
        pub fn healthy_threshold_count(mut self, input: i32) -> Self {
            self.inner = self.inner.healthy_threshold_count(input);
            self
        }
        pub fn set_healthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_healthy_threshold_count(input);
            self
        }
        /// <p>The number of consecutive health check failures required before considering a target
        /// unhealthy. If the target group protocol is HTTP or HTTPS, the default is 2. If the target
        /// group protocol is TCP or TLS, this value must be the same as the healthy threshold count. If
        /// the target group protocol is GENEVE, the default is 3. If the target type is
        /// <code>lambda</code>, the default is 2.</p>
        pub fn unhealthy_threshold_count(mut self, input: i32) -> Self {
            self.inner = self.inner.unhealthy_threshold_count(input);
            self
        }
        pub fn set_unhealthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_unhealthy_threshold_count(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
        /// response from a target.</p>
        pub fn matcher(mut self, input: crate::model::Matcher) -> Self {
            self.inner = self.inner.matcher(input);
            self
        }
        pub fn set_matcher(mut self, input: std::option::Option<crate::model::Matcher>) -> Self {
            self.inner = self.inner.set_matcher(input);
            self
        }
        /// <p>The type of target that you must specify when registering targets with this target group.
        /// You can't specify targets for a target group using more than one target type.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance</code> - Register targets by instance ID. This is the default
        /// value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip</code> - Register targets by IP address. You can specify IP addresses from
        /// the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range
        /// (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10).
        /// You can't specify publicly routable IP addresses.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda</code> - Register a single Lambda function as a target.</p>
        /// </li>
        /// </ul>
        pub fn target_type(mut self, input: crate::model::TargetTypeEnum) -> Self {
            self.inner = self.inner.target_type(input);
            self
        }
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_target_type(input);
            self
        }
        /// <p>The tags to assign to the target group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteListener<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_listener_input::Builder,
    }
    impl<C> DeleteListener<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteListenerOutput,
            smithy_http::result::SdkError<crate::error::DeleteListenerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_load_balancer_input::Builder,
    }
    impl<C> DeleteLoadBalancer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_rule_input::Builder,
    }
    impl<C> DeleteRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arn(input);
            self
        }
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTargetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_target_group_input::Builder,
    }
    impl<C> DeleteTargetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteTargetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_targets_input::Builder,
    }
    impl<C> DeregisterTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterTargetsOutput,
            smithy_http::result::SdkError<crate::error::DeregisterTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The targets. If you specified a port override when you registered a target, you must
        /// specify both the target ID and the port when you deregister it.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountLimits<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_limits_input::Builder,
    }
    impl<C> DescribeAccountLimits<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountLimitsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeListenerCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_listener_certificates_input::Builder,
    }
    impl<C> DescribeListenerCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::DescribeListenerCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Names (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeListeners<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_listeners_input::Builder,
    }
    impl<C> DescribeListeners<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeListenersOutput,
            smithy_http::result::SdkError<crate::error::DescribeListenersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the listeners.</p>
        pub fn listener_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arns(inp);
            self
        }
        pub fn set_listener_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_listener_arns(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_load_balancer_attributes_input::Builder,
    }
    impl<C> DescribeLoadBalancerAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_load_balancers_input::Builder,
    }
    impl<C> DescribeLoadBalancers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load
        /// balancers in a single call.</p>
        pub fn load_balancer_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arns(inp);
            self
        }
        pub fn set_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arns(input);
            self
        }
        /// <p>The names of the load balancers.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_rules_input::Builder,
    }
    impl<C> DescribeRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRulesOutput,
            smithy_http::result::SdkError<crate::error::DescribeRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the rules.</p>
        pub fn rule_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arns(inp);
            self
        }
        pub fn set_rule_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_arns(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSSLPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_ssl_policies_input::Builder,
    }
    impl<C> DescribeSSLPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSslPoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSSLPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the policies.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C> DescribeTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Names (ARN) of the resources. You can specify up to 20 resources in a
        /// single call.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetGroupAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_target_group_attributes_input::Builder,
    }
    impl<C> DescribeTargetGroupAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetGroupAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetGroupAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_target_groups_input::Builder,
    }
    impl<C> DescribeTargetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the target groups.</p>
        pub fn target_group_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arns(inp);
            self
        }
        pub fn set_target_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arns(input);
            self
        }
        /// <p>The names of the target groups.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.inner = self.inner.page_size(input);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetHealth<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_target_health_input::Builder,
    }
    impl<C> DescribeTargetHealth<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetHealthOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetHealthError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The targets.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyListener<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_listener_input::Builder,
    }
    impl<C> ModifyListener<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyListenerOutput,
            smithy_http::result::SdkError<crate::error::ModifyListenerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The port for connections from clients to the load balancer. You cannot specify a port for
        /// a Gateway Load Balancer.</p>
        pub fn port(mut self, input: i32) -> Self {
            self.inner = self.inner.port(input);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The protocol for connections from clients to the load balancer. Application Load Balancers
        /// support the HTTP and HTTPS protocols. Network Load Balancers support the TCP, TLS, UDP, and
        /// TCP_UDP protocols. You canâ€™t change the protocol to UDP or TCP_UDP if dual-stack mode is
        /// enabled. You cannot specify a protocol for a Gateway Load Balancer.</p>
        pub fn protocol(mut self, input: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
        /// supported.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> or
        /// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn ssl_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssl_policy(input);
            self
        }
        pub fn set_ssl_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssl_policy(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
        /// exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
        /// <p>The actions for the default rule.</p>
        pub fn default_actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.default_actions(inp);
            self
        }
        pub fn set_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_default_actions(input);
            self
        }
        /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
        /// can specify one policy name. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HTTP1Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Optional</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Preferred</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>None</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
        /// policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn alpn_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alpn_policy(inp);
            self
        }
        pub fn set_alpn_policy(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alpn_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyLoadBalancerAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_load_balancer_attributes_input::Builder,
    }
    impl<C> ModifyLoadBalancerAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyLoadBalancerAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The load balancer attributes.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::LoadBalancerAttribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadBalancerAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_rule_input::Builder,
    }
    impl<C> ModifyRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyRuleOutput,
            smithy_http::result::SdkError<crate::error::ModifyRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arn(input);
            self
        }
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_arn(input);
            self
        }
        /// <p>The conditions.</p>
        pub fn conditions(mut self, inp: impl Into<crate::model::RuleCondition>) -> Self {
            self.inner = self.inner.conditions(inp);
            self
        }
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleCondition>>,
        ) -> Self {
            self.inner = self.inner.set_conditions(input);
            self
        }
        /// <p>The actions.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTargetGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_target_group_input::Builder,
    }
    impl<C> ModifyTargetGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::ModifyTargetGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The protocol the load balancer uses when performing health checks on targets. For
        /// Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
        /// Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
        /// protocol of the target group is HTTP or HTTPS. It is supported for health checks only if the
        /// protocol of the target group is TCP, TLS, UDP, or TCP_UDP. The GENEVE, TLS, UDP, and TCP_UDP
        /// protocols are not supported for health checks.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_protocol(mut self, input: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.health_check_protocol(input);
            self
        }
        pub fn set_health_check_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_health_check_protocol(input);
            self
        }
        /// <p>The port the load balancer uses when performing health checks on targets.</p>
        pub fn health_check_port(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_port(input);
            self
        }
        pub fn set_health_check_port(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_port(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
        /// <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
        /// <p>[GRPC protocol version] The path of a custom health check method with the format
        /// /package.service/method. The default is /Amazon Web Services.ALB/healthcheck.</p>
        pub fn health_check_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_path(input);
            self
        }
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_path(input);
            self
        }
        /// <p>Indicates whether health checks are enabled.</p>
        pub fn health_check_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.health_check_enabled(input);
            self
        }
        pub fn set_health_check_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_health_check_enabled(input);
            self
        }
        /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
        /// For TCP health checks, the supported values are 10 or 30 seconds.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_interval_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_interval_seconds(input);
            self
        }
        pub fn set_health_check_interval_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_interval_seconds(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The amount of time, in seconds, during which no response means
        /// a failed health check.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_timeout_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_timeout_seconds(input);
            self
        }
        pub fn set_health_check_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_timeout_seconds(input);
            self
        }
        /// <p>The number of consecutive health checks successes required before considering an unhealthy
        /// target healthy.</p>
        pub fn healthy_threshold_count(mut self, input: i32) -> Self {
            self.inner = self.inner.healthy_threshold_count(input);
            self
        }
        pub fn set_healthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_healthy_threshold_count(input);
            self
        }
        /// <p>The number of consecutive health check failures required before considering the target
        /// unhealthy. For target groups with a protocol of TCP or TLS, this value must be the same as the
        /// healthy threshold count.</p>
        pub fn unhealthy_threshold_count(mut self, input: i32) -> Self {
            self.inner = self.inner.unhealthy_threshold_count(input);
            self
        }
        pub fn set_unhealthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_unhealthy_threshold_count(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
        /// response from a target.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn matcher(mut self, input: crate::model::Matcher) -> Self {
            self.inner = self.inner.matcher(input);
            self
        }
        pub fn set_matcher(mut self, input: std::option::Option<crate::model::Matcher>) -> Self {
            self.inner = self.inner.set_matcher(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTargetGroupAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_target_group_attributes_input::Builder,
    }
    impl<C> ModifyTargetGroupAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTargetGroupAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyTargetGroupAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The attributes.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::TargetGroupAttribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetGroupAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_targets_input::Builder,
    }
    impl<C> RegisterTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterTargetsOutput,
            smithy_http::result::SdkError<crate::error::RegisterTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(input);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The targets.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveListenerCertificates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_listener_certificates_input::Builder,
    }
    impl<C> RemoveListenerCertificates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::RemoveListenerCertificatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(input);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The certificate to remove. You can specify one certificate per call. Set
        /// <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_input::Builder,
    }
    impl<C> RemoveTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
        /// <p>The tag keys for the tags to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIpAddressType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_ip_address_type_input::Builder,
    }
    impl<C> SetIpAddressType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIpAddressTypeOutput,
            smithy_http::result::SdkError<crate::error::SetIpAddressTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The IP address type. The possible values are <code>ipv4</code> (for IPv4 addresses) and
        /// <code>dualstack</code> (for IPv4 and IPv6 addresses). Internal load balancers must use
        /// <code>ipv4</code>. You canâ€™t specify <code>dualstack</code> for a load balancer with a UDP
        /// or TCP_UDP listener.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetRulePriorities<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_rule_priorities_input::Builder,
    }
    impl<C> SetRulePriorities<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetRulePrioritiesOutput,
            smithy_http::result::SdkError<crate::error::SetRulePrioritiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The rule priorities.</p>
        pub fn rule_priorities(mut self, inp: impl Into<crate::model::RulePriorityPair>) -> Self {
            self.inner = self.inner.rule_priorities(inp);
            self
        }
        pub fn set_rule_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RulePriorityPair>>,
        ) -> Self {
            self.inner = self.inner.set_rule_priorities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_security_groups_input::Builder,
    }
    impl<C> SetSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::SetSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The IDs of the security groups.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSubnets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_subnets_input::Builder,
    }
    impl<C> SetSubnets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSubnetsOutput,
            smithy_http::result::SdkError<crate::error::SetSubnetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(input);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones. You cannot specify Elastic IP addresses for your subnets.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// can specify one Elastic IP address per subnet if you need static IP addresses for your
        /// internet-facing load balancer. For internal load balancers, you can specify one private IP
        /// address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
        /// can specify one IPv6 address per subnet.</p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
        /// <p>[Network Load Balancers] The type of IP addresses used by the subnets for your load
        /// balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and
        /// <code>dualstack</code> (for IPv4 and IPv6 addresses). You canâ€™t specify
        /// <code>dualstack</code> for a load balancer with a UDP or TCP_UDP listener. Internal load
        /// balancers must use <code>ipv4</code>.</p>
        pub fn ip_address_type(mut self, input: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(input);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
}
