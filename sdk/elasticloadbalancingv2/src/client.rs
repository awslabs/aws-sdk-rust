// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `ElasticLoadBalancing_v10`.
///
/// This client allows ergonomic access to a `ElasticLoadBalancing_v10`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn add_listener_certificates(&self) -> fluent_builders::AddListenerCertificates<C, M, R> {
        fluent_builders::AddListenerCertificates::new(self.handle.clone())
    }
    pub fn add_tags(&self) -> fluent_builders::AddTags<C, M, R> {
        fluent_builders::AddTags::new(self.handle.clone())
    }
    pub fn create_listener(&self) -> fluent_builders::CreateListener<C, M, R> {
        fluent_builders::CreateListener::new(self.handle.clone())
    }
    pub fn create_load_balancer(&self) -> fluent_builders::CreateLoadBalancer<C, M, R> {
        fluent_builders::CreateLoadBalancer::new(self.handle.clone())
    }
    pub fn create_rule(&self) -> fluent_builders::CreateRule<C, M, R> {
        fluent_builders::CreateRule::new(self.handle.clone())
    }
    pub fn create_target_group(&self) -> fluent_builders::CreateTargetGroup<C, M, R> {
        fluent_builders::CreateTargetGroup::new(self.handle.clone())
    }
    pub fn delete_listener(&self) -> fluent_builders::DeleteListener<C, M, R> {
        fluent_builders::DeleteListener::new(self.handle.clone())
    }
    pub fn delete_load_balancer(&self) -> fluent_builders::DeleteLoadBalancer<C, M, R> {
        fluent_builders::DeleteLoadBalancer::new(self.handle.clone())
    }
    pub fn delete_rule(&self) -> fluent_builders::DeleteRule<C, M, R> {
        fluent_builders::DeleteRule::new(self.handle.clone())
    }
    pub fn delete_target_group(&self) -> fluent_builders::DeleteTargetGroup<C, M, R> {
        fluent_builders::DeleteTargetGroup::new(self.handle.clone())
    }
    pub fn deregister_targets(&self) -> fluent_builders::DeregisterTargets<C, M, R> {
        fluent_builders::DeregisterTargets::new(self.handle.clone())
    }
    pub fn describe_account_limits(&self) -> fluent_builders::DescribeAccountLimits<C, M, R> {
        fluent_builders::DescribeAccountLimits::new(self.handle.clone())
    }
    pub fn describe_listener_certificates(
        &self,
    ) -> fluent_builders::DescribeListenerCertificates<C, M, R> {
        fluent_builders::DescribeListenerCertificates::new(self.handle.clone())
    }
    pub fn describe_listeners(&self) -> fluent_builders::DescribeListeners<C, M, R> {
        fluent_builders::DescribeListeners::new(self.handle.clone())
    }
    pub fn describe_load_balancer_attributes(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerAttributes<C, M, R> {
        fluent_builders::DescribeLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn describe_load_balancers(&self) -> fluent_builders::DescribeLoadBalancers<C, M, R> {
        fluent_builders::DescribeLoadBalancers::new(self.handle.clone())
    }
    pub fn describe_rules(&self) -> fluent_builders::DescribeRules<C, M, R> {
        fluent_builders::DescribeRules::new(self.handle.clone())
    }
    pub fn describe_ssl_policies(&self) -> fluent_builders::DescribeSSLPolicies<C, M, R> {
        fluent_builders::DescribeSSLPolicies::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C, M, R> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn describe_target_group_attributes(
        &self,
    ) -> fluent_builders::DescribeTargetGroupAttributes<C, M, R> {
        fluent_builders::DescribeTargetGroupAttributes::new(self.handle.clone())
    }
    pub fn describe_target_groups(&self) -> fluent_builders::DescribeTargetGroups<C, M, R> {
        fluent_builders::DescribeTargetGroups::new(self.handle.clone())
    }
    pub fn describe_target_health(&self) -> fluent_builders::DescribeTargetHealth<C, M, R> {
        fluent_builders::DescribeTargetHealth::new(self.handle.clone())
    }
    pub fn modify_listener(&self) -> fluent_builders::ModifyListener<C, M, R> {
        fluent_builders::ModifyListener::new(self.handle.clone())
    }
    pub fn modify_load_balancer_attributes(
        &self,
    ) -> fluent_builders::ModifyLoadBalancerAttributes<C, M, R> {
        fluent_builders::ModifyLoadBalancerAttributes::new(self.handle.clone())
    }
    pub fn modify_rule(&self) -> fluent_builders::ModifyRule<C, M, R> {
        fluent_builders::ModifyRule::new(self.handle.clone())
    }
    pub fn modify_target_group(&self) -> fluent_builders::ModifyTargetGroup<C, M, R> {
        fluent_builders::ModifyTargetGroup::new(self.handle.clone())
    }
    pub fn modify_target_group_attributes(
        &self,
    ) -> fluent_builders::ModifyTargetGroupAttributes<C, M, R> {
        fluent_builders::ModifyTargetGroupAttributes::new(self.handle.clone())
    }
    pub fn register_targets(&self) -> fluent_builders::RegisterTargets<C, M, R> {
        fluent_builders::RegisterTargets::new(self.handle.clone())
    }
    pub fn remove_listener_certificates(
        &self,
    ) -> fluent_builders::RemoveListenerCertificates<C, M, R> {
        fluent_builders::RemoveListenerCertificates::new(self.handle.clone())
    }
    pub fn remove_tags(&self) -> fluent_builders::RemoveTags<C, M, R> {
        fluent_builders::RemoveTags::new(self.handle.clone())
    }
    pub fn set_ip_address_type(&self) -> fluent_builders::SetIpAddressType<C, M, R> {
        fluent_builders::SetIpAddressType::new(self.handle.clone())
    }
    pub fn set_rule_priorities(&self) -> fluent_builders::SetRulePriorities<C, M, R> {
        fluent_builders::SetRulePriorities::new(self.handle.clone())
    }
    pub fn set_security_groups(&self) -> fluent_builders::SetSecurityGroups<C, M, R> {
        fluent_builders::SetSecurityGroups::new(self.handle.clone())
    }
    pub fn set_subnets(&self) -> fluent_builders::SetSubnets<C, M, R> {
        fluent_builders::SetSubnets::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddListenerCertificates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_listener_certificates_input::Builder,
    }
    impl<C, M, R> AddListenerCertificates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::AddListenerCertificatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddListenerCertificatesInputOperationOutputAlias,
                crate::output::AddListenerCertificatesOutput,
                crate::error::AddListenerCertificatesError,
                crate::input::AddListenerCertificatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// Appends an item to `Certificates`.
        ///
        /// To override the contents of this collection use [`set_certificates`](Self::set_certificates).
        /// <p>The certificate to add. You can specify one certificate per call. Set
        /// <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AddTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::add_tags_input::Builder,
    }
    impl<C, M, R> AddTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsOutput,
            smithy_http::result::SdkError<crate::error::AddTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AddTagsInputOperationOutputAlias,
                crate::output::AddTagsOutput,
                crate::error::AddTagsError,
                crate::input::AddTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `ResourceArns`.
        ///
        /// To override the contents of this collection use [`set_resource_arns`](Self::set_resource_arns).
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateListener<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_listener_input::Builder,
    }
    impl<C, M, R> CreateListener<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateListenerOutput,
            smithy_http::result::SdkError<crate::error::CreateListenerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateListenerInputOperationOutputAlias,
                crate::output::CreateListenerOutput,
                crate::error::CreateListenerError,
                crate::input::CreateListenerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The protocol for connections from clients to the load balancer. For Application Load
        /// Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the
        /// supported protocols are TCP, TLS, UDP, and TCP_UDP. You canâ€™t specify the UDP or TCP_UDP
        /// protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load
        /// Balancer.</p>
        pub fn protocol(mut self, inp: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(inp);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The port on which the load balancer is listening. You cannot specify a port for a Gateway
        /// Load Balancer.</p>
        pub fn port(mut self, inp: i32) -> Self {
            self.inner = self.inner.port(inp);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
        /// supported.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> and
        /// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn ssl_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssl_policy(inp);
            self
        }
        pub fn set_ssl_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssl_policy(input);
            self
        }
        /// Appends an item to `Certificates`.
        ///
        /// To override the contents of this collection use [`set_certificates`](Self::set_certificates).
        /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
        /// exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
        /// Appends an item to `DefaultActions`.
        ///
        /// To override the contents of this collection use [`set_default_actions`](Self::set_default_actions).
        /// <p>The actions for the default rule.</p>
        pub fn default_actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.default_actions(inp);
            self
        }
        pub fn set_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_default_actions(input);
            self
        }
        /// Appends an item to `AlpnPolicy`.
        ///
        /// To override the contents of this collection use [`set_alpn_policy`](Self::set_alpn_policy).
        /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
        /// can specify one policy name. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HTTP1Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Optional</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Preferred</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>None</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
        /// policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn alpn_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alpn_policy(inp);
            self
        }
        pub fn set_alpn_policy(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alpn_policy(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to assign to the listener.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_load_balancer_input::Builder,
    }
    impl<C, M, R> CreateLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::CreateLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLoadBalancerInputOperationOutputAlias,
                crate::output::CreateLoadBalancerOutput,
                crate::error::CreateLoadBalancerError,
                crate::input::CreateLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the load balancer.</p>
        /// <p>This name must be unique per region per account, can have a maximum of 32 characters, must
        /// contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must
        /// not begin with "internal-".</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// Appends an item to `Subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        /// <p>[Gateway Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// Appends an item to `SubnetMappings`.
        ///
        /// To override the contents of this collection use [`set_subnet_mappings`](Self::set_subnet_mappings).
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones. You cannot specify Elastic IP addresses for your subnets.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// can specify one Elastic IP address per subnet if you need static IP addresses for your
        /// internet-facing load balancer. For internal load balancers, you can specify one private IP
        /// address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
        /// can specify one IPv6 address per subnet.</p>
        /// <p>[Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// cannot specify Elastic IP addresses for your subnets.</p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
        /// Appends an item to `SecurityGroups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        /// <p>[Application Load Balancers] The IDs of the security groups for the load balancer.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
        /// Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
        /// Therefore, Internet-facing load balancers can route requests from clients over the
        /// internet.</p>
        /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
        /// internal load balancer is publicly resolvable to the private IP addresses of the nodes.
        /// Therefore, internal load balancers can route requests only from clients with access to the VPC
        /// for the load balancer.</p>
        /// <p>The default is an Internet-facing load balancer.</p>
        /// <p>You cannot specify a scheme for a Gateway Load Balancer.</p>
        pub fn scheme(mut self, inp: crate::model::LoadBalancerSchemeEnum) -> Self {
            self.inner = self.inner.scheme(inp);
            self
        }
        pub fn set_scheme(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerSchemeEnum>,
        ) -> Self {
            self.inner = self.inner.set_scheme(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to assign to the load balancer.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The type of load balancer. The default is <code>application</code>.</p>
        pub fn r#type(mut self, inp: crate::model::LoadBalancerTypeEnum) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
        /// are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
        /// addresses). Internal load balancers must use <code>ipv4</code>.</p>
        pub fn ip_address_type(mut self, inp: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(inp);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
        /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool (CoIP
        /// pool).</p>
        pub fn customer_owned_ipv4_pool(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_owned_ipv4_pool(inp);
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_owned_ipv4_pool(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRule<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_rule_input::Builder,
    }
    impl<C, M, R> CreateRule<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateRuleError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateRuleInputOperationOutputAlias,
                crate::output::CreateRuleOutput,
                crate::error::CreateRuleError,
                crate::input::CreateRuleInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// Appends an item to `Conditions`.
        ///
        /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
        /// <p>The conditions.</p>
        pub fn conditions(mut self, inp: impl Into<crate::model::RuleCondition>) -> Self {
            self.inner = self.inner.conditions(inp);
            self
        }
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleCondition>>,
        ) -> Self {
            self.inner = self.inner.set_conditions(input);
            self
        }
        /// <p>The rule priority. A listener can't have multiple rules with the same priority.</p>
        pub fn priority(mut self, inp: i32) -> Self {
            self.inner = self.inner.priority(inp);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// Appends an item to `Actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        /// <p>The actions.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to assign to the rule.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTargetGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_target_group_input::Builder,
    }
    impl<C, M, R> CreateTargetGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateTargetGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateTargetGroupInputOperationOutputAlias,
                crate::output::CreateTargetGroupOutput,
                crate::error::CreateTargetGroupError,
                crate::input::CreateTargetGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the target group.</p>
        /// <p>This name must be unique per region per account, can have a maximum of 32 characters, must
        /// contain only alphanumeric characters or hyphens, and must not begin or end with a
        /// hyphen.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The protocol to use for routing traffic to the targets. For Application Load Balancers,
        /// the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported
        /// protocols are TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is
        /// GENEVE. A TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a
        /// Lambda function, this parameter does not apply.</p>
        pub fn protocol(mut self, inp: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(inp);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>[HTTP/HTTPS protocol] The protocol version. Specify <code>GRPC</code> to send requests to
        /// targets using gRPC. Specify <code>HTTP2</code> to send requests to targets using HTTP/2. The
        /// default is <code>HTTP1</code>, which sends requests to targets using HTTP/1.1.</p>
        pub fn protocol_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.protocol_version(inp);
            self
        }
        pub fn set_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_protocol_version(input);
            self
        }
        /// <p>The port on which the targets receive traffic. This port is used unless you specify a port
        /// override when registering the target. If the target is a Lambda function, this parameter does
        /// not apply. If the protocol is GENEVE, the supported port is 6081.</p>
        pub fn port(mut self, inp: i32) -> Self {
            self.inner = self.inner.port(inp);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
        /// this parameter does not apply. Otherwise, this parameter is required.</p>
        pub fn vpc_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(inp);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The protocol the load balancer uses when performing health checks on targets. For
        /// Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
        /// Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
        /// protocol of the target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are
        /// not supported for health checks.</p>
        pub fn health_check_protocol(mut self, inp: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.health_check_protocol(inp);
            self
        }
        pub fn set_health_check_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_health_check_protocol(input);
            self
        }
        /// <p>The port the load balancer uses when performing health checks on targets. If the protocol
        /// is HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is <code>traffic-port</code>, which is
        /// the port on which each target receives traffic from the load balancer. If the protocol is
        /// GENEVE, the default is port 80.</p>
        pub fn health_check_port(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_port(inp);
            self
        }
        pub fn set_health_check_port(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_port(input);
            self
        }
        /// <p>Indicates whether health checks are enabled. If the target type is <code>lambda</code>,
        /// health checks are disabled by default but can be enabled. If the target type is
        /// <code>instance</code>, <code>ip</code>, or <code>alb</code>, health checks are always
        /// enabled and cannot be disabled.</p>
        pub fn health_check_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.health_check_enabled(inp);
            self
        }
        pub fn set_health_check_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_health_check_enabled(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
        /// <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
        /// <p>[GRPC protocol version] The path of a custom health check method with the format
        /// /package.service/method. The default is /Amazon Web Services.ALB/healthcheck.</p>
        pub fn health_check_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_path(inp);
            self
        }
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_path(input);
            self
        }
        /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
        /// If the target group protocol is TCP, TLS, UDP, or TCP_UDP, the supported values are 10 and 30
        /// seconds. If the target group protocol is HTTP or HTTPS, the default is 30 seconds. If the
        /// target group protocol is GENEVE, the default is 10 seconds. If the target type is
        /// <code>lambda</code>, the default is 35 seconds.</p>
        pub fn health_check_interval_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.health_check_interval_seconds(inp);
            self
        }
        pub fn set_health_check_interval_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_interval_seconds(input);
            self
        }
        /// <p>The amount of time, in seconds, during which no response from a target means a failed
        /// health check. For target groups with a protocol of HTTP, HTTPS, or GENEVE, the default is 5
        /// seconds. For target groups with a protocol of TCP or TLS, this value must be 6 seconds for
        /// HTTP health checks and 10 seconds for TCP and HTTPS health checks. If the target type is
        /// <code>lambda</code>, the default is 30 seconds.</p>
        pub fn health_check_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.health_check_timeout_seconds(inp);
            self
        }
        pub fn set_health_check_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_timeout_seconds(input);
            self
        }
        /// <p>The number of consecutive health checks successes required before considering an unhealthy
        /// target healthy. For target groups with a protocol of HTTP or HTTPS, the default is 5. For
        /// target groups with a protocol of TCP, TLS, or GENEVE, the default is 3. If the target type is
        /// <code>lambda</code>, the default is 5.</p>
        pub fn healthy_threshold_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.healthy_threshold_count(inp);
            self
        }
        pub fn set_healthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_healthy_threshold_count(input);
            self
        }
        /// <p>The number of consecutive health check failures required before considering a target
        /// unhealthy. If the target group protocol is HTTP or HTTPS, the default is 2. If the target
        /// group protocol is TCP or TLS, this value must be the same as the healthy threshold count. If
        /// the target group protocol is GENEVE, the default is 3. If the target type is
        /// <code>lambda</code>, the default is 2.</p>
        pub fn unhealthy_threshold_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.unhealthy_threshold_count(inp);
            self
        }
        pub fn set_unhealthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_unhealthy_threshold_count(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
        /// response from a target.</p>
        pub fn matcher(mut self, inp: crate::model::Matcher) -> Self {
            self.inner = self.inner.matcher(inp);
            self
        }
        pub fn set_matcher(mut self, input: std::option::Option<crate::model::Matcher>) -> Self {
            self.inner = self.inner.set_matcher(input);
            self
        }
        /// <p>The type of target that you must specify when registering targets with this target group.
        /// You can't specify targets for a target group using more than one target type.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance</code> - Register targets by instance ID. This is the default
        /// value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip</code> - Register targets by IP address. You can specify IP addresses from
        /// the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range
        /// (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10).
        /// You can't specify publicly routable IP addresses.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lambda</code> - Register a single Lambda function as a target.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>alb</code> - Register a single Application Load Balancer as a target.</p>
        /// </li>
        /// </ul>
        pub fn target_type(mut self, inp: crate::model::TargetTypeEnum) -> Self {
            self.inner = self.inner.target_type(inp);
            self
        }
        pub fn set_target_type(
            mut self,
            input: std::option::Option<crate::model::TargetTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_target_type(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to assign to the target group.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The type of IP address used for this target group. The possible values are
        /// <code>ipv4</code> and <code>ipv6</code>. This is an optional parameter. If not specified,
        /// the IP address type defaults to <code>ipv4</code>.</p>
        pub fn ip_address_type(mut self, inp: crate::model::TargetGroupIpAddressTypeEnum) -> Self {
            self.inner = self.inner.ip_address_type(inp);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::TargetGroupIpAddressTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteListener<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_listener_input::Builder,
    }
    impl<C, M, R> DeleteListener<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteListenerOutput,
            smithy_http::result::SdkError<crate::error::DeleteListenerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteListenerInputOperationOutputAlias,
                crate::output::DeleteListenerOutput,
                crate::error::DeleteListenerError,
                crate::input::DeleteListenerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLoadBalancer<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_load_balancer_input::Builder,
    }
    impl<C, M, R> DeleteLoadBalancer<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLoadBalancerOutput,
            smithy_http::result::SdkError<crate::error::DeleteLoadBalancerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLoadBalancerInputOperationOutputAlias,
                crate::output::DeleteLoadBalancerOutput,
                crate::error::DeleteLoadBalancerError,
                crate::input::DeleteLoadBalancerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRule<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_rule_input::Builder,
    }
    impl<C, M, R> DeleteRule<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteRuleError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteRuleInputOperationOutputAlias,
                crate::output::DeleteRuleOutput,
                crate::error::DeleteRuleError,
                crate::input::DeleteRuleInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arn(inp);
            self
        }
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTargetGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_target_group_input::Builder,
    }
    impl<C, M, R> DeleteTargetGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteTargetGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteTargetGroupInputOperationOutputAlias,
                crate::output::DeleteTargetGroupOutput,
                crate::error::DeleteTargetGroupError,
                crate::input::DeleteTargetGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterTargets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::deregister_targets_input::Builder,
    }
    impl<C, M, R> DeregisterTargets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterTargetsOutput,
            smithy_http::result::SdkError<crate::error::DeregisterTargetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeregisterTargetsInputOperationOutputAlias,
                crate::output::DeregisterTargetsOutput,
                crate::error::DeregisterTargetsError,
                crate::input::DeregisterTargetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// Appends an item to `Targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        /// <p>The targets. If you specified a port override when you registered a target, you must
        /// specify both the target ID and the port when you deregister it.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountLimits<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_account_limits_input::Builder,
    }
    impl<C, M, R> DescribeAccountLimits<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountLimitsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAccountLimitsInputOperationOutputAlias,
                crate::output::DescribeAccountLimitsOutput,
                crate::error::DescribeAccountLimitsError,
                crate::input::DescribeAccountLimitsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeListenerCertificates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_listener_certificates_input::Builder,
    }
    impl<C, M, R> DescribeListenerCertificates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::DescribeListenerCertificatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeListenerCertificatesInputOperationOutputAlias,
                crate::output::DescribeListenerCertificatesOutput,
                crate::error::DescribeListenerCertificatesError,
                crate::input::DescribeListenerCertificatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Names (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeListeners<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_listeners_input::Builder,
    }
    impl<C, M, R> DescribeListeners<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeListenersOutput,
            smithy_http::result::SdkError<crate::error::DescribeListenersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeListenersInputOperationOutputAlias,
                crate::output::DescribeListenersOutput,
                crate::error::DescribeListenersError,
                crate::input::DescribeListenersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// Appends an item to `ListenerArns`.
        ///
        /// To override the contents of this collection use [`set_listener_arns`](Self::set_listener_arns).
        /// <p>The Amazon Resource Names (ARN) of the listeners.</p>
        pub fn listener_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arns(inp);
            self
        }
        pub fn set_listener_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_listener_arns(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancer_attributes_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancerAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancerAttributesInputOperationOutputAlias,
                crate::output::DescribeLoadBalancerAttributesOutput,
                crate::error::DescribeLoadBalancerAttributesError,
                crate::input::DescribeLoadBalancerAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_load_balancers_input::Builder,
    }
    impl<C, M, R> DescribeLoadBalancers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLoadBalancersInputOperationOutputAlias,
                crate::output::DescribeLoadBalancersOutput,
                crate::error::DescribeLoadBalancersError,
                crate::input::DescribeLoadBalancersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `LoadBalancerArns`.
        ///
        /// To override the contents of this collection use [`set_load_balancer_arns`](Self::set_load_balancer_arns).
        /// <p>The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load
        /// balancers in a single call.</p>
        pub fn load_balancer_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arns(inp);
            self
        }
        pub fn set_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arns(input);
            self
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>The names of the load balancers.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRules<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_rules_input::Builder,
    }
    impl<C, M, R> DescribeRules<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRulesOutput,
            smithy_http::result::SdkError<crate::error::DescribeRulesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeRulesInputOperationOutputAlias,
                crate::output::DescribeRulesOutput,
                crate::error::DescribeRulesError,
                crate::input::DescribeRulesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// Appends an item to `RuleArns`.
        ///
        /// To override the contents of this collection use [`set_rule_arns`](Self::set_rule_arns).
        /// <p>The Amazon Resource Names (ARN) of the rules.</p>
        pub fn rule_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arns(inp);
            self
        }
        pub fn set_rule_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_rule_arns(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSSLPolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_ssl_policies_input::Builder,
    }
    impl<C, M, R> DescribeSSLPolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSslPoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSSLPoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSslPoliciesInputOperationOutputAlias,
                crate::output::DescribeSslPoliciesOutput,
                crate::error::DescribeSSLPoliciesError,
                crate::input::DescribeSslPoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>The names of the policies.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
        /// <p> The type of load balancer. The default lists the SSL policies for all load
        /// balancers.</p>
        pub fn load_balancer_type(mut self, inp: crate::model::LoadBalancerTypeEnum) -> Self {
            self.inner = self.inner.load_balancer_type(inp);
            self
        }
        pub fn set_load_balancer_type(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C, M, R> DescribeTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTagsInputOperationOutputAlias,
                crate::output::DescribeTagsOutput,
                crate::error::DescribeTagsError,
                crate::input::DescribeTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `ResourceArns`.
        ///
        /// To override the contents of this collection use [`set_resource_arns`](Self::set_resource_arns).
        /// <p>The Amazon Resource Names (ARN) of the resources. You can specify up to 20 resources in a
        /// single call.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetGroupAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_target_group_attributes_input::Builder,
    }
    impl<C, M, R> DescribeTargetGroupAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetGroupAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetGroupAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTargetGroupAttributesInputOperationOutputAlias,
                crate::output::DescribeTargetGroupAttributesOutput,
                crate::error::DescribeTargetGroupAttributesError,
                crate::input::DescribeTargetGroupAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetGroups<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_target_groups_input::Builder,
    }
    impl<C, M, R> DescribeTargetGroups<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetGroupsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTargetGroupsInputOperationOutputAlias,
                crate::output::DescribeTargetGroupsOutput,
                crate::error::DescribeTargetGroupsError,
                crate::input::DescribeTargetGroupsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// Appends an item to `TargetGroupArns`.
        ///
        /// To override the contents of this collection use [`set_target_group_arns`](Self::set_target_group_arns).
        /// <p>The Amazon Resource Names (ARN) of the target groups.</p>
        pub fn target_group_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arns(inp);
            self
        }
        pub fn set_target_group_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arns(input);
            self
        }
        /// Appends an item to `Names`.
        ///
        /// To override the contents of this collection use [`set_names`](Self::set_names).
        /// <p>The names of the target groups.</p>
        pub fn names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.names(inp);
            self
        }
        pub fn set_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_names(input);
            self
        }
        /// <p>The marker for the next set of results. (You received this marker from a previous
        /// call.)</p>
        pub fn marker(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(inp);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The maximum number of results to return with this call.</p>
        pub fn page_size(mut self, inp: i32) -> Self {
            self.inner = self.inner.page_size(inp);
            self
        }
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_page_size(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTargetHealth<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_target_health_input::Builder,
    }
    impl<C, M, R> DescribeTargetHealth<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTargetHealthOutput,
            smithy_http::result::SdkError<crate::error::DescribeTargetHealthError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeTargetHealthInputOperationOutputAlias,
                crate::output::DescribeTargetHealthOutput,
                crate::error::DescribeTargetHealthError,
                crate::input::DescribeTargetHealthInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// Appends an item to `Targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        /// <p>The targets.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyListener<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_listener_input::Builder,
    }
    impl<C, M, R> ModifyListener<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyListenerOutput,
            smithy_http::result::SdkError<crate::error::ModifyListenerError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyListenerInputOperationOutputAlias,
                crate::output::ModifyListenerOutput,
                crate::error::ModifyListenerError,
                crate::input::ModifyListenerInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// <p>The port for connections from clients to the load balancer. You cannot specify a port for
        /// a Gateway Load Balancer.</p>
        pub fn port(mut self, inp: i32) -> Self {
            self.inner = self.inner.port(inp);
            self
        }
        pub fn set_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_port(input);
            self
        }
        /// <p>The protocol for connections from clients to the load balancer. Application Load Balancers
        /// support the HTTP and HTTPS protocols. Network Load Balancers support the TCP, TLS, UDP, and
        /// TCP_UDP protocols. You canâ€™t change the protocol to UDP or TCP_UDP if dual-stack mode is
        /// enabled. You cannot specify a protocol for a Gateway Load Balancer.</p>
        pub fn protocol(mut self, inp: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.protocol(inp);
            self
        }
        pub fn set_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
        /// supported.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> or
        /// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn ssl_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssl_policy(inp);
            self
        }
        pub fn set_ssl_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ssl_policy(input);
            self
        }
        /// Appends an item to `Certificates`.
        ///
        /// To override the contents of this collection use [`set_certificates`](Self::set_certificates).
        /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
        /// exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
        /// Appends an item to `DefaultActions`.
        ///
        /// To override the contents of this collection use [`set_default_actions`](Self::set_default_actions).
        /// <p>The actions for the default rule.</p>
        pub fn default_actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.default_actions(inp);
            self
        }
        pub fn set_default_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_default_actions(input);
            self
        }
        /// Appends an item to `AlpnPolicy`.
        ///
        /// To override the contents of this collection use [`set_alpn_policy`](Self::set_alpn_policy).
        /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
        /// can specify one policy name. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HTTP1Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Only</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Optional</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HTTP2Preferred</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>None</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
        /// policies</a> in the <i>Network Load Balancers Guide</i>.</p>
        pub fn alpn_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.alpn_policy(inp);
            self
        }
        pub fn set_alpn_policy(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_alpn_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyLoadBalancerAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_load_balancer_attributes_input::Builder,
    }
    impl<C, M, R> ModifyLoadBalancerAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyLoadBalancerAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyLoadBalancerAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyLoadBalancerAttributesInputOperationOutputAlias,
                crate::output::ModifyLoadBalancerAttributesOutput,
                crate::error::ModifyLoadBalancerAttributesError,
                crate::input::ModifyLoadBalancerAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// Appends an item to `Attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        /// <p>The load balancer attributes.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::LoadBalancerAttribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoadBalancerAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyRule<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_rule_input::Builder,
    }
    impl<C, M, R> ModifyRule<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyRuleOutput,
            smithy_http::result::SdkError<crate::error::ModifyRuleError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyRuleInputOperationOutputAlias,
                crate::output::ModifyRuleOutput,
                crate::error::ModifyRuleError,
                crate::input::ModifyRuleInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        pub fn rule_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rule_arn(inp);
            self
        }
        pub fn set_rule_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_rule_arn(input);
            self
        }
        /// Appends an item to `Conditions`.
        ///
        /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
        /// <p>The conditions.</p>
        pub fn conditions(mut self, inp: impl Into<crate::model::RuleCondition>) -> Self {
            self.inner = self.inner.conditions(inp);
            self
        }
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RuleCondition>>,
        ) -> Self {
            self.inner = self.inner.set_conditions(input);
            self
        }
        /// Appends an item to `Actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        /// <p>The actions.</p>
        pub fn actions(mut self, inp: impl Into<crate::model::Action>) -> Self {
            self.inner = self.inner.actions(inp);
            self
        }
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Action>>,
        ) -> Self {
            self.inner = self.inner.set_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTargetGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_target_group_input::Builder,
    }
    impl<C, M, R> ModifyTargetGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTargetGroupOutput,
            smithy_http::result::SdkError<crate::error::ModifyTargetGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyTargetGroupInputOperationOutputAlias,
                crate::output::ModifyTargetGroupOutput,
                crate::error::ModifyTargetGroupError,
                crate::input::ModifyTargetGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// <p>The protocol the load balancer uses when performing health checks on targets. For
        /// Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
        /// Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
        /// protocol of the target group is HTTP or HTTPS. It is supported for health checks only if the
        /// protocol of the target group is TCP, TLS, UDP, or TCP_UDP. The GENEVE, TLS, UDP, and TCP_UDP
        /// protocols are not supported for health checks.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_protocol(mut self, inp: crate::model::ProtocolEnum) -> Self {
            self.inner = self.inner.health_check_protocol(inp);
            self
        }
        pub fn set_health_check_protocol(
            mut self,
            input: std::option::Option<crate::model::ProtocolEnum>,
        ) -> Self {
            self.inner = self.inner.set_health_check_protocol(input);
            self
        }
        /// <p>The port the load balancer uses when performing health checks on targets.</p>
        pub fn health_check_port(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_port(inp);
            self
        }
        pub fn set_health_check_port(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_port(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
        /// <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
        /// <p>[GRPC protocol version] The path of a custom health check method with the format
        /// /package.service/method. The default is /Amazon Web Services.ALB/healthcheck.</p>
        pub fn health_check_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_path(inp);
            self
        }
        pub fn set_health_check_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_path(input);
            self
        }
        /// <p>Indicates whether health checks are enabled.</p>
        pub fn health_check_enabled(mut self, inp: bool) -> Self {
            self.inner = self.inner.health_check_enabled(inp);
            self
        }
        pub fn set_health_check_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_health_check_enabled(input);
            self
        }
        /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
        /// For TCP health checks, the supported values are 10 or 30 seconds.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_interval_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.health_check_interval_seconds(inp);
            self
        }
        pub fn set_health_check_interval_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_health_check_interval_seconds(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The amount of time, in seconds, during which no response means
        /// a failed health check.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn health_check_timeout_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.health_check_timeout_seconds(inp);
            self
        }
        pub fn set_health_check_timeout_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_timeout_seconds(input);
            self
        }
        /// <p>The number of consecutive health checks successes required before considering an unhealthy
        /// target healthy.</p>
        pub fn healthy_threshold_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.healthy_threshold_count(inp);
            self
        }
        pub fn set_healthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_healthy_threshold_count(input);
            self
        }
        /// <p>The number of consecutive health check failures required before considering the target
        /// unhealthy. For target groups with a protocol of TCP or TLS, this value must be the same as the
        /// healthy threshold count.</p>
        pub fn unhealthy_threshold_count(mut self, inp: i32) -> Self {
            self.inner = self.inner.unhealthy_threshold_count(inp);
            self
        }
        pub fn set_unhealthy_threshold_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_unhealthy_threshold_count(input);
            self
        }
        /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
        /// response from a target.</p>
        /// <p>With Network Load Balancers, you can't modify this setting.</p>
        pub fn matcher(mut self, inp: crate::model::Matcher) -> Self {
            self.inner = self.inner.matcher(inp);
            self
        }
        pub fn set_matcher(mut self, input: std::option::Option<crate::model::Matcher>) -> Self {
            self.inner = self.inner.set_matcher(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTargetGroupAttributes<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::modify_target_group_attributes_input::Builder,
    }
    impl<C, M, R> ModifyTargetGroupAttributes<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTargetGroupAttributesOutput,
            smithy_http::result::SdkError<crate::error::ModifyTargetGroupAttributesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ModifyTargetGroupAttributesInputOperationOutputAlias,
                crate::output::ModifyTargetGroupAttributesOutput,
                crate::error::ModifyTargetGroupAttributesError,
                crate::input::ModifyTargetGroupAttributesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// Appends an item to `Attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        /// <p>The attributes.</p>
        pub fn attributes(mut self, inp: impl Into<crate::model::TargetGroupAttribute>) -> Self {
            self.inner = self.inner.attributes(inp);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetGroupAttribute>>,
        ) -> Self {
            self.inner = self.inner.set_attributes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterTargets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::register_targets_input::Builder,
    }
    impl<C, M, R> RegisterTargets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterTargetsOutput,
            smithy_http::result::SdkError<crate::error::RegisterTargetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RegisterTargetsInputOperationOutputAlias,
                crate::output::RegisterTargetsOutput,
                crate::error::RegisterTargetsError,
                crate::input::RegisterTargetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn target_group_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_arn(inp);
            self
        }
        pub fn set_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_group_arn(input);
            self
        }
        /// Appends an item to `Targets`.
        ///
        /// To override the contents of this collection use [`set_targets`](Self::set_targets).
        /// <p>The targets.</p>
        pub fn targets(mut self, inp: impl Into<crate::model::TargetDescription>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetDescription>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveListenerCertificates<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_listener_certificates_input::Builder,
    }
    impl<C, M, R> RemoveListenerCertificates<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveListenerCertificatesOutput,
            smithy_http::result::SdkError<crate::error::RemoveListenerCertificatesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveListenerCertificatesInputOperationOutputAlias,
                crate::output::RemoveListenerCertificatesOutput,
                crate::error::RemoveListenerCertificatesError,
                crate::input::RemoveListenerCertificatesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        pub fn listener_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.listener_arn(inp);
            self
        }
        pub fn set_listener_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_listener_arn(input);
            self
        }
        /// Appends an item to `Certificates`.
        ///
        /// To override the contents of this collection use [`set_certificates`](Self::set_certificates).
        /// <p>The certificate to remove. You can specify one certificate per call. Set
        /// <code>CertificateArn</code> to the certificate ARN but do not set
        /// <code>IsDefault</code>.</p>
        pub fn certificates(mut self, inp: impl Into<crate::model::Certificate>) -> Self {
            self.inner = self.inner.certificates(inp);
            self
        }
        pub fn set_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Certificate>>,
        ) -> Self {
            self.inner = self.inner.set_certificates(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTags<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_tags_input::Builder,
    }
    impl<C, M, R> RemoveTags<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveTagsInputOperationOutputAlias,
                crate::output::RemoveTagsOutput,
                crate::error::RemoveTagsError,
                crate::input::RemoveTagsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `ResourceArns`.
        ///
        /// To override the contents of this collection use [`set_resource_arns`](Self::set_resource_arns).
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arns(inp);
            self
        }
        pub fn set_resource_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_arns(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>The tag keys for the tags to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetIpAddressType<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_ip_address_type_input::Builder,
    }
    impl<C, M, R> SetIpAddressType<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetIpAddressTypeOutput,
            smithy_http::result::SdkError<crate::error::SetIpAddressTypeError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetIpAddressTypeInputOperationOutputAlias,
                crate::output::SetIpAddressTypeOutput,
                crate::error::SetIpAddressTypeError,
                crate::input::SetIpAddressTypeInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// <p>The IP address type. The possible values are <code>ipv4</code> (for IPv4 addresses) and
        /// <code>dualstack</code> (for IPv4 and IPv6 addresses). Internal load balancers must use
        /// <code>ipv4</code>. You canâ€™t specify <code>dualstack</code> for a load balancer with a UDP
        /// or TCP_UDP listener.</p>
        pub fn ip_address_type(mut self, inp: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(inp);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetRulePriorities<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_rule_priorities_input::Builder,
    }
    impl<C, M, R> SetRulePriorities<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetRulePrioritiesOutput,
            smithy_http::result::SdkError<crate::error::SetRulePrioritiesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetRulePrioritiesInputOperationOutputAlias,
                crate::output::SetRulePrioritiesOutput,
                crate::error::SetRulePrioritiesError,
                crate::input::SetRulePrioritiesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `RulePriorities`.
        ///
        /// To override the contents of this collection use [`set_rule_priorities`](Self::set_rule_priorities).
        /// <p>The rule priorities.</p>
        pub fn rule_priorities(mut self, inp: impl Into<crate::model::RulePriorityPair>) -> Self {
            self.inner = self.inner.rule_priorities(inp);
            self
        }
        pub fn set_rule_priorities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RulePriorityPair>>,
        ) -> Self {
            self.inner = self.inner.set_rule_priorities(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSecurityGroups<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_security_groups_input::Builder,
    }
    impl<C, M, R> SetSecurityGroups<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::SetSecurityGroupsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetSecurityGroupsInputOperationOutputAlias,
                crate::output::SetSecurityGroupsOutput,
                crate::error::SetSecurityGroupsError,
                crate::input::SetSecurityGroupsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// Appends an item to `SecurityGroups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        /// <p>The IDs of the security groups.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetSubnets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::set_subnets_input::Builder,
    }
    impl<C, M, R> SetSubnets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetSubnetsOutput,
            smithy_http::result::SdkError<crate::error::SetSubnetsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SetSubnetsInputOperationOutputAlias,
                crate::output::SetSubnetsOutput,
                crate::error::SetSubnetsError,
                crate::input::SetSubnetsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        pub fn load_balancer_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_arn(inp);
            self
        }
        pub fn set_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_arn(input);
            self
        }
        /// Appends an item to `Subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability
        /// Zones.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// Appends an item to `SubnetMappings`.
        ///
        /// To override the contents of this collection use [`set_subnet_mappings`](Self::set_subnet_mappings).
        /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
        /// must specify either subnets or subnet mappings.</p>
        /// <p>[Application Load Balancers] You must specify subnets from at least two Availability
        /// Zones. You cannot specify Elastic IP addresses for your subnets.</p>
        /// <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
        /// <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
        /// Zones.</p>
        /// <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
        /// can specify one Elastic IP address per subnet if you need static IP addresses for your
        /// internet-facing load balancer. For internal load balancers, you can specify one private IP
        /// address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
        /// can specify one IPv6 address per subnet.</p>
        pub fn subnet_mappings(mut self, inp: impl Into<crate::model::SubnetMapping>) -> Self {
            self.inner = self.inner.subnet_mappings(inp);
            self
        }
        pub fn set_subnet_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SubnetMapping>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_mappings(input);
            self
        }
        /// <p>[Network Load Balancers] The type of IP addresses used by the subnets for your load
        /// balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and
        /// <code>dualstack</code> (for IPv4 and IPv6 addresses). You canâ€™t specify
        /// <code>dualstack</code> for a load balancer with a UDP or TCP_UDP listener. Internal load
        /// balancers must use <code>ipv4</code>.</p>
        pub fn ip_address_type(mut self, inp: crate::model::IpAddressType) -> Self {
            self.inner = self.inner.ip_address_type(inp);
            self
        }
        pub fn set_ip_address_type(
            mut self,
            input: std::option::Option<crate::model::IpAddressType>,
        ) -> Self {
            self.inner = self.inner.set_ip_address_type(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
