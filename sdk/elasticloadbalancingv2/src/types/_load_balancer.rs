// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a load balancer.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct LoadBalancer {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub load_balancer_arn: ::std::option::Option<::std::string::String>,
    /// <p>The public DNS name of the load balancer.</p>
    pub dns_name: ::std::option::Option<::std::string::String>,
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub canonical_hosted_zone_id: ::std::option::Option<::std::string::String>,
    /// <p>The date and time the load balancer was created.</p>
    pub created_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: ::std::option::Option<::std::string::String>,
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.</p>
    /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.</p>
    pub scheme: ::std::option::Option<crate::types::LoadBalancerSchemeEnum>,
    /// <p>The ID of the VPC for the load balancer.</p>
    pub vpc_id: ::std::option::Option<::std::string::String>,
    /// <p>The state of the load balancer.</p>
    pub state: ::std::option::Option<crate::types::LoadBalancerState>,
    /// <p>The type of load balancer.</p>
    pub r#type: ::std::option::Option<crate::types::LoadBalancerTypeEnum>,
    /// <p>The subnets for the load balancer.</p>
    pub availability_zones: ::std::option::Option<::std::vec::Vec<crate::types::AvailabilityZone>>,
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub security_groups: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub ip_address_type: ::std::option::Option<crate::types::IpAddressType>,
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    pub customer_owned_ipv4_pool: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through Amazon Web Services PrivateLink.</p>
    pub enforce_security_group_inbound_rules_on_private_link_traffic: ::std::option::Option<::std::string::String>,
}
impl LoadBalancer {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn load_balancer_arn(&self) -> ::std::option::Option<&str> {
        self.load_balancer_arn.as_deref()
    }
    /// <p>The public DNS name of the load balancer.</p>
    pub fn dns_name(&self) -> ::std::option::Option<&str> {
        self.dns_name.as_deref()
    }
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub fn canonical_hosted_zone_id(&self) -> ::std::option::Option<&str> {
        self.canonical_hosted_zone_id.as_deref()
    }
    /// <p>The date and time the load balancer was created.</p>
    pub fn created_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(&self) -> ::std::option::Option<&str> {
        self.load_balancer_name.as_deref()
    }
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.</p>
    /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.</p>
    pub fn scheme(&self) -> ::std::option::Option<&crate::types::LoadBalancerSchemeEnum> {
        self.scheme.as_ref()
    }
    /// <p>The ID of the VPC for the load balancer.</p>
    pub fn vpc_id(&self) -> ::std::option::Option<&str> {
        self.vpc_id.as_deref()
    }
    /// <p>The state of the load balancer.</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::LoadBalancerState> {
        self.state.as_ref()
    }
    /// <p>The type of load balancer.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::LoadBalancerTypeEnum> {
        self.r#type.as_ref()
    }
    /// <p>The subnets for the load balancer.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.availability_zones.is_none()`.
    pub fn availability_zones(&self) -> &[crate::types::AvailabilityZone] {
        self.availability_zones.as_deref().unwrap_or_default()
    }
    /// <p>The IDs of the security groups for the load balancer.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.security_groups.is_none()`.
    pub fn security_groups(&self) -> &[::std::string::String] {
        self.security_groups.as_deref().unwrap_or_default()
    }
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub fn ip_address_type(&self) -> ::std::option::Option<&crate::types::IpAddressType> {
        self.ip_address_type.as_ref()
    }
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    pub fn customer_owned_ipv4_pool(&self) -> ::std::option::Option<&str> {
        self.customer_owned_ipv4_pool.as_deref()
    }
    /// <p>Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through Amazon Web Services PrivateLink.</p>
    pub fn enforce_security_group_inbound_rules_on_private_link_traffic(&self) -> ::std::option::Option<&str> {
        self.enforce_security_group_inbound_rules_on_private_link_traffic.as_deref()
    }
}
impl LoadBalancer {
    /// Creates a new builder-style object to manufacture [`LoadBalancer`](crate::types::LoadBalancer).
    pub fn builder() -> crate::types::builders::LoadBalancerBuilder {
        crate::types::builders::LoadBalancerBuilder::default()
    }
}

/// A builder for [`LoadBalancer`](crate::types::LoadBalancer).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct LoadBalancerBuilder {
    pub(crate) load_balancer_arn: ::std::option::Option<::std::string::String>,
    pub(crate) dns_name: ::std::option::Option<::std::string::String>,
    pub(crate) canonical_hosted_zone_id: ::std::option::Option<::std::string::String>,
    pub(crate) created_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) load_balancer_name: ::std::option::Option<::std::string::String>,
    pub(crate) scheme: ::std::option::Option<crate::types::LoadBalancerSchemeEnum>,
    pub(crate) vpc_id: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<crate::types::LoadBalancerState>,
    pub(crate) r#type: ::std::option::Option<crate::types::LoadBalancerTypeEnum>,
    pub(crate) availability_zones: ::std::option::Option<::std::vec::Vec<crate::types::AvailabilityZone>>,
    pub(crate) security_groups: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) ip_address_type: ::std::option::Option<crate::types::IpAddressType>,
    pub(crate) customer_owned_ipv4_pool: ::std::option::Option<::std::string::String>,
    pub(crate) enforce_security_group_inbound_rules_on_private_link_traffic: ::std::option::Option<::std::string::String>,
}
impl LoadBalancerBuilder {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn load_balancer_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.load_balancer_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn set_load_balancer_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.load_balancer_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    pub fn get_load_balancer_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.load_balancer_arn
    }
    /// <p>The public DNS name of the load balancer.</p>
    pub fn dns_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dns_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The public DNS name of the load balancer.</p>
    pub fn set_dns_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dns_name = input;
        self
    }
    /// <p>The public DNS name of the load balancer.</p>
    pub fn get_dns_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.dns_name
    }
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub fn canonical_hosted_zone_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.canonical_hosted_zone_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub fn set_canonical_hosted_zone_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.canonical_hosted_zone_id = input;
        self
    }
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    pub fn get_canonical_hosted_zone_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.canonical_hosted_zone_id
    }
    /// <p>The date and time the load balancer was created.</p>
    pub fn created_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the load balancer was created.</p>
    pub fn set_created_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_time = input;
        self
    }
    /// <p>The date and time the load balancer was created.</p>
    pub fn get_created_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_time
    }
    /// <p>The name of the load balancer.</p>
    pub fn load_balancer_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.load_balancer_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the load balancer.</p>
    pub fn set_load_balancer_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.load_balancer_name = input;
        self
    }
    /// <p>The name of the load balancer.</p>
    pub fn get_load_balancer_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.load_balancer_name
    }
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.</p>
    /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.</p>
    pub fn scheme(mut self, input: crate::types::LoadBalancerSchemeEnum) -> Self {
        self.scheme = ::std::option::Option::Some(input);
        self
    }
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.</p>
    /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.</p>
    pub fn set_scheme(mut self, input: ::std::option::Option<crate::types::LoadBalancerSchemeEnum>) -> Self {
        self.scheme = input;
        self
    }
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet.</p>
    /// <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer.</p>
    pub fn get_scheme(&self) -> &::std::option::Option<crate::types::LoadBalancerSchemeEnum> {
        &self.scheme
    }
    /// <p>The ID of the VPC for the load balancer.</p>
    pub fn vpc_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vpc_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ID of the VPC for the load balancer.</p>
    pub fn set_vpc_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vpc_id = input;
        self
    }
    /// <p>The ID of the VPC for the load balancer.</p>
    pub fn get_vpc_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.vpc_id
    }
    /// <p>The state of the load balancer.</p>
    pub fn state(mut self, input: crate::types::LoadBalancerState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of the load balancer.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::LoadBalancerState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The state of the load balancer.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::LoadBalancerState> {
        &self.state
    }
    /// <p>The type of load balancer.</p>
    pub fn r#type(mut self, input: crate::types::LoadBalancerTypeEnum) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of load balancer.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::LoadBalancerTypeEnum>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of load balancer.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::LoadBalancerTypeEnum> {
        &self.r#type
    }
    /// Appends an item to `availability_zones`.
    ///
    /// To override the contents of this collection use [`set_availability_zones`](Self::set_availability_zones).
    ///
    /// <p>The subnets for the load balancer.</p>
    pub fn availability_zones(mut self, input: crate::types::AvailabilityZone) -> Self {
        let mut v = self.availability_zones.unwrap_or_default();
        v.push(input);
        self.availability_zones = ::std::option::Option::Some(v);
        self
    }
    /// <p>The subnets for the load balancer.</p>
    pub fn set_availability_zones(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AvailabilityZone>>) -> Self {
        self.availability_zones = input;
        self
    }
    /// <p>The subnets for the load balancer.</p>
    pub fn get_availability_zones(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AvailabilityZone>> {
        &self.availability_zones
    }
    /// Appends an item to `security_groups`.
    ///
    /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
    ///
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub fn security_groups(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.security_groups.unwrap_or_default();
        v.push(input.into());
        self.security_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub fn set_security_groups(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.security_groups = input;
        self
    }
    /// <p>The IDs of the security groups for the load balancer.</p>
    pub fn get_security_groups(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.security_groups
    }
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub fn ip_address_type(mut self, input: crate::types::IpAddressType) -> Self {
        self.ip_address_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub fn set_ip_address_type(mut self, input: ::std::option::Option<crate::types::IpAddressType>) -> Self {
        self.ip_address_type = input;
        self
    }
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6 addresses).</p>
    pub fn get_ip_address_type(&self) -> &::std::option::Option<crate::types::IpAddressType> {
        &self.ip_address_type
    }
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    pub fn customer_owned_ipv4_pool(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.customer_owned_ipv4_pool = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    pub fn set_customer_owned_ipv4_pool(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.customer_owned_ipv4_pool = input;
        self
    }
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    pub fn get_customer_owned_ipv4_pool(&self) -> &::std::option::Option<::std::string::String> {
        &self.customer_owned_ipv4_pool
    }
    /// <p>Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through Amazon Web Services PrivateLink.</p>
    pub fn enforce_security_group_inbound_rules_on_private_link_traffic(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.enforce_security_group_inbound_rules_on_private_link_traffic = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through Amazon Web Services PrivateLink.</p>
    pub fn set_enforce_security_group_inbound_rules_on_private_link_traffic(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.enforce_security_group_inbound_rules_on_private_link_traffic = input;
        self
    }
    /// <p>Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through Amazon Web Services PrivateLink.</p>
    pub fn get_enforce_security_group_inbound_rules_on_private_link_traffic(&self) -> &::std::option::Option<::std::string::String> {
        &self.enforce_security_group_inbound_rules_on_private_link_traffic
    }
    /// Consumes the builder and constructs a [`LoadBalancer`](crate::types::LoadBalancer).
    pub fn build(self) -> crate::types::LoadBalancer {
        crate::types::LoadBalancer {
            load_balancer_arn: self.load_balancer_arn,
            dns_name: self.dns_name,
            canonical_hosted_zone_id: self.canonical_hosted_zone_id,
            created_time: self.created_time,
            load_balancer_name: self.load_balancer_name,
            scheme: self.scheme,
            vpc_id: self.vpc_id,
            state: self.state,
            r#type: self.r#type,
            availability_zones: self.availability_zones,
            security_groups: self.security_groups,
            ip_address_type: self.ip_address_type,
            customer_owned_ipv4_pool: self.customer_owned_ipv4_pool,
            enforce_security_group_inbound_rules_on_private_link_traffic: self.enforce_security_group_inbound_rules_on_private_link_traffic,
        }
    }
}
