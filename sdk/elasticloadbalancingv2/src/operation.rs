// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds the specified SSL server certificate to the certificate list for the specified HTTPS
/// or TLS listener.</p>
/// <p>If the certificate in already in the certificate list, the call is successful but the
/// certificate is not added again.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html">HTTPS
/// listeners</a> in the <i>Application Load Balancers Guide</i> or <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html">TLS
/// listeners</a> in the <i>Network Load Balancers Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddListenerCertificates {
    _private: (),
}
impl AddListenerCertificates {
    /// Creates a new builder-style object to manufacture [`AddListenerCertificatesInput`](crate::input::AddListenerCertificatesInput)
    pub fn builder() -> crate::input::add_listener_certificates_input::Builder {
        crate::input::add_listener_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddListenerCertificates {
    type Output = std::result::Result<
        crate::output::AddListenerCertificatesOutput,
        crate::error::AddListenerCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_listener_certificates_error(response)
        } else {
            crate::operation_deser::parse_add_listener_certificates_response(response)
        }
    }
}

/// <p>Adds the specified tags to the specified Elastic Load Balancing resource. You can tag your
/// Application Load Balancers, Network Load Balancers, Gateway Load Balancers, target groups,
/// listeners, and rules.</p>
/// <p>Each tag consists of a key and an optional value. If a resource already has a tag with the
/// same key, <code>AddTags</code> updates its value.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTags {
    _private: (),
}
impl AddTags {
    /// Creates a new builder-style object to manufacture [`AddTagsInput`](crate::input::AddTagsInput)
    pub fn builder() -> crate::input::add_tags_input::Builder {
        crate::input::add_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTags {
    type Output = std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_tags_error(response)
        } else {
            crate::operation_deser::parse_add_tags_response(response)
        }
    }
}

/// <p>Creates a listener for the specified Application Load Balancer, Network Load Balancer, or
/// Gateway Load Balancer.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html">Listeners for
/// your Application Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-listeners.html">Listeners for
/// your Network Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/gateway-listeners.html">Listeners for your
/// Gateway Load Balancers</a>
/// </p>
/// </li>
/// </ul>
/// <p>This operation is idempotent, which means that it completes at most one time. If you
/// attempt to create multiple listeners with the same settings, each call succeeds.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateListener {
    _private: (),
}
impl CreateListener {
    /// Creates a new builder-style object to manufacture [`CreateListenerInput`](crate::input::CreateListenerInput)
    pub fn builder() -> crate::input::create_listener_input::Builder {
        crate::input::create_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateListener {
    type Output =
        std::result::Result<crate::output::CreateListenerOutput, crate::error::CreateListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_listener_error(response)
        } else {
            crate::operation_deser::parse_create_listener_response(response)
        }
    }
}

/// <p>Creates an Application Load Balancer, Network Load Balancer, or Gateway Load
/// Balancer.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html">Application Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html">Network Load
/// Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/gateway-load-balancers.html">Gateway Load
/// Balancers</a>
/// </p>
/// </li>
/// </ul>
/// <p>This operation is idempotent, which means that it completes at most one time. If you
/// attempt to create multiple load balancers with the same settings, each call succeeds.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLoadBalancer {
    _private: (),
}
impl CreateLoadBalancer {
    /// Creates a new builder-style object to manufacture [`CreateLoadBalancerInput`](crate::input::CreateLoadBalancerInput)
    pub fn builder() -> crate::input::create_load_balancer_input::Builder {
        crate::input::create_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLoadBalancer {
    type Output = std::result::Result<
        crate::output::CreateLoadBalancerOutput,
        crate::error::CreateLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_create_load_balancer_response(response)
        }
    }
}

/// <p>Creates a rule for the specified listener. The listener must be associated with an
/// Application Load Balancer.</p>
/// <p>Each rule consists of a priority, one or more actions, and one or more conditions. Rules
/// are evaluated in priority order, from the lowest value to the highest value. When the
/// conditions for a rule are met, its actions are performed. If the conditions for no rules are
/// met, the actions for the default rule are performed. For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html#listener-rules">Listener rules</a> in the <i>Application Load Balancers Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRule {
    _private: (),
}
impl CreateRule {
    /// Creates a new builder-style object to manufacture [`CreateRuleInput`](crate::input::CreateRuleInput)
    pub fn builder() -> crate::input::create_rule_input::Builder {
        crate::input::create_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRule {
    type Output =
        std::result::Result<crate::output::CreateRuleOutput, crate::error::CreateRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_rule_error(response)
        } else {
            crate::operation_deser::parse_create_rule_response(response)
        }
    }
}

/// <p>Creates a target group.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html">Target
/// groups for your Application Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html">Target groups
/// for your Network Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/target-groups.html">Target groups for your
/// Gateway Load Balancers</a>
/// </p>
/// </li>
/// </ul>
/// <p>This operation is idempotent, which means that it completes at most one time. If you
/// attempt to create multiple target groups with the same settings, each call succeeds.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTargetGroup {
    _private: (),
}
impl CreateTargetGroup {
    /// Creates a new builder-style object to manufacture [`CreateTargetGroupInput`](crate::input::CreateTargetGroupInput)
    pub fn builder() -> crate::input::create_target_group_input::Builder {
        crate::input::create_target_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTargetGroup {
    type Output = std::result::Result<
        crate::output::CreateTargetGroupOutput,
        crate::error::CreateTargetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_target_group_error(response)
        } else {
            crate::operation_deser::parse_create_target_group_response(response)
        }
    }
}

/// <p>Deletes the specified listener.</p>
/// <p>Alternatively, your listener is deleted when you delete the load balancer to which it is
/// attached.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteListener {
    _private: (),
}
impl DeleteListener {
    /// Creates a new builder-style object to manufacture [`DeleteListenerInput`](crate::input::DeleteListenerInput)
    pub fn builder() -> crate::input::delete_listener_input::Builder {
        crate::input::delete_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteListener {
    type Output =
        std::result::Result<crate::output::DeleteListenerOutput, crate::error::DeleteListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_listener_error(response)
        } else {
            crate::operation_deser::parse_delete_listener_response(response)
        }
    }
}

/// <p>Deletes the specified Application Load Balancer, Network Load Balancer, or Gateway Load
/// Balancer. Deleting a load balancer also deletes its listeners.</p>
/// <p>You can't delete a load balancer if deletion protection is enabled. If the load balancer
/// does not exist or has already been deleted, the call succeeds.</p>
/// <p>Deleting a load balancer does not affect its registered targets. For example, your EC2
/// instances continue to run and are still registered to their target groups. If you no longer
/// need these EC2 instances, you can stop or terminate them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLoadBalancer {
    _private: (),
}
impl DeleteLoadBalancer {
    /// Creates a new builder-style object to manufacture [`DeleteLoadBalancerInput`](crate::input::DeleteLoadBalancerInput)
    pub fn builder() -> crate::input::delete_load_balancer_input::Builder {
        crate::input::delete_load_balancer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLoadBalancer {
    type Output = std::result::Result<
        crate::output::DeleteLoadBalancerOutput,
        crate::error::DeleteLoadBalancerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_load_balancer_error(response)
        } else {
            crate::operation_deser::parse_delete_load_balancer_response(response)
        }
    }
}

/// <p>Deletes the specified rule.</p>
/// <p>You can't delete the default rule.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRule {
    _private: (),
}
impl DeleteRule {
    /// Creates a new builder-style object to manufacture [`DeleteRuleInput`](crate::input::DeleteRuleInput)
    pub fn builder() -> crate::input::delete_rule_input::Builder {
        crate::input::delete_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRule {
    type Output =
        std::result::Result<crate::output::DeleteRuleOutput, crate::error::DeleteRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_rule_response(response)
        }
    }
}

/// <p>Deletes the specified target group.</p>
/// <p>You can delete a target group if it is not referenced by any actions. Deleting a target
/// group also deletes any associated health checks. Deleting a target group does not affect its
/// registered targets. For example, any EC2 instances continue to run until you stop or terminate
/// them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTargetGroup {
    _private: (),
}
impl DeleteTargetGroup {
    /// Creates a new builder-style object to manufacture [`DeleteTargetGroupInput`](crate::input::DeleteTargetGroupInput)
    pub fn builder() -> crate::input::delete_target_group_input::Builder {
        crate::input::delete_target_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTargetGroup {
    type Output = std::result::Result<
        crate::output::DeleteTargetGroupOutput,
        crate::error::DeleteTargetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_target_group_error(response)
        } else {
            crate::operation_deser::parse_delete_target_group_response(response)
        }
    }
}

/// <p>Deregisters the specified targets from the specified target group. After the targets are
/// deregistered, they no longer receive traffic from the load balancer.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterTargets {
    _private: (),
}
impl DeregisterTargets {
    /// Creates a new builder-style object to manufacture [`DeregisterTargetsInput`](crate::input::DeregisterTargetsInput)
    pub fn builder() -> crate::input::deregister_targets_input::Builder {
        crate::input::deregister_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterTargets {
    type Output = std::result::Result<
        crate::output::DeregisterTargetsOutput,
        crate::error::DeregisterTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_targets_error(response)
        } else {
            crate::operation_deser::parse_deregister_targets_response(response)
        }
    }
}

/// <p>Describes the current Elastic Load Balancing resource limits for your Amazon Web Services
/// account.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-limits.html">Quotas for your
/// Application Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-limits.html">Quotas for your
/// Network Load Balancers</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/quotas-limits.html">Quotas for your Gateway
/// Load Balancers</a>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountLimits {
    _private: (),
}
impl DescribeAccountLimits {
    /// Creates a new builder-style object to manufacture [`DescribeAccountLimitsInput`](crate::input::DescribeAccountLimitsInput)
    pub fn builder() -> crate::input::describe_account_limits_input::Builder {
        crate::input::describe_account_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountLimits {
    type Output = std::result::Result<
        crate::output::DescribeAccountLimitsOutput,
        crate::error::DescribeAccountLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_limits_error(response)
        } else {
            crate::operation_deser::parse_describe_account_limits_response(response)
        }
    }
}

/// <p>Describes the default certificate and the certificate list for the specified HTTPS or TLS
/// listener.</p>
/// <p>If the default certificate is also in the certificate list, it appears twice in the
/// results (once with <code>IsDefault</code> set to true and once with <code>IsDefault</code> set
/// to false).</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#https-listener-certificates">SSL certificates</a> in the <i>Application Load Balancers Guide</i> or
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#tls-listener-certificate">Server certificates</a> in the <i>Network Load Balancers
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeListenerCertificates {
    _private: (),
}
impl DescribeListenerCertificates {
    /// Creates a new builder-style object to manufacture [`DescribeListenerCertificatesInput`](crate::input::DescribeListenerCertificatesInput)
    pub fn builder() -> crate::input::describe_listener_certificates_input::Builder {
        crate::input::describe_listener_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeListenerCertificates {
    type Output = std::result::Result<
        crate::output::DescribeListenerCertificatesOutput,
        crate::error::DescribeListenerCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_listener_certificates_error(response)
        } else {
            crate::operation_deser::parse_describe_listener_certificates_response(response)
        }
    }
}

/// <p>Describes the specified listeners or the listeners for the specified Application Load
/// Balancer, Network Load Balancer, or Gateway Load Balancer. You must specify either a load
/// balancer or one or more listeners.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeListeners {
    _private: (),
}
impl DescribeListeners {
    /// Creates a new builder-style object to manufacture [`DescribeListenersInput`](crate::input::DescribeListenersInput)
    pub fn builder() -> crate::input::describe_listeners_input::Builder {
        crate::input::describe_listeners_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeListeners {
    type Output = std::result::Result<
        crate::output::DescribeListenersOutput,
        crate::error::DescribeListenersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_listeners_error(response)
        } else {
            crate::operation_deser::parse_describe_listeners_response(response)
        }
    }
}

/// <p>Describes the attributes for the specified Application Load Balancer, Network Load
/// Balancer, or Gateway Load Balancer.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes">Load balancer attributes</a> in the <i>Application Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#load-balancer-attributes">Load balancer attributes</a> in the <i>Network Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/gateway-load-balancers.html#load-balancer-attributes">Load balancer attributes</a> in the <i>Gateway Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLoadBalancerAttributes {
    _private: (),
}
impl DescribeLoadBalancerAttributes {
    /// Creates a new builder-style object to manufacture [`DescribeLoadBalancerAttributesInput`](crate::input::DescribeLoadBalancerAttributesInput)
    pub fn builder() -> crate::input::describe_load_balancer_attributes_input::Builder {
        crate::input::describe_load_balancer_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLoadBalancerAttributes {
    type Output = std::result::Result<
        crate::output::DescribeLoadBalancerAttributesOutput,
        crate::error::DescribeLoadBalancerAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_load_balancer_attributes_error(response)
        } else {
            crate::operation_deser::parse_describe_load_balancer_attributes_response(response)
        }
    }
}

/// <p>Describes the specified load balancers or all of your load balancers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLoadBalancers {
    _private: (),
}
impl DescribeLoadBalancers {
    /// Creates a new builder-style object to manufacture [`DescribeLoadBalancersInput`](crate::input::DescribeLoadBalancersInput)
    pub fn builder() -> crate::input::describe_load_balancers_input::Builder {
        crate::input::describe_load_balancers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLoadBalancers {
    type Output = std::result::Result<
        crate::output::DescribeLoadBalancersOutput,
        crate::error::DescribeLoadBalancersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_load_balancers_error(response)
        } else {
            crate::operation_deser::parse_describe_load_balancers_response(response)
        }
    }
}

/// <p>Describes the specified rules or the rules for the specified listener. You must specify
/// either a listener or one or more rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRules {
    _private: (),
}
impl DescribeRules {
    /// Creates a new builder-style object to manufacture [`DescribeRulesInput`](crate::input::DescribeRulesInput)
    pub fn builder() -> crate::input::describe_rules_input::Builder {
        crate::input::describe_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRules {
    type Output =
        std::result::Result<crate::output::DescribeRulesOutput, crate::error::DescribeRulesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_rules_error(response)
        } else {
            crate::operation_deser::parse_describe_rules_response(response)
        }
    }
}

/// <p>Describes the specified policies or all policies used for SSL negotiation.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> or
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSSLPolicies {
    _private: (),
}
impl DescribeSSLPolicies {
    /// Creates a new builder-style object to manufacture [`DescribeSslPoliciesInput`](crate::input::DescribeSslPoliciesInput)
    pub fn builder() -> crate::input::describe_ssl_policies_input::Builder {
        crate::input::describe_ssl_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSSLPolicies {
    type Output = std::result::Result<
        crate::output::DescribeSslPoliciesOutput,
        crate::error::DescribeSSLPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_ssl_policies_error(response)
        } else {
            crate::operation_deser::parse_describe_ssl_policies_response(response)
        }
    }
}

/// <p>Describes the tags for the specified Elastic Load Balancing resources. You can describe
/// the tags for one or more Application Load Balancers, Network Load Balancers, Gateway Load
/// Balancers, target groups, listeners, or rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTags {
    _private: (),
}
impl DescribeTags {
    /// Creates a new builder-style object to manufacture [`DescribeTagsInput`](crate::input::DescribeTagsInput)
    pub fn builder() -> crate::input::describe_tags_input::Builder {
        crate::input::describe_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTags {
    type Output =
        std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tags_error(response)
        } else {
            crate::operation_deser::parse_describe_tags_response(response)
        }
    }
}

/// <p>Describes the attributes for the specified target group.</p>
/// <p>For more information, see the following:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes">Target group attributes</a> in the <i>Application Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#target-group-attributes">Target group attributes</a> in the <i>Network Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/target-groups.html#target-group-attributes">Target group attributes</a> in the <i>Gateway Load Balancers
/// Guide</i>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTargetGroupAttributes {
    _private: (),
}
impl DescribeTargetGroupAttributes {
    /// Creates a new builder-style object to manufacture [`DescribeTargetGroupAttributesInput`](crate::input::DescribeTargetGroupAttributesInput)
    pub fn builder() -> crate::input::describe_target_group_attributes_input::Builder {
        crate::input::describe_target_group_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTargetGroupAttributes {
    type Output = std::result::Result<
        crate::output::DescribeTargetGroupAttributesOutput,
        crate::error::DescribeTargetGroupAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_target_group_attributes_error(response)
        } else {
            crate::operation_deser::parse_describe_target_group_attributes_response(response)
        }
    }
}

/// <p>Describes the specified target groups or all of your target groups. By default, all target
/// groups are described. Alternatively, you can specify one of the following to filter the
/// results: the ARN of the load balancer, the names of one or more target groups, or the ARNs of
/// one or more target groups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTargetGroups {
    _private: (),
}
impl DescribeTargetGroups {
    /// Creates a new builder-style object to manufacture [`DescribeTargetGroupsInput`](crate::input::DescribeTargetGroupsInput)
    pub fn builder() -> crate::input::describe_target_groups_input::Builder {
        crate::input::describe_target_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTargetGroups {
    type Output = std::result::Result<
        crate::output::DescribeTargetGroupsOutput,
        crate::error::DescribeTargetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_target_groups_error(response)
        } else {
            crate::operation_deser::parse_describe_target_groups_response(response)
        }
    }
}

/// <p>Describes the health of the specified targets or all of your targets.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTargetHealth {
    _private: (),
}
impl DescribeTargetHealth {
    /// Creates a new builder-style object to manufacture [`DescribeTargetHealthInput`](crate::input::DescribeTargetHealthInput)
    pub fn builder() -> crate::input::describe_target_health_input::Builder {
        crate::input::describe_target_health_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTargetHealth {
    type Output = std::result::Result<
        crate::output::DescribeTargetHealthOutput,
        crate::error::DescribeTargetHealthError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_target_health_error(response)
        } else {
            crate::operation_deser::parse_describe_target_health_response(response)
        }
    }
}

/// <p>Replaces the specified properties of the specified listener. Any properties that you do
/// not specify remain unchanged.</p>
/// <p>Changing the protocol from HTTPS to HTTP, or from TLS to TCP, removes the security policy
/// and default certificate properties. If you change the protocol from HTTP to HTTPS, or from TCP
/// to TLS, you must add the security policy and default certificate properties.</p>
/// <p>To add an item to a list, remove an item from a list, or update an item in a list, you
/// must provide the entire list. For example, to add an action, specify a list with the current
/// actions plus the new action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyListener {
    _private: (),
}
impl ModifyListener {
    /// Creates a new builder-style object to manufacture [`ModifyListenerInput`](crate::input::ModifyListenerInput)
    pub fn builder() -> crate::input::modify_listener_input::Builder {
        crate::input::modify_listener_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyListener {
    type Output =
        std::result::Result<crate::output::ModifyListenerOutput, crate::error::ModifyListenerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_listener_error(response)
        } else {
            crate::operation_deser::parse_modify_listener_response(response)
        }
    }
}

/// <p>Modifies the specified attributes of the specified Application Load Balancer, Network Load
/// Balancer, or Gateway Load Balancer.</p>
/// <p>If any of the specified attributes can't be modified as requested, the call fails. Any
/// existing attributes that you do not modify retain their current values.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyLoadBalancerAttributes {
    _private: (),
}
impl ModifyLoadBalancerAttributes {
    /// Creates a new builder-style object to manufacture [`ModifyLoadBalancerAttributesInput`](crate::input::ModifyLoadBalancerAttributesInput)
    pub fn builder() -> crate::input::modify_load_balancer_attributes_input::Builder {
        crate::input::modify_load_balancer_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyLoadBalancerAttributes {
    type Output = std::result::Result<
        crate::output::ModifyLoadBalancerAttributesOutput,
        crate::error::ModifyLoadBalancerAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_load_balancer_attributes_error(response)
        } else {
            crate::operation_deser::parse_modify_load_balancer_attributes_response(response)
        }
    }
}

/// <p>Replaces the specified properties of the specified rule. Any properties that you do not
/// specify are unchanged.</p>
/// <p>To add an item to a list, remove an item from a list, or update an item in a list, you
/// must provide the entire list. For example, to add an action, specify a list with the current
/// actions plus the new action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyRule {
    _private: (),
}
impl ModifyRule {
    /// Creates a new builder-style object to manufacture [`ModifyRuleInput`](crate::input::ModifyRuleInput)
    pub fn builder() -> crate::input::modify_rule_input::Builder {
        crate::input::modify_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyRule {
    type Output =
        std::result::Result<crate::output::ModifyRuleOutput, crate::error::ModifyRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_rule_error(response)
        } else {
            crate::operation_deser::parse_modify_rule_response(response)
        }
    }
}

/// <p>Modifies the health checks used when evaluating the health state of the targets in the
/// specified target group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyTargetGroup {
    _private: (),
}
impl ModifyTargetGroup {
    /// Creates a new builder-style object to manufacture [`ModifyTargetGroupInput`](crate::input::ModifyTargetGroupInput)
    pub fn builder() -> crate::input::modify_target_group_input::Builder {
        crate::input::modify_target_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyTargetGroup {
    type Output = std::result::Result<
        crate::output::ModifyTargetGroupOutput,
        crate::error::ModifyTargetGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_target_group_error(response)
        } else {
            crate::operation_deser::parse_modify_target_group_response(response)
        }
    }
}

/// <p>Modifies the specified attributes of the specified target group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyTargetGroupAttributes {
    _private: (),
}
impl ModifyTargetGroupAttributes {
    /// Creates a new builder-style object to manufacture [`ModifyTargetGroupAttributesInput`](crate::input::ModifyTargetGroupAttributesInput)
    pub fn builder() -> crate::input::modify_target_group_attributes_input::Builder {
        crate::input::modify_target_group_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyTargetGroupAttributes {
    type Output = std::result::Result<
        crate::output::ModifyTargetGroupAttributesOutput,
        crate::error::ModifyTargetGroupAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_target_group_attributes_error(response)
        } else {
            crate::operation_deser::parse_modify_target_group_attributes_response(response)
        }
    }
}

/// <p>Registers the specified targets with the specified target group.</p>
/// <p>If the target is an EC2 instance, it must be in the <code>running</code> state when you
/// register it.</p>
/// <p>By default, the load balancer routes requests to registered targets using the protocol and
/// port for the target group. Alternatively, you can override the port for a target when you
/// register it. You can register each EC2 instance or IP address with the same target group
/// multiple times using different ports.</p>
/// <p>With a Network Load Balancer, you cannot register instances by instance ID if they have
/// the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3,
/// and T1. You can register instances of these types by IP address.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterTargets {
    _private: (),
}
impl RegisterTargets {
    /// Creates a new builder-style object to manufacture [`RegisterTargetsInput`](crate::input::RegisterTargetsInput)
    pub fn builder() -> crate::input::register_targets_input::Builder {
        crate::input::register_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterTargets {
    type Output = std::result::Result<
        crate::output::RegisterTargetsOutput,
        crate::error::RegisterTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_targets_error(response)
        } else {
            crate::operation_deser::parse_register_targets_response(response)
        }
    }
}

/// <p>Removes the specified certificate from the certificate list for the specified HTTPS or TLS
/// listener.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveListenerCertificates {
    _private: (),
}
impl RemoveListenerCertificates {
    /// Creates a new builder-style object to manufacture [`RemoveListenerCertificatesInput`](crate::input::RemoveListenerCertificatesInput)
    pub fn builder() -> crate::input::remove_listener_certificates_input::Builder {
        crate::input::remove_listener_certificates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveListenerCertificates {
    type Output = std::result::Result<
        crate::output::RemoveListenerCertificatesOutput,
        crate::error::RemoveListenerCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_listener_certificates_error(response)
        } else {
            crate::operation_deser::parse_remove_listener_certificates_response(response)
        }
    }
}

/// <p>Removes the specified tags from the specified Elastic Load Balancing resources. You can
/// remove the tags for one or more Application Load Balancers, Network Load Balancers, Gateway
/// Load Balancers, target groups, listeners, or rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTags {
    _private: (),
}
impl RemoveTags {
    /// Creates a new builder-style object to manufacture [`RemoveTagsInput`](crate::input::RemoveTagsInput)
    pub fn builder() -> crate::input::remove_tags_input::Builder {
        crate::input::remove_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTags {
    type Output =
        std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_tags_error(response)
        } else {
            crate::operation_deser::parse_remove_tags_response(response)
        }
    }
}

/// <p>Sets the type of IP addresses used by the subnets of the specified Application Load
/// Balancer or Network Load Balancer.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetIpAddressType {
    _private: (),
}
impl SetIpAddressType {
    /// Creates a new builder-style object to manufacture [`SetIpAddressTypeInput`](crate::input::SetIpAddressTypeInput)
    pub fn builder() -> crate::input::set_ip_address_type_input::Builder {
        crate::input::set_ip_address_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetIpAddressType {
    type Output = std::result::Result<
        crate::output::SetIpAddressTypeOutput,
        crate::error::SetIpAddressTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_ip_address_type_error(response)
        } else {
            crate::operation_deser::parse_set_ip_address_type_response(response)
        }
    }
}

/// <p>Sets the priorities of the specified rules.</p>
/// <p>You can reorder the rules as long as there are no priority conflicts in the new order. Any
/// existing rules that you do not specify retain their current priority.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetRulePriorities {
    _private: (),
}
impl SetRulePriorities {
    /// Creates a new builder-style object to manufacture [`SetRulePrioritiesInput`](crate::input::SetRulePrioritiesInput)
    pub fn builder() -> crate::input::set_rule_priorities_input::Builder {
        crate::input::set_rule_priorities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetRulePriorities {
    type Output = std::result::Result<
        crate::output::SetRulePrioritiesOutput,
        crate::error::SetRulePrioritiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_rule_priorities_error(response)
        } else {
            crate::operation_deser::parse_set_rule_priorities_response(response)
        }
    }
}

/// <p>Associates the specified security groups with the specified Application Load Balancer. The
/// specified security groups override the previously associated security groups.</p>
/// <p>You can't specify a security group for a Network Load Balancer or Gateway Load
/// Balancer.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetSecurityGroups {
    _private: (),
}
impl SetSecurityGroups {
    /// Creates a new builder-style object to manufacture [`SetSecurityGroupsInput`](crate::input::SetSecurityGroupsInput)
    pub fn builder() -> crate::input::set_security_groups_input::Builder {
        crate::input::set_security_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetSecurityGroups {
    type Output = std::result::Result<
        crate::output::SetSecurityGroupsOutput,
        crate::error::SetSecurityGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_security_groups_error(response)
        } else {
            crate::operation_deser::parse_set_security_groups_response(response)
        }
    }
}

/// <p>Enables the Availability Zones for the specified public subnets for the specified
/// Application Load Balancer or Network Load Balancer. The specified subnets replace the
/// previously enabled subnets.</p>
/// <p>When you specify subnets for a Network Load Balancer, you must include all subnets that
/// were enabled previously, with their existing configurations, plus any additional
/// subnets.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetSubnets {
    _private: (),
}
impl SetSubnets {
    /// Creates a new builder-style object to manufacture [`SetSubnetsInput`](crate::input::SetSubnetsInput)
    pub fn builder() -> crate::input::set_subnets_input::Builder {
        crate::input::set_subnets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetSubnets {
    type Output =
        std::result::Result<crate::output::SetSubnetsOutput, crate::error::SetSubnetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_subnets_error(response)
        } else {
            crate::operation_deser::parse_set_subnets_response(response)
        }
    }
}
