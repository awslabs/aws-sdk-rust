// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>There is another ongoing conflicting backup control plane operation on the table. The backup is either being created, deleted or restored to a table.</p>
    BackupInUseException(crate::error::BackupInUseException),
    /// <p>Backup not found for the given BackupARN. </p>
    BackupNotFoundException(crate::error::BackupNotFoundException),
    /// <p>A condition specified in the operation could not be evaluated.</p>
    ConditionalCheckFailedException(crate::error::ConditionalCheckFailedException),
    /// <p>Backups have not yet been enabled for this table.</p>
    ContinuousBackupsUnavailableException(crate::error::ContinuousBackupsUnavailableException),
    /// <p> There was an attempt to insert an item with the same primary key as an item that already exists in the DynamoDB table.</p>
    DuplicateItemException(crate::error::DuplicateItemException),
    /// <p>There was a conflict when writing to the specified S3 bucket.</p>
    ExportConflictException(crate::error::ExportConflictException),
    /// <p>The specified export was not found.</p>
    ExportNotFoundException(crate::error::ExportNotFoundException),
    /// <p>The specified global table already exists.</p>
    GlobalTableAlreadyExistsException(crate::error::GlobalTableAlreadyExistsException),
    /// <p>The specified global table does not exist.</p>
    GlobalTableNotFoundException(crate::error::GlobalTableNotFoundException),
    /// <p>DynamoDB rejected the request because you retried a request with a different payload but with an idempotent token that was already used.</p>
    IdempotentParameterMismatchException(crate::error::IdempotentParameterMismatchException),
    /// <p> There was a conflict when importing from the specified S3 source. This can occur when the current import conflicts with a previous import request that had the same client token. </p>
    ImportConflictException(crate::error::ImportConflictException),
    /// <p> The specified import was not found. </p>
    ImportNotFoundException(crate::error::ImportNotFoundException),
    /// <p>The operation tried to access a nonexistent index.</p>
    IndexNotFoundException(crate::error::IndexNotFoundException),
    /// <p>An error occurred on the server side.</p>
    InternalServerError(crate::error::InternalServerError),
    #[allow(missing_docs)] // documentation missing in model
    InvalidEndpointException(crate::error::InvalidEndpointException),
    /// <p>The specified <code>ExportTime</code> is outside of the point in time recovery window.</p>
    InvalidExportTimeException(crate::error::InvalidExportTimeException),
    /// <p>An invalid restore time was specified. RestoreDateTime must be between EarliestRestorableDateTime and LatestRestorableDateTime.</p>
    InvalidRestoreTimeException(crate::error::InvalidRestoreTimeException),
    /// <p>An item collection is too large. This exception is only returned for tables that have one or more local secondary indexes.</p>
    ItemCollectionSizeLimitExceededException(
        crate::error::ItemCollectionSizeLimitExceededException,
    ),
    /// <p>There is no limit to the number of daily on-demand backups that can be taken. </p>
    /// <p>For most purposes, up to 500 simultaneous table operations are allowed per account. These operations include <code>CreateTable</code>, <code>UpdateTable</code>, <code>DeleteTable</code>,<code>UpdateTimeToLive</code>, <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>. </p>
    /// <p>When you are creating a table with one or more secondary indexes, you can have up to 250 such requests running at a time. However, if the table or index specifications are complex, then DynamoDB might temporarily reduce the number of concurrent operations.</p>
    /// <p>When importing into DynamoDB, up to 50 simultaneous import table operations are allowed per account.</p>
    /// <p>There is a soft account quota of 2,500 tables.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>Point in time recovery has not yet been enabled for this source table.</p>
    PointInTimeRecoveryUnavailableException(crate::error::PointInTimeRecoveryUnavailableException),
    /// <p>Your request rate is too high. The Amazon Web Services SDKs for DynamoDB automatically retry requests that receive this exception. Your request is eventually successful, unless your retry queue is too large to finish. Reduce the frequency of requests and use exponential backoff. For more information, go to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error Retries and Exponential Backoff</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    ProvisionedThroughputExceededException(crate::error::ProvisionedThroughputExceededException),
    /// <p>The specified replica is already part of the global table.</p>
    ReplicaAlreadyExistsException(crate::error::ReplicaAlreadyExistsException),
    /// <p>The specified replica is no longer part of the global table.</p>
    ReplicaNotFoundException(crate::error::ReplicaNotFoundException),
    /// <p>Throughput exceeds the current throughput quota for your account. Please contact <a href="https://aws.amazon.com/support">Amazon Web Services Support</a> to request a quota increase.</p>
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    /// <p>The operation conflicts with the resource's availability. For example, you attempted to recreate an existing table, or tried to delete a table currently in the <code>CREATING</code> state.</p>
    ResourceInUseException(crate::error::ResourceInUseException),
    /// <p>The operation tried to access a nonexistent table or index. The resource might not be specified correctly, or its status might not be <code>ACTIVE</code>.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>A target table with the specified name already exists. </p>
    TableAlreadyExistsException(crate::error::TableAlreadyExistsException),
    /// <p>A target table with the specified name is either being created or deleted. </p>
    TableInUseException(crate::error::TableInUseException),
    /// <p>A source table with the name <code>TableName</code> does not currently exist within the subscriber's account or the subscriber is operating in the wrong Amazon Web Services Region.</p>
    TableNotFoundException(crate::error::TableNotFoundException),
    /// <p>The entire transaction request was canceled.</p>
    /// <p>DynamoDB cancels a <code>TransactWriteItems</code> request under the following circumstances:</p>
    /// <ul>
    /// <li> <p>A condition in one of the condition expressions is not met.</p> </li>
    /// <li> <p>A table in the <code>TransactWriteItems</code> request is in a different account or region.</p> </li>
    /// <li> <p>More than one action in the <code>TransactWriteItems</code> operation targets the same item.</p> </li>
    /// <li> <p>There is insufficient provisioned capacity for the transaction to be completed.</p> </li>
    /// <li> <p>An item size becomes too large (larger than 400 KB), or a local secondary index (LSI) becomes too large, or a similar validation error occurs because of changes made by the transaction.</p> </li>
    /// <li> <p>There is a user error, such as an invalid data format.</p> </li>
    /// </ul>
    /// <p>DynamoDB cancels a <code>TransactGetItems</code> request under the following circumstances:</p>
    /// <ul>
    /// <li> <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts with a concurrent <code>PutItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code> or <code>TransactWriteItems</code> request. In this case the <code>TransactGetItems</code> operation fails with a <code>TransactionCanceledException</code>.</p> </li>
    /// <li> <p>A table in the <code>TransactGetItems</code> request is in a different account or region.</p> </li>
    /// <li> <p>There is insufficient provisioned capacity for the transaction to be completed.</p> </li>
    /// <li> <p>There is a user error, such as an invalid data format.</p> </li>
    /// </ul> <note>
    /// <p>If using Java, DynamoDB lists the cancellation reasons on the <code>CancellationReasons</code> property. This property is not set for other languages. Transaction cancellation reasons are ordered in the order of requested items, if an item has no error it will have <code>None</code> code and <code>Null</code> message.</p>
    /// </note>
    /// <p>Cancellation reason codes and possible error messages:</p>
    /// <ul>
    /// <li> <p>No Errors:</p>
    /// <ul>
    /// <li> <p>Code: <code>None</code> </p> </li>
    /// <li> <p>Message: <code>null</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Conditional Check Failed:</p>
    /// <ul>
    /// <li> <p>Code: <code>ConditionalCheckFailed</code> </p> </li>
    /// <li> <p>Message: The conditional request failed. </p> </li>
    /// </ul> </li>
    /// <li> <p>Item Collection Size Limit Exceeded:</p>
    /// <ul>
    /// <li> <p>Code: <code>ItemCollectionSizeLimitExceeded</code> </p> </li>
    /// <li> <p>Message: Collection size exceeded.</p> </li>
    /// </ul> </li>
    /// <li> <p>Transaction Conflict:</p>
    /// <ul>
    /// <li> <p>Code: <code>TransactionConflict</code> </p> </li>
    /// <li> <p>Message: Transaction is ongoing for the item.</p> </li>
    /// </ul> </li>
    /// <li> <p>Provisioned Throughput Exceeded:</p>
    /// <ul>
    /// <li> <p>Code: <code>ProvisionedThroughputExceeded</code> </p> </li>
    /// <li> <p>Messages:</p>
    /// <ul>
    /// <li> <p>The level of configured provisioned throughput for the table was exceeded. Consider increasing your provisioning level with the UpdateTable API.</p> <note>
    /// <p>This Message is received when provisioned throughput is exceeded is on a provisioned DynamoDB table.</p>
    /// </note> </li>
    /// <li> <p>The level of configured provisioned throughput for one or more global secondary indexes of the table was exceeded. Consider increasing your provisioning level for the under-provisioned global secondary indexes with the UpdateTable API.</p> <note>
    /// <p>This message is returned when provisioned throughput is exceeded is on a provisioned GSI.</p>
    /// </note> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Throttling Error:</p>
    /// <ul>
    /// <li> <p>Code: <code>ThrottlingError</code> </p> </li>
    /// <li> <p>Messages: </p>
    /// <ul>
    /// <li> <p>Throughput exceeds the current capacity of your table or index. DynamoDB is automatically scaling your table or index so please try again shortly. If exceptions persist, check if you have a hot key: https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p> <note>
    /// <p>This message is returned when writes get throttled on an On-Demand table as DynamoDB is automatically scaling the table.</p>
    /// </note> </li>
    /// <li> <p>Throughput exceeds the current capacity for one or more global secondary indexes. DynamoDB is automatically scaling your index so please try again shortly.</p> <note>
    /// <p>This message is returned when when writes get throttled on an On-Demand GSI as DynamoDB is automatically scaling the GSI.</p>
    /// </note> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// <li> <p>Validation Error:</p>
    /// <ul>
    /// <li> <p>Code: <code>ValidationError</code> </p> </li>
    /// <li> <p>Messages: </p>
    /// <ul>
    /// <li> <p>One or more parameter values were invalid.</p> </li>
    /// <li> <p>The update expression attempted to update the secondary index key beyond allowed size limits.</p> </li>
    /// <li> <p>The update expression attempted to update the secondary index key to unsupported type.</p> </li>
    /// <li> <p>An operand in the update expression has an incorrect data type.</p> </li>
    /// <li> <p>Item size to update has exceeded the maximum allowed size.</p> </li>
    /// <li> <p>Number overflow. Attempting to store a number with magnitude larger than supported range.</p> </li>
    /// <li> <p>Type mismatch for attribute to update.</p> </li>
    /// <li> <p>Nesting Levels have exceeded supported limits.</p> </li>
    /// <li> <p>The document path provided in the update expression is invalid for update.</p> </li>
    /// <li> <p>The provided expression refers to an attribute that does not exist in the item.</p> </li>
    /// </ul> </li>
    /// </ul> </li>
    /// </ul>
    TransactionCanceledException(crate::error::TransactionCanceledException),
    /// <p>Operation was rejected because there is an ongoing transaction for the item.</p>
    TransactionConflictException(crate::error::TransactionConflictException),
    /// <p>The transaction with the given request token is already in progress.</p>
    TransactionInProgressException(crate::error::TransactionInProgressException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BackupInUseException(inner) => inner.fmt(f),
            Error::BackupNotFoundException(inner) => inner.fmt(f),
            Error::ConditionalCheckFailedException(inner) => inner.fmt(f),
            Error::ContinuousBackupsUnavailableException(inner) => inner.fmt(f),
            Error::DuplicateItemException(inner) => inner.fmt(f),
            Error::ExportConflictException(inner) => inner.fmt(f),
            Error::ExportNotFoundException(inner) => inner.fmt(f),
            Error::GlobalTableAlreadyExistsException(inner) => inner.fmt(f),
            Error::GlobalTableNotFoundException(inner) => inner.fmt(f),
            Error::IdempotentParameterMismatchException(inner) => inner.fmt(f),
            Error::ImportConflictException(inner) => inner.fmt(f),
            Error::ImportNotFoundException(inner) => inner.fmt(f),
            Error::IndexNotFoundException(inner) => inner.fmt(f),
            Error::InternalServerError(inner) => inner.fmt(f),
            Error::InvalidEndpointException(inner) => inner.fmt(f),
            Error::InvalidExportTimeException(inner) => inner.fmt(f),
            Error::InvalidRestoreTimeException(inner) => inner.fmt(f),
            Error::ItemCollectionSizeLimitExceededException(inner) => inner.fmt(f),
            Error::LimitExceededException(inner) => inner.fmt(f),
            Error::PointInTimeRecoveryUnavailableException(inner) => inner.fmt(f),
            Error::ProvisionedThroughputExceededException(inner) => inner.fmt(f),
            Error::ReplicaAlreadyExistsException(inner) => inner.fmt(f),
            Error::ReplicaNotFoundException(inner) => inner.fmt(f),
            Error::RequestLimitExceeded(inner) => inner.fmt(f),
            Error::ResourceInUseException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::TableAlreadyExistsException(inner) => inner.fmt(f),
            Error::TableInUseException(inner) => inner.fmt(f),
            Error::TableNotFoundException(inner) => inner.fmt(f),
            Error::TransactionCanceledException(inner) => inner.fmt(f),
            Error::TransactionConflictException(inner) => inner.fmt(f),
            Error::TransactionInProgressException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchExecuteStatementError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchExecuteStatementError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchExecuteStatementError> for Error {
    fn from(err: crate::error::BatchExecuteStatementError) -> Self {
        match err {
            crate::error::BatchExecuteStatementError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::BatchExecuteStatementError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::BatchExecuteStatementError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetItemError> for Error {
    fn from(err: crate::error::BatchGetItemError) -> Self {
        match err {
            crate::error::BatchGetItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::BatchGetItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::BatchGetItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::BatchGetItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::BatchGetItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::BatchGetItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchWriteItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchWriteItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchWriteItemError> for Error {
    fn from(err: crate::error::BatchWriteItemError) -> Self {
        match err {
            crate::error::BatchWriteItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::BatchWriteItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::BatchWriteItemError::ItemCollectionSizeLimitExceededException(inner) => {
                Error::ItemCollectionSizeLimitExceededException(inner)
            }
            crate::error::BatchWriteItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::BatchWriteItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::BatchWriteItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::BatchWriteItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateBackupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateBackupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateBackupError> for Error {
    fn from(err: crate::error::CreateBackupError) -> Self {
        match err {
            crate::error::CreateBackupError::BackupInUseException(inner) => {
                Error::BackupInUseException(inner)
            }
            crate::error::CreateBackupError::ContinuousBackupsUnavailableException(inner) => {
                Error::ContinuousBackupsUnavailableException(inner)
            }
            crate::error::CreateBackupError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateBackupError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::CreateBackupError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateBackupError::TableInUseException(inner) => {
                Error::TableInUseException(inner)
            }
            crate::error::CreateBackupError::TableNotFoundException(inner) => {
                Error::TableNotFoundException(inner)
            }
            crate::error::CreateBackupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateGlobalTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateGlobalTableError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateGlobalTableError> for Error {
    fn from(err: crate::error::CreateGlobalTableError) -> Self {
        match err {
            crate::error::CreateGlobalTableError::GlobalTableAlreadyExistsException(inner) => {
                Error::GlobalTableAlreadyExistsException(inner)
            }
            crate::error::CreateGlobalTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateGlobalTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::CreateGlobalTableError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateGlobalTableError::TableNotFoundException(inner) => {
                Error::TableNotFoundException(inner)
            }
            crate::error::CreateGlobalTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateTableError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTableError> for Error {
    fn from(err: crate::error::CreateTableError) -> Self {
        match err {
            crate::error::CreateTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::CreateTableError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::CreateTableError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::CreateTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteBackupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteBackupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteBackupError> for Error {
    fn from(err: crate::error::DeleteBackupError) -> Self {
        match err {
            crate::error::DeleteBackupError::BackupInUseException(inner) => {
                Error::BackupInUseException(inner)
            }
            crate::error::DeleteBackupError::BackupNotFoundException(inner) => {
                Error::BackupNotFoundException(inner)
            }
            crate::error::DeleteBackupError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteBackupError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DeleteBackupError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteBackupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteItemError> for Error {
    fn from(err: crate::error::DeleteItemError) -> Self {
        match err {
            crate::error::DeleteItemError::ConditionalCheckFailedException(inner) => {
                Error::ConditionalCheckFailedException(inner)
            }
            crate::error::DeleteItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DeleteItemError::ItemCollectionSizeLimitExceededException(inner) => {
                Error::ItemCollectionSizeLimitExceededException(inner)
            }
            crate::error::DeleteItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::DeleteItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::DeleteItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteItemError::TransactionConflictException(inner) => {
                Error::TransactionConflictException(inner)
            }
            crate::error::DeleteItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteTableError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTableError> for Error {
    fn from(err: crate::error::DeleteTableError) -> Self {
        match err {
            crate::error::DeleteTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DeleteTableError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DeleteTableError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::DeleteTableError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DeleteTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeBackupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeBackupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeBackupError> for Error {
    fn from(err: crate::error::DescribeBackupError) -> Self {
        match err {
            crate::error::DescribeBackupError::BackupNotFoundException(inner) => {
                Error::BackupNotFoundException(inner)
            }
            crate::error::DescribeBackupError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeBackupError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeBackupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeContinuousBackupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeContinuousBackupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeContinuousBackupsError> for Error {
    fn from(err: crate::error::DescribeContinuousBackupsError) -> Self {
        match err {
            crate::error::DescribeContinuousBackupsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeContinuousBackupsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeContinuousBackupsError::TableNotFoundException(inner) => {
                Error::TableNotFoundException(inner)
            }
            crate::error::DescribeContinuousBackupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeContributorInsightsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeContributorInsightsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeContributorInsightsError> for Error {
    fn from(err: crate::error::DescribeContributorInsightsError) -> Self {
        match err {
            crate::error::DescribeContributorInsightsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeContributorInsightsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeContributorInsightsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeEndpointsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeEndpointsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeEndpointsError> for Error {
    fn from(err: crate::error::DescribeEndpointsError) -> Self {
        match err {
            crate::error::DescribeEndpointsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeExportError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeExportError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeExportError> for Error {
    fn from(err: crate::error::DescribeExportError) -> Self {
        match err {
            crate::error::DescribeExportError::ExportNotFoundException(inner) => {
                Error::ExportNotFoundException(inner)
            }
            crate::error::DescribeExportError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeExportError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::DescribeExportError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeGlobalTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeGlobalTableError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeGlobalTableError> for Error {
    fn from(err: crate::error::DescribeGlobalTableError) -> Self {
        match err {
            crate::error::DescribeGlobalTableError::GlobalTableNotFoundException(inner) => {
                Error::GlobalTableNotFoundException(inner)
            }
            crate::error::DescribeGlobalTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeGlobalTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeGlobalTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeGlobalTableSettingsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeGlobalTableSettingsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeGlobalTableSettingsError> for Error {
    fn from(err: crate::error::DescribeGlobalTableSettingsError) -> Self {
        match err {
            crate::error::DescribeGlobalTableSettingsError::GlobalTableNotFoundException(inner) => {
                Error::GlobalTableNotFoundException(inner)
            }
            crate::error::DescribeGlobalTableSettingsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeGlobalTableSettingsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeGlobalTableSettingsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeImportError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeImportError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeImportError> for Error {
    fn from(err: crate::error::DescribeImportError) -> Self {
        match err {
            crate::error::DescribeImportError::ImportNotFoundException(inner) => {
                Error::ImportNotFoundException(inner)
            }
            crate::error::DescribeImportError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::DescribeKinesisStreamingDestinationError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeKinesisStreamingDestinationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeKinesisStreamingDestinationError> for Error {
    fn from(err: crate::error::DescribeKinesisStreamingDestinationError) -> Self {
        match err {
            crate::error::DescribeKinesisStreamingDestinationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeKinesisStreamingDestinationError::InvalidEndpointException(
                inner,
            ) => Error::InvalidEndpointException(inner),
            crate::error::DescribeKinesisStreamingDestinationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeKinesisStreamingDestinationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeLimitsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeLimitsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeLimitsError> for Error {
    fn from(err: crate::error::DescribeLimitsError) -> Self {
        match err {
            crate::error::DescribeLimitsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeLimitsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeLimitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeTableError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTableError> for Error {
    fn from(err: crate::error::DescribeTableError) -> Self {
        match err {
            crate::error::DescribeTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeTableError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeTableReplicaAutoScalingError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeTableReplicaAutoScalingError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTableReplicaAutoScalingError> for Error {
    fn from(err: crate::error::DescribeTableReplicaAutoScalingError) -> Self {
        match err {
            crate::error::DescribeTableReplicaAutoScalingError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeTableReplicaAutoScalingError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::DescribeTableReplicaAutoScalingError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTimeToLiveError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeTimeToLiveError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTimeToLiveError> for Error {
    fn from(err: crate::error::DescribeTimeToLiveError) -> Self {
        match err {
            crate::error::DescribeTimeToLiveError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeTimeToLiveError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::DescribeTimeToLiveError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::DescribeTimeToLiveError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<crate::error::DisableKinesisStreamingDestinationError, R>,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DisableKinesisStreamingDestinationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DisableKinesisStreamingDestinationError> for Error {
    fn from(err: crate::error::DisableKinesisStreamingDestinationError) -> Self {
        match err {
            crate::error::DisableKinesisStreamingDestinationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DisableKinesisStreamingDestinationError::InvalidEndpointException(
                inner,
            ) => Error::InvalidEndpointException(inner),
            crate::error::DisableKinesisStreamingDestinationError::LimitExceededException(
                inner,
            ) => Error::LimitExceededException(inner),
            crate::error::DisableKinesisStreamingDestinationError::ResourceInUseException(
                inner,
            ) => Error::ResourceInUseException(inner),
            crate::error::DisableKinesisStreamingDestinationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::DisableKinesisStreamingDestinationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::EnableKinesisStreamingDestinationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::EnableKinesisStreamingDestinationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::EnableKinesisStreamingDestinationError> for Error {
    fn from(err: crate::error::EnableKinesisStreamingDestinationError) -> Self {
        match err {
            crate::error::EnableKinesisStreamingDestinationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::EnableKinesisStreamingDestinationError::InvalidEndpointException(
                inner,
            ) => Error::InvalidEndpointException(inner),
            crate::error::EnableKinesisStreamingDestinationError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::EnableKinesisStreamingDestinationError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::EnableKinesisStreamingDestinationError::ResourceNotFoundException(
                inner,
            ) => Error::ResourceNotFoundException(inner),
            crate::error::EnableKinesisStreamingDestinationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ExecuteStatementError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ExecuteStatementError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ExecuteStatementError> for Error {
    fn from(err: crate::error::ExecuteStatementError) -> Self {
        match err {
            crate::error::ExecuteStatementError::ConditionalCheckFailedException(inner) => {
                Error::ConditionalCheckFailedException(inner)
            }
            crate::error::ExecuteStatementError::DuplicateItemException(inner) => {
                Error::DuplicateItemException(inner)
            }
            crate::error::ExecuteStatementError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ExecuteStatementError::ItemCollectionSizeLimitExceededException(
                inner,
            ) => Error::ItemCollectionSizeLimitExceededException(inner),
            crate::error::ExecuteStatementError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::ExecuteStatementError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::ExecuteStatementError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ExecuteStatementError::TransactionConflictException(inner) => {
                Error::TransactionConflictException(inner)
            }
            crate::error::ExecuteStatementError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ExecuteTransactionError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ExecuteTransactionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ExecuteTransactionError> for Error {
    fn from(err: crate::error::ExecuteTransactionError) -> Self {
        match err {
            crate::error::ExecuteTransactionError::IdempotentParameterMismatchException(inner) => {
                Error::IdempotentParameterMismatchException(inner)
            }
            crate::error::ExecuteTransactionError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ExecuteTransactionError::ProvisionedThroughputExceededException(
                inner,
            ) => Error::ProvisionedThroughputExceededException(inner),
            crate::error::ExecuteTransactionError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::ExecuteTransactionError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ExecuteTransactionError::TransactionCanceledException(inner) => {
                Error::TransactionCanceledException(inner)
            }
            crate::error::ExecuteTransactionError::TransactionInProgressException(inner) => {
                Error::TransactionInProgressException(inner)
            }
            crate::error::ExecuteTransactionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ExportTableToPointInTimeError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ExportTableToPointInTimeError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ExportTableToPointInTimeError> for Error {
    fn from(err: crate::error::ExportTableToPointInTimeError) -> Self {
        match err {
            crate::error::ExportTableToPointInTimeError::ExportConflictException(inner) => Error::ExportConflictException(inner),
            crate::error::ExportTableToPointInTimeError::InternalServerError(inner) => Error::InternalServerError(inner),
            crate::error::ExportTableToPointInTimeError::InvalidExportTimeException(inner) => Error::InvalidExportTimeException(inner),
            crate::error::ExportTableToPointInTimeError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::ExportTableToPointInTimeError::PointInTimeRecoveryUnavailableException(inner) => Error::PointInTimeRecoveryUnavailableException(inner),
            crate::error::ExportTableToPointInTimeError::TableNotFoundException(inner) => Error::TableNotFoundException(inner),
            crate::error::ExportTableToPointInTimeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetItemError> for Error {
    fn from(err: crate::error::GetItemError) -> Self {
        match err {
            crate::error::GetItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::GetItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::GetItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::GetItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::GetItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::GetItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ImportTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ImportTableError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ImportTableError> for Error {
    fn from(err: crate::error::ImportTableError) -> Self {
        match err {
            crate::error::ImportTableError::ImportConflictException(inner) => {
                Error::ImportConflictException(inner)
            }
            crate::error::ImportTableError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ImportTableError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::ImportTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListBackupsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListBackupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListBackupsError> for Error {
    fn from(err: crate::error::ListBackupsError) -> Self {
        match err {
            crate::error::ListBackupsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListBackupsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::ListBackupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListContributorInsightsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListContributorInsightsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListContributorInsightsError> for Error {
    fn from(err: crate::error::ListContributorInsightsError) -> Self {
        match err {
            crate::error::ListContributorInsightsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListContributorInsightsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListContributorInsightsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListExportsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListExportsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListExportsError> for Error {
    fn from(err: crate::error::ListExportsError) -> Self {
        match err {
            crate::error::ListExportsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListExportsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListExportsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListGlobalTablesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListGlobalTablesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListGlobalTablesError> for Error {
    fn from(err: crate::error::ListGlobalTablesError) -> Self {
        match err {
            crate::error::ListGlobalTablesError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListGlobalTablesError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::ListGlobalTablesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListImportsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListImportsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListImportsError> for Error {
    fn from(err: crate::error::ListImportsError) -> Self {
        match err {
            crate::error::ListImportsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::ListImportsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTablesError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTablesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTablesError> for Error {
    fn from(err: crate::error::ListTablesError) -> Self {
        match err {
            crate::error::ListTablesError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListTablesError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::ListTablesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsOfResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsOfResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsOfResourceError> for Error {
    fn from(err: crate::error::ListTagsOfResourceError) -> Self {
        match err {
            crate::error::ListTagsOfResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListTagsOfResourceError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::ListTagsOfResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ListTagsOfResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutItemError> for Error {
    fn from(err: crate::error::PutItemError) -> Self {
        match err {
            crate::error::PutItemError::ConditionalCheckFailedException(inner) => {
                Error::ConditionalCheckFailedException(inner)
            }
            crate::error::PutItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::PutItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::PutItemError::ItemCollectionSizeLimitExceededException(inner) => {
                Error::ItemCollectionSizeLimitExceededException(inner)
            }
            crate::error::PutItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::PutItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::PutItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::PutItemError::TransactionConflictException(inner) => {
                Error::TransactionConflictException(inner)
            }
            crate::error::PutItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::QueryError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::QueryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::QueryError> for Error {
    fn from(err: crate::error::QueryError) -> Self {
        match err {
            crate::error::QueryError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::QueryError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::QueryError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::QueryError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::QueryError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::QueryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RestoreTableFromBackupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RestoreTableFromBackupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RestoreTableFromBackupError> for Error {
    fn from(err: crate::error::RestoreTableFromBackupError) -> Self {
        match err {
            crate::error::RestoreTableFromBackupError::BackupInUseException(inner) => {
                Error::BackupInUseException(inner)
            }
            crate::error::RestoreTableFromBackupError::BackupNotFoundException(inner) => {
                Error::BackupNotFoundException(inner)
            }
            crate::error::RestoreTableFromBackupError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::RestoreTableFromBackupError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::RestoreTableFromBackupError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::RestoreTableFromBackupError::TableAlreadyExistsException(inner) => {
                Error::TableAlreadyExistsException(inner)
            }
            crate::error::RestoreTableFromBackupError::TableInUseException(inner) => {
                Error::TableInUseException(inner)
            }
            crate::error::RestoreTableFromBackupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RestoreTableToPointInTimeError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RestoreTableToPointInTimeError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RestoreTableToPointInTimeError> for Error {
    fn from(err: crate::error::RestoreTableToPointInTimeError) -> Self {
        match err {
            crate::error::RestoreTableToPointInTimeError::InternalServerError(inner) => Error::InternalServerError(inner),
            crate::error::RestoreTableToPointInTimeError::InvalidEndpointException(inner) => Error::InvalidEndpointException(inner),
            crate::error::RestoreTableToPointInTimeError::InvalidRestoreTimeException(inner) => Error::InvalidRestoreTimeException(inner),
            crate::error::RestoreTableToPointInTimeError::LimitExceededException(inner) => Error::LimitExceededException(inner),
            crate::error::RestoreTableToPointInTimeError::PointInTimeRecoveryUnavailableException(inner) => Error::PointInTimeRecoveryUnavailableException(inner),
            crate::error::RestoreTableToPointInTimeError::TableAlreadyExistsException(inner) => Error::TableAlreadyExistsException(inner),
            crate::error::RestoreTableToPointInTimeError::TableInUseException(inner) => Error::TableInUseException(inner),
            crate::error::RestoreTableToPointInTimeError::TableNotFoundException(inner) => Error::TableNotFoundException(inner),
            crate::error::RestoreTableToPointInTimeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ScanError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ScanError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ScanError> for Error {
    fn from(err: crate::error::ScanError) -> Self {
        match err {
            crate::error::ScanError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ScanError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::ScanError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::ScanError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::ScanError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::ScanError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::TagResourceError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::TagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::TagResourceError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::TagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TransactGetItemsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::TransactGetItemsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TransactGetItemsError> for Error {
    fn from(err: crate::error::TransactGetItemsError) -> Self {
        match err {
            crate::error::TransactGetItemsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::TransactGetItemsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::TransactGetItemsError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::TransactGetItemsError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::TransactGetItemsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TransactGetItemsError::TransactionCanceledException(inner) => {
                Error::TransactionCanceledException(inner)
            }
            crate::error::TransactGetItemsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TransactWriteItemsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::TransactWriteItemsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TransactWriteItemsError> for Error {
    fn from(err: crate::error::TransactWriteItemsError) -> Self {
        match err {
            crate::error::TransactWriteItemsError::IdempotentParameterMismatchException(inner) => {
                Error::IdempotentParameterMismatchException(inner)
            }
            crate::error::TransactWriteItemsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::TransactWriteItemsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::TransactWriteItemsError::ProvisionedThroughputExceededException(
                inner,
            ) => Error::ProvisionedThroughputExceededException(inner),
            crate::error::TransactWriteItemsError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::TransactWriteItemsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::TransactWriteItemsError::TransactionCanceledException(inner) => {
                Error::TransactionCanceledException(inner)
            }
            crate::error::TransactWriteItemsError::TransactionInProgressException(inner) => {
                Error::TransactionInProgressException(inner)
            }
            crate::error::TransactWriteItemsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UntagResourceError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UntagResourceError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UntagResourceError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UntagResourceError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateContinuousBackupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateContinuousBackupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateContinuousBackupsError> for Error {
    fn from(err: crate::error::UpdateContinuousBackupsError) -> Self {
        match err {
            crate::error::UpdateContinuousBackupsError::ContinuousBackupsUnavailableException(
                inner,
            ) => Error::ContinuousBackupsUnavailableException(inner),
            crate::error::UpdateContinuousBackupsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateContinuousBackupsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateContinuousBackupsError::TableNotFoundException(inner) => {
                Error::TableNotFoundException(inner)
            }
            crate::error::UpdateContinuousBackupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateContributorInsightsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateContributorInsightsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateContributorInsightsError> for Error {
    fn from(err: crate::error::UpdateContributorInsightsError) -> Self {
        match err {
            crate::error::UpdateContributorInsightsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateContributorInsightsError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateContributorInsightsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateGlobalTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateGlobalTableError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateGlobalTableError> for Error {
    fn from(err: crate::error::UpdateGlobalTableError) -> Self {
        match err {
            crate::error::UpdateGlobalTableError::GlobalTableNotFoundException(inner) => {
                Error::GlobalTableNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateGlobalTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateGlobalTableError::ReplicaAlreadyExistsException(inner) => {
                Error::ReplicaAlreadyExistsException(inner)
            }
            crate::error::UpdateGlobalTableError::ReplicaNotFoundException(inner) => {
                Error::ReplicaNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableError::TableNotFoundException(inner) => {
                Error::TableNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateGlobalTableSettingsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateGlobalTableSettingsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateGlobalTableSettingsError> for Error {
    fn from(err: crate::error::UpdateGlobalTableSettingsError) -> Self {
        match err {
            crate::error::UpdateGlobalTableSettingsError::GlobalTableNotFoundException(inner) => {
                Error::GlobalTableNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::IndexNotFoundException(inner) => {
                Error::IndexNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::ReplicaNotFoundException(inner) => {
                Error::ReplicaNotFoundException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateGlobalTableSettingsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateItemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateItemError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateItemError> for Error {
    fn from(err: crate::error::UpdateItemError) -> Self {
        match err {
            crate::error::UpdateItemError::ConditionalCheckFailedException(inner) => {
                Error::ConditionalCheckFailedException(inner)
            }
            crate::error::UpdateItemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateItemError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateItemError::ItemCollectionSizeLimitExceededException(inner) => {
                Error::ItemCollectionSizeLimitExceededException(inner)
            }
            crate::error::UpdateItemError::ProvisionedThroughputExceededException(inner) => {
                Error::ProvisionedThroughputExceededException(inner)
            }
            crate::error::UpdateItemError::RequestLimitExceeded(inner) => {
                Error::RequestLimitExceeded(inner)
            }
            crate::error::UpdateItemError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateItemError::TransactionConflictException(inner) => {
                Error::TransactionConflictException(inner)
            }
            crate::error::UpdateItemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTableError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateTableError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTableError> for Error {
    fn from(err: crate::error::UpdateTableError) -> Self {
        match err {
            crate::error::UpdateTableError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateTableError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateTableError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateTableError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateTableError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateTableError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTableReplicaAutoScalingError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateTableReplicaAutoScalingError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTableReplicaAutoScalingError> for Error {
    fn from(err: crate::error::UpdateTableReplicaAutoScalingError) -> Self {
        match err {
            crate::error::UpdateTableReplicaAutoScalingError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateTableReplicaAutoScalingError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateTableReplicaAutoScalingError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateTableReplicaAutoScalingError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateTableReplicaAutoScalingError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateTimeToLiveError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateTimeToLiveError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateTimeToLiveError> for Error {
    fn from(err: crate::error::UpdateTimeToLiveError) -> Self {
        match err {
            crate::error::UpdateTimeToLiveError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateTimeToLiveError::InvalidEndpointException(inner) => {
                Error::InvalidEndpointException(inner)
            }
            crate::error::UpdateTimeToLiveError::LimitExceededException(inner) => {
                Error::LimitExceededException(inner)
            }
            crate::error::UpdateTimeToLiveError::ResourceInUseException(inner) => {
                Error::ResourceInUseException(inner)
            }
            crate::error::UpdateTimeToLiveError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::error::UpdateTimeToLiveError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::BackupInUseException(e) => e.request_id(),
            Self::BackupNotFoundException(e) => e.request_id(),
            Self::ConditionalCheckFailedException(e) => e.request_id(),
            Self::ContinuousBackupsUnavailableException(e) => e.request_id(),
            Self::DuplicateItemException(e) => e.request_id(),
            Self::ExportConflictException(e) => e.request_id(),
            Self::ExportNotFoundException(e) => e.request_id(),
            Self::GlobalTableAlreadyExistsException(e) => e.request_id(),
            Self::GlobalTableNotFoundException(e) => e.request_id(),
            Self::IdempotentParameterMismatchException(e) => e.request_id(),
            Self::ImportConflictException(e) => e.request_id(),
            Self::ImportNotFoundException(e) => e.request_id(),
            Self::IndexNotFoundException(e) => e.request_id(),
            Self::InternalServerError(e) => e.request_id(),
            Self::InvalidEndpointException(e) => e.request_id(),
            Self::InvalidExportTimeException(e) => e.request_id(),
            Self::InvalidRestoreTimeException(e) => e.request_id(),
            Self::ItemCollectionSizeLimitExceededException(e) => e.request_id(),
            Self::LimitExceededException(e) => e.request_id(),
            Self::PointInTimeRecoveryUnavailableException(e) => e.request_id(),
            Self::ProvisionedThroughputExceededException(e) => e.request_id(),
            Self::ReplicaAlreadyExistsException(e) => e.request_id(),
            Self::ReplicaNotFoundException(e) => e.request_id(),
            Self::RequestLimitExceeded(e) => e.request_id(),
            Self::ResourceInUseException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::TableAlreadyExistsException(e) => e.request_id(),
            Self::TableInUseException(e) => e.request_id(),
            Self::TableNotFoundException(e) => e.request_id(),
            Self::TransactionCanceledException(e) => e.request_id(),
            Self::TransactionConflictException(e) => e.request_id(),
            Self::TransactionInProgressException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
