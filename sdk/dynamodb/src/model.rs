// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Represents the settings used to enable or disable Time to Live (TTL) for the specified
/// table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TimeToLiveSpecification {
    /// <p>Indicates whether TTL is to be enabled (true) or disabled (false) on the table.</p>
    #[serde(rename = "Enabled")]
    #[serde(default)]
    pub enabled: std::option::Option<bool>,
    /// <p>The name of the TTL attribute used to store the expiration time for items in the
    /// table.</p>
    #[serde(rename = "AttributeName")]
    #[serde(default)]
    pub attribute_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TimeToLiveSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TimeToLiveSpecification");
        formatter.field("enabled", &self.enabled);
        formatter.field("attribute_name", &self.attribute_name);
        formatter.finish()
    }
}
/// See [`TimeToLiveSpecification`](crate::model::TimeToLiveSpecification)
pub mod time_to_live_specification {
    /// A builder for [`TimeToLiveSpecification`](crate::model::TimeToLiveSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether TTL is to be enabled (true) or disabled (false) on the table.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.enabled = Some(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.enabled = inp;
            self
        }
        /// <p>The name of the TTL attribute used to store the expiration time for items in the
        /// table.</p>
        pub fn attribute_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(inp.into());
            self
        }
        pub fn set_attribute_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.attribute_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`TimeToLiveSpecification`](crate::model::TimeToLiveSpecification)
        pub fn build(self) -> crate::model::TimeToLiveSpecification {
            crate::model::TimeToLiveSpecification {
                enabled: self.enabled,
                attribute_name: self.attribute_name,
            }
        }
    }
}
impl TimeToLiveSpecification {
    /// Creates a new builder-style object to manufacture [`TimeToLiveSpecification`](crate::model::TimeToLiveSpecification)
    pub fn builder() -> crate::model::time_to_live_specification::Builder {
        crate::model::time_to_live_specification::Builder::default()
    }
}

/// <p>Represents the auto scaling configuration for a global table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TableAutoScalingDescription {
    /// <p>The name of the table.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The current state of the table:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The table is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The table is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The table is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The table is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "TableStatus")]
    #[serde(default)]
    pub table_status: std::option::Option<crate::model::TableStatus>,
    /// <p>Represents replicas of the global table.</p>
    #[serde(rename = "Replicas")]
    #[serde(default)]
    pub replicas: std::option::Option<std::vec::Vec<crate::model::ReplicaAutoScalingDescription>>,
}
impl std::fmt::Debug for TableAutoScalingDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableAutoScalingDescription");
        formatter.field("table_name", &self.table_name);
        formatter.field("table_status", &self.table_status);
        formatter.field("replicas", &self.replicas);
        formatter.finish()
    }
}
/// See [`TableAutoScalingDescription`](crate::model::TableAutoScalingDescription)
pub mod table_auto_scaling_description {
    /// A builder for [`TableAutoScalingDescription`](crate::model::TableAutoScalingDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) table_status: std::option::Option<crate::model::TableStatus>,
        pub(crate) replicas:
            std::option::Option<std::vec::Vec<crate::model::ReplicaAutoScalingDescription>>,
    }
    impl Builder {
        /// <p>The name of the table.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>The current state of the table:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The table is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The table is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The table is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The table is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn table_status(mut self, inp: crate::model::TableStatus) -> Self {
            self.table_status = Some(inp);
            self
        }
        pub fn set_table_status(
            mut self,
            inp: std::option::Option<crate::model::TableStatus>,
        ) -> Self {
            self.table_status = inp;
            self
        }
        pub fn replicas(
            mut self,
            inp: impl Into<crate::model::ReplicaAutoScalingDescription>,
        ) -> Self {
            let mut v = self.replicas.unwrap_or_default();
            v.push(inp.into());
            self.replicas = Some(v);
            self
        }
        pub fn set_replicas(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ReplicaAutoScalingDescription>>,
        ) -> Self {
            self.replicas = inp;
            self
        }
        /// Consumes the builder and constructs a [`TableAutoScalingDescription`](crate::model::TableAutoScalingDescription)
        pub fn build(self) -> crate::model::TableAutoScalingDescription {
            crate::model::TableAutoScalingDescription {
                table_name: self.table_name,
                table_status: self.table_status,
                replicas: self.replicas,
            }
        }
    }
}
impl TableAutoScalingDescription {
    /// Creates a new builder-style object to manufacture [`TableAutoScalingDescription`](crate::model::TableAutoScalingDescription)
    pub fn builder() -> crate::model::table_auto_scaling_description::Builder {
        crate::model::table_auto_scaling_description::Builder::default()
    }
}

/// <p>Represents the auto scaling settings of the replica.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaAutoScalingDescription {
    /// <p>The Region where the replica exists.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>Replica-specific global secondary index auto scaling settings.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes: std::option::Option<
        std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription>,
    >,
    /// <p>Represents the auto scaling settings for a global table or global secondary
    /// index.</p>
    #[serde(rename = "ReplicaProvisionedReadCapacityAutoScalingSettings")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>Represents the auto scaling settings for a global table or global secondary
    /// index.</p>
    #[serde(rename = "ReplicaProvisionedWriteCapacityAutoScalingSettings")]
    #[serde(default)]
    pub replica_provisioned_write_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>The current state of the replica:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The replica is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The replica is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The replica is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The replica is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "ReplicaStatus")]
    #[serde(default)]
    pub replica_status: std::option::Option<crate::model::ReplicaStatus>,
}
impl std::fmt::Debug for ReplicaAutoScalingDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaAutoScalingDescription");
        formatter.field("region_name", &self.region_name);
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field(
            "replica_provisioned_read_capacity_auto_scaling_settings",
            &self.replica_provisioned_read_capacity_auto_scaling_settings,
        );
        formatter.field(
            "replica_provisioned_write_capacity_auto_scaling_settings",
            &self.replica_provisioned_write_capacity_auto_scaling_settings,
        );
        formatter.field("replica_status", &self.replica_status);
        formatter.finish()
    }
}
/// See [`ReplicaAutoScalingDescription`](crate::model::ReplicaAutoScalingDescription)
pub mod replica_auto_scaling_description {
    /// A builder for [`ReplicaAutoScalingDescription`](crate::model::ReplicaAutoScalingDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) global_secondary_indexes: std::option::Option<
            std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription>,
        >,
        pub(crate) replica_provisioned_read_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) replica_provisioned_write_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) replica_status: std::option::Option<crate::model::ReplicaStatus>,
    }
    impl Builder {
        /// <p>The Region where the replica exists.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription>,
            >,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// <p>Represents the auto scaling settings for a global table or global secondary
        /// index.</p>
        pub fn replica_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings = inp;
            self
        }
        /// <p>Represents the auto scaling settings for a global table or global secondary
        /// index.</p>
        pub fn replica_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.replica_provisioned_write_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_replica_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.replica_provisioned_write_capacity_auto_scaling_settings = inp;
            self
        }
        /// <p>The current state of the replica:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The replica is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The replica is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The replica is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The replica is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn replica_status(mut self, inp: crate::model::ReplicaStatus) -> Self {
            self.replica_status = Some(inp);
            self
        }
        pub fn set_replica_status(
            mut self,
            inp: std::option::Option<crate::model::ReplicaStatus>,
        ) -> Self {
            self.replica_status = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaAutoScalingDescription`](crate::model::ReplicaAutoScalingDescription)
        pub fn build(self) -> crate::model::ReplicaAutoScalingDescription {
            crate::model::ReplicaAutoScalingDescription {
                region_name: self.region_name,
                global_secondary_indexes: self.global_secondary_indexes,
                replica_provisioned_read_capacity_auto_scaling_settings: self
                    .replica_provisioned_read_capacity_auto_scaling_settings,
                replica_provisioned_write_capacity_auto_scaling_settings: self
                    .replica_provisioned_write_capacity_auto_scaling_settings,
                replica_status: self.replica_status,
            }
        }
    }
}
impl ReplicaAutoScalingDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaAutoScalingDescription`](crate::model::ReplicaAutoScalingDescription)
    pub fn builder() -> crate::model::replica_auto_scaling_description::Builder {
        crate::model::replica_auto_scaling_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReplicaStatus {
    Active,
    Creating,
    CreationFailed,
    Deleting,
    InaccessibleEncryptionCredentials,
    RegionDisabled,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReplicaStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ReplicaStatus::Active,
            "CREATING" => ReplicaStatus::Creating,
            "CREATION_FAILED" => ReplicaStatus::CreationFailed,
            "DELETING" => ReplicaStatus::Deleting,
            "INACCESSIBLE_ENCRYPTION_CREDENTIALS" => {
                ReplicaStatus::InaccessibleEncryptionCredentials
            }
            "REGION_DISABLED" => ReplicaStatus::RegionDisabled,
            "UPDATING" => ReplicaStatus::Updating,
            other => ReplicaStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReplicaStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReplicaStatus::from(s))
    }
}
impl ReplicaStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ReplicaStatus::Active => "ACTIVE",
            ReplicaStatus::Creating => "CREATING",
            ReplicaStatus::CreationFailed => "CREATION_FAILED",
            ReplicaStatus::Deleting => "DELETING",
            ReplicaStatus::InaccessibleEncryptionCredentials => {
                "INACCESSIBLE_ENCRYPTION_CREDENTIALS"
            }
            ReplicaStatus::RegionDisabled => "REGION_DISABLED",
            ReplicaStatus::Updating => "UPDATING",
            ReplicaStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReplicaStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReplicaStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the auto scaling settings for a global table or global secondary
/// index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingSettingsDescription {
    /// <p>The minimum capacity units that a global table or global secondary index should be scaled down to.</p>
    #[serde(rename = "MinimumUnits")]
    #[serde(default)]
    pub minimum_units: std::option::Option<i64>,
    /// <p>The maximum capacity units that a global table or global secondary index should be scaled up to.</p>
    #[serde(rename = "MaximumUnits")]
    #[serde(default)]
    pub maximum_units: std::option::Option<i64>,
    /// <p>Disabled auto scaling for this global table or global secondary index.</p>
    #[serde(rename = "AutoScalingDisabled")]
    #[serde(default)]
    pub auto_scaling_disabled: std::option::Option<bool>,
    /// <p>Role ARN used for configuring the auto scaling policy.</p>
    #[serde(rename = "AutoScalingRoleArn")]
    #[serde(default)]
    pub auto_scaling_role_arn: std::option::Option<std::string::String>,
    /// <p>Information about the scaling policies.</p>
    #[serde(rename = "ScalingPolicies")]
    #[serde(default)]
    pub scaling_policies:
        std::option::Option<std::vec::Vec<crate::model::AutoScalingPolicyDescription>>,
}
impl std::fmt::Debug for AutoScalingSettingsDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingSettingsDescription");
        formatter.field("minimum_units", &self.minimum_units);
        formatter.field("maximum_units", &self.maximum_units);
        formatter.field("auto_scaling_disabled", &self.auto_scaling_disabled);
        formatter.field("auto_scaling_role_arn", &self.auto_scaling_role_arn);
        formatter.field("scaling_policies", &self.scaling_policies);
        formatter.finish()
    }
}
/// See [`AutoScalingSettingsDescription`](crate::model::AutoScalingSettingsDescription)
pub mod auto_scaling_settings_description {
    /// A builder for [`AutoScalingSettingsDescription`](crate::model::AutoScalingSettingsDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_units: std::option::Option<i64>,
        pub(crate) maximum_units: std::option::Option<i64>,
        pub(crate) auto_scaling_disabled: std::option::Option<bool>,
        pub(crate) auto_scaling_role_arn: std::option::Option<std::string::String>,
        pub(crate) scaling_policies:
            std::option::Option<std::vec::Vec<crate::model::AutoScalingPolicyDescription>>,
    }
    impl Builder {
        /// <p>The minimum capacity units that a global table or global secondary index should be scaled down to.</p>
        pub fn minimum_units(mut self, inp: i64) -> Self {
            self.minimum_units = Some(inp);
            self
        }
        pub fn set_minimum_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.minimum_units = inp;
            self
        }
        /// <p>The maximum capacity units that a global table or global secondary index should be scaled up to.</p>
        pub fn maximum_units(mut self, inp: i64) -> Self {
            self.maximum_units = Some(inp);
            self
        }
        pub fn set_maximum_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.maximum_units = inp;
            self
        }
        /// <p>Disabled auto scaling for this global table or global secondary index.</p>
        pub fn auto_scaling_disabled(mut self, inp: bool) -> Self {
            self.auto_scaling_disabled = Some(inp);
            self
        }
        pub fn set_auto_scaling_disabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.auto_scaling_disabled = inp;
            self
        }
        /// <p>Role ARN used for configuring the auto scaling policy.</p>
        pub fn auto_scaling_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.auto_scaling_role_arn = Some(inp.into());
            self
        }
        pub fn set_auto_scaling_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_role_arn = inp;
            self
        }
        pub fn scaling_policies(
            mut self,
            inp: impl Into<crate::model::AutoScalingPolicyDescription>,
        ) -> Self {
            let mut v = self.scaling_policies.unwrap_or_default();
            v.push(inp.into());
            self.scaling_policies = Some(v);
            self
        }
        pub fn set_scaling_policies(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AutoScalingPolicyDescription>>,
        ) -> Self {
            self.scaling_policies = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingSettingsDescription`](crate::model::AutoScalingSettingsDescription)
        pub fn build(self) -> crate::model::AutoScalingSettingsDescription {
            crate::model::AutoScalingSettingsDescription {
                minimum_units: self.minimum_units,
                maximum_units: self.maximum_units,
                auto_scaling_disabled: self.auto_scaling_disabled,
                auto_scaling_role_arn: self.auto_scaling_role_arn,
                scaling_policies: self.scaling_policies,
            }
        }
    }
}
impl AutoScalingSettingsDescription {
    /// Creates a new builder-style object to manufacture [`AutoScalingSettingsDescription`](crate::model::AutoScalingSettingsDescription)
    pub fn builder() -> crate::model::auto_scaling_settings_description::Builder {
        crate::model::auto_scaling_settings_description::Builder::default()
    }
}

/// <p>Represents the properties of the scaling policy.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingPolicyDescription {
    /// <p>The name of the scaling policy.</p>
    #[serde(rename = "PolicyName")]
    #[serde(default)]
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>Represents a target tracking scaling policy configuration.</p>
    #[serde(rename = "TargetTrackingScalingPolicyConfiguration")]
    #[serde(default)]
    pub target_tracking_scaling_policy_configuration: std::option::Option<
        crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription,
    >,
}
impl std::fmt::Debug for AutoScalingPolicyDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingPolicyDescription");
        formatter.field("policy_name", &self.policy_name);
        formatter.field(
            "target_tracking_scaling_policy_configuration",
            &self.target_tracking_scaling_policy_configuration,
        );
        formatter.finish()
    }
}
/// See [`AutoScalingPolicyDescription`](crate::model::AutoScalingPolicyDescription)
pub mod auto_scaling_policy_description {
    /// A builder for [`AutoScalingPolicyDescription`](crate::model::AutoScalingPolicyDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) target_tracking_scaling_policy_configuration: std::option::Option<
            crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription,
        >,
    }
    impl Builder {
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>Represents a target tracking scaling policy configuration.</p>
        pub fn target_tracking_scaling_policy_configuration(
            mut self,
            inp: crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription,
        ) -> Self {
            self.target_tracking_scaling_policy_configuration = Some(inp);
            self
        }
        pub fn set_target_tracking_scaling_policy_configuration(
            mut self,
            inp: std::option::Option<
                crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription,
            >,
        ) -> Self {
            self.target_tracking_scaling_policy_configuration = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingPolicyDescription`](crate::model::AutoScalingPolicyDescription)
        pub fn build(self) -> crate::model::AutoScalingPolicyDescription {
            crate::model::AutoScalingPolicyDescription {
                policy_name: self.policy_name,
                target_tracking_scaling_policy_configuration: self
                    .target_tracking_scaling_policy_configuration,
            }
        }
    }
}
impl AutoScalingPolicyDescription {
    /// Creates a new builder-style object to manufacture [`AutoScalingPolicyDescription`](crate::model::AutoScalingPolicyDescription)
    pub fn builder() -> crate::model::auto_scaling_policy_description::Builder {
        crate::model::auto_scaling_policy_description::Builder::default()
    }
}

/// <p>Represents the properties of a target tracking scaling policy.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
    /// <p>Indicates whether scale in by the target tracking policy is disabled. If the value is true,
    /// scale in is disabled and the target tracking policy won't remove capacity from the scalable resource.
    /// Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource.
    /// The default value is false.</p>
    #[serde(rename = "DisableScaleIn")]
    #[serde(default)]
    pub disable_scale_in: std::option::Option<bool>,
    /// <p>The amount of time, in seconds, after a scale in activity completes before another scale
    /// in activity can start. The cooldown period is used to block subsequent scale in requests
    /// until it has expired. You should scale in conservatively to protect your application's
    /// availability. However, if another alarm triggers a scale out policy during the cooldown
    /// period after a scale-in, application auto scaling scales out your scalable target
    /// immediately. </p>
    #[serde(rename = "ScaleInCooldown")]
    #[serde(default)]
    pub scale_in_cooldown: std::option::Option<i32>,
    /// <p>The amount of time, in seconds, after a scale out activity completes before another scale out
    /// activity can start. While the cooldown period is in effect, the capacity that has been added
    /// by the previous scale out event that initiated the cooldown is calculated as part of the
    /// desired capacity for the next scale out. You should continuously (but not excessively)
    /// scale out.</p>
    #[serde(rename = "ScaleOutCooldown")]
    #[serde(default)]
    pub scale_out_cooldown: std::option::Option<i32>,
    /// <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10) or 2e-360 to 2e360 (Base 2).</p>
    #[serde(rename = "TargetValue")]
    #[serde(default)]
    pub target_value: std::option::Option<f64>,
}
impl std::fmt::Debug for AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AutoScalingTargetTrackingScalingPolicyConfigurationDescription");
        formatter.field("disable_scale_in", &self.disable_scale_in);
        formatter.field("scale_in_cooldown", &self.scale_in_cooldown);
        formatter.field("scale_out_cooldown", &self.scale_out_cooldown);
        formatter.field("target_value", &self.target_value);
        formatter.finish()
    }
}
/// See [`AutoScalingTargetTrackingScalingPolicyConfigurationDescription`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription)
pub mod auto_scaling_target_tracking_scaling_policy_configuration_description {
    /// A builder for [`AutoScalingTargetTrackingScalingPolicyConfigurationDescription`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disable_scale_in: std::option::Option<bool>,
        pub(crate) scale_in_cooldown: std::option::Option<i32>,
        pub(crate) scale_out_cooldown: std::option::Option<i32>,
        pub(crate) target_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Indicates whether scale in by the target tracking policy is disabled. If the value is true,
        /// scale in is disabled and the target tracking policy won't remove capacity from the scalable resource.
        /// Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource.
        /// The default value is false.</p>
        pub fn disable_scale_in(mut self, inp: bool) -> Self {
            self.disable_scale_in = Some(inp);
            self
        }
        pub fn set_disable_scale_in(mut self, inp: std::option::Option<bool>) -> Self {
            self.disable_scale_in = inp;
            self
        }
        /// <p>The amount of time, in seconds, after a scale in activity completes before another scale
        /// in activity can start. The cooldown period is used to block subsequent scale in requests
        /// until it has expired. You should scale in conservatively to protect your application's
        /// availability. However, if another alarm triggers a scale out policy during the cooldown
        /// period after a scale-in, application auto scaling scales out your scalable target
        /// immediately. </p>
        pub fn scale_in_cooldown(mut self, inp: i32) -> Self {
            self.scale_in_cooldown = Some(inp);
            self
        }
        pub fn set_scale_in_cooldown(mut self, inp: std::option::Option<i32>) -> Self {
            self.scale_in_cooldown = inp;
            self
        }
        /// <p>The amount of time, in seconds, after a scale out activity completes before another scale out
        /// activity can start. While the cooldown period is in effect, the capacity that has been added
        /// by the previous scale out event that initiated the cooldown is calculated as part of the
        /// desired capacity for the next scale out. You should continuously (but not excessively)
        /// scale out.</p>
        pub fn scale_out_cooldown(mut self, inp: i32) -> Self {
            self.scale_out_cooldown = Some(inp);
            self
        }
        pub fn set_scale_out_cooldown(mut self, inp: std::option::Option<i32>) -> Self {
            self.scale_out_cooldown = inp;
            self
        }
        /// <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10) or 2e-360 to 2e360 (Base 2).</p>
        pub fn target_value(mut self, inp: f64) -> Self {
            self.target_value = Some(inp);
            self
        }
        pub fn set_target_value(mut self, inp: std::option::Option<f64>) -> Self {
            self.target_value = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingTargetTrackingScalingPolicyConfigurationDescription`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription)
        pub fn build(
            self,
        ) -> crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
            crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
                disable_scale_in: self.disable_scale_in,
                scale_in_cooldown: self.scale_in_cooldown,
                scale_out_cooldown: self.scale_out_cooldown,
                target_value: self.target_value,
            }
        }
    }
}
impl AutoScalingTargetTrackingScalingPolicyConfigurationDescription {
    /// Creates a new builder-style object to manufacture [`AutoScalingTargetTrackingScalingPolicyConfigurationDescription`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationDescription)
    pub fn builder(
    ) -> crate::model::auto_scaling_target_tracking_scaling_policy_configuration_description::Builder
    {
        crate::model::auto_scaling_target_tracking_scaling_policy_configuration_description::Builder::default()
    }
}

/// <p>Represents the auto scaling configuration for a replica global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndexAutoScalingDescription {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The current state of the replica global secondary index:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The index is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The index is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The index is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The index is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "IndexStatus")]
    #[serde(default)]
    pub index_status: std::option::Option<crate::model::IndexStatus>,
    /// <p>Represents the auto scaling settings for a global table or global secondary
    /// index.</p>
    #[serde(rename = "ProvisionedReadCapacityAutoScalingSettings")]
    #[serde(default)]
    pub provisioned_read_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>Represents the auto scaling settings for a global table or global secondary
    /// index.</p>
    #[serde(rename = "ProvisionedWriteCapacityAutoScalingSettings")]
    #[serde(default)]
    pub provisioned_write_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndexAutoScalingDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndexAutoScalingDescription");
        formatter.field("index_name", &self.index_name);
        formatter.field("index_status", &self.index_status);
        formatter.field(
            "provisioned_read_capacity_auto_scaling_settings",
            &self.provisioned_read_capacity_auto_scaling_settings,
        );
        formatter.field(
            "provisioned_write_capacity_auto_scaling_settings",
            &self.provisioned_write_capacity_auto_scaling_settings,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndexAutoScalingDescription`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription)
pub mod replica_global_secondary_index_auto_scaling_description {
    /// A builder for [`ReplicaGlobalSecondaryIndexAutoScalingDescription`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) index_status: std::option::Option<crate::model::IndexStatus>,
        pub(crate) provisioned_read_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) provisioned_write_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>The current state of the replica global secondary index:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The index is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The index is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The index is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The index is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn index_status(mut self, inp: crate::model::IndexStatus) -> Self {
            self.index_status = Some(inp);
            self
        }
        pub fn set_index_status(
            mut self,
            inp: std::option::Option<crate::model::IndexStatus>,
        ) -> Self {
            self.index_status = inp;
            self
        }
        /// <p>Represents the auto scaling settings for a global table or global secondary
        /// index.</p>
        pub fn provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings = inp;
            self
        }
        /// <p>Represents the auto scaling settings for a global table or global secondary
        /// index.</p>
        pub fn provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexAutoScalingDescription`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription {
            crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription {
                index_name: self.index_name,
                index_status: self.index_status,
                provisioned_read_capacity_auto_scaling_settings: self
                    .provisioned_read_capacity_auto_scaling_settings,
                provisioned_write_capacity_auto_scaling_settings: self
                    .provisioned_write_capacity_auto_scaling_settings,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndexAutoScalingDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexAutoScalingDescription`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingDescription)
    pub fn builder(
    ) -> crate::model::replica_global_secondary_index_auto_scaling_description::Builder {
        crate::model::replica_global_secondary_index_auto_scaling_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IndexStatus {
    Active,
    Creating,
    Deleting,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IndexStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => IndexStatus::Active,
            "CREATING" => IndexStatus::Creating,
            "DELETING" => IndexStatus::Deleting,
            "UPDATING" => IndexStatus::Updating,
            other => IndexStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IndexStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(IndexStatus::from(s))
    }
}
impl IndexStatus {
    pub fn as_str(&self) -> &str {
        match self {
            IndexStatus::Active => "ACTIVE",
            IndexStatus::Creating => "CREATING",
            IndexStatus::Deleting => "DELETING",
            IndexStatus::Updating => "UPDATING",
            IndexStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for IndexStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for IndexStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TableStatus {
    Active,
    Archived,
    Archiving,
    Creating,
    Deleting,
    InaccessibleEncryptionCredentials,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TableStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => TableStatus::Active,
            "ARCHIVED" => TableStatus::Archived,
            "ARCHIVING" => TableStatus::Archiving,
            "CREATING" => TableStatus::Creating,
            "DELETING" => TableStatus::Deleting,
            "INACCESSIBLE_ENCRYPTION_CREDENTIALS" => TableStatus::InaccessibleEncryptionCredentials,
            "UPDATING" => TableStatus::Updating,
            other => TableStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TableStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TableStatus::from(s))
    }
}
impl TableStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TableStatus::Active => "ACTIVE",
            TableStatus::Archived => "ARCHIVED",
            TableStatus::Archiving => "ARCHIVING",
            TableStatus::Creating => "CREATING",
            TableStatus::Deleting => "DELETING",
            TableStatus::InaccessibleEncryptionCredentials => "INACCESSIBLE_ENCRYPTION_CREDENTIALS",
            TableStatus::Updating => "UPDATING",
            TableStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TableStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TableStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the auto scaling settings of a replica that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaAutoScalingUpdate {
    /// <p>The Region where the replica exists.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>Represents the auto scaling settings of global secondary indexes that will
    /// be modified.</p>
    #[serde(rename = "ReplicaGlobalSecondaryIndexUpdates")]
    #[serde(default)]
    pub replica_global_secondary_index_updates: std::option::Option<
        std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate>,
    >,
    /// <p>Represents the auto scaling settings to be modified for a global table or global
    /// secondary index.</p>
    #[serde(rename = "ReplicaProvisionedReadCapacityAutoScalingUpdate")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_auto_scaling_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
}
impl std::fmt::Debug for ReplicaAutoScalingUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaAutoScalingUpdate");
        formatter.field("region_name", &self.region_name);
        formatter.field(
            "replica_global_secondary_index_updates",
            &self.replica_global_secondary_index_updates,
        );
        formatter.field(
            "replica_provisioned_read_capacity_auto_scaling_update",
            &self.replica_provisioned_read_capacity_auto_scaling_update,
        );
        formatter.finish()
    }
}
/// See [`ReplicaAutoScalingUpdate`](crate::model::ReplicaAutoScalingUpdate)
pub mod replica_auto_scaling_update {
    /// A builder for [`ReplicaAutoScalingUpdate`](crate::model::ReplicaAutoScalingUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) replica_global_secondary_index_updates: std::option::Option<
            std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate>,
        >,
        pub(crate) replica_provisioned_read_capacity_auto_scaling_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    }
    impl Builder {
        /// <p>The Region where the replica exists.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        pub fn replica_global_secondary_index_updates(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate>,
        ) -> Self {
            let mut v = self
                .replica_global_secondary_index_updates
                .unwrap_or_default();
            v.push(inp.into());
            self.replica_global_secondary_index_updates = Some(v);
            self
        }
        pub fn set_replica_global_secondary_index_updates(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate>,
            >,
        ) -> Self {
            self.replica_global_secondary_index_updates = inp;
            self
        }
        /// <p>Represents the auto scaling settings to be modified for a global table or global
        /// secondary index.</p>
        pub fn replica_provisioned_read_capacity_auto_scaling_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_update = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_auto_scaling_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaAutoScalingUpdate`](crate::model::ReplicaAutoScalingUpdate)
        pub fn build(self) -> crate::model::ReplicaAutoScalingUpdate {
            crate::model::ReplicaAutoScalingUpdate {
                region_name: self.region_name,
                replica_global_secondary_index_updates: self.replica_global_secondary_index_updates,
                replica_provisioned_read_capacity_auto_scaling_update: self
                    .replica_provisioned_read_capacity_auto_scaling_update,
            }
        }
    }
}
impl ReplicaAutoScalingUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicaAutoScalingUpdate`](crate::model::ReplicaAutoScalingUpdate)
    pub fn builder() -> crate::model::replica_auto_scaling_update::Builder {
        crate::model::replica_auto_scaling_update::Builder::default()
    }
}

/// <p>Represents the auto scaling settings to be modified for a global table or global
/// secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingSettingsUpdate {
    /// <p>The minimum capacity units that a global table or global secondary index should be scaled down to.</p>
    #[serde(rename = "MinimumUnits")]
    #[serde(default)]
    pub minimum_units: std::option::Option<i64>,
    /// <p>The maximum capacity units that a global table or global secondary index should be scaled up to.</p>
    #[serde(rename = "MaximumUnits")]
    #[serde(default)]
    pub maximum_units: std::option::Option<i64>,
    /// <p>Disabled auto scaling for this global table or global secondary index.</p>
    #[serde(rename = "AutoScalingDisabled")]
    #[serde(default)]
    pub auto_scaling_disabled: std::option::Option<bool>,
    /// <p>Role ARN used for configuring auto scaling policy.</p>
    #[serde(rename = "AutoScalingRoleArn")]
    #[serde(default)]
    pub auto_scaling_role_arn: std::option::Option<std::string::String>,
    /// <p>The scaling policy to apply for scaling target global table or global secondary index capacity units.</p>
    #[serde(rename = "ScalingPolicyUpdate")]
    #[serde(default)]
    pub scaling_policy_update: std::option::Option<crate::model::AutoScalingPolicyUpdate>,
}
impl std::fmt::Debug for AutoScalingSettingsUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingSettingsUpdate");
        formatter.field("minimum_units", &self.minimum_units);
        formatter.field("maximum_units", &self.maximum_units);
        formatter.field("auto_scaling_disabled", &self.auto_scaling_disabled);
        formatter.field("auto_scaling_role_arn", &self.auto_scaling_role_arn);
        formatter.field("scaling_policy_update", &self.scaling_policy_update);
        formatter.finish()
    }
}
/// See [`AutoScalingSettingsUpdate`](crate::model::AutoScalingSettingsUpdate)
pub mod auto_scaling_settings_update {
    /// A builder for [`AutoScalingSettingsUpdate`](crate::model::AutoScalingSettingsUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) minimum_units: std::option::Option<i64>,
        pub(crate) maximum_units: std::option::Option<i64>,
        pub(crate) auto_scaling_disabled: std::option::Option<bool>,
        pub(crate) auto_scaling_role_arn: std::option::Option<std::string::String>,
        pub(crate) scaling_policy_update:
            std::option::Option<crate::model::AutoScalingPolicyUpdate>,
    }
    impl Builder {
        /// <p>The minimum capacity units that a global table or global secondary index should be scaled down to.</p>
        pub fn minimum_units(mut self, inp: i64) -> Self {
            self.minimum_units = Some(inp);
            self
        }
        pub fn set_minimum_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.minimum_units = inp;
            self
        }
        /// <p>The maximum capacity units that a global table or global secondary index should be scaled up to.</p>
        pub fn maximum_units(mut self, inp: i64) -> Self {
            self.maximum_units = Some(inp);
            self
        }
        pub fn set_maximum_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.maximum_units = inp;
            self
        }
        /// <p>Disabled auto scaling for this global table or global secondary index.</p>
        pub fn auto_scaling_disabled(mut self, inp: bool) -> Self {
            self.auto_scaling_disabled = Some(inp);
            self
        }
        pub fn set_auto_scaling_disabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.auto_scaling_disabled = inp;
            self
        }
        /// <p>Role ARN used for configuring auto scaling policy.</p>
        pub fn auto_scaling_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.auto_scaling_role_arn = Some(inp.into());
            self
        }
        pub fn set_auto_scaling_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_role_arn = inp;
            self
        }
        /// <p>The scaling policy to apply for scaling target global table or global secondary index capacity units.</p>
        pub fn scaling_policy_update(mut self, inp: crate::model::AutoScalingPolicyUpdate) -> Self {
            self.scaling_policy_update = Some(inp);
            self
        }
        pub fn set_scaling_policy_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingPolicyUpdate>,
        ) -> Self {
            self.scaling_policy_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingSettingsUpdate`](crate::model::AutoScalingSettingsUpdate)
        pub fn build(self) -> crate::model::AutoScalingSettingsUpdate {
            crate::model::AutoScalingSettingsUpdate {
                minimum_units: self.minimum_units,
                maximum_units: self.maximum_units,
                auto_scaling_disabled: self.auto_scaling_disabled,
                auto_scaling_role_arn: self.auto_scaling_role_arn,
                scaling_policy_update: self.scaling_policy_update,
            }
        }
    }
}
impl AutoScalingSettingsUpdate {
    /// Creates a new builder-style object to manufacture [`AutoScalingSettingsUpdate`](crate::model::AutoScalingSettingsUpdate)
    pub fn builder() -> crate::model::auto_scaling_settings_update::Builder {
        crate::model::auto_scaling_settings_update::Builder::default()
    }
}

/// <p>Represents the auto scaling policy to be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingPolicyUpdate {
    /// <p>The name of the scaling policy.</p>
    #[serde(rename = "PolicyName")]
    #[serde(default)]
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>Represents a target tracking scaling policy configuration.</p>
    #[serde(rename = "TargetTrackingScalingPolicyConfiguration")]
    #[serde(default)]
    pub target_tracking_scaling_policy_configuration: std::option::Option<
        crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate,
    >,
}
impl std::fmt::Debug for AutoScalingPolicyUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingPolicyUpdate");
        formatter.field("policy_name", &self.policy_name);
        formatter.field(
            "target_tracking_scaling_policy_configuration",
            &self.target_tracking_scaling_policy_configuration,
        );
        formatter.finish()
    }
}
/// See [`AutoScalingPolicyUpdate`](crate::model::AutoScalingPolicyUpdate)
pub mod auto_scaling_policy_update {
    /// A builder for [`AutoScalingPolicyUpdate`](crate::model::AutoScalingPolicyUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) target_tracking_scaling_policy_configuration: std::option::Option<
            crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate,
        >,
    }
    impl Builder {
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(inp.into());
            self
        }
        pub fn set_policy_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.policy_name = inp;
            self
        }
        /// <p>Represents a target tracking scaling policy configuration.</p>
        pub fn target_tracking_scaling_policy_configuration(
            mut self,
            inp: crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate,
        ) -> Self {
            self.target_tracking_scaling_policy_configuration = Some(inp);
            self
        }
        pub fn set_target_tracking_scaling_policy_configuration(
            mut self,
            inp: std::option::Option<
                crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate,
            >,
        ) -> Self {
            self.target_tracking_scaling_policy_configuration = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingPolicyUpdate`](crate::model::AutoScalingPolicyUpdate)
        pub fn build(self) -> crate::model::AutoScalingPolicyUpdate {
            crate::model::AutoScalingPolicyUpdate {
                policy_name: self.policy_name,
                target_tracking_scaling_policy_configuration: self
                    .target_tracking_scaling_policy_configuration,
            }
        }
    }
}
impl AutoScalingPolicyUpdate {
    /// Creates a new builder-style object to manufacture [`AutoScalingPolicyUpdate`](crate::model::AutoScalingPolicyUpdate)
    pub fn builder() -> crate::model::auto_scaling_policy_update::Builder {
        crate::model::auto_scaling_policy_update::Builder::default()
    }
}

/// <p>Represents the settings of a target tracking scaling policy that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
    /// <p>Indicates whether scale in by the target tracking policy is disabled. If the value is true,
    /// scale in is disabled and the target tracking policy won't remove capacity from the scalable resource.
    /// Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource.
    /// The default value is false.</p>
    #[serde(rename = "DisableScaleIn")]
    #[serde(default)]
    pub disable_scale_in: std::option::Option<bool>,
    /// <p>The amount of time, in seconds, after a scale in activity completes before another scale
    /// in activity can start. The cooldown period is used to block subsequent scale in requests
    /// until it has expired. You should scale in conservatively to protect your application's
    /// availability. However, if another alarm triggers a scale out policy during the cooldown
    /// period after a scale-in, application auto scaling scales out your scalable target
    /// immediately. </p>
    #[serde(rename = "ScaleInCooldown")]
    #[serde(default)]
    pub scale_in_cooldown: std::option::Option<i32>,
    /// <p>The amount of time, in seconds, after a scale out activity completes before another scale out
    /// activity can start. While the cooldown period is in effect, the capacity that has been added
    /// by the previous scale out event that initiated the cooldown is calculated as part of the
    /// desired capacity for the next scale out. You should continuously (but not excessively)
    /// scale out.</p>
    #[serde(rename = "ScaleOutCooldown")]
    #[serde(default)]
    pub scale_out_cooldown: std::option::Option<i32>,
    /// <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10) or 2e-360 to 2e360 (Base 2).</p>
    #[serde(rename = "TargetValue")]
    #[serde(default)]
    pub target_value: std::option::Option<f64>,
}
impl std::fmt::Debug for AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter =
            f.debug_struct("AutoScalingTargetTrackingScalingPolicyConfigurationUpdate");
        formatter.field("disable_scale_in", &self.disable_scale_in);
        formatter.field("scale_in_cooldown", &self.scale_in_cooldown);
        formatter.field("scale_out_cooldown", &self.scale_out_cooldown);
        formatter.field("target_value", &self.target_value);
        formatter.finish()
    }
}
/// See [`AutoScalingTargetTrackingScalingPolicyConfigurationUpdate`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate)
pub mod auto_scaling_target_tracking_scaling_policy_configuration_update {
    /// A builder for [`AutoScalingTargetTrackingScalingPolicyConfigurationUpdate`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) disable_scale_in: std::option::Option<bool>,
        pub(crate) scale_in_cooldown: std::option::Option<i32>,
        pub(crate) scale_out_cooldown: std::option::Option<i32>,
        pub(crate) target_value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>Indicates whether scale in by the target tracking policy is disabled. If the value is true,
        /// scale in is disabled and the target tracking policy won't remove capacity from the scalable resource.
        /// Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource.
        /// The default value is false.</p>
        pub fn disable_scale_in(mut self, inp: bool) -> Self {
            self.disable_scale_in = Some(inp);
            self
        }
        pub fn set_disable_scale_in(mut self, inp: std::option::Option<bool>) -> Self {
            self.disable_scale_in = inp;
            self
        }
        /// <p>The amount of time, in seconds, after a scale in activity completes before another scale
        /// in activity can start. The cooldown period is used to block subsequent scale in requests
        /// until it has expired. You should scale in conservatively to protect your application's
        /// availability. However, if another alarm triggers a scale out policy during the cooldown
        /// period after a scale-in, application auto scaling scales out your scalable target
        /// immediately. </p>
        pub fn scale_in_cooldown(mut self, inp: i32) -> Self {
            self.scale_in_cooldown = Some(inp);
            self
        }
        pub fn set_scale_in_cooldown(mut self, inp: std::option::Option<i32>) -> Self {
            self.scale_in_cooldown = inp;
            self
        }
        /// <p>The amount of time, in seconds, after a scale out activity completes before another scale out
        /// activity can start. While the cooldown period is in effect, the capacity that has been added
        /// by the previous scale out event that initiated the cooldown is calculated as part of the
        /// desired capacity for the next scale out. You should continuously (but not excessively)
        /// scale out.</p>
        pub fn scale_out_cooldown(mut self, inp: i32) -> Self {
            self.scale_out_cooldown = Some(inp);
            self
        }
        pub fn set_scale_out_cooldown(mut self, inp: std::option::Option<i32>) -> Self {
            self.scale_out_cooldown = inp;
            self
        }
        /// <p>The target value for the metric. The range is 8.515920e-109 to 1.174271e+108 (Base 10) or 2e-360 to 2e360 (Base 2).</p>
        pub fn target_value(mut self, inp: f64) -> Self {
            self.target_value = Some(inp);
            self
        }
        pub fn set_target_value(mut self, inp: std::option::Option<f64>) -> Self {
            self.target_value = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingTargetTrackingScalingPolicyConfigurationUpdate`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate)
        pub fn build(
            self,
        ) -> crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
            crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
                disable_scale_in: self.disable_scale_in,
                scale_in_cooldown: self.scale_in_cooldown,
                scale_out_cooldown: self.scale_out_cooldown,
                target_value: self.target_value,
            }
        }
    }
}
impl AutoScalingTargetTrackingScalingPolicyConfigurationUpdate {
    /// Creates a new builder-style object to manufacture [`AutoScalingTargetTrackingScalingPolicyConfigurationUpdate`](crate::model::AutoScalingTargetTrackingScalingPolicyConfigurationUpdate)
    pub fn builder(
    ) -> crate::model::auto_scaling_target_tracking_scaling_policy_configuration_update::Builder
    {
        crate::model::auto_scaling_target_tracking_scaling_policy_configuration_update::Builder::default()
    }
}

/// <p>Represents the auto scaling settings of a global secondary index for a replica
/// that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndexAutoScalingUpdate {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Represents the auto scaling settings to be modified for a global table or global
    /// secondary index.</p>
    #[serde(rename = "ProvisionedReadCapacityAutoScalingUpdate")]
    #[serde(default)]
    pub provisioned_read_capacity_auto_scaling_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndexAutoScalingUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndexAutoScalingUpdate");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_read_capacity_auto_scaling_update",
            &self.provisioned_read_capacity_auto_scaling_update,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndexAutoScalingUpdate`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate)
pub mod replica_global_secondary_index_auto_scaling_update {
    /// A builder for [`ReplicaGlobalSecondaryIndexAutoScalingUpdate`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_read_capacity_auto_scaling_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>Represents the auto scaling settings to be modified for a global table or global
        /// secondary index.</p>
        pub fn provisioned_read_capacity_auto_scaling_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_update = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_auto_scaling_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexAutoScalingUpdate`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate {
            crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate {
                index_name: self.index_name,
                provisioned_read_capacity_auto_scaling_update: self
                    .provisioned_read_capacity_auto_scaling_update,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndexAutoScalingUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexAutoScalingUpdate`](crate::model::ReplicaGlobalSecondaryIndexAutoScalingUpdate)
    pub fn builder() -> crate::model::replica_global_secondary_index_auto_scaling_update::Builder {
        crate::model::replica_global_secondary_index_auto_scaling_update::Builder::default()
    }
}

/// <p>Represents the auto scaling settings of a global secondary index for a global table
/// that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalSecondaryIndexAutoScalingUpdate {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Represents the auto scaling settings to be modified for a global table or global
    /// secondary index.</p>
    #[serde(rename = "ProvisionedWriteCapacityAutoScalingUpdate")]
    #[serde(default)]
    pub provisioned_write_capacity_auto_scaling_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
}
impl std::fmt::Debug for GlobalSecondaryIndexAutoScalingUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalSecondaryIndexAutoScalingUpdate");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_write_capacity_auto_scaling_update",
            &self.provisioned_write_capacity_auto_scaling_update,
        );
        formatter.finish()
    }
}
/// See [`GlobalSecondaryIndexAutoScalingUpdate`](crate::model::GlobalSecondaryIndexAutoScalingUpdate)
pub mod global_secondary_index_auto_scaling_update {
    /// A builder for [`GlobalSecondaryIndexAutoScalingUpdate`](crate::model::GlobalSecondaryIndexAutoScalingUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_write_capacity_auto_scaling_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>Represents the auto scaling settings to be modified for a global table or global
        /// secondary index.</p>
        pub fn provisioned_write_capacity_auto_scaling_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_update = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_auto_scaling_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndexAutoScalingUpdate`](crate::model::GlobalSecondaryIndexAutoScalingUpdate)
        pub fn build(self) -> crate::model::GlobalSecondaryIndexAutoScalingUpdate {
            crate::model::GlobalSecondaryIndexAutoScalingUpdate {
                index_name: self.index_name,
                provisioned_write_capacity_auto_scaling_update: self
                    .provisioned_write_capacity_auto_scaling_update,
            }
        }
    }
}
impl GlobalSecondaryIndexAutoScalingUpdate {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndexAutoScalingUpdate`](crate::model::GlobalSecondaryIndexAutoScalingUpdate)
    pub fn builder() -> crate::model::global_secondary_index_auto_scaling_update::Builder {
        crate::model::global_secondary_index_auto_scaling_update::Builder::default()
    }
}

/// <p>Represents the properties of a table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TableDescription {
    /// <p>An array of <code>AttributeDefinition</code> objects. Each of these objects describes one attribute
    /// in the table and index key schema.</p>
    /// <p>Each <code>AttributeDefinition</code> object in this array is composed of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AttributeName</code> - The name of the attribute.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AttributeType</code> - The data type for the attribute.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "AttributeDefinitions")]
    #[serde(default)]
    pub attribute_definitions:
        std::option::Option<std::vec::Vec<crate::model::AttributeDefinition>>,
    /// <p>The name of the table.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The primary key structure for the table. Each <code>KeySchemaElement</code> consists of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AttributeName</code> - The name of the attribute.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KeyType</code> - The role of the attribute:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> -  partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    /// </li>
    /// </ul>
    /// <p>For more information about primary keys, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey">Primary Key</a> in the
    /// <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>The current state of the table:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The table is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The table is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The table is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The table is ready for use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The AWS KMS
    /// key used to encrypt the table in inaccessible. Table operations
    /// may fail due to failure to use the AWS KMS key. DynamoDB will
    /// initiate the table archival process when a table's AWS KMS key
    /// remains inaccessible for more than seven days.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARCHIVING</code> - The table is being archived. Operations
    /// are not allowed until archival is complete.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ARCHIVED</code> - The table has been archived. See the
    /// ArchivalReason for more information.
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "TableStatus")]
    #[serde(default)]
    pub table_status: std::option::Option<crate::model::TableStatus>,
    /// <p>The date and time when the table was created, in <a href="http://www.epochconverter.com/">UNIX epoch time</a> format.</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The provisioned throughput settings for the table, consisting of read and write capacity units, along with data about increases and decreases.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughputDescription>,
    /// <p>The total size of the specified table, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "TableSizeBytes")]
    #[serde(default)]
    pub table_size_bytes: i64,
    /// <p>The number of items in the specified table. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "ItemCount")]
    #[serde(default)]
    pub item_count: i64,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the table.</p>
    #[serde(rename = "TableArn")]
    #[serde(default)]
    pub table_arn: std::option::Option<std::string::String>,
    /// <p>Unique identifier for the table for which the backup was created. </p>
    #[serde(rename = "TableId")]
    #[serde(default)]
    pub table_id: std::option::Option<std::string::String>,
    /// <p>Contains the details for the read/write capacity mode.</p>
    #[serde(rename = "BillingModeSummary")]
    #[serde(default)]
    pub billing_mode_summary: std::option::Option<crate::model::BillingModeSummary>,
    /// <p>Represents one or more local secondary indexes on the table. Each index is scoped to a given partition key value. Tables with one or more local secondary indexes are subject to an item collection size limit, where the amount of data within a given item collection cannot exceed 10 GB. Each element is composed of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IndexName</code> - The name of the local secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KeySchema</code> - Specifies the complete index key schema. The attribute names in the
    /// key schema must be between 1 and 255 characters (inclusive). The key schema must begin
    /// with the same partition key as the table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Projection</code> - Specifies
    /// attributes that are copied (projected) from the table into the index. These are in
    /// addition to the primary key attributes and index key
    /// attributes, which are automatically projected. Each
    /// attribute specification is composed of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ProjectionType</code> - One
    /// of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the
    /// index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INCLUDE</code> - Only the specified table attributes are projected
    /// into the index. The list of projected attributes is in
    /// <code>NonKeyAttributes</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code> - All of the table attributes are projected into the
    /// index.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NonKeyAttributes</code> - A list of one or more non-key attribute names that are
    /// projected into the secondary index. The total count of attributes provided in <code>NonKeyAttributes</code>, summed across all of the secondary indexes, must not exceed 20. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IndexSizeBytes</code> - Represents the total size of the index, in bytes. DynamoDB updates
    /// this value approximately every six hours. Recent changes might not be reflected in this
    /// value.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ItemCount</code> - Represents the number of items in the index. DynamoDB updates this value
    /// approximately every six hours. Recent changes might not be reflected in this value.</p>
    /// </li>
    /// </ul>
    /// <p>If the table is in the <code>DELETING</code> state, no information about indexes will be
    /// returned.</p>
    #[serde(rename = "LocalSecondaryIndexes")]
    #[serde(default)]
    pub local_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexDescription>>,
    /// <p>The global secondary indexes, if any, on the table. Each index is scoped to a given partition key value. Each element is composed of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Backfilling</code> - If true, then the index is currently in the backfilling
    /// phase. Backfilling occurs only when a new global secondary index is added to the
    /// table. It is the process by which DynamoDB populates the new index with data from the
    /// table. (This attribute does not appear for indexes that were created during a
    /// <code>CreateTable</code> operation.) </p>
    /// <p> You can delete an index that is being created during the <code>Backfilling</code>
    /// phase when <code>IndexStatus</code> is set to CREATING and <code>Backfilling</code>
    /// is true. You can't delete the index that is being created when
    /// <code>IndexStatus</code> is set to CREATING and <code>Backfilling</code> is false.
    /// (This attribute does not appear for indexes that were created during a
    /// <code>CreateTable</code> operation.)</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IndexName</code> - The name of the global secondary index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IndexSizeBytes</code> - The total size of the global secondary index, in bytes. DynamoDB updates this value approximately every six
    /// hours. Recent changes might not be reflected in this value.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IndexStatus</code> - The current status of the global secondary index:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The index is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The index is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The index is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The index is ready for use.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ItemCount</code> - The number of items in the global secondary index. DynamoDB updates this value approximately every six
    /// hours. Recent changes might not be reflected in this value.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KeySchema</code> - Specifies the complete index key schema. The attribute names in the
    /// key schema must be between 1 and 255 characters (inclusive). The key schema must begin
    /// with the same partition key as the table.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Projection</code> - Specifies
    /// attributes that are copied (projected) from the table into the index. These are in
    /// addition to the primary key attributes and index key
    /// attributes, which are automatically projected. Each
    /// attribute specification is composed of:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ProjectionType</code> - One
    /// of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the
    /// index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INCLUDE</code> - In addition to the attributes described in <code>KEYS_ONLY</code>, the secondary index will include other non-key attributes that you specify.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code> - All of the table attributes are projected into the
    /// index.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NonKeyAttributes</code> - A list of one or more non-key attribute names that are
    /// projected into the secondary index. The total count of attributes provided in <code>NonKeyAttributes</code>, summed across all of the secondary indexes, must not exceed 20. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ProvisionedThroughput</code> - The provisioned throughput settings for the global secondary index,
    /// consisting of read and write capacity units, along with data about increases and
    /// decreases. </p>
    /// </li>
    /// </ul>
    /// <p>If the table is in the <code>DELETING</code> state, no information about indexes will be
    /// returned.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexDescription>>,
    /// <p>The current DynamoDB Streams configuration for the table.</p>
    #[serde(rename = "StreamSpecification")]
    #[serde(default)]
    pub stream_specification: std::option::Option<crate::model::StreamSpecification>,
    /// <p>A timestamp, in ISO 8601 format, for this stream.</p>
    /// <p>Note that <code>LatestStreamLabel</code> is not a unique identifier for the stream, because it is possible that a stream from another table might have the same timestamp. However, the combination of the following three elements is guaranteed to be unique:</p>
    /// <ul>
    /// <li>
    /// <p>AWS customer ID</p>
    /// </li>
    /// <li>
    /// <p>Table name</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>StreamLabel</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "LatestStreamLabel")]
    #[serde(default)]
    pub latest_stream_label: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the latest stream for this table.</p>
    #[serde(rename = "LatestStreamArn")]
    #[serde(default)]
    pub latest_stream_arn: std::option::Option<std::string::String>,
    /// <p>Represents the version of <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html">global tables</a> in use, if the table is replicated across AWS Regions.</p>
    #[serde(rename = "GlobalTableVersion")]
    #[serde(default)]
    pub global_table_version: std::option::Option<std::string::String>,
    /// <p>Represents replicas of the table.</p>
    #[serde(rename = "Replicas")]
    #[serde(default)]
    pub replicas: std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
    /// <p>Contains details for the restore.</p>
    #[serde(rename = "RestoreSummary")]
    #[serde(default)]
    pub restore_summary: std::option::Option<crate::model::RestoreSummary>,
    /// <p>The description of the server-side encryption status on the specified table.</p>
    #[serde(rename = "SSEDescription")]
    #[serde(default)]
    pub sse_description: std::option::Option<crate::model::SSEDescription>,
    /// <p>Contains information about the table archive.</p>
    #[serde(rename = "ArchivalSummary")]
    #[serde(default)]
    pub archival_summary: std::option::Option<crate::model::ArchivalSummary>,
}
impl std::fmt::Debug for TableDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableDescription");
        formatter.field("attribute_definitions", &self.attribute_definitions);
        formatter.field("table_name", &self.table_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("table_status", &self.table_status);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.field("table_size_bytes", &self.table_size_bytes);
        formatter.field("item_count", &self.item_count);
        formatter.field("table_arn", &self.table_arn);
        formatter.field("table_id", &self.table_id);
        formatter.field("billing_mode_summary", &self.billing_mode_summary);
        formatter.field("local_secondary_indexes", &self.local_secondary_indexes);
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field("stream_specification", &self.stream_specification);
        formatter.field("latest_stream_label", &self.latest_stream_label);
        formatter.field("latest_stream_arn", &self.latest_stream_arn);
        formatter.field("global_table_version", &self.global_table_version);
        formatter.field("replicas", &self.replicas);
        formatter.field("restore_summary", &self.restore_summary);
        formatter.field("sse_description", &self.sse_description);
        formatter.field("archival_summary", &self.archival_summary);
        formatter.finish()
    }
}
/// See [`TableDescription`](crate::model::TableDescription)
pub mod table_description {
    /// A builder for [`TableDescription`](crate::model::TableDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_definitions:
            std::option::Option<std::vec::Vec<crate::model::AttributeDefinition>>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) table_status: std::option::Option<crate::model::TableStatus>,
        pub(crate) creation_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) provisioned_throughput:
            std::option::Option<crate::model::ProvisionedThroughputDescription>,
        pub(crate) table_size_bytes: std::option::Option<i64>,
        pub(crate) item_count: std::option::Option<i64>,
        pub(crate) table_arn: std::option::Option<std::string::String>,
        pub(crate) table_id: std::option::Option<std::string::String>,
        pub(crate) billing_mode_summary: std::option::Option<crate::model::BillingModeSummary>,
        pub(crate) local_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexDescription>>,
        pub(crate) global_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexDescription>>,
        pub(crate) stream_specification: std::option::Option<crate::model::StreamSpecification>,
        pub(crate) latest_stream_label: std::option::Option<std::string::String>,
        pub(crate) latest_stream_arn: std::option::Option<std::string::String>,
        pub(crate) global_table_version: std::option::Option<std::string::String>,
        pub(crate) replicas: std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
        pub(crate) restore_summary: std::option::Option<crate::model::RestoreSummary>,
        pub(crate) sse_description: std::option::Option<crate::model::SSEDescription>,
        pub(crate) archival_summary: std::option::Option<crate::model::ArchivalSummary>,
    }
    impl Builder {
        pub fn attribute_definitions(
            mut self,
            inp: impl Into<crate::model::AttributeDefinition>,
        ) -> Self {
            let mut v = self.attribute_definitions.unwrap_or_default();
            v.push(inp.into());
            self.attribute_definitions = Some(v);
            self
        }
        pub fn set_attribute_definitions(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttributeDefinition>>,
        ) -> Self {
            self.attribute_definitions = inp;
            self
        }
        /// <p>The name of the table.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>The current state of the table:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The table is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The table is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The table is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The table is ready for use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The AWS KMS
        /// key used to encrypt the table in inaccessible. Table operations
        /// may fail due to failure to use the AWS KMS key. DynamoDB will
        /// initiate the table archival process when a table's AWS KMS key
        /// remains inaccessible for more than seven days.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARCHIVING</code> - The table is being archived. Operations
        /// are not allowed until archival is complete.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ARCHIVED</code> - The table has been archived. See the
        /// ArchivalReason for more information.
        /// </p>
        /// </li>
        /// </ul>
        pub fn table_status(mut self, inp: crate::model::TableStatus) -> Self {
            self.table_status = Some(inp);
            self
        }
        pub fn set_table_status(
            mut self,
            inp: std::option::Option<crate::model::TableStatus>,
        ) -> Self {
            self.table_status = inp;
            self
        }
        /// <p>The date and time when the table was created, in <a href="http://www.epochconverter.com/">UNIX epoch time</a> format.</p>
        pub fn creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_date_time = Some(inp);
            self
        }
        pub fn set_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_date_time = inp;
            self
        }
        /// <p>The provisioned throughput settings for the table, consisting of read and write capacity units, along with data about increases and decreases.</p>
        pub fn provisioned_throughput(
            mut self,
            inp: crate::model::ProvisionedThroughputDescription,
        ) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputDescription>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// <p>The total size of the specified table, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn table_size_bytes(mut self, inp: i64) -> Self {
            self.table_size_bytes = Some(inp);
            self
        }
        pub fn set_table_size_bytes(mut self, inp: i64) -> Self {
            self.table_size_bytes = Some(inp);
            self
        }
        /// <p>The number of items in the specified table. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        pub fn set_item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the table.</p>
        pub fn table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_arn = Some(inp.into());
            self
        }
        pub fn set_table_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_arn = inp;
            self
        }
        /// <p>Unique identifier for the table for which the backup was created. </p>
        pub fn table_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_id = Some(inp.into());
            self
        }
        pub fn set_table_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_id = inp;
            self
        }
        /// <p>Contains the details for the read/write capacity mode.</p>
        pub fn billing_mode_summary(mut self, inp: crate::model::BillingModeSummary) -> Self {
            self.billing_mode_summary = Some(inp);
            self
        }
        pub fn set_billing_mode_summary(
            mut self,
            inp: std::option::Option<crate::model::BillingModeSummary>,
        ) -> Self {
            self.billing_mode_summary = inp;
            self
        }
        pub fn local_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::LocalSecondaryIndexDescription>,
        ) -> Self {
            let mut v = self.local_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.local_secondary_indexes = Some(v);
            self
        }
        pub fn set_local_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexDescription>>,
        ) -> Self {
            self.local_secondary_indexes = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::GlobalSecondaryIndexDescription>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexDescription>>,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// <p>The current DynamoDB Streams configuration for the table.</p>
        pub fn stream_specification(mut self, inp: crate::model::StreamSpecification) -> Self {
            self.stream_specification = Some(inp);
            self
        }
        pub fn set_stream_specification(
            mut self,
            inp: std::option::Option<crate::model::StreamSpecification>,
        ) -> Self {
            self.stream_specification = inp;
            self
        }
        /// <p>A timestamp, in ISO 8601 format, for this stream.</p>
        /// <p>Note that <code>LatestStreamLabel</code> is not a unique identifier for the stream, because it is possible that a stream from another table might have the same timestamp. However, the combination of the following three elements is guaranteed to be unique:</p>
        /// <ul>
        /// <li>
        /// <p>AWS customer ID</p>
        /// </li>
        /// <li>
        /// <p>Table name</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>StreamLabel</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn latest_stream_label(mut self, inp: impl Into<std::string::String>) -> Self {
            self.latest_stream_label = Some(inp.into());
            self
        }
        pub fn set_latest_stream_label(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_stream_label = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the latest stream for this table.</p>
        pub fn latest_stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.latest_stream_arn = Some(inp.into());
            self
        }
        pub fn set_latest_stream_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.latest_stream_arn = inp;
            self
        }
        /// <p>Represents the version of <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html">global tables</a> in use, if the table is replicated across AWS Regions.</p>
        pub fn global_table_version(mut self, inp: impl Into<std::string::String>) -> Self {
            self.global_table_version = Some(inp.into());
            self
        }
        pub fn set_global_table_version(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_table_version = inp;
            self
        }
        pub fn replicas(mut self, inp: impl Into<crate::model::ReplicaDescription>) -> Self {
            let mut v = self.replicas.unwrap_or_default();
            v.push(inp.into());
            self.replicas = Some(v);
            self
        }
        pub fn set_replicas(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
        ) -> Self {
            self.replicas = inp;
            self
        }
        /// <p>Contains details for the restore.</p>
        pub fn restore_summary(mut self, inp: crate::model::RestoreSummary) -> Self {
            self.restore_summary = Some(inp);
            self
        }
        pub fn set_restore_summary(
            mut self,
            inp: std::option::Option<crate::model::RestoreSummary>,
        ) -> Self {
            self.restore_summary = inp;
            self
        }
        /// <p>The description of the server-side encryption status on the specified table.</p>
        pub fn sse_description(mut self, inp: crate::model::SSEDescription) -> Self {
            self.sse_description = Some(inp);
            self
        }
        pub fn set_sse_description(
            mut self,
            inp: std::option::Option<crate::model::SSEDescription>,
        ) -> Self {
            self.sse_description = inp;
            self
        }
        /// <p>Contains information about the table archive.</p>
        pub fn archival_summary(mut self, inp: crate::model::ArchivalSummary) -> Self {
            self.archival_summary = Some(inp);
            self
        }
        pub fn set_archival_summary(
            mut self,
            inp: std::option::Option<crate::model::ArchivalSummary>,
        ) -> Self {
            self.archival_summary = inp;
            self
        }
        /// Consumes the builder and constructs a [`TableDescription`](crate::model::TableDescription)
        pub fn build(self) -> crate::model::TableDescription {
            crate::model::TableDescription {
                attribute_definitions: self.attribute_definitions,
                table_name: self.table_name,
                key_schema: self.key_schema,
                table_status: self.table_status,
                creation_date_time: self.creation_date_time,
                provisioned_throughput: self.provisioned_throughput,
                table_size_bytes: self.table_size_bytes.unwrap_or_default(),
                item_count: self.item_count.unwrap_or_default(),
                table_arn: self.table_arn,
                table_id: self.table_id,
                billing_mode_summary: self.billing_mode_summary,
                local_secondary_indexes: self.local_secondary_indexes,
                global_secondary_indexes: self.global_secondary_indexes,
                stream_specification: self.stream_specification,
                latest_stream_label: self.latest_stream_label,
                latest_stream_arn: self.latest_stream_arn,
                global_table_version: self.global_table_version,
                replicas: self.replicas,
                restore_summary: self.restore_summary,
                sse_description: self.sse_description,
                archival_summary: self.archival_summary,
            }
        }
    }
}
impl TableDescription {
    /// Creates a new builder-style object to manufacture [`TableDescription`](crate::model::TableDescription)
    pub fn builder() -> crate::model::table_description::Builder {
        crate::model::table_description::Builder::default()
    }
}

/// <p>Contains details of a table archival operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ArchivalSummary {
    /// <p>The date and time when table archival was initiated by DynamoDB,
    /// in UNIX epoch time format.</p>
    #[serde(rename = "ArchivalDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub archival_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The reason DynamoDB archived the table. Currently, the only
    /// possible value is:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The
    /// table was archived due to the table's AWS KMS key being inaccessible
    /// for more than seven days. An On-Demand backup was created at the archival
    /// time.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "ArchivalReason")]
    #[serde(default)]
    pub archival_reason: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the backup the table was archived
    /// to, when applicable in the archival reason. If you wish to restore this
    /// backup to the same table name, you will need to delete the original
    /// table.</p>
    #[serde(rename = "ArchivalBackupArn")]
    #[serde(default)]
    pub archival_backup_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ArchivalSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArchivalSummary");
        formatter.field("archival_date_time", &self.archival_date_time);
        formatter.field("archival_reason", &self.archival_reason);
        formatter.field("archival_backup_arn", &self.archival_backup_arn);
        formatter.finish()
    }
}
/// See [`ArchivalSummary`](crate::model::ArchivalSummary)
pub mod archival_summary {
    /// A builder for [`ArchivalSummary`](crate::model::ArchivalSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) archival_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) archival_reason: std::option::Option<std::string::String>,
        pub(crate) archival_backup_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date and time when table archival was initiated by DynamoDB,
        /// in UNIX epoch time format.</p>
        pub fn archival_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.archival_date_time = Some(inp);
            self
        }
        pub fn set_archival_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.archival_date_time = inp;
            self
        }
        /// <p>The reason DynamoDB archived the table. Currently, the only
        /// possible value is:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code> - The
        /// table was archived due to the table's AWS KMS key being inaccessible
        /// for more than seven days. An On-Demand backup was created at the archival
        /// time.</p>
        /// </li>
        /// </ul>
        pub fn archival_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.archival_reason = Some(inp.into());
            self
        }
        pub fn set_archival_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.archival_reason = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the backup the table was archived
        /// to, when applicable in the archival reason. If you wish to restore this
        /// backup to the same table name, you will need to delete the original
        /// table.</p>
        pub fn archival_backup_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.archival_backup_arn = Some(inp.into());
            self
        }
        pub fn set_archival_backup_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.archival_backup_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`ArchivalSummary`](crate::model::ArchivalSummary)
        pub fn build(self) -> crate::model::ArchivalSummary {
            crate::model::ArchivalSummary {
                archival_date_time: self.archival_date_time,
                archival_reason: self.archival_reason,
                archival_backup_arn: self.archival_backup_arn,
            }
        }
    }
}
impl ArchivalSummary {
    /// Creates a new builder-style object to manufacture [`ArchivalSummary`](crate::model::ArchivalSummary)
    pub fn builder() -> crate::model::archival_summary::Builder {
        crate::model::archival_summary::Builder::default()
    }
}

/// <p>The description of the server-side encryption status on the specified table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SSEDescription {
    /// <p>Represents the current state of server-side encryption. The only supported values are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ENABLED</code> - Server-side encryption is enabled.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - Server-side encryption is being updated.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "Status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::SseStatus>,
    /// <p>Server-side encryption type. The only supported value is:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KMS</code> - Server-side encryption that uses AWS Key Management Service. The
    /// key is stored in your account and is managed by AWS KMS (AWS KMS charges
    /// apply).</p>
    /// </li>
    /// </ul>
    #[serde(rename = "SSEType")]
    #[serde(default)]
    pub sse_type: std::option::Option<crate::model::SseType>,
    /// <p>The AWS KMS customer master key (CMK) ARN used for the AWS KMS encryption.</p>
    #[serde(rename = "KMSMasterKeyArn")]
    #[serde(default)]
    pub kms_master_key_arn: std::option::Option<std::string::String>,
    /// <p>Indicates the time, in UNIX epoch date format, when DynamoDB detected that the table's
    /// AWS KMS key was inaccessible. This attribute will automatically be cleared when DynamoDB
    /// detects that the table's AWS KMS key is accessible again. DynamoDB will initiate the table
    /// archival process when table's AWS KMS key remains inaccessible for more than seven days
    /// from this date.</p>
    #[serde(rename = "InaccessibleEncryptionDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub inaccessible_encryption_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for SSEDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SSEDescription");
        formatter.field("status", &self.status);
        formatter.field("sse_type", &self.sse_type);
        formatter.field("kms_master_key_arn", &self.kms_master_key_arn);
        formatter.field(
            "inaccessible_encryption_date_time",
            &self.inaccessible_encryption_date_time,
        );
        formatter.finish()
    }
}
/// See [`SSEDescription`](crate::model::SSEDescription)
pub mod sse_description {
    /// A builder for [`SSEDescription`](crate::model::SSEDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::SseStatus>,
        pub(crate) sse_type: std::option::Option<crate::model::SseType>,
        pub(crate) kms_master_key_arn: std::option::Option<std::string::String>,
        pub(crate) inaccessible_encryption_date_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Represents the current state of server-side encryption. The only supported values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ENABLED</code> - Server-side encryption is enabled.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - Server-side encryption is being updated.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::SseStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(mut self, inp: std::option::Option<crate::model::SseStatus>) -> Self {
            self.status = inp;
            self
        }
        /// <p>Server-side encryption type. The only supported value is:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KMS</code> - Server-side encryption that uses AWS Key Management Service. The
        /// key is stored in your account and is managed by AWS KMS (AWS KMS charges
        /// apply).</p>
        /// </li>
        /// </ul>
        pub fn sse_type(mut self, inp: crate::model::SseType) -> Self {
            self.sse_type = Some(inp);
            self
        }
        pub fn set_sse_type(mut self, inp: std::option::Option<crate::model::SseType>) -> Self {
            self.sse_type = inp;
            self
        }
        /// <p>The AWS KMS customer master key (CMK) ARN used for the AWS KMS encryption.</p>
        pub fn kms_master_key_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_master_key_arn = Some(inp.into());
            self
        }
        pub fn set_kms_master_key_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_arn = inp;
            self
        }
        /// <p>Indicates the time, in UNIX epoch date format, when DynamoDB detected that the table's
        /// AWS KMS key was inaccessible. This attribute will automatically be cleared when DynamoDB
        /// detects that the table's AWS KMS key is accessible again. DynamoDB will initiate the table
        /// archival process when table's AWS KMS key remains inaccessible for more than seven days
        /// from this date.</p>
        pub fn inaccessible_encryption_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.inaccessible_encryption_date_time = Some(inp);
            self
        }
        pub fn set_inaccessible_encryption_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inaccessible_encryption_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`SSEDescription`](crate::model::SSEDescription)
        pub fn build(self) -> crate::model::SSEDescription {
            crate::model::SSEDescription {
                status: self.status,
                sse_type: self.sse_type,
                kms_master_key_arn: self.kms_master_key_arn,
                inaccessible_encryption_date_time: self.inaccessible_encryption_date_time,
            }
        }
    }
}
impl SSEDescription {
    /// Creates a new builder-style object to manufacture [`SSEDescription`](crate::model::SSEDescription)
    pub fn builder() -> crate::model::sse_description::Builder {
        crate::model::sse_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SseType {
    Aes256,
    Kms,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SseType {
    fn from(s: &str) -> Self {
        match s {
            "AES256" => SseType::Aes256,
            "KMS" => SseType::Kms,
            other => SseType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SseType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SseType::from(s))
    }
}
impl SseType {
    pub fn as_str(&self) -> &str {
        match self {
            SseType::Aes256 => "AES256",
            SseType::Kms => "KMS",
            SseType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SseType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SseType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SseStatus {
    Disabled,
    Disabling,
    Enabled,
    Enabling,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SseStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => SseStatus::Disabled,
            "DISABLING" => SseStatus::Disabling,
            "ENABLED" => SseStatus::Enabled,
            "ENABLING" => SseStatus::Enabling,
            "UPDATING" => SseStatus::Updating,
            other => SseStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SseStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(SseStatus::from(s))
    }
}
impl SseStatus {
    pub fn as_str(&self) -> &str {
        match self {
            SseStatus::Disabled => "DISABLED",
            SseStatus::Disabling => "DISABLING",
            SseStatus::Enabled => "ENABLED",
            SseStatus::Enabling => "ENABLING",
            SseStatus::Updating => "UPDATING",
            SseStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for SseStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for SseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains details for the restore.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreSummary {
    /// <p>The Amazon Resource Name (ARN) of the backup from which the table was restored.</p>
    #[serde(rename = "SourceBackupArn")]
    #[serde(default)]
    pub source_backup_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the source table of the backup that is being restored.</p>
    #[serde(rename = "SourceTableArn")]
    #[serde(default)]
    pub source_table_arn: std::option::Option<std::string::String>,
    /// <p>Point in time or source backup time.</p>
    #[serde(rename = "RestoreDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub restore_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Indicates if a restore is in progress or not.</p>
    #[serde(rename = "RestoreInProgress")]
    #[serde(default)]
    pub restore_in_progress: std::option::Option<bool>,
}
impl std::fmt::Debug for RestoreSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreSummary");
        formatter.field("source_backup_arn", &self.source_backup_arn);
        formatter.field("source_table_arn", &self.source_table_arn);
        formatter.field("restore_date_time", &self.restore_date_time);
        formatter.field("restore_in_progress", &self.restore_in_progress);
        formatter.finish()
    }
}
/// See [`RestoreSummary`](crate::model::RestoreSummary)
pub mod restore_summary {
    /// A builder for [`RestoreSummary`](crate::model::RestoreSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_backup_arn: std::option::Option<std::string::String>,
        pub(crate) source_table_arn: std::option::Option<std::string::String>,
        pub(crate) restore_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) restore_in_progress: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the backup from which the table was restored.</p>
        pub fn source_backup_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.source_backup_arn = Some(inp.into());
            self
        }
        pub fn set_source_backup_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_backup_arn = inp;
            self
        }
        /// <p>The ARN of the source table of the backup that is being restored.</p>
        pub fn source_table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.source_table_arn = Some(inp.into());
            self
        }
        pub fn set_source_table_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_table_arn = inp;
            self
        }
        /// <p>Point in time or source backup time.</p>
        pub fn restore_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.restore_date_time = Some(inp);
            self
        }
        pub fn set_restore_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.restore_date_time = inp;
            self
        }
        /// <p>Indicates if a restore is in progress or not.</p>
        pub fn restore_in_progress(mut self, inp: bool) -> Self {
            self.restore_in_progress = Some(inp);
            self
        }
        pub fn set_restore_in_progress(mut self, inp: std::option::Option<bool>) -> Self {
            self.restore_in_progress = inp;
            self
        }
        /// Consumes the builder and constructs a [`RestoreSummary`](crate::model::RestoreSummary)
        pub fn build(self) -> crate::model::RestoreSummary {
            crate::model::RestoreSummary {
                source_backup_arn: self.source_backup_arn,
                source_table_arn: self.source_table_arn,
                restore_date_time: self.restore_date_time,
                restore_in_progress: self.restore_in_progress,
            }
        }
    }
}
impl RestoreSummary {
    /// Creates a new builder-style object to manufacture [`RestoreSummary`](crate::model::RestoreSummary)
    pub fn builder() -> crate::model::restore_summary::Builder {
        crate::model::restore_summary::Builder::default()
    }
}

/// <p>Contains the details of the replica.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaDescription {
    /// <p>The name of the Region.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The current state of the replica:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The replica is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The replica is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The replica is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The replica is ready for use.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>REGION_DISABLED</code> - The replica is inaccessible because the AWS Region has been disabled.</p>
    /// <note>
    /// <p>If the AWS Region remains inaccessible for more than 20 hours, DynamoDB will remove this replica from the replication group. The replica will not be deleted and replication will stop from and to this region.</p>
    /// </note>
    /// </li>
    /// <li>      
    /// <p>
    /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS </code> - The AWS KMS key used to encrypt the table is inaccessible.</p>
    /// <note>
    /// <p>If the AWS KMS key remains inaccessible for more than 20 hours, DynamoDB will remove this replica from the replication group. The replica will not be deleted and replication will stop from and to this region.</p>
    /// </note>
    /// </li>
    /// </ul>
    #[serde(rename = "ReplicaStatus")]
    #[serde(default)]
    pub replica_status: std::option::Option<crate::model::ReplicaStatus>,
    /// <p>Detailed information about the replica status.</p>
    #[serde(rename = "ReplicaStatusDescription")]
    #[serde(default)]
    pub replica_status_description: std::option::Option<std::string::String>,
    /// <p>Specifies the progress of a Create, Update, or Delete action on the replica
    /// as a percentage.</p>
    #[serde(rename = "ReplicaStatusPercentProgress")]
    #[serde(default)]
    pub replica_status_percent_progress: std::option::Option<std::string::String>,
    /// <p>The AWS KMS customer master key (CMK) of the replica that will be used for AWS KMS
    /// encryption.</p>
    #[serde(rename = "KMSMasterKeyId")]
    #[serde(default)]
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>Replica-specific provisioned throughput. If not described, uses the source table's
    /// provisioned throughput settings.</p>
    #[serde(rename = "ProvisionedThroughputOverride")]
    #[serde(default)]
    pub provisioned_throughput_override:
        std::option::Option<crate::model::ProvisionedThroughputOverride>,
    /// <p>Replica-specific global secondary index settings.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexDescription>>,
    /// <p>The time at which the replica was first detected as inaccessible. To determine cause of inaccessibility check the <code>ReplicaStatus</code> property.</p>
    #[serde(rename = "ReplicaInaccessibleDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub replica_inaccessible_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for ReplicaDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaDescription");
        formatter.field("region_name", &self.region_name);
        formatter.field("replica_status", &self.replica_status);
        formatter.field(
            "replica_status_description",
            &self.replica_status_description,
        );
        formatter.field(
            "replica_status_percent_progress",
            &self.replica_status_percent_progress,
        );
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field(
            "replica_inaccessible_date_time",
            &self.replica_inaccessible_date_time,
        );
        formatter.finish()
    }
}
/// See [`ReplicaDescription`](crate::model::ReplicaDescription)
pub mod replica_description {
    /// A builder for [`ReplicaDescription`](crate::model::ReplicaDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) replica_status: std::option::Option<crate::model::ReplicaStatus>,
        pub(crate) replica_status_description: std::option::Option<std::string::String>,
        pub(crate) replica_status_percent_progress: std::option::Option<std::string::String>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::ProvisionedThroughputOverride>,
        pub(crate) global_secondary_indexes: std::option::Option<
            std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexDescription>,
        >,
        pub(crate) replica_inaccessible_date_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the Region.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// <p>The current state of the replica:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The replica is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The replica is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The replica is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The replica is ready for use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REGION_DISABLED</code> - The replica is inaccessible because the AWS Region has been disabled.</p>
        /// <note>
        /// <p>If the AWS Region remains inaccessible for more than 20 hours, DynamoDB will remove this replica from the replication group. The replica will not be deleted and replication will stop from and to this region.</p>
        /// </note>
        /// </li>
        /// <li>      
        /// <p>
        /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS </code> - The AWS KMS key used to encrypt the table is inaccessible.</p>
        /// <note>
        /// <p>If the AWS KMS key remains inaccessible for more than 20 hours, DynamoDB will remove this replica from the replication group. The replica will not be deleted and replication will stop from and to this region.</p>
        /// </note>
        /// </li>
        /// </ul>
        pub fn replica_status(mut self, inp: crate::model::ReplicaStatus) -> Self {
            self.replica_status = Some(inp);
            self
        }
        pub fn set_replica_status(
            mut self,
            inp: std::option::Option<crate::model::ReplicaStatus>,
        ) -> Self {
            self.replica_status = inp;
            self
        }
        /// <p>Detailed information about the replica status.</p>
        pub fn replica_status_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.replica_status_description = Some(inp.into());
            self
        }
        pub fn set_replica_status_description(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_status_description = inp;
            self
        }
        /// <p>Specifies the progress of a Create, Update, or Delete action on the replica
        /// as a percentage.</p>
        pub fn replica_status_percent_progress(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.replica_status_percent_progress = Some(inp.into());
            self
        }
        pub fn set_replica_status_percent_progress(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.replica_status_percent_progress = inp;
            self
        }
        /// <p>The AWS KMS customer master key (CMK) of the replica that will be used for AWS KMS
        /// encryption.</p>
        pub fn kms_master_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_master_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = inp;
            self
        }
        /// <p>Replica-specific provisioned throughput. If not described, uses the source table's
        /// provisioned throughput settings.</p>
        pub fn provisioned_throughput_override(
            mut self,
            inp: crate::model::ProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(inp);
            self
        }
        pub fn set_provisioned_throughput_override(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndexDescription>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexDescription>,
            >,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// <p>The time at which the replica was first detected as inaccessible. To determine cause of inaccessibility check the <code>ReplicaStatus</code> property.</p>
        pub fn replica_inaccessible_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.replica_inaccessible_date_time = Some(inp);
            self
        }
        pub fn set_replica_inaccessible_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.replica_inaccessible_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaDescription`](crate::model::ReplicaDescription)
        pub fn build(self) -> crate::model::ReplicaDescription {
            crate::model::ReplicaDescription {
                region_name: self.region_name,
                replica_status: self.replica_status,
                replica_status_description: self.replica_status_description,
                replica_status_percent_progress: self.replica_status_percent_progress,
                kms_master_key_id: self.kms_master_key_id,
                provisioned_throughput_override: self.provisioned_throughput_override,
                global_secondary_indexes: self.global_secondary_indexes,
                replica_inaccessible_date_time: self.replica_inaccessible_date_time,
            }
        }
    }
}
impl ReplicaDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaDescription`](crate::model::ReplicaDescription)
    pub fn builder() -> crate::model::replica_description::Builder {
        crate::model::replica_description::Builder::default()
    }
}

/// <p>Represents the properties of a replica global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndexDescription {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>If not described, uses the source table GSI's read capacity settings.</p>
    #[serde(rename = "ProvisionedThroughputOverride")]
    #[serde(default)]
    pub provisioned_throughput_override:
        std::option::Option<crate::model::ProvisionedThroughputOverride>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndexDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndexDescription");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription)
pub mod replica_global_secondary_index_description {
    /// A builder for [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::ProvisionedThroughputOverride>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>If not described, uses the source table GSI's read capacity settings.</p>
        pub fn provisioned_throughput_override(
            mut self,
            inp: crate::model::ProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(inp);
            self
        }
        pub fn set_provisioned_throughput_override(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexDescription {
            crate::model::ReplicaGlobalSecondaryIndexDescription {
                index_name: self.index_name,
                provisioned_throughput_override: self.provisioned_throughput_override,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndexDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription)
    pub fn builder() -> crate::model::replica_global_secondary_index_description::Builder {
        crate::model::replica_global_secondary_index_description::Builder::default()
    }
}

/// <p>Replica-specific provisioned throughput settings. If not specified, uses the
/// source table's provisioned throughput settings.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughputOverride {
    /// <p>Replica-specific read capacity units. If not specified, uses the source table's
    /// read capacity settings.</p>
    #[serde(rename = "ReadCapacityUnits")]
    #[serde(default)]
    pub read_capacity_units: std::option::Option<i64>,
}
impl std::fmt::Debug for ProvisionedThroughputOverride {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputOverride");
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.finish()
    }
}
/// See [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride)
pub mod provisioned_throughput_override {
    /// A builder for [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Replica-specific read capacity units. If not specified, uses the source table's
        /// read capacity settings.</p>
        pub fn read_capacity_units(mut self, inp: i64) -> Self {
            self.read_capacity_units = Some(inp);
            self
        }
        pub fn set_read_capacity_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.read_capacity_units = inp;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride)
        pub fn build(self) -> crate::model::ProvisionedThroughputOverride {
            crate::model::ProvisionedThroughputOverride {
                read_capacity_units: self.read_capacity_units,
            }
        }
    }
}
impl ProvisionedThroughputOverride {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride)
    pub fn builder() -> crate::model::provisioned_throughput_override::Builder {
        crate::model::provisioned_throughput_override::Builder::default()
    }
}

/// <p>Represents the DynamoDB Streams configuration for a table in DynamoDB.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamSpecification {
    /// <p>Indicates whether DynamoDB Streams is enabled (true) or disabled (false) on the table.</p>
    #[serde(rename = "StreamEnabled")]
    #[serde(default)]
    pub stream_enabled: std::option::Option<bool>,
    /// <p>
    /// When an item in the table is modified, <code>StreamViewType</code>
    /// determines what information is written to the stream for this table. Valid values for
    /// <code>StreamViewType</code> are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KEYS_ONLY</code> - Only the key attributes of the modified item are written to the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW_IMAGE</code> - The entire item, as it appears after it was modified, is written
    /// to the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OLD_IMAGE</code> - The entire item, as it appeared before it was modified, is
    /// written to the stream.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NEW_AND_OLD_IMAGES</code> - Both the new and the old item images of the item are
    /// written to the stream.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "StreamViewType")]
    #[serde(default)]
    pub stream_view_type: std::option::Option<crate::model::StreamViewType>,
}
impl std::fmt::Debug for StreamSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamSpecification");
        formatter.field("stream_enabled", &self.stream_enabled);
        formatter.field("stream_view_type", &self.stream_view_type);
        formatter.finish()
    }
}
/// See [`StreamSpecification`](crate::model::StreamSpecification)
pub mod stream_specification {
    /// A builder for [`StreamSpecification`](crate::model::StreamSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_enabled: std::option::Option<bool>,
        pub(crate) stream_view_type: std::option::Option<crate::model::StreamViewType>,
    }
    impl Builder {
        /// <p>Indicates whether DynamoDB Streams is enabled (true) or disabled (false) on the table.</p>
        pub fn stream_enabled(mut self, inp: bool) -> Self {
            self.stream_enabled = Some(inp);
            self
        }
        pub fn set_stream_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.stream_enabled = inp;
            self
        }
        /// <p>
        /// When an item in the table is modified, <code>StreamViewType</code>
        /// determines what information is written to the stream for this table. Valid values for
        /// <code>StreamViewType</code> are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KEYS_ONLY</code> - Only the key attributes of the modified item are written to the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW_IMAGE</code> - The entire item, as it appears after it was modified, is written
        /// to the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OLD_IMAGE</code> - The entire item, as it appeared before it was modified, is
        /// written to the stream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEW_AND_OLD_IMAGES</code> - Both the new and the old item images of the item are
        /// written to the stream.</p>
        /// </li>
        /// </ul>
        pub fn stream_view_type(mut self, inp: crate::model::StreamViewType) -> Self {
            self.stream_view_type = Some(inp);
            self
        }
        pub fn set_stream_view_type(
            mut self,
            inp: std::option::Option<crate::model::StreamViewType>,
        ) -> Self {
            self.stream_view_type = inp;
            self
        }
        /// Consumes the builder and constructs a [`StreamSpecification`](crate::model::StreamSpecification)
        pub fn build(self) -> crate::model::StreamSpecification {
            crate::model::StreamSpecification {
                stream_enabled: self.stream_enabled,
                stream_view_type: self.stream_view_type,
            }
        }
    }
}
impl StreamSpecification {
    /// Creates a new builder-style object to manufacture [`StreamSpecification`](crate::model::StreamSpecification)
    pub fn builder() -> crate::model::stream_specification::Builder {
        crate::model::stream_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamViewType {
    KeysOnly,
    NewAndOldImages,
    NewImage,
    OldImage,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamViewType {
    fn from(s: &str) -> Self {
        match s {
            "KEYS_ONLY" => StreamViewType::KeysOnly,
            "NEW_AND_OLD_IMAGES" => StreamViewType::NewAndOldImages,
            "NEW_IMAGE" => StreamViewType::NewImage,
            "OLD_IMAGE" => StreamViewType::OldImage,
            other => StreamViewType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamViewType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StreamViewType::from(s))
    }
}
impl StreamViewType {
    pub fn as_str(&self) -> &str {
        match self {
            StreamViewType::KeysOnly => "KEYS_ONLY",
            StreamViewType::NewAndOldImages => "NEW_AND_OLD_IMAGES",
            StreamViewType::NewImage => "NEW_IMAGE",
            StreamViewType::OldImage => "OLD_IMAGE",
            StreamViewType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StreamViewType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StreamViewType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the properties of a global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalSecondaryIndexDescription {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into the global
    /// secondary index. These are in addition to the primary key attributes and index key
    /// attributes, which are automatically projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
    /// <p>The current state of the global secondary index:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The index is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The index is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The index is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The index is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "IndexStatus")]
    #[serde(default)]
    pub index_status: std::option::Option<crate::model::IndexStatus>,
    /// <p>Indicates whether the index is currently backfilling. <i>Backfilling</i> is the process of reading items from
    /// the table and determining whether they can be added to the index. (Not all items will qualify:  For example, a partition key
    /// cannot have any duplicate values.) If an item can be added to the index, DynamoDB will do so. After all items have been processed,
    /// the backfilling operation is complete and <code>Backfilling</code> is false.</p>
    /// <p>You can delete an index that is being created during the <code>Backfilling</code> phase
    /// when <code>IndexStatus</code> is set to CREATING and <code>Backfilling</code> is true. You
    /// can't delete the index that is being created when <code>IndexStatus</code> is set to
    /// CREATING and <code>Backfilling</code> is false. </p>
    /// <note>
    /// <p>For indexes that were created during a <code>CreateTable</code> operation, the <code>Backfilling</code> attribute does not appear in the <code>DescribeTable</code> output.</p>
    /// </note>
    #[serde(rename = "Backfilling")]
    #[serde(default)]
    pub backfilling: std::option::Option<bool>,
    /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
    /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughputDescription>,
    /// <p>The total size of the specified index, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "IndexSizeBytes")]
    #[serde(default)]
    pub index_size_bytes: i64,
    /// <p>The number of items in the specified index. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "ItemCount")]
    #[serde(default)]
    pub item_count: i64,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
    #[serde(rename = "IndexArn")]
    #[serde(default)]
    pub index_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalSecondaryIndexDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalSecondaryIndexDescription");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("index_status", &self.index_status);
        formatter.field("backfilling", &self.backfilling);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.field("index_size_bytes", &self.index_size_bytes);
        formatter.field("item_count", &self.item_count);
        formatter.field("index_arn", &self.index_arn);
        formatter.finish()
    }
}
/// See [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription)
pub mod global_secondary_index_description {
    /// A builder for [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
        pub(crate) index_status: std::option::Option<crate::model::IndexStatus>,
        pub(crate) backfilling: std::option::Option<bool>,
        pub(crate) provisioned_throughput:
            std::option::Option<crate::model::ProvisionedThroughputDescription>,
        pub(crate) index_size_bytes: std::option::Option<i64>,
        pub(crate) item_count: std::option::Option<i64>,
        pub(crate) index_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into the global
        /// secondary index. These are in addition to the primary key attributes and index key
        /// attributes, which are automatically projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// <p>The current state of the global secondary index:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The index is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The index is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The index is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The index is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn index_status(mut self, inp: crate::model::IndexStatus) -> Self {
            self.index_status = Some(inp);
            self
        }
        pub fn set_index_status(
            mut self,
            inp: std::option::Option<crate::model::IndexStatus>,
        ) -> Self {
            self.index_status = inp;
            self
        }
        /// <p>Indicates whether the index is currently backfilling. <i>Backfilling</i> is the process of reading items from
        /// the table and determining whether they can be added to the index. (Not all items will qualify:  For example, a partition key
        /// cannot have any duplicate values.) If an item can be added to the index, DynamoDB will do so. After all items have been processed,
        /// the backfilling operation is complete and <code>Backfilling</code> is false.</p>
        /// <p>You can delete an index that is being created during the <code>Backfilling</code> phase
        /// when <code>IndexStatus</code> is set to CREATING and <code>Backfilling</code> is true. You
        /// can't delete the index that is being created when <code>IndexStatus</code> is set to
        /// CREATING and <code>Backfilling</code> is false. </p>
        /// <note>
        /// <p>For indexes that were created during a <code>CreateTable</code> operation, the <code>Backfilling</code> attribute does not appear in the <code>DescribeTable</code> output.</p>
        /// </note>
        pub fn backfilling(mut self, inp: bool) -> Self {
            self.backfilling = Some(inp);
            self
        }
        pub fn set_backfilling(mut self, inp: std::option::Option<bool>) -> Self {
            self.backfilling = inp;
            self
        }
        /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
        /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn provisioned_throughput(
            mut self,
            inp: crate::model::ProvisionedThroughputDescription,
        ) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputDescription>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// <p>The total size of the specified index, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn index_size_bytes(mut self, inp: i64) -> Self {
            self.index_size_bytes = Some(inp);
            self
        }
        pub fn set_index_size_bytes(mut self, inp: i64) -> Self {
            self.index_size_bytes = Some(inp);
            self
        }
        /// <p>The number of items in the specified index. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        pub fn set_item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
        pub fn index_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_arn = Some(inp.into());
            self
        }
        pub fn set_index_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription)
        pub fn build(self) -> crate::model::GlobalSecondaryIndexDescription {
            crate::model::GlobalSecondaryIndexDescription {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
                index_status: self.index_status,
                backfilling: self.backfilling,
                provisioned_throughput: self.provisioned_throughput,
                index_size_bytes: self.index_size_bytes.unwrap_or_default(),
                item_count: self.item_count.unwrap_or_default(),
                index_arn: self.index_arn,
            }
        }
    }
}
impl GlobalSecondaryIndexDescription {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription)
    pub fn builder() -> crate::model::global_secondary_index_description::Builder {
        crate::model::global_secondary_index_description::Builder::default()
    }
}

/// <p>Represents the provisioned throughput settings for the table, consisting of read and write capacity units, along with data about increases and decreases.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughputDescription {
    /// <p>The date and time of the last provisioned throughput increase for this table.</p>
    #[serde(rename = "LastIncreaseDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_increase_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time of the last provisioned throughput decrease for this table.</p>
    #[serde(rename = "LastDecreaseDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_decrease_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The number of provisioned throughput decreases for this table during this UTC calendar day.
    /// For current maximums on provisioned throughput decreases, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "NumberOfDecreasesToday")]
    #[serde(default)]
    pub number_of_decreases_today: std::option::Option<i64>,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a
    /// <code>ThrottlingException</code>. Eventually consistent reads require less effort than strongly
    /// consistent reads, so a setting of 50 <code>ReadCapacityUnits</code> per second provides 100
    /// eventually consistent <code>ReadCapacityUnits</code> per second.</p>
    #[serde(rename = "ReadCapacityUnits")]
    #[serde(default)]
    pub read_capacity_units: std::option::Option<i64>,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a
    /// <code>ThrottlingException</code>.</p>
    #[serde(rename = "WriteCapacityUnits")]
    #[serde(default)]
    pub write_capacity_units: std::option::Option<i64>,
}
impl std::fmt::Debug for ProvisionedThroughputDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputDescription");
        formatter.field("last_increase_date_time", &self.last_increase_date_time);
        formatter.field("last_decrease_date_time", &self.last_decrease_date_time);
        formatter.field("number_of_decreases_today", &self.number_of_decreases_today);
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.field("write_capacity_units", &self.write_capacity_units);
        formatter.finish()
    }
}
/// See [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription)
pub mod provisioned_throughput_description {
    /// A builder for [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_increase_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_decrease_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) number_of_decreases_today: std::option::Option<i64>,
        pub(crate) read_capacity_units: std::option::Option<i64>,
        pub(crate) write_capacity_units: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The date and time of the last provisioned throughput increase for this table.</p>
        pub fn last_increase_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.last_increase_date_time = Some(inp);
            self
        }
        pub fn set_last_increase_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_increase_date_time = inp;
            self
        }
        /// <p>The date and time of the last provisioned throughput decrease for this table.</p>
        pub fn last_decrease_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.last_decrease_date_time = Some(inp);
            self
        }
        pub fn set_last_decrease_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_decrease_date_time = inp;
            self
        }
        /// <p>The number of provisioned throughput decreases for this table during this UTC calendar day.
        /// For current maximums on provisioned throughput decreases, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn number_of_decreases_today(mut self, inp: i64) -> Self {
            self.number_of_decreases_today = Some(inp);
            self
        }
        pub fn set_number_of_decreases_today(mut self, inp: std::option::Option<i64>) -> Self {
            self.number_of_decreases_today = inp;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a
        /// <code>ThrottlingException</code>. Eventually consistent reads require less effort than strongly
        /// consistent reads, so a setting of 50 <code>ReadCapacityUnits</code> per second provides 100
        /// eventually consistent <code>ReadCapacityUnits</code> per second.</p>
        pub fn read_capacity_units(mut self, inp: i64) -> Self {
            self.read_capacity_units = Some(inp);
            self
        }
        pub fn set_read_capacity_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.read_capacity_units = inp;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a
        /// <code>ThrottlingException</code>.</p>
        pub fn write_capacity_units(mut self, inp: i64) -> Self {
            self.write_capacity_units = Some(inp);
            self
        }
        pub fn set_write_capacity_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.write_capacity_units = inp;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription)
        pub fn build(self) -> crate::model::ProvisionedThroughputDescription {
            crate::model::ProvisionedThroughputDescription {
                last_increase_date_time: self.last_increase_date_time,
                last_decrease_date_time: self.last_decrease_date_time,
                number_of_decreases_today: self.number_of_decreases_today,
                read_capacity_units: self.read_capacity_units,
                write_capacity_units: self.write_capacity_units,
            }
        }
    }
}
impl ProvisionedThroughputDescription {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription)
    pub fn builder() -> crate::model::provisioned_throughput_description::Builder {
        crate::model::provisioned_throughput_description::Builder::default()
    }
}

/// <p>Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Projection {
    /// <p>The set of attributes that are projected into the index:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the
    /// index.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INCLUDE</code> - In addition to the attributes described in <code>KEYS_ONLY</code>, the secondary index will include other non-key attributes that you specify.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALL</code> - All of the table attributes are projected into the index.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "ProjectionType")]
    #[serde(default)]
    pub projection_type: std::option::Option<crate::model::ProjectionType>,
    /// <p>Represents the non-key attribute names which will be projected into the index.</p>
    /// <p>For local secondary indexes, the total count of <code>NonKeyAttributes</code> summed across all of the local secondary indexes,
    /// must not exceed 20. If you project the same attribute into two
    /// different indexes, this counts as two distinct attributes when determining the total.</p>
    #[serde(rename = "NonKeyAttributes")]
    #[serde(default)]
    pub non_key_attributes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Projection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Projection");
        formatter.field("projection_type", &self.projection_type);
        formatter.field("non_key_attributes", &self.non_key_attributes);
        formatter.finish()
    }
}
/// See [`Projection`](crate::model::Projection)
pub mod projection {
    /// A builder for [`Projection`](crate::model::Projection)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) projection_type: std::option::Option<crate::model::ProjectionType>,
        pub(crate) non_key_attributes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The set of attributes that are projected into the index:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KEYS_ONLY</code> - Only the index and primary keys are projected into the
        /// index.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INCLUDE</code> - In addition to the attributes described in <code>KEYS_ONLY</code>, the secondary index will include other non-key attributes that you specify.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALL</code> - All of the table attributes are projected into the index.</p>
        /// </li>
        /// </ul>
        pub fn projection_type(mut self, inp: crate::model::ProjectionType) -> Self {
            self.projection_type = Some(inp);
            self
        }
        pub fn set_projection_type(
            mut self,
            inp: std::option::Option<crate::model::ProjectionType>,
        ) -> Self {
            self.projection_type = inp;
            self
        }
        pub fn non_key_attributes(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.non_key_attributes.unwrap_or_default();
            v.push(inp.into());
            self.non_key_attributes = Some(v);
            self
        }
        pub fn set_non_key_attributes(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.non_key_attributes = inp;
            self
        }
        /// Consumes the builder and constructs a [`Projection`](crate::model::Projection)
        pub fn build(self) -> crate::model::Projection {
            crate::model::Projection {
                projection_type: self.projection_type,
                non_key_attributes: self.non_key_attributes,
            }
        }
    }
}
impl Projection {
    /// Creates a new builder-style object to manufacture [`Projection`](crate::model::Projection)
    pub fn builder() -> crate::model::projection::Builder {
        crate::model::projection::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProjectionType {
    All,
    Include,
    KeysOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProjectionType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => ProjectionType::All,
            "INCLUDE" => ProjectionType::Include,
            "KEYS_ONLY" => ProjectionType::KeysOnly,
            other => ProjectionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProjectionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ProjectionType::from(s))
    }
}
impl ProjectionType {
    pub fn as_str(&self) -> &str {
        match self {
            ProjectionType::All => "ALL",
            ProjectionType::Include => "INCLUDE",
            ProjectionType::KeysOnly => "KEYS_ONLY",
            ProjectionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ProjectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents <i>a single element</i> of a key schema. A key schema specifies the attributes
/// that make up the primary key of a table, or the key attributes of an index.</p>
/// <p>A <code>KeySchemaElement</code> represents exactly one attribute of the primary key. For example, a
/// simple primary key would be represented by one <code>KeySchemaElement</code> (for the partition key). A composite
/// primary key would require one <code>KeySchemaElement</code> for the partition key, and another
/// <code>KeySchemaElement</code> for the sort key.</p>
/// <p>A <code>KeySchemaElement</code> must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary.  The attribute cannot be nested within a List or a Map.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KeySchemaElement {
    /// <p>The name of a key attribute.</p>
    #[serde(rename = "AttributeName")]
    #[serde(default)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The role that this key attribute will assume:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeyType")]
    #[serde(default)]
    pub key_type: std::option::Option<crate::model::KeyType>,
}
impl std::fmt::Debug for KeySchemaElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeySchemaElement");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`KeySchemaElement`](crate::model::KeySchemaElement)
pub mod key_schema_element {
    /// A builder for [`KeySchemaElement`](crate::model::KeySchemaElement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) key_type: std::option::Option<crate::model::KeyType>,
    }
    impl Builder {
        /// <p>The name of a key attribute.</p>
        pub fn attribute_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(inp.into());
            self
        }
        pub fn set_attribute_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.attribute_name = inp;
            self
        }
        /// <p>The role that this key attribute will assume:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HASH</code> - partition key</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RANGE</code> - sort key</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
        /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
        /// evenly distribute data items across partitions, based on their partition key values.</p>
        /// <p>The sort key of an item is also known as its <i>range attribute</i>.
        /// The term "range attribute" derives from the way DynamoDB stores items with the same
        /// partition key physically close together, in sorted order by the sort key value.</p>
        /// </note>
        pub fn key_type(mut self, inp: crate::model::KeyType) -> Self {
            self.key_type = Some(inp);
            self
        }
        pub fn set_key_type(mut self, inp: std::option::Option<crate::model::KeyType>) -> Self {
            self.key_type = inp;
            self
        }
        /// Consumes the builder and constructs a [`KeySchemaElement`](crate::model::KeySchemaElement)
        pub fn build(self) -> crate::model::KeySchemaElement {
            crate::model::KeySchemaElement {
                attribute_name: self.attribute_name,
                key_type: self.key_type,
            }
        }
    }
}
impl KeySchemaElement {
    /// Creates a new builder-style object to manufacture [`KeySchemaElement`](crate::model::KeySchemaElement)
    pub fn builder() -> crate::model::key_schema_element::Builder {
        crate::model::key_schema_element::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum KeyType {
    Hash,
    Range,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for KeyType {
    fn from(s: &str) -> Self {
        match s {
            "HASH" => KeyType::Hash,
            "RANGE" => KeyType::Range,
            other => KeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for KeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(KeyType::from(s))
    }
}
impl KeyType {
    pub fn as_str(&self) -> &str {
        match self {
            KeyType::Hash => "HASH",
            KeyType::Range => "RANGE",
            KeyType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for KeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for KeyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the properties of a local secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalSecondaryIndexDescription {
    /// <p>Represents the name of the local secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into the global
    /// secondary index. These are in addition to the primary key attributes and index key
    /// attributes, which are automatically projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
    /// <p>The total size of the specified index, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "IndexSizeBytes")]
    #[serde(default)]
    pub index_size_bytes: i64,
    /// <p>The number of items in the specified index. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
    #[serde(rename = "ItemCount")]
    #[serde(default)]
    pub item_count: i64,
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
    #[serde(rename = "IndexArn")]
    #[serde(default)]
    pub index_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LocalSecondaryIndexDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalSecondaryIndexDescription");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("index_size_bytes", &self.index_size_bytes);
        formatter.field("item_count", &self.item_count);
        formatter.field("index_arn", &self.index_arn);
        formatter.finish()
    }
}
/// See [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription)
pub mod local_secondary_index_description {
    /// A builder for [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
        pub(crate) index_size_bytes: std::option::Option<i64>,
        pub(crate) item_count: std::option::Option<i64>,
        pub(crate) index_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Represents the name of the local secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into the global
        /// secondary index. These are in addition to the primary key attributes and index key
        /// attributes, which are automatically projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// <p>The total size of the specified index, in bytes. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn index_size_bytes(mut self, inp: i64) -> Self {
            self.index_size_bytes = Some(inp);
            self
        }
        pub fn set_index_size_bytes(mut self, inp: i64) -> Self {
            self.index_size_bytes = Some(inp);
            self
        }
        /// <p>The number of items in the specified index. DynamoDB updates this value approximately every six hours. Recent changes might not be reflected in this value.</p>
        pub fn item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        pub fn set_item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) that uniquely identifies the index.</p>
        pub fn index_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_arn = Some(inp.into());
            self
        }
        pub fn set_index_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription)
        pub fn build(self) -> crate::model::LocalSecondaryIndexDescription {
            crate::model::LocalSecondaryIndexDescription {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
                index_size_bytes: self.index_size_bytes.unwrap_or_default(),
                item_count: self.item_count.unwrap_or_default(),
                index_arn: self.index_arn,
            }
        }
    }
}
impl LocalSecondaryIndexDescription {
    /// Creates a new builder-style object to manufacture [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription)
    pub fn builder() -> crate::model::local_secondary_index_description::Builder {
        crate::model::local_secondary_index_description::Builder::default()
    }
}

/// <p>Contains the details for the read/write capacity mode.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BillingModeSummary {
    /// <p>Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PROVISIONED</code> - Sets the read/write capacity mode to <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for predictable workloads.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to <code>PAY_PER_REQUEST</code>. We recommend using <code>PAY_PER_REQUEST</code> for unpredictable workloads.
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "BillingMode")]
    #[serde(default)]
    pub billing_mode: std::option::Option<crate::model::BillingMode>,
    /// <p>Represents the time when <code>PAY_PER_REQUEST</code> was last set as the read/write capacity mode.</p>
    #[serde(rename = "LastUpdateToPayPerRequestDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_update_to_pay_per_request_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for BillingModeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BillingModeSummary");
        formatter.field("billing_mode", &self.billing_mode);
        formatter.field(
            "last_update_to_pay_per_request_date_time",
            &self.last_update_to_pay_per_request_date_time,
        );
        formatter.finish()
    }
}
/// See [`BillingModeSummary`](crate::model::BillingModeSummary)
pub mod billing_mode_summary {
    /// A builder for [`BillingModeSummary`](crate::model::BillingModeSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_mode: std::option::Option<crate::model::BillingMode>,
        pub(crate) last_update_to_pay_per_request_date_time:
            std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PROVISIONED</code> - Sets the read/write capacity mode to <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for predictable workloads.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to <code>PAY_PER_REQUEST</code>. We recommend using <code>PAY_PER_REQUEST</code> for unpredictable workloads.
        /// </p>
        /// </li>
        /// </ul>
        pub fn billing_mode(mut self, inp: crate::model::BillingMode) -> Self {
            self.billing_mode = Some(inp);
            self
        }
        pub fn set_billing_mode(
            mut self,
            inp: std::option::Option<crate::model::BillingMode>,
        ) -> Self {
            self.billing_mode = inp;
            self
        }
        /// <p>Represents the time when <code>PAY_PER_REQUEST</code> was last set as the read/write capacity mode.</p>
        pub fn last_update_to_pay_per_request_date_time(
            mut self,
            inp: smithy_types::Instant,
        ) -> Self {
            self.last_update_to_pay_per_request_date_time = Some(inp);
            self
        }
        pub fn set_last_update_to_pay_per_request_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_update_to_pay_per_request_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`BillingModeSummary`](crate::model::BillingModeSummary)
        pub fn build(self) -> crate::model::BillingModeSummary {
            crate::model::BillingModeSummary {
                billing_mode: self.billing_mode,
                last_update_to_pay_per_request_date_time: self
                    .last_update_to_pay_per_request_date_time,
            }
        }
    }
}
impl BillingModeSummary {
    /// Creates a new builder-style object to manufacture [`BillingModeSummary`](crate::model::BillingModeSummary)
    pub fn builder() -> crate::model::billing_mode_summary::Builder {
        crate::model::billing_mode_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BillingMode {
    PayPerRequest,
    Provisioned,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BillingMode {
    fn from(s: &str) -> Self {
        match s {
            "PAY_PER_REQUEST" => BillingMode::PayPerRequest,
            "PROVISIONED" => BillingMode::Provisioned,
            other => BillingMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BillingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(BillingMode::from(s))
    }
}
impl BillingMode {
    pub fn as_str(&self) -> &str {
        match self {
            BillingMode::PayPerRequest => "PAY_PER_REQUEST",
            BillingMode::Provisioned => "PROVISIONED",
            BillingMode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for BillingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for BillingMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents an attribute for describing the key schema for the table and indexes.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeDefinition {
    /// <p>A name for the attribute.</p>
    #[serde(rename = "AttributeName")]
    #[serde(default)]
    pub attribute_name: std::option::Option<std::string::String>,
    /// <p>The data type for the attribute, where:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>S</code> - the attribute is of type String</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>N</code> - the attribute is of type Number</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>B</code> - the attribute is of type Binary</p>
    /// </li>
    /// </ul>
    #[serde(rename = "AttributeType")]
    #[serde(default)]
    pub attribute_type: std::option::Option<crate::model::ScalarAttributeType>,
}
impl std::fmt::Debug for AttributeDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeDefinition");
        formatter.field("attribute_name", &self.attribute_name);
        formatter.field("attribute_type", &self.attribute_type);
        formatter.finish()
    }
}
/// See [`AttributeDefinition`](crate::model::AttributeDefinition)
pub mod attribute_definition {
    /// A builder for [`AttributeDefinition`](crate::model::AttributeDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<crate::model::ScalarAttributeType>,
    }
    impl Builder {
        /// <p>A name for the attribute.</p>
        pub fn attribute_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(inp.into());
            self
        }
        pub fn set_attribute_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.attribute_name = inp;
            self
        }
        /// <p>The data type for the attribute, where:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>S</code> - the attribute is of type String</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>N</code> - the attribute is of type Number</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>B</code> - the attribute is of type Binary</p>
        /// </li>
        /// </ul>
        pub fn attribute_type(mut self, inp: crate::model::ScalarAttributeType) -> Self {
            self.attribute_type = Some(inp);
            self
        }
        pub fn set_attribute_type(
            mut self,
            inp: std::option::Option<crate::model::ScalarAttributeType>,
        ) -> Self {
            self.attribute_type = inp;
            self
        }
        /// Consumes the builder and constructs a [`AttributeDefinition`](crate::model::AttributeDefinition)
        pub fn build(self) -> crate::model::AttributeDefinition {
            crate::model::AttributeDefinition {
                attribute_name: self.attribute_name,
                attribute_type: self.attribute_type,
            }
        }
    }
}
impl AttributeDefinition {
    /// Creates a new builder-style object to manufacture [`AttributeDefinition`](crate::model::AttributeDefinition)
    pub fn builder() -> crate::model::attribute_definition::Builder {
        crate::model::attribute_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalarAttributeType {
    B,
    N,
    S,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalarAttributeType {
    fn from(s: &str) -> Self {
        match s {
            "B" => ScalarAttributeType::B,
            "N" => ScalarAttributeType::N,
            "S" => ScalarAttributeType::S,
            other => ScalarAttributeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalarAttributeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ScalarAttributeType::from(s))
    }
}
impl ScalarAttributeType {
    pub fn as_str(&self) -> &str {
        match self {
            ScalarAttributeType::B => "B",
            ScalarAttributeType::N => "N",
            ScalarAttributeType::S => "S",
            ScalarAttributeType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ScalarAttributeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ScalarAttributeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents one of the following:</p>
/// <ul>
/// <li>
/// <p>A new replica to be added to an existing regional table or global table. This
/// request invokes the <code>CreateTableReplica</code> action in the destination
/// Region.</p>
/// </li>
/// <li>
/// <p>New parameters for an existing replica. This request invokes the
/// <code>UpdateTable</code> action in the destination Region.</p>
/// </li>
/// <li>
/// <p>An existing replica to be deleted. The request invokes the
/// <code>DeleteTableReplica</code> action in the destination Region, deleting the
/// replica and all if its items in the destination Region.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationGroupUpdate {
    /// <p>The parameters required for creating a replica for the table.</p>
    #[serde(rename = "Create")]
    #[serde(default)]
    pub create: std::option::Option<crate::model::CreateReplicationGroupMemberAction>,
    /// <p>The parameters required for updating a replica for the table.</p>
    #[serde(rename = "Update")]
    #[serde(default)]
    pub update: std::option::Option<crate::model::UpdateReplicationGroupMemberAction>,
    /// <p>The parameters required for deleting a replica for the table.</p>
    #[serde(rename = "Delete")]
    #[serde(default)]
    pub delete: std::option::Option<crate::model::DeleteReplicationGroupMemberAction>,
}
impl std::fmt::Debug for ReplicationGroupUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationGroupUpdate");
        formatter.field("create", &self.create);
        formatter.field("update", &self.update);
        formatter.field("delete", &self.delete);
        formatter.finish()
    }
}
/// See [`ReplicationGroupUpdate`](crate::model::ReplicationGroupUpdate)
pub mod replication_group_update {
    /// A builder for [`ReplicationGroupUpdate`](crate::model::ReplicationGroupUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create: std::option::Option<crate::model::CreateReplicationGroupMemberAction>,
        pub(crate) update: std::option::Option<crate::model::UpdateReplicationGroupMemberAction>,
        pub(crate) delete: std::option::Option<crate::model::DeleteReplicationGroupMemberAction>,
    }
    impl Builder {
        /// <p>The parameters required for creating a replica for the table.</p>
        pub fn create(mut self, inp: crate::model::CreateReplicationGroupMemberAction) -> Self {
            self.create = Some(inp);
            self
        }
        pub fn set_create(
            mut self,
            inp: std::option::Option<crate::model::CreateReplicationGroupMemberAction>,
        ) -> Self {
            self.create = inp;
            self
        }
        /// <p>The parameters required for updating a replica for the table.</p>
        pub fn update(mut self, inp: crate::model::UpdateReplicationGroupMemberAction) -> Self {
            self.update = Some(inp);
            self
        }
        pub fn set_update(
            mut self,
            inp: std::option::Option<crate::model::UpdateReplicationGroupMemberAction>,
        ) -> Self {
            self.update = inp;
            self
        }
        /// <p>The parameters required for deleting a replica for the table.</p>
        pub fn delete(mut self, inp: crate::model::DeleteReplicationGroupMemberAction) -> Self {
            self.delete = Some(inp);
            self
        }
        pub fn set_delete(
            mut self,
            inp: std::option::Option<crate::model::DeleteReplicationGroupMemberAction>,
        ) -> Self {
            self.delete = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationGroupUpdate`](crate::model::ReplicationGroupUpdate)
        pub fn build(self) -> crate::model::ReplicationGroupUpdate {
            crate::model::ReplicationGroupUpdate {
                create: self.create,
                update: self.update,
                delete: self.delete,
            }
        }
    }
}
impl ReplicationGroupUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicationGroupUpdate`](crate::model::ReplicationGroupUpdate)
    pub fn builder() -> crate::model::replication_group_update::Builder {
        crate::model::replication_group_update::Builder::default()
    }
}

/// <p>Represents a replica to be deleted.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteReplicationGroupMemberAction {
    /// <p>The Region where the replica exists.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteReplicationGroupMemberAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteReplicationGroupMemberAction");
        formatter.field("region_name", &self.region_name);
        formatter.finish()
    }
}
/// See [`DeleteReplicationGroupMemberAction`](crate::model::DeleteReplicationGroupMemberAction)
pub mod delete_replication_group_member_action {
    /// A builder for [`DeleteReplicationGroupMemberAction`](crate::model::DeleteReplicationGroupMemberAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Region where the replica exists.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteReplicationGroupMemberAction`](crate::model::DeleteReplicationGroupMemberAction)
        pub fn build(self) -> crate::model::DeleteReplicationGroupMemberAction {
            crate::model::DeleteReplicationGroupMemberAction {
                region_name: self.region_name,
            }
        }
    }
}
impl DeleteReplicationGroupMemberAction {
    /// Creates a new builder-style object to manufacture [`DeleteReplicationGroupMemberAction`](crate::model::DeleteReplicationGroupMemberAction)
    pub fn builder() -> crate::model::delete_replication_group_member_action::Builder {
        crate::model::delete_replication_group_member_action::Builder::default()
    }
}

/// <p>Represents a replica to be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateReplicationGroupMemberAction {
    /// <p>The Region where the replica exists.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The AWS KMS customer master key (CMK) of the replica that should be used for AWS KMS encryption.
    /// To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias
    /// ARN. Note that you should only provide this parameter if the key is different from
    /// the default DynamoDB KMS master key alias/aws/dynamodb.</p>
    #[serde(rename = "KMSMasterKeyId")]
    #[serde(default)]
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>Replica-specific provisioned throughput. If not specified, uses the source table's
    /// provisioned throughput settings.</p>
    #[serde(rename = "ProvisionedThroughputOverride")]
    #[serde(default)]
    pub provisioned_throughput_override:
        std::option::Option<crate::model::ProvisionedThroughputOverride>,
    /// <p>Replica-specific global secondary index settings.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
}
impl std::fmt::Debug for UpdateReplicationGroupMemberAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateReplicationGroupMemberAction");
        formatter.field("region_name", &self.region_name);
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.finish()
    }
}
/// See [`UpdateReplicationGroupMemberAction`](crate::model::UpdateReplicationGroupMemberAction)
pub mod update_replication_group_member_action {
    /// A builder for [`UpdateReplicationGroupMemberAction`](crate::model::UpdateReplicationGroupMemberAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::ProvisionedThroughputOverride>,
        pub(crate) global_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
    }
    impl Builder {
        /// <p>The Region where the replica exists.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// <p>The AWS KMS customer master key (CMK) of the replica that should be used for AWS KMS encryption.
        /// To specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias
        /// ARN. Note that you should only provide this parameter if the key is different from
        /// the default DynamoDB KMS master key alias/aws/dynamodb.</p>
        pub fn kms_master_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_master_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = inp;
            self
        }
        /// <p>Replica-specific provisioned throughput. If not specified, uses the source table's
        /// provisioned throughput settings.</p>
        pub fn provisioned_throughput_override(
            mut self,
            inp: crate::model::ProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(inp);
            self
        }
        pub fn set_provisioned_throughput_override(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndex>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateReplicationGroupMemberAction`](crate::model::UpdateReplicationGroupMemberAction)
        pub fn build(self) -> crate::model::UpdateReplicationGroupMemberAction {
            crate::model::UpdateReplicationGroupMemberAction {
                region_name: self.region_name,
                kms_master_key_id: self.kms_master_key_id,
                provisioned_throughput_override: self.provisioned_throughput_override,
                global_secondary_indexes: self.global_secondary_indexes,
            }
        }
    }
}
impl UpdateReplicationGroupMemberAction {
    /// Creates a new builder-style object to manufacture [`UpdateReplicationGroupMemberAction`](crate::model::UpdateReplicationGroupMemberAction)
    pub fn builder() -> crate::model::update_replication_group_member_action::Builder {
        crate::model::update_replication_group_member_action::Builder::default()
    }
}

/// <p>Represents the properties of a replica global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndex {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Replica table GSI-specific provisioned throughput. If not specified, uses the
    /// source table GSI's read capacity settings.</p>
    #[serde(rename = "ProvisionedThroughputOverride")]
    #[serde(default)]
    pub provisioned_throughput_override:
        std::option::Option<crate::model::ProvisionedThroughputOverride>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndex");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndex`](crate::model::ReplicaGlobalSecondaryIndex)
pub mod replica_global_secondary_index {
    /// A builder for [`ReplicaGlobalSecondaryIndex`](crate::model::ReplicaGlobalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::ProvisionedThroughputOverride>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>Replica table GSI-specific provisioned throughput. If not specified, uses the
        /// source table GSI's read capacity settings.</p>
        pub fn provisioned_throughput_override(
            mut self,
            inp: crate::model::ProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(inp);
            self
        }
        pub fn set_provisioned_throughput_override(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndex`](crate::model::ReplicaGlobalSecondaryIndex)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndex {
            crate::model::ReplicaGlobalSecondaryIndex {
                index_name: self.index_name,
                provisioned_throughput_override: self.provisioned_throughput_override,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndex`](crate::model::ReplicaGlobalSecondaryIndex)
    pub fn builder() -> crate::model::replica_global_secondary_index::Builder {
        crate::model::replica_global_secondary_index::Builder::default()
    }
}

/// <p>Represents a replica to be created.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateReplicationGroupMemberAction {
    /// <p>The Region where the new replica will be created.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The AWS KMS customer master key (CMK) that should be used for AWS KMS encryption
    /// in the new replica. To specify a CMK, use its key ID, Amazon Resource Name (ARN),
    /// alias name, or alias ARN. Note that you should only provide this parameter if the
    /// key is different from the default DynamoDB KMS master key alias/aws/dynamodb.</p>
    #[serde(rename = "KMSMasterKeyId")]
    #[serde(default)]
    pub kms_master_key_id: std::option::Option<std::string::String>,
    /// <p>Replica-specific provisioned throughput. If not specified, uses the source table's
    /// provisioned throughput settings.</p>
    #[serde(rename = "ProvisionedThroughputOverride")]
    #[serde(default)]
    pub provisioned_throughput_override:
        std::option::Option<crate::model::ProvisionedThroughputOverride>,
    /// <p>Replica-specific global secondary index settings.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
}
impl std::fmt::Debug for CreateReplicationGroupMemberAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateReplicationGroupMemberAction");
        formatter.field("region_name", &self.region_name);
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.field(
            "provisioned_throughput_override",
            &self.provisioned_throughput_override,
        );
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.finish()
    }
}
/// See [`CreateReplicationGroupMemberAction`](crate::model::CreateReplicationGroupMemberAction)
pub mod create_replication_group_member_action {
    /// A builder for [`CreateReplicationGroupMemberAction`](crate::model::CreateReplicationGroupMemberAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput_override:
            std::option::Option<crate::model::ProvisionedThroughputOverride>,
        pub(crate) global_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
    }
    impl Builder {
        /// <p>The Region where the new replica will be created.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// <p>The AWS KMS customer master key (CMK) that should be used for AWS KMS encryption
        /// in the new replica. To specify a CMK, use its key ID, Amazon Resource Name (ARN),
        /// alias name, or alias ARN. Note that you should only provide this parameter if the
        /// key is different from the default DynamoDB KMS master key alias/aws/dynamodb.</p>
        pub fn kms_master_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_master_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = inp;
            self
        }
        /// <p>Replica-specific provisioned throughput. If not specified, uses the source table's
        /// provisioned throughput settings.</p>
        pub fn provisioned_throughput_override(
            mut self,
            inp: crate::model::ProvisionedThroughputOverride,
        ) -> Self {
            self.provisioned_throughput_override = Some(inp);
            self
        }
        pub fn set_provisioned_throughput_override(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughputOverride>,
        ) -> Self {
            self.provisioned_throughput_override = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndex>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndex>>,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateReplicationGroupMemberAction`](crate::model::CreateReplicationGroupMemberAction)
        pub fn build(self) -> crate::model::CreateReplicationGroupMemberAction {
            crate::model::CreateReplicationGroupMemberAction {
                region_name: self.region_name,
                kms_master_key_id: self.kms_master_key_id,
                provisioned_throughput_override: self.provisioned_throughput_override,
                global_secondary_indexes: self.global_secondary_indexes,
            }
        }
    }
}
impl CreateReplicationGroupMemberAction {
    /// Creates a new builder-style object to manufacture [`CreateReplicationGroupMemberAction`](crate::model::CreateReplicationGroupMemberAction)
    pub fn builder() -> crate::model::create_replication_group_member_action::Builder {
        crate::model::create_replication_group_member_action::Builder::default()
    }
}

/// <p>Represents the settings used to enable server-side encryption.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SSESpecification {
    /// <p>Indicates whether server-side encryption is done using an AWS managed CMK or an AWS owned CMK. If enabled (true),
    /// server-side encryption type is set to <code>KMS</code> and an AWS managed CMK is used (AWS KMS charges apply). If disabled (false) or not specified, server-side
    /// encryption is set to AWS owned CMK.</p>
    #[serde(rename = "Enabled")]
    #[serde(default)]
    pub enabled: std::option::Option<bool>,
    /// <p>Server-side encryption type. The only supported value is:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>KMS</code> - Server-side encryption that uses AWS Key Management Service. The
    /// key is stored in your account and is managed by AWS KMS (AWS KMS charges
    /// apply).</p>
    /// </li>
    /// </ul>
    #[serde(rename = "SSEType")]
    #[serde(default)]
    pub sse_type: std::option::Option<crate::model::SseType>,
    /// <p>The AWS KMS customer master key (CMK) that should be used for the AWS KMS encryption. To
    /// specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note
    /// that you should only provide this parameter if the key is different from the default
    /// DynamoDB customer master key alias/aws/dynamodb.</p>
    #[serde(rename = "KMSMasterKeyId")]
    #[serde(default)]
    pub kms_master_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SSESpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SSESpecification");
        formatter.field("enabled", &self.enabled);
        formatter.field("sse_type", &self.sse_type);
        formatter.field("kms_master_key_id", &self.kms_master_key_id);
        formatter.finish()
    }
}
/// See [`SSESpecification`](crate::model::SSESpecification)
pub mod sse_specification {
    /// A builder for [`SSESpecification`](crate::model::SSESpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) sse_type: std::option::Option<crate::model::SseType>,
        pub(crate) kms_master_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether server-side encryption is done using an AWS managed CMK or an AWS owned CMK. If enabled (true),
        /// server-side encryption type is set to <code>KMS</code> and an AWS managed CMK is used (AWS KMS charges apply). If disabled (false) or not specified, server-side
        /// encryption is set to AWS owned CMK.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.enabled = Some(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.enabled = inp;
            self
        }
        /// <p>Server-side encryption type. The only supported value is:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>KMS</code> - Server-side encryption that uses AWS Key Management Service. The
        /// key is stored in your account and is managed by AWS KMS (AWS KMS charges
        /// apply).</p>
        /// </li>
        /// </ul>
        pub fn sse_type(mut self, inp: crate::model::SseType) -> Self {
            self.sse_type = Some(inp);
            self
        }
        pub fn set_sse_type(mut self, inp: std::option::Option<crate::model::SseType>) -> Self {
            self.sse_type = inp;
            self
        }
        /// <p>The AWS KMS customer master key (CMK) that should be used for the AWS KMS encryption. To
        /// specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note
        /// that you should only provide this parameter if the key is different from the default
        /// DynamoDB customer master key alias/aws/dynamodb.</p>
        pub fn kms_master_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_master_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_master_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_master_key_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`SSESpecification`](crate::model::SSESpecification)
        pub fn build(self) -> crate::model::SSESpecification {
            crate::model::SSESpecification {
                enabled: self.enabled,
                sse_type: self.sse_type,
                kms_master_key_id: self.kms_master_key_id,
            }
        }
    }
}
impl SSESpecification {
    /// Creates a new builder-style object to manufacture [`SSESpecification`](crate::model::SSESpecification)
    pub fn builder() -> crate::model::sse_specification::Builder {
        crate::model::sse_specification::Builder::default()
    }
}

/// <p>Represents one of the following:</p>
/// <ul>
/// <li>
/// <p>A new global secondary index to be added to an existing table.</p>
/// </li>
/// <li>
/// <p>New provisioned throughput parameters for an existing global secondary index.</p>
/// </li>
/// <li>
/// <p>An existing global secondary index to be removed from an existing table.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalSecondaryIndexUpdate {
    /// <p>The name of an existing global secondary index, along with new provisioned throughput settings to be applied to that index.</p>
    #[serde(rename = "Update")]
    #[serde(default)]
    pub update: std::option::Option<crate::model::UpdateGlobalSecondaryIndexAction>,
    /// <p>The parameters required for creating a global secondary index on an existing table:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>IndexName </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KeySchema </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AttributeDefinitions </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Projection </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ProvisionedThroughput </code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "Create")]
    #[serde(default)]
    pub create: std::option::Option<crate::model::CreateGlobalSecondaryIndexAction>,
    /// <p>The name of an existing global secondary index to be removed.</p>
    #[serde(rename = "Delete")]
    #[serde(default)]
    pub delete: std::option::Option<crate::model::DeleteGlobalSecondaryIndexAction>,
}
impl std::fmt::Debug for GlobalSecondaryIndexUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalSecondaryIndexUpdate");
        formatter.field("update", &self.update);
        formatter.field("create", &self.create);
        formatter.field("delete", &self.delete);
        formatter.finish()
    }
}
/// See [`GlobalSecondaryIndexUpdate`](crate::model::GlobalSecondaryIndexUpdate)
pub mod global_secondary_index_update {
    /// A builder for [`GlobalSecondaryIndexUpdate`](crate::model::GlobalSecondaryIndexUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update: std::option::Option<crate::model::UpdateGlobalSecondaryIndexAction>,
        pub(crate) create: std::option::Option<crate::model::CreateGlobalSecondaryIndexAction>,
        pub(crate) delete: std::option::Option<crate::model::DeleteGlobalSecondaryIndexAction>,
    }
    impl Builder {
        /// <p>The name of an existing global secondary index, along with new provisioned throughput settings to be applied to that index.</p>
        pub fn update(mut self, inp: crate::model::UpdateGlobalSecondaryIndexAction) -> Self {
            self.update = Some(inp);
            self
        }
        pub fn set_update(
            mut self,
            inp: std::option::Option<crate::model::UpdateGlobalSecondaryIndexAction>,
        ) -> Self {
            self.update = inp;
            self
        }
        /// <p>The parameters required for creating a global secondary index on an existing table:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>IndexName </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KeySchema </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AttributeDefinitions </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Projection </code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ProvisionedThroughput </code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn create(mut self, inp: crate::model::CreateGlobalSecondaryIndexAction) -> Self {
            self.create = Some(inp);
            self
        }
        pub fn set_create(
            mut self,
            inp: std::option::Option<crate::model::CreateGlobalSecondaryIndexAction>,
        ) -> Self {
            self.create = inp;
            self
        }
        /// <p>The name of an existing global secondary index to be removed.</p>
        pub fn delete(mut self, inp: crate::model::DeleteGlobalSecondaryIndexAction) -> Self {
            self.delete = Some(inp);
            self
        }
        pub fn set_delete(
            mut self,
            inp: std::option::Option<crate::model::DeleteGlobalSecondaryIndexAction>,
        ) -> Self {
            self.delete = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndexUpdate`](crate::model::GlobalSecondaryIndexUpdate)
        pub fn build(self) -> crate::model::GlobalSecondaryIndexUpdate {
            crate::model::GlobalSecondaryIndexUpdate {
                update: self.update,
                create: self.create,
                delete: self.delete,
            }
        }
    }
}
impl GlobalSecondaryIndexUpdate {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndexUpdate`](crate::model::GlobalSecondaryIndexUpdate)
    pub fn builder() -> crate::model::global_secondary_index_update::Builder {
        crate::model::global_secondary_index_update::Builder::default()
    }
}

/// <p>Represents a global secondary index to be deleted from an existing table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteGlobalSecondaryIndexAction {
    /// <p>The name of the global secondary index to be deleted.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteGlobalSecondaryIndexAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteGlobalSecondaryIndexAction");
        formatter.field("index_name", &self.index_name);
        formatter.finish()
    }
}
/// See [`DeleteGlobalSecondaryIndexAction`](crate::model::DeleteGlobalSecondaryIndexAction)
pub mod delete_global_secondary_index_action {
    /// A builder for [`DeleteGlobalSecondaryIndexAction`](crate::model::DeleteGlobalSecondaryIndexAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the global secondary index to be deleted.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteGlobalSecondaryIndexAction`](crate::model::DeleteGlobalSecondaryIndexAction)
        pub fn build(self) -> crate::model::DeleteGlobalSecondaryIndexAction {
            crate::model::DeleteGlobalSecondaryIndexAction {
                index_name: self.index_name,
            }
        }
    }
}
impl DeleteGlobalSecondaryIndexAction {
    /// Creates a new builder-style object to manufacture [`DeleteGlobalSecondaryIndexAction`](crate::model::DeleteGlobalSecondaryIndexAction)
    pub fn builder() -> crate::model::delete_global_secondary_index_action::Builder {
        crate::model::delete_global_secondary_index_action::Builder::default()
    }
}

/// <p>Represents a new global secondary index to be added to an existing table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGlobalSecondaryIndexAction {
    /// <p>The name of the global secondary index to be created.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The key schema for the global secondary index.</p>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into an index. These
    /// are in addition to the primary key attributes and index key attributes, which are
    /// automatically projected.</p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
    /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
    /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
}
impl std::fmt::Debug for CreateGlobalSecondaryIndexAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateGlobalSecondaryIndexAction");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.finish()
    }
}
/// See [`CreateGlobalSecondaryIndexAction`](crate::model::CreateGlobalSecondaryIndexAction)
pub mod create_global_secondary_index_action {
    /// A builder for [`CreateGlobalSecondaryIndexAction`](crate::model::CreateGlobalSecondaryIndexAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    }
    impl Builder {
        /// <p>The name of the global secondary index to be created.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into an index. These
        /// are in addition to the primary key attributes and index key attributes, which are
        /// automatically projected.</p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
        /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn provisioned_throughput(mut self, inp: crate::model::ProvisionedThroughput) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateGlobalSecondaryIndexAction`](crate::model::CreateGlobalSecondaryIndexAction)
        pub fn build(self) -> crate::model::CreateGlobalSecondaryIndexAction {
            crate::model::CreateGlobalSecondaryIndexAction {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
                provisioned_throughput: self.provisioned_throughput,
            }
        }
    }
}
impl CreateGlobalSecondaryIndexAction {
    /// Creates a new builder-style object to manufacture [`CreateGlobalSecondaryIndexAction`](crate::model::CreateGlobalSecondaryIndexAction)
    pub fn builder() -> crate::model::create_global_secondary_index_action::Builder {
        crate::model::create_global_secondary_index_action::Builder::default()
    }
}

/// <p>Represents the provisioned throughput settings for a specified table or index. The settings
/// can be modified using the <code>UpdateTable</code> operation.</p>
/// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughput {
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a
    /// <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
    /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    /// <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to 0.</p>
    #[serde(rename = "ReadCapacityUnits")]
    #[serde(default)]
    pub read_capacity_units: std::option::Option<i64>,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a
    /// <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
    /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    /// <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to 0.</p>
    #[serde(rename = "WriteCapacityUnits")]
    #[serde(default)]
    pub write_capacity_units: std::option::Option<i64>,
}
impl std::fmt::Debug for ProvisionedThroughput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughput");
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.field("write_capacity_units", &self.write_capacity_units);
        formatter.finish()
    }
}
/// See [`ProvisionedThroughput`](crate::model::ProvisionedThroughput)
pub mod provisioned_throughput {
    /// A builder for [`ProvisionedThroughput`](crate::model::ProvisionedThroughput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: std::option::Option<i64>,
        pub(crate) write_capacity_units: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a
        /// <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
        /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        /// <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to 0.</p>
        pub fn read_capacity_units(mut self, inp: i64) -> Self {
            self.read_capacity_units = Some(inp);
            self
        }
        pub fn set_read_capacity_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.read_capacity_units = inp;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a
        /// <code>ThrottlingException</code>. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
        /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        /// <p>If read/write capacity mode is <code>PAY_PER_REQUEST</code> the value is set to 0.</p>
        pub fn write_capacity_units(mut self, inp: i64) -> Self {
            self.write_capacity_units = Some(inp);
            self
        }
        pub fn set_write_capacity_units(mut self, inp: std::option::Option<i64>) -> Self {
            self.write_capacity_units = inp;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughput`](crate::model::ProvisionedThroughput)
        pub fn build(self) -> crate::model::ProvisionedThroughput {
            crate::model::ProvisionedThroughput {
                read_capacity_units: self.read_capacity_units,
                write_capacity_units: self.write_capacity_units,
            }
        }
    }
}
impl ProvisionedThroughput {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughput`](crate::model::ProvisionedThroughput)
    pub fn builder() -> crate::model::provisioned_throughput::Builder {
        crate::model::provisioned_throughput::Builder::default()
    }
}

/// <p>Represents the new provisioned throughput settings to be applied to a global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGlobalSecondaryIndexAction {
    /// <p>The name of the global secondary index to be updated.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
    /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
}
impl std::fmt::Debug for UpdateGlobalSecondaryIndexAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateGlobalSecondaryIndexAction");
        formatter.field("index_name", &self.index_name);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.finish()
    }
}
/// See [`UpdateGlobalSecondaryIndexAction`](crate::model::UpdateGlobalSecondaryIndexAction)
pub mod update_global_secondary_index_action {
    /// A builder for [`UpdateGlobalSecondaryIndexAction`](crate::model::UpdateGlobalSecondaryIndexAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    }
    impl Builder {
        /// <p>The name of the global secondary index to be updated.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
        /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn provisioned_throughput(mut self, inp: crate::model::ProvisionedThroughput) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGlobalSecondaryIndexAction`](crate::model::UpdateGlobalSecondaryIndexAction)
        pub fn build(self) -> crate::model::UpdateGlobalSecondaryIndexAction {
            crate::model::UpdateGlobalSecondaryIndexAction {
                index_name: self.index_name,
                provisioned_throughput: self.provisioned_throughput,
            }
        }
    }
}
impl UpdateGlobalSecondaryIndexAction {
    /// Creates a new builder-style object to manufacture [`UpdateGlobalSecondaryIndexAction`](crate::model::UpdateGlobalSecondaryIndexAction)
    pub fn builder() -> crate::model::update_global_secondary_index_action::Builder {
        crate::model::update_global_secondary_index_action::Builder::default()
    }
}

/// <p>Information about item collections, if any, that were affected by the operation.
/// <code>ItemCollectionMetrics</code> is only returned if the request asked for it. If the
/// table does not have any local secondary indexes, this information is not returned in the response.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemCollectionMetrics {
    /// <p>The partition key value of the item collection. This value is the same as the partition key value of the item.</p>
    #[serde(rename = "ItemCollectionKey")]
    #[serde(default)]
    pub item_collection_key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>An estimate of item collection size, in gigabytes. This value is a two-element array containing a lower bound and an upper bound for the estimate. The estimate includes the size of all the items in the table, plus the size of all attributes projected into all of the local secondary indexes on that table. Use this estimate to measure whether a local secondary index is approaching its size limit.</p>
    /// <p>The estimate is subject to change over time; therefore, do not rely on the precision or accuracy of the estimate.</p>
    #[serde(rename = "SizeEstimateRangeGB")]
    #[serde(default)]
    pub size_estimate_range_gb: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for ItemCollectionMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemCollectionMetrics");
        formatter.field("item_collection_key", &self.item_collection_key);
        formatter.field("size_estimate_range_gb", &self.size_estimate_range_gb);
        formatter.finish()
    }
}
/// See [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics)
pub mod item_collection_metrics {
    /// A builder for [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item_collection_key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) size_estimate_range_gb: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        pub fn item_collection_key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item_collection_key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item_collection_key = Some(hash_map);
            self
        }
        pub fn set_item_collection_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item_collection_key = inp;
            self
        }
        pub fn size_estimate_range_gb(mut self, inp: impl Into<f64>) -> Self {
            let mut v = self.size_estimate_range_gb.unwrap_or_default();
            v.push(inp.into());
            self.size_estimate_range_gb = Some(v);
            self
        }
        pub fn set_size_estimate_range_gb(
            mut self,
            inp: std::option::Option<std::vec::Vec<f64>>,
        ) -> Self {
            self.size_estimate_range_gb = inp;
            self
        }
        /// Consumes the builder and constructs a [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics)
        pub fn build(self) -> crate::model::ItemCollectionMetrics {
            crate::model::ItemCollectionMetrics {
                item_collection_key: self.item_collection_key,
                size_estimate_range_gb: self.size_estimate_range_gb,
            }
        }
    }
}
impl ItemCollectionMetrics {
    /// Creates a new builder-style object to manufacture [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics)
    pub fn builder() -> crate::model::item_collection_metrics::Builder {
        crate::model::item_collection_metrics::Builder::default()
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AttributeValue {
    /// <p>An attribute of type Binary.  For example:</p>
    /// <p>
    /// <code>"B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"</code>
    /// </p>
    #[serde(rename = "B")]
    #[serde(deserialize_with = "crate::serde_util::smithytypesblob_deser")]
    B(smithy_types::Blob),
    /// <p>An attribute of type Boolean.  For example:</p>
    /// <p>
    /// <code>"BOOL": true</code>
    /// </p>
    #[serde(rename = "BOOL")]
    Bool(bool),
    /// <p>An attribute of type Binary Set.  For example:</p>
    /// <p>
    /// <code>"BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]</code>
    /// </p>
    #[serde(rename = "BS")]
    #[serde(deserialize_with = "crate::serde_util::stdvecvecsmithytypesblob_deser")]
    Bs(std::vec::Vec<smithy_types::Blob>),
    /// <p>An attribute of type List.  For example:</p>
    /// <p>
    /// <code>"L": [ {"S": "Cookies"} , {"S": "Coffee"}, {"N", "3.14159"}]</code>
    /// </p>
    #[serde(rename = "L")]
    L(std::vec::Vec<crate::model::AttributeValue>),
    /// <p>An attribute of type Map.  For example:</p>
    /// <p>
    /// <code>"M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}</code>
    /// </p>
    #[serde(rename = "M")]
    M(std::collections::HashMap<std::string::String, crate::model::AttributeValue>),
    /// <p>An attribute of type Number.  For example:</p>
    /// <p>
    /// <code>"N": "123.45"</code>
    /// </p>
    /// <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.</p>
    #[serde(rename = "N")]
    N(std::string::String),
    /// <p>An attribute of type Number Set.  For example:</p>
    /// <p>
    /// <code>"NS": ["42.2", "-19", "7.5", "3.14"]</code>
    /// </p>
    /// <p>Numbers are sent across the network to DynamoDB as strings, to maximize compatibility across languages and libraries. However, DynamoDB treats them as number type attributes for mathematical operations.</p>
    #[serde(rename = "NS")]
    Ns(std::vec::Vec<std::string::String>),
    /// <p>An attribute of type Null.  For example:</p>
    /// <p>
    /// <code>"NULL": true</code>
    /// </p>
    #[serde(rename = "NULL")]
    Null(bool),
    /// <p>An attribute of type  String. For example:</p>
    /// <p>
    /// <code>"S": "Hello"</code>
    /// </p>
    #[serde(rename = "S")]
    S(std::string::String),
    /// <p>An attribute of type String Set.  For example:</p>
    /// <p>
    /// <code>"SS": ["Giraffe", "Hippo" ,"Zebra"]</code>
    /// </p>
    #[serde(rename = "SS")]
    Ss(std::vec::Vec<std::string::String>),
}
impl AttributeValue {
    pub fn as_b(&self) -> Option<&smithy_types::Blob> {
        if let AttributeValue::B(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_b(&self) -> bool {
        self.as_b().is_some()
    }
    pub fn as_bool(&self) -> Option<&bool> {
        if let AttributeValue::Bool(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_bool(&self) -> bool {
        self.as_bool().is_some()
    }
    pub fn as_bs(&self) -> Option<&std::vec::Vec<smithy_types::Blob>> {
        if let AttributeValue::Bs(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_bs(&self) -> bool {
        self.as_bs().is_some()
    }
    pub fn as_l(&self) -> Option<&std::vec::Vec<crate::model::AttributeValue>> {
        if let AttributeValue::L(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_l(&self) -> bool {
        self.as_l().is_some()
    }
    pub fn as_m(
        &self,
    ) -> Option<&std::collections::HashMap<std::string::String, crate::model::AttributeValue>> {
        if let AttributeValue::M(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_m(&self) -> bool {
        self.as_m().is_some()
    }
    pub fn as_n(&self) -> Option<&std::string::String> {
        if let AttributeValue::N(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_n(&self) -> bool {
        self.as_n().is_some()
    }
    pub fn as_ns(&self) -> Option<&std::vec::Vec<std::string::String>> {
        if let AttributeValue::Ns(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_ns(&self) -> bool {
        self.as_ns().is_some()
    }
    pub fn as_null(&self) -> Option<&bool> {
        if let AttributeValue::Null(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_null(&self) -> bool {
        self.as_null().is_some()
    }
    pub fn as_s(&self) -> Option<&std::string::String> {
        if let AttributeValue::S(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_s(&self) -> bool {
        self.as_s().is_some()
    }
    pub fn as_ss(&self) -> Option<&std::vec::Vec<std::string::String>> {
        if let AttributeValue::Ss(val) = &self {
            Some(&val)
        } else {
            None
        }
    }
    pub fn is_ss(&self) -> bool {
        self.as_ss().is_some()
    }
}

/// <p>The capacity units consumed by an operation. The data returned includes the total
/// provisioned throughput consumed, along with statistics for the table and any indexes involved
/// in the operation. <code>ConsumedCapacity</code> is only returned if the request asked for it.
/// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned
/// Throughput</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConsumedCapacity {
    /// <p>The name of the table that was affected by the operation.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>The total number of capacity units consumed by the operation.</p>
    #[serde(rename = "CapacityUnits")]
    #[serde(default)]
    pub capacity_units: std::option::Option<f64>,
    /// <p>The total number of read capacity units consumed by the operation.</p>
    #[serde(rename = "ReadCapacityUnits")]
    #[serde(default)]
    pub read_capacity_units: std::option::Option<f64>,
    /// <p>The total number of write capacity units consumed by the operation.</p>
    #[serde(rename = "WriteCapacityUnits")]
    #[serde(default)]
    pub write_capacity_units: std::option::Option<f64>,
    /// <p>The amount of throughput consumed on the table affected by the operation.</p>
    #[serde(rename = "Table")]
    #[serde(default)]
    pub table: std::option::Option<crate::model::Capacity>,
    /// <p>The amount of throughput consumed on each local index affected by the operation.</p>
    #[serde(rename = "LocalSecondaryIndexes")]
    #[serde(default)]
    pub local_secondary_indexes:
        std::option::Option<std::collections::HashMap<std::string::String, crate::model::Capacity>>,
    /// <p>The amount of throughput consumed on each global index affected by the operation.</p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::collections::HashMap<std::string::String, crate::model::Capacity>>,
}
impl std::fmt::Debug for ConsumedCapacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConsumedCapacity");
        formatter.field("table_name", &self.table_name);
        formatter.field("capacity_units", &self.capacity_units);
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.field("write_capacity_units", &self.write_capacity_units);
        formatter.field("table", &self.table);
        formatter.field("local_secondary_indexes", &self.local_secondary_indexes);
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.finish()
    }
}
/// See [`ConsumedCapacity`](crate::model::ConsumedCapacity)
pub mod consumed_capacity {
    /// A builder for [`ConsumedCapacity`](crate::model::ConsumedCapacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) capacity_units: std::option::Option<f64>,
        pub(crate) read_capacity_units: std::option::Option<f64>,
        pub(crate) write_capacity_units: std::option::Option<f64>,
        pub(crate) table: std::option::Option<crate::model::Capacity>,
        pub(crate) local_secondary_indexes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Capacity>,
        >,
        pub(crate) global_secondary_indexes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Capacity>,
        >,
    }
    impl Builder {
        /// <p>The name of the table that was affected by the operation.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>The total number of capacity units consumed by the operation.</p>
        pub fn capacity_units(mut self, inp: f64) -> Self {
            self.capacity_units = Some(inp);
            self
        }
        pub fn set_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.capacity_units = inp;
            self
        }
        /// <p>The total number of read capacity units consumed by the operation.</p>
        pub fn read_capacity_units(mut self, inp: f64) -> Self {
            self.read_capacity_units = Some(inp);
            self
        }
        pub fn set_read_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.read_capacity_units = inp;
            self
        }
        /// <p>The total number of write capacity units consumed by the operation.</p>
        pub fn write_capacity_units(mut self, inp: f64) -> Self {
            self.write_capacity_units = Some(inp);
            self
        }
        pub fn set_write_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.write_capacity_units = inp;
            self
        }
        /// <p>The amount of throughput consumed on the table affected by the operation.</p>
        pub fn table(mut self, inp: crate::model::Capacity) -> Self {
            self.table = Some(inp);
            self
        }
        pub fn set_table(mut self, inp: std::option::Option<crate::model::Capacity>) -> Self {
            self.table = inp;
            self
        }
        pub fn local_secondary_indexes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Capacity>,
        ) -> Self {
            let mut hash_map = self.local_secondary_indexes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.local_secondary_indexes = Some(hash_map);
            self
        }
        pub fn set_local_secondary_indexes(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Capacity>,
            >,
        ) -> Self {
            self.local_secondary_indexes = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Capacity>,
        ) -> Self {
            let mut hash_map = self.global_secondary_indexes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.global_secondary_indexes = Some(hash_map);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Capacity>,
            >,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConsumedCapacity`](crate::model::ConsumedCapacity)
        pub fn build(self) -> crate::model::ConsumedCapacity {
            crate::model::ConsumedCapacity {
                table_name: self.table_name,
                capacity_units: self.capacity_units,
                read_capacity_units: self.read_capacity_units,
                write_capacity_units: self.write_capacity_units,
                table: self.table,
                local_secondary_indexes: self.local_secondary_indexes,
                global_secondary_indexes: self.global_secondary_indexes,
            }
        }
    }
}
impl ConsumedCapacity {
    /// Creates a new builder-style object to manufacture [`ConsumedCapacity`](crate::model::ConsumedCapacity)
    pub fn builder() -> crate::model::consumed_capacity::Builder {
        crate::model::consumed_capacity::Builder::default()
    }
}

/// <p>Represents the amount of provisioned throughput capacity consumed on a table or an index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Capacity {
    /// <p>The total number of read capacity units consumed on a table or an index.</p>
    #[serde(rename = "ReadCapacityUnits")]
    #[serde(default)]
    pub read_capacity_units: std::option::Option<f64>,
    /// <p>The total number of write capacity units consumed on a table or an index.</p>
    #[serde(rename = "WriteCapacityUnits")]
    #[serde(default)]
    pub write_capacity_units: std::option::Option<f64>,
    /// <p>The total number of capacity units consumed on a table or an index.</p>
    #[serde(rename = "CapacityUnits")]
    #[serde(default)]
    pub capacity_units: std::option::Option<f64>,
}
impl std::fmt::Debug for Capacity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Capacity");
        formatter.field("read_capacity_units", &self.read_capacity_units);
        formatter.field("write_capacity_units", &self.write_capacity_units);
        formatter.field("capacity_units", &self.capacity_units);
        formatter.finish()
    }
}
/// See [`Capacity`](crate::model::Capacity)
pub mod capacity {
    /// A builder for [`Capacity`](crate::model::Capacity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: std::option::Option<f64>,
        pub(crate) write_capacity_units: std::option::Option<f64>,
        pub(crate) capacity_units: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The total number of read capacity units consumed on a table or an index.</p>
        pub fn read_capacity_units(mut self, inp: f64) -> Self {
            self.read_capacity_units = Some(inp);
            self
        }
        pub fn set_read_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.read_capacity_units = inp;
            self
        }
        /// <p>The total number of write capacity units consumed on a table or an index.</p>
        pub fn write_capacity_units(mut self, inp: f64) -> Self {
            self.write_capacity_units = Some(inp);
            self
        }
        pub fn set_write_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.write_capacity_units = inp;
            self
        }
        /// <p>The total number of capacity units consumed on a table or an index.</p>
        pub fn capacity_units(mut self, inp: f64) -> Self {
            self.capacity_units = Some(inp);
            self
        }
        pub fn set_capacity_units(mut self, inp: std::option::Option<f64>) -> Self {
            self.capacity_units = inp;
            self
        }
        /// Consumes the builder and constructs a [`Capacity`](crate::model::Capacity)
        pub fn build(self) -> crate::model::Capacity {
            crate::model::Capacity {
                read_capacity_units: self.read_capacity_units,
                write_capacity_units: self.write_capacity_units,
                capacity_units: self.capacity_units,
            }
        }
    }
}
impl Capacity {
    /// Creates a new builder-style object to manufacture [`Capacity`](crate::model::Capacity)
    pub fn builder() -> crate::model::capacity::Builder {
        crate::model::capacity::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReturnItemCollectionMetrics {
    None,
    Size,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReturnItemCollectionMetrics {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => ReturnItemCollectionMetrics::None,
            "SIZE" => ReturnItemCollectionMetrics::Size,
            other => ReturnItemCollectionMetrics::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReturnItemCollectionMetrics {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReturnItemCollectionMetrics::from(s))
    }
}
impl ReturnItemCollectionMetrics {
    pub fn as_str(&self) -> &str {
        match self {
            ReturnItemCollectionMetrics::None => "NONE",
            ReturnItemCollectionMetrics::Size => "SIZE",
            ReturnItemCollectionMetrics::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReturnItemCollectionMetrics {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReturnItemCollectionMetrics {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Determines the level of detail about provisioned throughput consumption that is returned in the response:</p>
/// <ul>
/// <li>
/// <p>
/// <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p>
/// <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all.  In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p>
/// </li>
/// <li>
/// <p>
/// <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p>
/// </li>
/// <li>
/// <p>
/// <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReturnConsumedCapacity {
    Indexes,
    None,
    Total,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReturnConsumedCapacity {
    fn from(s: &str) -> Self {
        match s {
            "INDEXES" => ReturnConsumedCapacity::Indexes,
            "NONE" => ReturnConsumedCapacity::None,
            "TOTAL" => ReturnConsumedCapacity::Total,
            other => ReturnConsumedCapacity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReturnConsumedCapacity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReturnConsumedCapacity::from(s))
    }
}
impl ReturnConsumedCapacity {
    pub fn as_str(&self) -> &str {
        match self {
            ReturnConsumedCapacity::Indexes => "INDEXES",
            ReturnConsumedCapacity::None => "NONE",
            ReturnConsumedCapacity::Total => "TOTAL",
            ReturnConsumedCapacity::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReturnConsumedCapacity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReturnConsumedCapacity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReturnValue {
    AllNew,
    AllOld,
    None,
    UpdatedNew,
    UpdatedOld,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReturnValue {
    fn from(s: &str) -> Self {
        match s {
            "ALL_NEW" => ReturnValue::AllNew,
            "ALL_OLD" => ReturnValue::AllOld,
            "NONE" => ReturnValue::None,
            "UPDATED_NEW" => ReturnValue::UpdatedNew,
            "UPDATED_OLD" => ReturnValue::UpdatedOld,
            other => ReturnValue::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReturnValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReturnValue::from(s))
    }
}
impl ReturnValue {
    pub fn as_str(&self) -> &str {
        match self {
            ReturnValue::AllNew => "ALL_NEW",
            ReturnValue::AllOld => "ALL_OLD",
            ReturnValue::None => "NONE",
            ReturnValue::UpdatedNew => "UPDATED_NEW",
            ReturnValue::UpdatedOld => "UPDATED_OLD",
            ReturnValue::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReturnValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReturnValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConditionalOperator {
    And,
    Or,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ConditionalOperator {
    fn from(s: &str) -> Self {
        match s {
            "AND" => ConditionalOperator::And,
            "OR" => ConditionalOperator::Or,
            other => ConditionalOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ConditionalOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ConditionalOperator::from(s))
    }
}
impl ConditionalOperator {
    pub fn as_str(&self) -> &str {
        match self {
            ConditionalOperator::And => "AND",
            ConditionalOperator::Or => "OR",
            ConditionalOperator::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ConditionalOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ConditionalOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents a condition to be compared with an attribute value. This condition can be
/// used with <code>DeleteItem</code>, <code>PutItem</code>, or <code>UpdateItem</code>
/// operations; if the comparison evaluates to true, the operation succeeds; if not, the
/// operation fails. You can use <code>ExpectedAttributeValue</code> in one of two different
/// ways:</p>
/// <ul>
/// <li>
/// <p>Use <code>AttributeValueList</code> to specify one or more values to compare against an
/// attribute. Use <code>ComparisonOperator</code> to specify how you want to perform the
/// comparison. If the comparison evaluates to true, then the conditional operation
/// succeeds.</p>
/// </li>
/// <li>
/// <p>Use <code>Value</code> to specify a value that DynamoDB will compare against an attribute. If the
/// values match, then <code>ExpectedAttributeValue</code> evaluates to true and the conditional
/// operation succeeds. Optionally, you can also set <code>Exists</code> to false, indicating that
/// you <i>do not</i> expect to find the attribute value in the table. In this case, the
/// conditional operation succeeds only if the comparison evaluates to false.</p>
/// </li>
/// </ul>
/// <p>
/// <code>Value</code> and <code>Exists</code> are incompatible with <code>AttributeValueList</code> and
/// <code>ComparisonOperator</code>. Note that if you use both sets of parameters at once, DynamoDB will
/// return a <code>ValidationException</code> exception.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExpectedAttributeValue {
    /// <p>Represents the data for the expected attribute.</p>
    /// <p>Each attribute value is described as a name-value pair.  The name is the data type, and the value is the data itself.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the
    /// <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<crate::model::AttributeValue>,
    /// <p>Causes DynamoDB to evaluate the value before attempting a conditional operation:</p>
    /// <ul>
    /// <li>
    /// <p>If <code>Exists</code> is <code>true</code>, DynamoDB will check to see if that attribute value
    /// already exists in the table. If it is found, then the operation succeeds. If it is not
    /// found, the operation fails with a <code>ConditionCheckFailedException</code>.</p>
    /// </li>
    /// <li>
    /// <p>If <code>Exists</code> is <code>false</code>, DynamoDB assumes that the attribute value does
    /// not exist in the table. If in fact the value does not exist, then the assumption
    /// is valid and the operation succeeds. If the value is found, despite the assumption that it
    /// does not exist, the operation fails with a <code>ConditionCheckFailedException</code>.</p>
    /// </li>
    /// </ul>
    /// <p>The default setting for <code>Exists</code> is <code>true</code>. If you supply a <code>Value</code> all
    /// by itself, DynamoDB assumes the attribute exists: You don't have to set <code>Exists</code> to
    /// <code>true</code>, because it is implied.</p>
    /// <p>DynamoDB returns a <code>ValidationException</code> if:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Exists</code> is <code>true</code> but there is no <code>Value</code> to check. (You expect a
    /// value to exist, but don't specify what that value is.)</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Exists</code> is <code>false</code> but you also provide a <code>Value</code>. (You cannot
    /// expect an attribute to have a value, while also expecting it not to exist.)</p>
    /// </li>
    /// </ul>
    #[serde(rename = "Exists")]
    #[serde(default)]
    pub exists: std::option::Option<bool>,
    /// <p>A comparator for evaluating attributes in the <code>AttributeValueList</code>. For example, equals,
    /// greater than, less than, etc.</p>
    /// <p>The following comparison operators are available:</p>
    /// <p>
    /// <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN | BETWEEN</code>
    /// </p>
    /// <p>The following are descriptions of each comparison operator.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types, including lists and maps.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NE</code> : Not equal. <code>NE</code> is supported for all data types, including lists and maps.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
    /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LE</code> : Less than or equal. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LT</code> : Less than. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GE</code> : Greater than or equal. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GT</code> : Greater than. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported for all data types, including lists and maps.</p>
    /// <note>
    /// <p>This operator tests for the existence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This result is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NOT_NULL</code> comparison operator.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported for all data types, including lists and maps.</p>
    /// <note>
    /// <p>This operator tests for the nonexistence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NULL</code>, the result is a Boolean <code>false</code>. This is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NULL</code> comparison operator.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If the target attribute of the comparison is of type String, then
    /// the operator checks for a substring match. If the target attribute of the comparison is
    /// of type Binary, then the operator looks for a subsequence of the target that matches the input.
    /// If the target attribute of the comparison is a set ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
    /// operator evaluates to true if it finds an exact match with any member of the set.</p>
    /// <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a value in
    /// a set.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If the target attribute of the comparison is a String, then
    /// the operator checks for the absence of a substring match. If the target attribute of the
    /// comparison is Binary, then the operator checks for the absence of a subsequence of the
    /// target that matches the input. If the target attribute of the comparison is a set ("<code>SS</code>",
    /// "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to true if it <i>does not</i> find an exact match with any member of the set.</p>
    /// <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BEGINS_WITH</code> : Checks for a prefix. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String or
    /// Binary (not a Number or a set type). The target attribute of the comparison must be of type String or
    /// Binary (not a Number or a set type).</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN</code> : Checks for matching elements in a list.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain one or more <code>AttributeValue</code>
    /// elements of type String, Number, or Binary. These attributes are compared against an
    /// existing attribute of an item. If any elements of the input are equal to the item
    /// attribute, the expression evaluates to true.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BETWEEN</code> : Greater than or equal to the first value, and less than or equal
    /// to the second value. </p>
    /// <p>
    /// <code>AttributeValueList</code> must contain two <code>AttributeValue</code> elements of the same
    /// type, either String, Number, or Binary (not a set type). A target attribute matches if the
    /// target value is greater than, or equal to, the first element and less than, or equal to,
    /// the second element. If an item contains an <code>AttributeValue</code> element of a different type than
    /// the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "ComparisonOperator")]
    #[serde(default)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    /// <p>One or more values to evaluate against the supplied attribute. The number of values in the
    /// list depends on the <code>ComparisonOperator</code> being used.</p>
    /// <p>For type Number, value comparisons are numeric.</p>
    /// <p>String value comparisons for greater than, equals, or less than are based on ASCII character
    /// code values. For example, <code>a</code> is greater than <code>A</code>, and <code>a</code>
    /// is greater than <code>B</code>. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>
    /// <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it compares binary values.</p>
    /// <p>For information on specifying data types in JSON, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html">JSON Data Format</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "AttributeValueList")]
    #[serde(default)]
    pub attribute_value_list: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
}
impl std::fmt::Debug for ExpectedAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExpectedAttributeValue");
        formatter.field("value", &self.value);
        formatter.field("exists", &self.exists);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("attribute_value_list", &self.attribute_value_list);
        formatter.finish()
    }
}
/// See [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue)
pub mod expected_attribute_value {
    /// A builder for [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<crate::model::AttributeValue>,
        pub(crate) exists: std::option::Option<bool>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
        pub(crate) attribute_value_list:
            std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
    }
    impl Builder {
        /// <p>Represents the data for the expected attribute.</p>
        /// <p>Each attribute value is described as a name-value pair.  The name is the data type, and the value is the data itself.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the
        /// <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn value(mut self, inp: crate::model::AttributeValue) -> Self {
            self.value = Some(inp);
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<crate::model::AttributeValue>) -> Self {
            self.value = inp;
            self
        }
        /// <p>Causes DynamoDB to evaluate the value before attempting a conditional operation:</p>
        /// <ul>
        /// <li>
        /// <p>If <code>Exists</code> is <code>true</code>, DynamoDB will check to see if that attribute value
        /// already exists in the table. If it is found, then the operation succeeds. If it is not
        /// found, the operation fails with a <code>ConditionCheckFailedException</code>.</p>
        /// </li>
        /// <li>
        /// <p>If <code>Exists</code> is <code>false</code>, DynamoDB assumes that the attribute value does
        /// not exist in the table. If in fact the value does not exist, then the assumption
        /// is valid and the operation succeeds. If the value is found, despite the assumption that it
        /// does not exist, the operation fails with a <code>ConditionCheckFailedException</code>.</p>
        /// </li>
        /// </ul>
        /// <p>The default setting for <code>Exists</code> is <code>true</code>. If you supply a <code>Value</code> all
        /// by itself, DynamoDB assumes the attribute exists: You don't have to set <code>Exists</code> to
        /// <code>true</code>, because it is implied.</p>
        /// <p>DynamoDB returns a <code>ValidationException</code> if:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Exists</code> is <code>true</code> but there is no <code>Value</code> to check. (You expect a
        /// value to exist, but don't specify what that value is.)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Exists</code> is <code>false</code> but you also provide a <code>Value</code>. (You cannot
        /// expect an attribute to have a value, while also expecting it not to exist.)</p>
        /// </li>
        /// </ul>
        pub fn exists(mut self, inp: bool) -> Self {
            self.exists = Some(inp);
            self
        }
        pub fn set_exists(mut self, inp: std::option::Option<bool>) -> Self {
            self.exists = inp;
            self
        }
        /// <p>A comparator for evaluating attributes in the <code>AttributeValueList</code>. For example, equals,
        /// greater than, less than, etc.</p>
        /// <p>The following comparison operators are available:</p>
        /// <p>
        /// <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN | BETWEEN</code>
        /// </p>
        /// <p>The following are descriptions of each comparison operator.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types, including lists and maps.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NE</code> : Not equal. <code>NE</code> is supported for all data types, including lists and maps.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
        /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LE</code> : Less than or equal. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LT</code> : Less than. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GE</code> : Greater than or equal. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GT</code> : Greater than. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported for all data types, including lists and maps.</p>
        /// <note>
        /// <p>This operator tests for the existence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This result is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NOT_NULL</code> comparison operator.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported for all data types, including lists and maps.</p>
        /// <note>
        /// <p>This operator tests for the nonexistence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NULL</code>, the result is a Boolean <code>false</code>. This is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NULL</code> comparison operator.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If the target attribute of the comparison is of type String, then
        /// the operator checks for a substring match. If the target attribute of the comparison is
        /// of type Binary, then the operator looks for a subsequence of the target that matches the input.
        /// If the target attribute of the comparison is a set ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
        /// operator evaluates to true if it finds an exact match with any member of the set.</p>
        /// <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a value in
        /// a set.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If the target attribute of the comparison is a String, then
        /// the operator checks for the absence of a substring match. If the target attribute of the
        /// comparison is Binary, then the operator checks for the absence of a subsequence of the
        /// target that matches the input. If the target attribute of the comparison is a set ("<code>SS</code>",
        /// "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to true if it <i>does not</i> find an exact match with any member of the set.</p>
        /// <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BEGINS_WITH</code> : Checks for a prefix. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String or
        /// Binary (not a Number or a set type). The target attribute of the comparison must be of type String or
        /// Binary (not a Number or a set type).</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN</code> : Checks for matching elements in a list.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain one or more <code>AttributeValue</code>
        /// elements of type String, Number, or Binary. These attributes are compared against an
        /// existing attribute of an item. If any elements of the input are equal to the item
        /// attribute, the expression evaluates to true.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BETWEEN</code> : Greater than or equal to the first value, and less than or equal
        /// to the second value. </p>
        /// <p>
        /// <code>AttributeValueList</code> must contain two <code>AttributeValue</code> elements of the same
        /// type, either String, Number, or Binary (not a set type). A target attribute matches if the
        /// target value is greater than, or equal to, the first element and less than, or equal to,
        /// the second element. If an item contains an <code>AttributeValue</code> element of a different type than
        /// the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn comparison_operator(mut self, inp: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(inp);
            self
        }
        pub fn set_comparison_operator(
            mut self,
            inp: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = inp;
            self
        }
        pub fn attribute_value_list(
            mut self,
            inp: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut v = self.attribute_value_list.unwrap_or_default();
            v.push(inp.into());
            self.attribute_value_list = Some(v);
            self
        }
        pub fn set_attribute_value_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        ) -> Self {
            self.attribute_value_list = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue)
        pub fn build(self) -> crate::model::ExpectedAttributeValue {
            crate::model::ExpectedAttributeValue {
                value: self.value,
                exists: self.exists,
                comparison_operator: self.comparison_operator,
                attribute_value_list: self.attribute_value_list,
            }
        }
    }
}
impl ExpectedAttributeValue {
    /// Creates a new builder-style object to manufacture [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue)
    pub fn builder() -> crate::model::expected_attribute_value::Builder {
        crate::model::expected_attribute_value::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ComparisonOperator {
    BeginsWith,
    Between,
    Contains,
    Eq,
    Ge,
    Gt,
    In,
    Le,
    Lt,
    Ne,
    NotContains,
    NotNull,
    Null,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ComparisonOperator {
    fn from(s: &str) -> Self {
        match s {
            "BEGINS_WITH" => ComparisonOperator::BeginsWith,
            "BETWEEN" => ComparisonOperator::Between,
            "CONTAINS" => ComparisonOperator::Contains,
            "EQ" => ComparisonOperator::Eq,
            "GE" => ComparisonOperator::Ge,
            "GT" => ComparisonOperator::Gt,
            "IN" => ComparisonOperator::In,
            "LE" => ComparisonOperator::Le,
            "LT" => ComparisonOperator::Lt,
            "NE" => ComparisonOperator::Ne,
            "NOT_CONTAINS" => ComparisonOperator::NotContains,
            "NOT_NULL" => ComparisonOperator::NotNull,
            "NULL" => ComparisonOperator::Null,
            other => ComparisonOperator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ComparisonOperator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ComparisonOperator::from(s))
    }
}
impl ComparisonOperator {
    pub fn as_str(&self) -> &str {
        match self {
            ComparisonOperator::BeginsWith => "BEGINS_WITH",
            ComparisonOperator::Between => "BETWEEN",
            ComparisonOperator::Contains => "CONTAINS",
            ComparisonOperator::Eq => "EQ",
            ComparisonOperator::Ge => "GE",
            ComparisonOperator::Gt => "GT",
            ComparisonOperator::In => "IN",
            ComparisonOperator::Le => "LE",
            ComparisonOperator::Lt => "LT",
            ComparisonOperator::Ne => "NE",
            ComparisonOperator::NotContains => "NOT_CONTAINS",
            ComparisonOperator::NotNull => "NOT_NULL",
            ComparisonOperator::Null => "NULL",
            ComparisonOperator::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ComparisonOperator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ComparisonOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>For the <code>UpdateItem</code> operation, represents the attributes to be modified, the action to
/// perform on each, and the new value for each.</p>
/// <note>
/// <p>You cannot use <code>UpdateItem</code> to update any primary key attributes. Instead, you will
/// need to delete the item, and then use <code>PutItem</code> to create a new item with new
/// attributes.</p>
/// </note>
/// <p>Attribute values cannot be null; string and binary type attributes must have lengths greater
/// than zero; and set type attributes must not be empty. Requests with empty values will be
/// rejected with a <code>ValidationException</code> exception.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeValueUpdate {
    /// <p>Represents the data for an attribute.</p>
    /// <p>Each attribute value is described as a name-value pair. The name is the data type, and the value is the data itself.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer Guide</i>.
    /// </p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<crate::model::AttributeValue>,
    /// <p>Specifies how to perform the update. Valid values are <code>PUT</code> (default), <code>DELETE</code>,
    /// and <code>ADD</code>. The behavior depends on whether the specified primary key already exists
    /// in the table.</p>
    /// <p>
    /// <b>If an item with the specified <i>Key</i> is found in the table:</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PUT</code> - Adds the specified attribute to the item. If the attribute already
    /// exists, it is replaced by the new value. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETE</code> - If no value is specified, the attribute and its value are removed
    /// from the item. The data type of the specified value must match the existing value's data
    /// type.</p>
    /// <p>If a <i>set</i> of values is specified, then those values are subtracted from the old
    /// set. For example, if the attribute value was the set <code>[a,b,c]</code> and the
    /// <code>DELETE</code> action specified <code>[a,c]</code>, then the final attribute value would
    /// be <code>[b]</code>. Specifying an empty set is an error.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ADD</code> - If the attribute does not already exist, then the attribute and its
    /// values are added to the item. If the attribute does exist, then the behavior of
    /// <code>ADD</code> depends on the data type of the attribute:</p>
    /// <ul>
    /// <li>
    /// <p>If the existing attribute is a number, and if <code>Value</code> is also a number, then the
    /// <code>Value</code> is mathematically added to the existing attribute. If <code>Value</code> is a
    /// negative number, then it is subtracted from the existing attribute.</p>
    /// <note>
    /// <p> If you use <code>ADD</code> to increment or decrement a number value for an item
    /// that doesn't exist before the update, DynamoDB uses 0 as the initial value.</p>
    /// <p>In addition, if you use <code>ADD</code> to update an existing item, and intend to
    /// increment or decrement an attribute value which does not yet exist, DynamoDB uses
    /// <code>0</code> as the initial value. For example, suppose that the item you want
    /// to update does not yet have an attribute named <i>itemcount</i>, but you decide to
    /// <code>ADD</code> the number <code>3</code> to this attribute anyway, even though
    /// it currently does not exist. DynamoDB will create the <i>itemcount</i> attribute, set
    /// its initial value to <code>0</code>, and finally add <code>3</code> to it. The
    /// result will be a new <i>itemcount</i> attribute in the item, with a value of
    /// <code>3</code>.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>If the existing data type is a set, and if the <code>Value</code> is also a set, then the
    /// <code>Value</code> is added to the existing set. (This is a <i>set</i> operation, not
    /// mathematical addition.) For example, if the attribute value was the set
    /// <code>[1,2]</code>, and the <code>ADD</code> action specified <code>[3]</code>, then
    /// the final attribute value would be <code>[1,2,3]</code>. An error occurs if an Add
    /// action is specified for a set attribute and the attribute type specified does not
    /// match the existing set type. </p>
    /// <p>Both sets must have the same primitive data type. For example, if the existing data
    /// type is a set of strings, the <code>Value</code> must also be a set of strings. The same
    /// holds true for number sets and binary sets.</p>
    /// </li>
    /// </ul>
    /// <p>This action is only valid for an existing attribute whose data type is number or is a
    /// set. Do not use <code>ADD</code> for any other data types.</p>
    /// </li>
    /// </ul>
    /// <p>
    /// <b>If no item with the specified <i>Key</i> is found:</b>
    /// </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PUT</code> - DynamoDB creates a new item with the specified primary key, and then adds
    /// the attribute. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETE</code> - Nothing happens; there is no attribute to delete.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ADD</code> - DynamoDB creates an item with the supplied primary key and number (or set
    /// of numbers) for the attribute value. The only data types allowed are number and number
    /// set; no other data types can be specified.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "Action")]
    #[serde(default)]
    pub action: std::option::Option<crate::model::AttributeAction>,
}
impl std::fmt::Debug for AttributeValueUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeValueUpdate");
        formatter.field("value", &self.value);
        formatter.field("action", &self.action);
        formatter.finish()
    }
}
/// See [`AttributeValueUpdate`](crate::model::AttributeValueUpdate)
pub mod attribute_value_update {
    /// A builder for [`AttributeValueUpdate`](crate::model::AttributeValueUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<crate::model::AttributeValue>,
        pub(crate) action: std::option::Option<crate::model::AttributeAction>,
    }
    impl Builder {
        /// <p>Represents the data for an attribute.</p>
        /// <p>Each attribute value is described as a name-value pair. The name is the data type, and the value is the data itself.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer Guide</i>.
        /// </p>
        pub fn value(mut self, inp: crate::model::AttributeValue) -> Self {
            self.value = Some(inp);
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<crate::model::AttributeValue>) -> Self {
            self.value = inp;
            self
        }
        /// <p>Specifies how to perform the update. Valid values are <code>PUT</code> (default), <code>DELETE</code>,
        /// and <code>ADD</code>. The behavior depends on whether the specified primary key already exists
        /// in the table.</p>
        /// <p>
        /// <b>If an item with the specified <i>Key</i> is found in the table:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PUT</code> - Adds the specified attribute to the item. If the attribute already
        /// exists, it is replaced by the new value. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETE</code> - If no value is specified, the attribute and its value are removed
        /// from the item. The data type of the specified value must match the existing value's data
        /// type.</p>
        /// <p>If a <i>set</i> of values is specified, then those values are subtracted from the old
        /// set. For example, if the attribute value was the set <code>[a,b,c]</code> and the
        /// <code>DELETE</code> action specified <code>[a,c]</code>, then the final attribute value would
        /// be <code>[b]</code>. Specifying an empty set is an error.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ADD</code> - If the attribute does not already exist, then the attribute and its
        /// values are added to the item. If the attribute does exist, then the behavior of
        /// <code>ADD</code> depends on the data type of the attribute:</p>
        /// <ul>
        /// <li>
        /// <p>If the existing attribute is a number, and if <code>Value</code> is also a number, then the
        /// <code>Value</code> is mathematically added to the existing attribute. If <code>Value</code> is a
        /// negative number, then it is subtracted from the existing attribute.</p>
        /// <note>
        /// <p> If you use <code>ADD</code> to increment or decrement a number value for an item
        /// that doesn't exist before the update, DynamoDB uses 0 as the initial value.</p>
        /// <p>In addition, if you use <code>ADD</code> to update an existing item, and intend to
        /// increment or decrement an attribute value which does not yet exist, DynamoDB uses
        /// <code>0</code> as the initial value. For example, suppose that the item you want
        /// to update does not yet have an attribute named <i>itemcount</i>, but you decide to
        /// <code>ADD</code> the number <code>3</code> to this attribute anyway, even though
        /// it currently does not exist. DynamoDB will create the <i>itemcount</i> attribute, set
        /// its initial value to <code>0</code>, and finally add <code>3</code> to it. The
        /// result will be a new <i>itemcount</i> attribute in the item, with a value of
        /// <code>3</code>.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>If the existing data type is a set, and if the <code>Value</code> is also a set, then the
        /// <code>Value</code> is added to the existing set. (This is a <i>set</i> operation, not
        /// mathematical addition.) For example, if the attribute value was the set
        /// <code>[1,2]</code>, and the <code>ADD</code> action specified <code>[3]</code>, then
        /// the final attribute value would be <code>[1,2,3]</code>. An error occurs if an Add
        /// action is specified for a set attribute and the attribute type specified does not
        /// match the existing set type. </p>
        /// <p>Both sets must have the same primitive data type. For example, if the existing data
        /// type is a set of strings, the <code>Value</code> must also be a set of strings. The same
        /// holds true for number sets and binary sets.</p>
        /// </li>
        /// </ul>
        /// <p>This action is only valid for an existing attribute whose data type is number or is a
        /// set. Do not use <code>ADD</code> for any other data types.</p>
        /// </li>
        /// </ul>
        /// <p>
        /// <b>If no item with the specified <i>Key</i> is found:</b>
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PUT</code> - DynamoDB creates a new item with the specified primary key, and then adds
        /// the attribute. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETE</code> - Nothing happens; there is no attribute to delete.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ADD</code> - DynamoDB creates an item with the supplied primary key and number (or set
        /// of numbers) for the attribute value. The only data types allowed are number and number
        /// set; no other data types can be specified.</p>
        /// </li>
        /// </ul>
        pub fn action(mut self, inp: crate::model::AttributeAction) -> Self {
            self.action = Some(inp);
            self
        }
        pub fn set_action(
            mut self,
            inp: std::option::Option<crate::model::AttributeAction>,
        ) -> Self {
            self.action = inp;
            self
        }
        /// Consumes the builder and constructs a [`AttributeValueUpdate`](crate::model::AttributeValueUpdate)
        pub fn build(self) -> crate::model::AttributeValueUpdate {
            crate::model::AttributeValueUpdate {
                value: self.value,
                action: self.action,
            }
        }
    }
}
impl AttributeValueUpdate {
    /// Creates a new builder-style object to manufacture [`AttributeValueUpdate`](crate::model::AttributeValueUpdate)
    pub fn builder() -> crate::model::attribute_value_update::Builder {
        crate::model::attribute_value_update::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttributeAction {
    Add,
    Delete,
    Put,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AttributeAction {
    fn from(s: &str) -> Self {
        match s {
            "ADD" => AttributeAction::Add,
            "DELETE" => AttributeAction::Delete,
            "PUT" => AttributeAction::Put,
            other => AttributeAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AttributeAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AttributeAction::from(s))
    }
}
impl AttributeAction {
    pub fn as_str(&self) -> &str {
        match self {
            AttributeAction::Add => "ADD",
            AttributeAction::Delete => "DELETE",
            AttributeAction::Put => "PUT",
            AttributeAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AttributeAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AttributeAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the properties of a replica.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaSettingsDescription {
    /// <p>The Region name of the replica.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The current state of the Region:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The Region is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The Region is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The Region is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The Region is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "ReplicaStatus")]
    #[serde(default)]
    pub replica_status: std::option::Option<crate::model::ReplicaStatus>,
    /// <p>The read/write capacity mode of the replica.</p>
    #[serde(rename = "ReplicaBillingModeSummary")]
    #[serde(default)]
    pub replica_billing_mode_summary: std::option::Option<crate::model::BillingModeSummary>,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
    /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
    /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.
    /// </p>
    #[serde(rename = "ReplicaProvisionedReadCapacityUnits")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for a global table replica's read capacity units.</p>
    #[serde(rename = "ReplicaProvisionedReadCapacityAutoScalingSettings")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
    /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
    /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ReplicaProvisionedWriteCapacityUnits")]
    #[serde(default)]
    pub replica_provisioned_write_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for a global table replica's write capacity units.</p>
    #[serde(rename = "ReplicaProvisionedWriteCapacityAutoScalingSettings")]
    #[serde(default)]
    pub replica_provisioned_write_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>Replica global secondary index settings for the global table.</p>
    #[serde(rename = "ReplicaGlobalSecondaryIndexSettings")]
    #[serde(default)]
    pub replica_global_secondary_index_settings: std::option::Option<
        std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsDescription>,
    >,
}
impl std::fmt::Debug for ReplicaSettingsDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaSettingsDescription");
        formatter.field("region_name", &self.region_name);
        formatter.field("replica_status", &self.replica_status);
        formatter.field(
            "replica_billing_mode_summary",
            &self.replica_billing_mode_summary,
        );
        formatter.field(
            "replica_provisioned_read_capacity_units",
            &self.replica_provisioned_read_capacity_units,
        );
        formatter.field(
            "replica_provisioned_read_capacity_auto_scaling_settings",
            &self.replica_provisioned_read_capacity_auto_scaling_settings,
        );
        formatter.field(
            "replica_provisioned_write_capacity_units",
            &self.replica_provisioned_write_capacity_units,
        );
        formatter.field(
            "replica_provisioned_write_capacity_auto_scaling_settings",
            &self.replica_provisioned_write_capacity_auto_scaling_settings,
        );
        formatter.field(
            "replica_global_secondary_index_settings",
            &self.replica_global_secondary_index_settings,
        );
        formatter.finish()
    }
}
/// See [`ReplicaSettingsDescription`](crate::model::ReplicaSettingsDescription)
pub mod replica_settings_description {
    /// A builder for [`ReplicaSettingsDescription`](crate::model::ReplicaSettingsDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) replica_status: std::option::Option<crate::model::ReplicaStatus>,
        pub(crate) replica_billing_mode_summary:
            std::option::Option<crate::model::BillingModeSummary>,
        pub(crate) replica_provisioned_read_capacity_units: std::option::Option<i64>,
        pub(crate) replica_provisioned_read_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) replica_provisioned_write_capacity_units: std::option::Option<i64>,
        pub(crate) replica_provisioned_write_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) replica_global_secondary_index_settings: std::option::Option<
            std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsDescription>,
        >,
    }
    impl Builder {
        /// <p>The Region name of the replica.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// <p>The current state of the Region:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The Region is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The Region is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The Region is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The Region is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn replica_status(mut self, inp: crate::model::ReplicaStatus) -> Self {
            self.replica_status = Some(inp);
            self
        }
        pub fn set_replica_status(
            mut self,
            inp: std::option::Option<crate::model::ReplicaStatus>,
        ) -> Self {
            self.replica_status = inp;
            self
        }
        /// <p>The read/write capacity mode of the replica.</p>
        pub fn replica_billing_mode_summary(
            mut self,
            inp: crate::model::BillingModeSummary,
        ) -> Self {
            self.replica_billing_mode_summary = Some(inp);
            self
        }
        pub fn set_replica_billing_mode_summary(
            mut self,
            inp: std::option::Option<crate::model::BillingModeSummary>,
        ) -> Self {
            self.replica_billing_mode_summary = inp;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
        /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
        /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.
        /// </p>
        pub fn replica_provisioned_read_capacity_units(mut self, inp: i64) -> Self {
            self.replica_provisioned_read_capacity_units = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.replica_provisioned_read_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for a global table replica's read capacity units.</p>
        pub fn replica_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings = inp;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
        /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
        /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn replica_provisioned_write_capacity_units(mut self, inp: i64) -> Self {
            self.replica_provisioned_write_capacity_units = Some(inp);
            self
        }
        pub fn set_replica_provisioned_write_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.replica_provisioned_write_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for a global table replica's write capacity units.</p>
        pub fn replica_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.replica_provisioned_write_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_replica_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.replica_provisioned_write_capacity_auto_scaling_settings = inp;
            self
        }
        pub fn replica_global_secondary_index_settings(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndexSettingsDescription>,
        ) -> Self {
            let mut v = self
                .replica_global_secondary_index_settings
                .unwrap_or_default();
            v.push(inp.into());
            self.replica_global_secondary_index_settings = Some(v);
            self
        }
        pub fn set_replica_global_secondary_index_settings(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsDescription>,
            >,
        ) -> Self {
            self.replica_global_secondary_index_settings = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaSettingsDescription`](crate::model::ReplicaSettingsDescription)
        pub fn build(self) -> crate::model::ReplicaSettingsDescription {
            crate::model::ReplicaSettingsDescription {
                region_name: self.region_name,
                replica_status: self.replica_status,
                replica_billing_mode_summary: self.replica_billing_mode_summary,
                replica_provisioned_read_capacity_units: self
                    .replica_provisioned_read_capacity_units,
                replica_provisioned_read_capacity_auto_scaling_settings: self
                    .replica_provisioned_read_capacity_auto_scaling_settings,
                replica_provisioned_write_capacity_units: self
                    .replica_provisioned_write_capacity_units,
                replica_provisioned_write_capacity_auto_scaling_settings: self
                    .replica_provisioned_write_capacity_auto_scaling_settings,
                replica_global_secondary_index_settings: self
                    .replica_global_secondary_index_settings,
            }
        }
    }
}
impl ReplicaSettingsDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaSettingsDescription`](crate::model::ReplicaSettingsDescription)
    pub fn builder() -> crate::model::replica_settings_description::Builder {
        crate::model::replica_settings_description::Builder::default()
    }
}

/// <p>Represents the properties of a global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndexSettingsDescription {
    /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>
    /// The current status of the global secondary index:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The global secondary index is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The global secondary index is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The global secondary index is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The global secondary index is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "IndexStatus")]
    #[serde(default)]
    pub index_status: std::option::Option<crate::model::IndexStatus>,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    #[serde(rename = "ProvisionedReadCapacityUnits")]
    #[serde(default)]
    pub provisioned_read_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for a global secondary index replica's read capacity units.</p>
    #[serde(rename = "ProvisionedReadCapacityAutoScalingSettings")]
    #[serde(default)]
    pub provisioned_read_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    #[serde(rename = "ProvisionedWriteCapacityUnits")]
    #[serde(default)]
    pub provisioned_write_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for a global secondary index replica's write capacity
    /// units.</p>
    #[serde(rename = "ProvisionedWriteCapacityAutoScalingSettings")]
    #[serde(default)]
    pub provisioned_write_capacity_auto_scaling_settings:
        std::option::Option<crate::model::AutoScalingSettingsDescription>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndexSettingsDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndexSettingsDescription");
        formatter.field("index_name", &self.index_name);
        formatter.field("index_status", &self.index_status);
        formatter.field(
            "provisioned_read_capacity_units",
            &self.provisioned_read_capacity_units,
        );
        formatter.field(
            "provisioned_read_capacity_auto_scaling_settings",
            &self.provisioned_read_capacity_auto_scaling_settings,
        );
        formatter.field(
            "provisioned_write_capacity_units",
            &self.provisioned_write_capacity_units,
        );
        formatter.field(
            "provisioned_write_capacity_auto_scaling_settings",
            &self.provisioned_write_capacity_auto_scaling_settings,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndexSettingsDescription`](crate::model::ReplicaGlobalSecondaryIndexSettingsDescription)
pub mod replica_global_secondary_index_settings_description {
    /// A builder for [`ReplicaGlobalSecondaryIndexSettingsDescription`](crate::model::ReplicaGlobalSecondaryIndexSettingsDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) index_status: std::option::Option<crate::model::IndexStatus>,
        pub(crate) provisioned_read_capacity_units: std::option::Option<i64>,
        pub(crate) provisioned_read_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
        pub(crate) provisioned_write_capacity_units: std::option::Option<i64>,
        pub(crate) provisioned_write_capacity_auto_scaling_settings:
            std::option::Option<crate::model::AutoScalingSettingsDescription>,
    }
    impl Builder {
        /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>
        /// The current status of the global secondary index:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The global secondary index is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The global secondary index is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The global secondary index is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The global secondary index is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn index_status(mut self, inp: crate::model::IndexStatus) -> Self {
            self.index_status = Some(inp);
            self
        }
        pub fn set_index_status(
            mut self,
            inp: std::option::Option<crate::model::IndexStatus>,
        ) -> Self {
            self.index_status = inp;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn provisioned_read_capacity_units(mut self, inp: i64) -> Self {
            self.provisioned_read_capacity_units = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.provisioned_read_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for a global secondary index replica's read capacity units.</p>
        pub fn provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings = inp;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn provisioned_write_capacity_units(mut self, inp: i64) -> Self {
            self.provisioned_write_capacity_units = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.provisioned_write_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for a global secondary index replica's write capacity
        /// units.</p>
        pub fn provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: crate::model::AutoScalingSettingsDescription,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_auto_scaling_settings(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsDescription>,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexSettingsDescription`](crate::model::ReplicaGlobalSecondaryIndexSettingsDescription)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexSettingsDescription {
            crate::model::ReplicaGlobalSecondaryIndexSettingsDescription {
                index_name: self.index_name,
                index_status: self.index_status,
                provisioned_read_capacity_units: self.provisioned_read_capacity_units,
                provisioned_read_capacity_auto_scaling_settings: self
                    .provisioned_read_capacity_auto_scaling_settings,
                provisioned_write_capacity_units: self.provisioned_write_capacity_units,
                provisioned_write_capacity_auto_scaling_settings: self
                    .provisioned_write_capacity_auto_scaling_settings,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndexSettingsDescription {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexSettingsDescription`](crate::model::ReplicaGlobalSecondaryIndexSettingsDescription)
    pub fn builder() -> crate::model::replica_global_secondary_index_settings_description::Builder {
        crate::model::replica_global_secondary_index_settings_description::Builder::default()
    }
}

/// <p>Represents the settings for a global table in a Region that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaSettingsUpdate {
    /// <p>The Region of the replica to be added.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
    /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
    /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.
    /// </p>
    #[serde(rename = "ReplicaProvisionedReadCapacityUnits")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for managing a global table replica's read capacity units.</p>
    #[serde(rename = "ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate")]
    #[serde(default)]
    pub replica_provisioned_read_capacity_auto_scaling_settings_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    /// <p>Represents the settings of a global secondary index for a global table that will be modified.</p>
    #[serde(rename = "ReplicaGlobalSecondaryIndexSettingsUpdate")]
    #[serde(default)]
    pub replica_global_secondary_index_settings_update:
        std::option::Option<std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate>>,
}
impl std::fmt::Debug for ReplicaSettingsUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaSettingsUpdate");
        formatter.field("region_name", &self.region_name);
        formatter.field(
            "replica_provisioned_read_capacity_units",
            &self.replica_provisioned_read_capacity_units,
        );
        formatter.field(
            "replica_provisioned_read_capacity_auto_scaling_settings_update",
            &self.replica_provisioned_read_capacity_auto_scaling_settings_update,
        );
        formatter.field(
            "replica_global_secondary_index_settings_update",
            &self.replica_global_secondary_index_settings_update,
        );
        formatter.finish()
    }
}
/// See [`ReplicaSettingsUpdate`](crate::model::ReplicaSettingsUpdate)
pub mod replica_settings_update {
    /// A builder for [`ReplicaSettingsUpdate`](crate::model::ReplicaSettingsUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
        pub(crate) replica_provisioned_read_capacity_units: std::option::Option<i64>,
        pub(crate) replica_provisioned_read_capacity_auto_scaling_settings_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        pub(crate) replica_global_secondary_index_settings_update: std::option::Option<
            std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate>,
        >,
    }
    impl Builder {
        /// <p>The Region of the replica to be added.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.
        /// For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput">Specifying Read and Write
        /// Requirements</a> in the <i>Amazon DynamoDB Developer Guide</i>.
        /// </p>
        pub fn replica_provisioned_read_capacity_units(mut self, inp: i64) -> Self {
            self.replica_provisioned_read_capacity_units = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.replica_provisioned_read_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for managing a global table replica's read capacity units.</p>
        pub fn replica_provisioned_read_capacity_auto_scaling_settings_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings_update = Some(inp);
            self
        }
        pub fn set_replica_provisioned_read_capacity_auto_scaling_settings_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.replica_provisioned_read_capacity_auto_scaling_settings_update = inp;
            self
        }
        pub fn replica_global_secondary_index_settings_update(
            mut self,
            inp: impl Into<crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate>,
        ) -> Self {
            let mut v = self
                .replica_global_secondary_index_settings_update
                .unwrap_or_default();
            v.push(inp.into());
            self.replica_global_secondary_index_settings_update = Some(v);
            self
        }
        pub fn set_replica_global_secondary_index_settings_update(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate>,
            >,
        ) -> Self {
            self.replica_global_secondary_index_settings_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaSettingsUpdate`](crate::model::ReplicaSettingsUpdate)
        pub fn build(self) -> crate::model::ReplicaSettingsUpdate {
            crate::model::ReplicaSettingsUpdate {
                region_name: self.region_name,
                replica_provisioned_read_capacity_units: self
                    .replica_provisioned_read_capacity_units,
                replica_provisioned_read_capacity_auto_scaling_settings_update: self
                    .replica_provisioned_read_capacity_auto_scaling_settings_update,
                replica_global_secondary_index_settings_update: self
                    .replica_global_secondary_index_settings_update,
            }
        }
    }
}
impl ReplicaSettingsUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicaSettingsUpdate`](crate::model::ReplicaSettingsUpdate)
    pub fn builder() -> crate::model::replica_settings_update::Builder {
        crate::model::replica_settings_update::Builder::default()
    }
}

/// <p>Represents the settings of a global secondary index for a global table that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaGlobalSecondaryIndexSettingsUpdate {
    /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
    #[serde(rename = "ProvisionedReadCapacityUnits")]
    #[serde(default)]
    pub provisioned_read_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for managing a global secondary index replica's read capacity
    /// units.</p>
    #[serde(rename = "ProvisionedReadCapacityAutoScalingSettingsUpdate")]
    #[serde(default)]
    pub provisioned_read_capacity_auto_scaling_settings_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
}
impl std::fmt::Debug for ReplicaGlobalSecondaryIndexSettingsUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaGlobalSecondaryIndexSettingsUpdate");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_read_capacity_units",
            &self.provisioned_read_capacity_units,
        );
        formatter.field(
            "provisioned_read_capacity_auto_scaling_settings_update",
            &self.provisioned_read_capacity_auto_scaling_settings_update,
        );
        formatter.finish()
    }
}
/// See [`ReplicaGlobalSecondaryIndexSettingsUpdate`](crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate)
pub mod replica_global_secondary_index_settings_update {
    /// A builder for [`ReplicaGlobalSecondaryIndexSettingsUpdate`](crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_read_capacity_units: std::option::Option<i64>,
        pub(crate) provisioned_read_capacity_auto_scaling_settings_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    }
    impl Builder {
        /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>The maximum number of strongly consistent reads consumed per second before DynamoDB returns a <code>ThrottlingException</code>.</p>
        pub fn provisioned_read_capacity_units(mut self, inp: i64) -> Self {
            self.provisioned_read_capacity_units = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.provisioned_read_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for managing a global secondary index replica's read capacity
        /// units.</p>
        pub fn provisioned_read_capacity_auto_scaling_settings_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings_update = Some(inp);
            self
        }
        pub fn set_provisioned_read_capacity_auto_scaling_settings_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.provisioned_read_capacity_auto_scaling_settings_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexSettingsUpdate`](crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate)
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate {
            crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate {
                index_name: self.index_name,
                provisioned_read_capacity_units: self.provisioned_read_capacity_units,
                provisioned_read_capacity_auto_scaling_settings_update: self
                    .provisioned_read_capacity_auto_scaling_settings_update,
            }
        }
    }
}
impl ReplicaGlobalSecondaryIndexSettingsUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexSettingsUpdate`](crate::model::ReplicaGlobalSecondaryIndexSettingsUpdate)
    pub fn builder() -> crate::model::replica_global_secondary_index_settings_update::Builder {
        crate::model::replica_global_secondary_index_settings_update::Builder::default()
    }
}

/// <p>Represents the settings of a global secondary index for a global table that will be modified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalTableGlobalSecondaryIndexSettingsUpdate {
    /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException.</code>
    /// </p>
    #[serde(rename = "ProvisionedWriteCapacityUnits")]
    #[serde(default)]
    pub provisioned_write_capacity_units: std::option::Option<i64>,
    /// <p>Auto scaling settings for managing a global secondary index's write capacity
    /// units.</p>
    #[serde(rename = "ProvisionedWriteCapacityAutoScalingSettingsUpdate")]
    #[serde(default)]
    pub provisioned_write_capacity_auto_scaling_settings_update:
        std::option::Option<crate::model::AutoScalingSettingsUpdate>,
}
impl std::fmt::Debug for GlobalTableGlobalSecondaryIndexSettingsUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalTableGlobalSecondaryIndexSettingsUpdate");
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "provisioned_write_capacity_units",
            &self.provisioned_write_capacity_units,
        );
        formatter.field(
            "provisioned_write_capacity_auto_scaling_settings_update",
            &self.provisioned_write_capacity_auto_scaling_settings_update,
        );
        formatter.finish()
    }
}
/// See [`GlobalTableGlobalSecondaryIndexSettingsUpdate`](crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate)
pub mod global_table_global_secondary_index_settings_update {
    /// A builder for [`GlobalTableGlobalSecondaryIndexSettingsUpdate`](crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) provisioned_write_capacity_units: std::option::Option<i64>,
        pub(crate) provisioned_write_capacity_auto_scaling_settings_update:
            std::option::Option<crate::model::AutoScalingSettingsUpdate>,
    }
    impl Builder {
        /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>The maximum number of writes consumed per second before DynamoDB returns a <code>ThrottlingException.</code>
        /// </p>
        pub fn provisioned_write_capacity_units(mut self, inp: i64) -> Self {
            self.provisioned_write_capacity_units = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_units(
            mut self,
            inp: std::option::Option<i64>,
        ) -> Self {
            self.provisioned_write_capacity_units = inp;
            self
        }
        /// <p>Auto scaling settings for managing a global secondary index's write capacity
        /// units.</p>
        pub fn provisioned_write_capacity_auto_scaling_settings_update(
            mut self,
            inp: crate::model::AutoScalingSettingsUpdate,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings_update = Some(inp);
            self
        }
        pub fn set_provisioned_write_capacity_auto_scaling_settings_update(
            mut self,
            inp: std::option::Option<crate::model::AutoScalingSettingsUpdate>,
        ) -> Self {
            self.provisioned_write_capacity_auto_scaling_settings_update = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableGlobalSecondaryIndexSettingsUpdate`](crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate)
        pub fn build(self) -> crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate {
            crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate {
                index_name: self.index_name,
                provisioned_write_capacity_units: self.provisioned_write_capacity_units,
                provisioned_write_capacity_auto_scaling_settings_update: self
                    .provisioned_write_capacity_auto_scaling_settings_update,
            }
        }
    }
}
impl GlobalTableGlobalSecondaryIndexSettingsUpdate {
    /// Creates a new builder-style object to manufacture [`GlobalTableGlobalSecondaryIndexSettingsUpdate`](crate::model::GlobalTableGlobalSecondaryIndexSettingsUpdate)
    pub fn builder() -> crate::model::global_table_global_secondary_index_settings_update::Builder {
        crate::model::global_table_global_secondary_index_settings_update::Builder::default()
    }
}

/// <p>Contains details about the global table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalTableDescription {
    /// <p>The Regions where the global table has replicas.</p>
    #[serde(rename = "ReplicationGroup")]
    #[serde(default)]
    pub replication_group: std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
    /// <p>The unique identifier of the global table.</p>
    #[serde(rename = "GlobalTableArn")]
    #[serde(default)]
    pub global_table_arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the global table.</p>
    #[serde(rename = "CreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current state of the global table:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CREATING</code> - The global table is being created.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UPDATING</code> - The global table is being updated.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DELETING</code> - The global table is being deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ACTIVE</code> - The global table is ready for use.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "GlobalTableStatus")]
    #[serde(default)]
    pub global_table_status: std::option::Option<crate::model::GlobalTableStatus>,
    /// <p>The global table name.</p>
    #[serde(rename = "GlobalTableName")]
    #[serde(default)]
    pub global_table_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalTableDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalTableDescription");
        formatter.field("replication_group", &self.replication_group);
        formatter.field("global_table_arn", &self.global_table_arn);
        formatter.field("creation_date_time", &self.creation_date_time);
        formatter.field("global_table_status", &self.global_table_status);
        formatter.field("global_table_name", &self.global_table_name);
        formatter.finish()
    }
}
/// See [`GlobalTableDescription`](crate::model::GlobalTableDescription)
pub mod global_table_description {
    /// A builder for [`GlobalTableDescription`](crate::model::GlobalTableDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) replication_group:
            std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
        pub(crate) global_table_arn: std::option::Option<std::string::String>,
        pub(crate) creation_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) global_table_status: std::option::Option<crate::model::GlobalTableStatus>,
        pub(crate) global_table_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn replication_group(
            mut self,
            inp: impl Into<crate::model::ReplicaDescription>,
        ) -> Self {
            let mut v = self.replication_group.unwrap_or_default();
            v.push(inp.into());
            self.replication_group = Some(v);
            self
        }
        pub fn set_replication_group(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ReplicaDescription>>,
        ) -> Self {
            self.replication_group = inp;
            self
        }
        /// <p>The unique identifier of the global table.</p>
        pub fn global_table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.global_table_arn = Some(inp.into());
            self
        }
        pub fn set_global_table_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_table_arn = inp;
            self
        }
        /// <p>The creation time of the global table.</p>
        pub fn creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_date_time = Some(inp);
            self
        }
        pub fn set_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_date_time = inp;
            self
        }
        /// <p>The current state of the global table:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CREATING</code> - The global table is being created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UPDATING</code> - The global table is being updated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DELETING</code> - The global table is being deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ACTIVE</code> - The global table is ready for use.</p>
        /// </li>
        /// </ul>
        pub fn global_table_status(mut self, inp: crate::model::GlobalTableStatus) -> Self {
            self.global_table_status = Some(inp);
            self
        }
        pub fn set_global_table_status(
            mut self,
            inp: std::option::Option<crate::model::GlobalTableStatus>,
        ) -> Self {
            self.global_table_status = inp;
            self
        }
        /// <p>The global table name.</p>
        pub fn global_table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.global_table_name = Some(inp.into());
            self
        }
        pub fn set_global_table_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_table_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableDescription`](crate::model::GlobalTableDescription)
        pub fn build(self) -> crate::model::GlobalTableDescription {
            crate::model::GlobalTableDescription {
                replication_group: self.replication_group,
                global_table_arn: self.global_table_arn,
                creation_date_time: self.creation_date_time,
                global_table_status: self.global_table_status,
                global_table_name: self.global_table_name,
            }
        }
    }
}
impl GlobalTableDescription {
    /// Creates a new builder-style object to manufacture [`GlobalTableDescription`](crate::model::GlobalTableDescription)
    pub fn builder() -> crate::model::global_table_description::Builder {
        crate::model::global_table_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum GlobalTableStatus {
    Active,
    Creating,
    Deleting,
    Updating,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for GlobalTableStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => GlobalTableStatus::Active,
            "CREATING" => GlobalTableStatus::Creating,
            "DELETING" => GlobalTableStatus::Deleting,
            "UPDATING" => GlobalTableStatus::Updating,
            other => GlobalTableStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for GlobalTableStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(GlobalTableStatus::from(s))
    }
}
impl GlobalTableStatus {
    pub fn as_str(&self) -> &str {
        match self {
            GlobalTableStatus::Active => "ACTIVE",
            GlobalTableStatus::Creating => "CREATING",
            GlobalTableStatus::Deleting => "DELETING",
            GlobalTableStatus::Updating => "UPDATING",
            GlobalTableStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for GlobalTableStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for GlobalTableStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents one of the following:</p>
/// <ul>
/// <li>
/// <p>A new replica to be added to an existing global table.</p>
/// </li>
/// <li>
/// <p>New parameters for an existing replica.</p>
/// </li>
/// <li>
/// <p>An existing replica to be removed from an existing global table.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaUpdate {
    /// <p>The parameters required for creating a replica on an existing global table.</p>
    #[serde(rename = "Create")]
    #[serde(default)]
    pub create: std::option::Option<crate::model::CreateReplicaAction>,
    /// <p>The name of the existing replica to be removed.</p>
    #[serde(rename = "Delete")]
    #[serde(default)]
    pub delete: std::option::Option<crate::model::DeleteReplicaAction>,
}
impl std::fmt::Debug for ReplicaUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaUpdate");
        formatter.field("create", &self.create);
        formatter.field("delete", &self.delete);
        formatter.finish()
    }
}
/// See [`ReplicaUpdate`](crate::model::ReplicaUpdate)
pub mod replica_update {
    /// A builder for [`ReplicaUpdate`](crate::model::ReplicaUpdate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) create: std::option::Option<crate::model::CreateReplicaAction>,
        pub(crate) delete: std::option::Option<crate::model::DeleteReplicaAction>,
    }
    impl Builder {
        /// <p>The parameters required for creating a replica on an existing global table.</p>
        pub fn create(mut self, inp: crate::model::CreateReplicaAction) -> Self {
            self.create = Some(inp);
            self
        }
        pub fn set_create(
            mut self,
            inp: std::option::Option<crate::model::CreateReplicaAction>,
        ) -> Self {
            self.create = inp;
            self
        }
        /// <p>The name of the existing replica to be removed.</p>
        pub fn delete(mut self, inp: crate::model::DeleteReplicaAction) -> Self {
            self.delete = Some(inp);
            self
        }
        pub fn set_delete(
            mut self,
            inp: std::option::Option<crate::model::DeleteReplicaAction>,
        ) -> Self {
            self.delete = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaUpdate`](crate::model::ReplicaUpdate)
        pub fn build(self) -> crate::model::ReplicaUpdate {
            crate::model::ReplicaUpdate {
                create: self.create,
                delete: self.delete,
            }
        }
    }
}
impl ReplicaUpdate {
    /// Creates a new builder-style object to manufacture [`ReplicaUpdate`](crate::model::ReplicaUpdate)
    pub fn builder() -> crate::model::replica_update::Builder {
        crate::model::replica_update::Builder::default()
    }
}

/// <p>Represents a replica to be removed.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteReplicaAction {
    /// <p>The Region of the replica to be removed.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteReplicaAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteReplicaAction");
        formatter.field("region_name", &self.region_name);
        formatter.finish()
    }
}
/// See [`DeleteReplicaAction`](crate::model::DeleteReplicaAction)
pub mod delete_replica_action {
    /// A builder for [`DeleteReplicaAction`](crate::model::DeleteReplicaAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Region of the replica to be removed.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteReplicaAction`](crate::model::DeleteReplicaAction)
        pub fn build(self) -> crate::model::DeleteReplicaAction {
            crate::model::DeleteReplicaAction {
                region_name: self.region_name,
            }
        }
    }
}
impl DeleteReplicaAction {
    /// Creates a new builder-style object to manufacture [`DeleteReplicaAction`](crate::model::DeleteReplicaAction)
    pub fn builder() -> crate::model::delete_replica_action::Builder {
        crate::model::delete_replica_action::Builder::default()
    }
}

/// <p>Represents a replica to be added.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateReplicaAction {
    /// <p>The Region of the replica to be added.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateReplicaAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateReplicaAction");
        formatter.field("region_name", &self.region_name);
        formatter.finish()
    }
}
/// See [`CreateReplicaAction`](crate::model::CreateReplicaAction)
pub mod create_replica_action {
    /// A builder for [`CreateReplicaAction`](crate::model::CreateReplicaAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Region of the replica to be added.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateReplicaAction`](crate::model::CreateReplicaAction)
        pub fn build(self) -> crate::model::CreateReplicaAction {
            crate::model::CreateReplicaAction {
                region_name: self.region_name,
            }
        }
    }
}
impl CreateReplicaAction {
    /// Creates a new builder-style object to manufacture [`CreateReplicaAction`](crate::model::CreateReplicaAction)
    pub fn builder() -> crate::model::create_replica_action::Builder {
        crate::model::create_replica_action::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContributorInsightsStatus {
    Disabled,
    Disabling,
    Enabled,
    Enabling,
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContributorInsightsStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ContributorInsightsStatus::Disabled,
            "DISABLING" => ContributorInsightsStatus::Disabling,
            "ENABLED" => ContributorInsightsStatus::Enabled,
            "ENABLING" => ContributorInsightsStatus::Enabling,
            "FAILED" => ContributorInsightsStatus::Failed,
            other => ContributorInsightsStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContributorInsightsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ContributorInsightsStatus::from(s))
    }
}
impl ContributorInsightsStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ContributorInsightsStatus::Disabled => "DISABLED",
            ContributorInsightsStatus::Disabling => "DISABLING",
            ContributorInsightsStatus::Enabled => "ENABLED",
            ContributorInsightsStatus::Enabling => "ENABLING",
            ContributorInsightsStatus::Failed => "FAILED",
            ContributorInsightsStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ContributorInsightsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ContributorInsightsStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContributorInsightsAction {
    Disable,
    Enable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContributorInsightsAction {
    fn from(s: &str) -> Self {
        match s {
            "DISABLE" => ContributorInsightsAction::Disable,
            "ENABLE" => ContributorInsightsAction::Enable,
            other => ContributorInsightsAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContributorInsightsAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ContributorInsightsAction::from(s))
    }
}
impl ContributorInsightsAction {
    pub fn as_str(&self) -> &str {
        match self {
            ContributorInsightsAction::Disable => "DISABLE",
            ContributorInsightsAction::Enable => "ENABLE",
            ContributorInsightsAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ContributorInsightsAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ContributorInsightsAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the continuous backups and point in time recovery settings on the table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousBackupsDescription {
    /// <p>
    /// <code>ContinuousBackupsStatus</code> can be one of the following states: ENABLED,
    /// DISABLED</p>
    #[serde(rename = "ContinuousBackupsStatus")]
    #[serde(default)]
    pub continuous_backups_status: std::option::Option<crate::model::ContinuousBackupsStatus>,
    /// <p>The description of the point in time recovery settings applied to the table.</p>
    #[serde(rename = "PointInTimeRecoveryDescription")]
    #[serde(default)]
    pub point_in_time_recovery_description:
        std::option::Option<crate::model::PointInTimeRecoveryDescription>,
}
impl std::fmt::Debug for ContinuousBackupsDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousBackupsDescription");
        formatter.field("continuous_backups_status", &self.continuous_backups_status);
        formatter.field(
            "point_in_time_recovery_description",
            &self.point_in_time_recovery_description,
        );
        formatter.finish()
    }
}
/// See [`ContinuousBackupsDescription`](crate::model::ContinuousBackupsDescription)
pub mod continuous_backups_description {
    /// A builder for [`ContinuousBackupsDescription`](crate::model::ContinuousBackupsDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) continuous_backups_status:
            std::option::Option<crate::model::ContinuousBackupsStatus>,
        pub(crate) point_in_time_recovery_description:
            std::option::Option<crate::model::PointInTimeRecoveryDescription>,
    }
    impl Builder {
        /// <p>
        /// <code>ContinuousBackupsStatus</code> can be one of the following states: ENABLED,
        /// DISABLED</p>
        pub fn continuous_backups_status(
            mut self,
            inp: crate::model::ContinuousBackupsStatus,
        ) -> Self {
            self.continuous_backups_status = Some(inp);
            self
        }
        pub fn set_continuous_backups_status(
            mut self,
            inp: std::option::Option<crate::model::ContinuousBackupsStatus>,
        ) -> Self {
            self.continuous_backups_status = inp;
            self
        }
        /// <p>The description of the point in time recovery settings applied to the table.</p>
        pub fn point_in_time_recovery_description(
            mut self,
            inp: crate::model::PointInTimeRecoveryDescription,
        ) -> Self {
            self.point_in_time_recovery_description = Some(inp);
            self
        }
        pub fn set_point_in_time_recovery_description(
            mut self,
            inp: std::option::Option<crate::model::PointInTimeRecoveryDescription>,
        ) -> Self {
            self.point_in_time_recovery_description = inp;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousBackupsDescription`](crate::model::ContinuousBackupsDescription)
        pub fn build(self) -> crate::model::ContinuousBackupsDescription {
            crate::model::ContinuousBackupsDescription {
                continuous_backups_status: self.continuous_backups_status,
                point_in_time_recovery_description: self.point_in_time_recovery_description,
            }
        }
    }
}
impl ContinuousBackupsDescription {
    /// Creates a new builder-style object to manufacture [`ContinuousBackupsDescription`](crate::model::ContinuousBackupsDescription)
    pub fn builder() -> crate::model::continuous_backups_description::Builder {
        crate::model::continuous_backups_description::Builder::default()
    }
}

/// <p>The description of the point in time settings applied to the table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PointInTimeRecoveryDescription {
    /// <p>The current state of point in time recovery:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ENABLING</code> - Point in time recovery is being enabled.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ENABLED</code> - Point in time recovery is enabled.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DISABLED</code> - Point in time recovery is disabled.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "PointInTimeRecoveryStatus")]
    #[serde(default)]
    pub point_in_time_recovery_status: std::option::Option<crate::model::PointInTimeRecoveryStatus>,
    /// <p>Specifies the earliest point in time you can restore your table to. You can restore your
    /// table to any point in time during the last 35 days. </p>
    #[serde(rename = "EarliestRestorableDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub earliest_restorable_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>
    /// <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
    /// </p>
    #[serde(rename = "LatestRestorableDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub latest_restorable_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for PointInTimeRecoveryDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PointInTimeRecoveryDescription");
        formatter.field(
            "point_in_time_recovery_status",
            &self.point_in_time_recovery_status,
        );
        formatter.field(
            "earliest_restorable_date_time",
            &self.earliest_restorable_date_time,
        );
        formatter.field(
            "latest_restorable_date_time",
            &self.latest_restorable_date_time,
        );
        formatter.finish()
    }
}
/// See [`PointInTimeRecoveryDescription`](crate::model::PointInTimeRecoveryDescription)
pub mod point_in_time_recovery_description {
    /// A builder for [`PointInTimeRecoveryDescription`](crate::model::PointInTimeRecoveryDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) point_in_time_recovery_status:
            std::option::Option<crate::model::PointInTimeRecoveryStatus>,
        pub(crate) earliest_restorable_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) latest_restorable_date_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The current state of point in time recovery:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ENABLING</code> - Point in time recovery is being enabled.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ENABLED</code> - Point in time recovery is enabled.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DISABLED</code> - Point in time recovery is disabled.</p>
        /// </li>
        /// </ul>
        pub fn point_in_time_recovery_status(
            mut self,
            inp: crate::model::PointInTimeRecoveryStatus,
        ) -> Self {
            self.point_in_time_recovery_status = Some(inp);
            self
        }
        pub fn set_point_in_time_recovery_status(
            mut self,
            inp: std::option::Option<crate::model::PointInTimeRecoveryStatus>,
        ) -> Self {
            self.point_in_time_recovery_status = inp;
            self
        }
        /// <p>Specifies the earliest point in time you can restore your table to. You can restore your
        /// table to any point in time during the last 35 days. </p>
        pub fn earliest_restorable_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.earliest_restorable_date_time = Some(inp);
            self
        }
        pub fn set_earliest_restorable_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.earliest_restorable_date_time = inp;
            self
        }
        /// <p>
        /// <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time.
        /// </p>
        pub fn latest_restorable_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.latest_restorable_date_time = Some(inp);
            self
        }
        pub fn set_latest_restorable_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.latest_restorable_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRecoveryDescription`](crate::model::PointInTimeRecoveryDescription)
        pub fn build(self) -> crate::model::PointInTimeRecoveryDescription {
            crate::model::PointInTimeRecoveryDescription {
                point_in_time_recovery_status: self.point_in_time_recovery_status,
                earliest_restorable_date_time: self.earliest_restorable_date_time,
                latest_restorable_date_time: self.latest_restorable_date_time,
            }
        }
    }
}
impl PointInTimeRecoveryDescription {
    /// Creates a new builder-style object to manufacture [`PointInTimeRecoveryDescription`](crate::model::PointInTimeRecoveryDescription)
    pub fn builder() -> crate::model::point_in_time_recovery_description::Builder {
        crate::model::point_in_time_recovery_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PointInTimeRecoveryStatus {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PointInTimeRecoveryStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => PointInTimeRecoveryStatus::Disabled,
            "ENABLED" => PointInTimeRecoveryStatus::Enabled,
            other => PointInTimeRecoveryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PointInTimeRecoveryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PointInTimeRecoveryStatus::from(s))
    }
}
impl PointInTimeRecoveryStatus {
    pub fn as_str(&self) -> &str {
        match self {
            PointInTimeRecoveryStatus::Disabled => "DISABLED",
            PointInTimeRecoveryStatus::Enabled => "ENABLED",
            PointInTimeRecoveryStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PointInTimeRecoveryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PointInTimeRecoveryStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ContinuousBackupsStatus {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ContinuousBackupsStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ContinuousBackupsStatus::Disabled,
            "ENABLED" => ContinuousBackupsStatus::Enabled,
            other => ContinuousBackupsStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ContinuousBackupsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ContinuousBackupsStatus::from(s))
    }
}
impl ContinuousBackupsStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ContinuousBackupsStatus::Disabled => "DISABLED",
            ContinuousBackupsStatus::Enabled => "ENABLED",
            ContinuousBackupsStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ContinuousBackupsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ContinuousBackupsStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the settings used to enable point in time recovery.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PointInTimeRecoverySpecification {
    /// <p>Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.</p>
    #[serde(rename = "PointInTimeRecoveryEnabled")]
    #[serde(default)]
    pub point_in_time_recovery_enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for PointInTimeRecoverySpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PointInTimeRecoverySpecification");
        formatter.field(
            "point_in_time_recovery_enabled",
            &self.point_in_time_recovery_enabled,
        );
        formatter.finish()
    }
}
/// See [`PointInTimeRecoverySpecification`](crate::model::PointInTimeRecoverySpecification)
pub mod point_in_time_recovery_specification {
    /// A builder for [`PointInTimeRecoverySpecification`](crate::model::PointInTimeRecoverySpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) point_in_time_recovery_enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.</p>
        pub fn point_in_time_recovery_enabled(mut self, inp: bool) -> Self {
            self.point_in_time_recovery_enabled = Some(inp);
            self
        }
        pub fn set_point_in_time_recovery_enabled(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.point_in_time_recovery_enabled = inp;
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRecoverySpecification`](crate::model::PointInTimeRecoverySpecification)
        pub fn build(self) -> crate::model::PointInTimeRecoverySpecification {
            crate::model::PointInTimeRecoverySpecification {
                point_in_time_recovery_enabled: self.point_in_time_recovery_enabled,
            }
        }
    }
}
impl PointInTimeRecoverySpecification {
    /// Creates a new builder-style object to manufacture [`PointInTimeRecoverySpecification`](crate::model::PointInTimeRecoverySpecification)
    pub fn builder() -> crate::model::point_in_time_recovery_specification::Builder {
        crate::model::point_in_time_recovery_specification::Builder::default()
    }
}

/// <p>An ordered list of errors for each item in the request which caused the transaction
/// to get cancelled. The values of the list are ordered according to the ordering of the
/// <code>TransactWriteItems</code> request parameter. If no error
/// occurred for the associated item an error with a Null code and Null message will be present.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CancellationReason {
    /// <p>Item in the request which caused the transaction to get cancelled.</p>
    #[serde(rename = "Item")]
    #[serde(default)]
    pub item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Status code for the result of the cancelled transaction.</p>
    #[serde(rename = "Code")]
    #[serde(default)]
    pub code: std::option::Option<std::string::String>,
    /// <p>Cancellation reason message description.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancellationReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancellationReason");
        formatter.field("item", &self.item);
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`CancellationReason`](crate::model::CancellationReason)
pub mod cancellation_reason {
    /// A builder for [`CancellationReason`](crate::model::CancellationReason)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item = Some(hash_map);
            self
        }
        pub fn set_item(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = inp;
            self
        }
        /// <p>Status code for the result of the cancelled transaction.</p>
        pub fn code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.code = Some(inp.into());
            self
        }
        pub fn set_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.code = inp;
            self
        }
        /// <p>Cancellation reason message description.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`CancellationReason`](crate::model::CancellationReason)
        pub fn build(self) -> crate::model::CancellationReason {
            crate::model::CancellationReason {
                item: self.item,
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl CancellationReason {
    /// Creates a new builder-style object to manufacture [`CancellationReason`](crate::model::CancellationReason)
    pub fn builder() -> crate::model::cancellation_reason::Builder {
        crate::model::cancellation_reason::Builder::default()
    }
}

/// <p>A list of requests that can perform update, put, delete, or check operations on multiple items in one or more tables atomically.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TransactWriteItem {
    /// <p>A request to perform a check item operation.</p>
    #[serde(rename = "ConditionCheck")]
    #[serde(default)]
    pub condition_check: std::option::Option<crate::model::ConditionCheck>,
    /// <p>A request to perform a <code>PutItem</code> operation.</p>
    #[serde(rename = "Put")]
    #[serde(default)]
    pub put: std::option::Option<crate::model::Put>,
    /// <p>A request to perform a <code>DeleteItem</code> operation.</p>
    #[serde(rename = "Delete")]
    #[serde(default)]
    pub delete: std::option::Option<crate::model::Delete>,
    /// <p>A request to perform an <code>UpdateItem</code> operation.</p>
    #[serde(rename = "Update")]
    #[serde(default)]
    pub update: std::option::Option<crate::model::Update>,
}
impl std::fmt::Debug for TransactWriteItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransactWriteItem");
        formatter.field("condition_check", &self.condition_check);
        formatter.field("put", &self.put);
        formatter.field("delete", &self.delete);
        formatter.field("update", &self.update);
        formatter.finish()
    }
}
/// See [`TransactWriteItem`](crate::model::TransactWriteItem)
pub mod transact_write_item {
    /// A builder for [`TransactWriteItem`](crate::model::TransactWriteItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition_check: std::option::Option<crate::model::ConditionCheck>,
        pub(crate) put: std::option::Option<crate::model::Put>,
        pub(crate) delete: std::option::Option<crate::model::Delete>,
        pub(crate) update: std::option::Option<crate::model::Update>,
    }
    impl Builder {
        /// <p>A request to perform a check item operation.</p>
        pub fn condition_check(mut self, inp: crate::model::ConditionCheck) -> Self {
            self.condition_check = Some(inp);
            self
        }
        pub fn set_condition_check(
            mut self,
            inp: std::option::Option<crate::model::ConditionCheck>,
        ) -> Self {
            self.condition_check = inp;
            self
        }
        /// <p>A request to perform a <code>PutItem</code> operation.</p>
        pub fn put(mut self, inp: crate::model::Put) -> Self {
            self.put = Some(inp);
            self
        }
        pub fn set_put(mut self, inp: std::option::Option<crate::model::Put>) -> Self {
            self.put = inp;
            self
        }
        /// <p>A request to perform a <code>DeleteItem</code> operation.</p>
        pub fn delete(mut self, inp: crate::model::Delete) -> Self {
            self.delete = Some(inp);
            self
        }
        pub fn set_delete(mut self, inp: std::option::Option<crate::model::Delete>) -> Self {
            self.delete = inp;
            self
        }
        /// <p>A request to perform an <code>UpdateItem</code> operation.</p>
        pub fn update(mut self, inp: crate::model::Update) -> Self {
            self.update = Some(inp);
            self
        }
        pub fn set_update(mut self, inp: std::option::Option<crate::model::Update>) -> Self {
            self.update = inp;
            self
        }
        /// Consumes the builder and constructs a [`TransactWriteItem`](crate::model::TransactWriteItem)
        pub fn build(self) -> crate::model::TransactWriteItem {
            crate::model::TransactWriteItem {
                condition_check: self.condition_check,
                put: self.put,
                delete: self.delete,
                update: self.update,
            }
        }
    }
}
impl TransactWriteItem {
    /// Creates a new builder-style object to manufacture [`TransactWriteItem`](crate::model::TransactWriteItem)
    pub fn builder() -> crate::model::transact_write_item::Builder {
        crate::model::transact_write_item::Builder::default()
    }
}

/// <p>Represents a request to perform an <code>UpdateItem</code> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Update {
    /// <p>The primary key of the item to be updated. Each element consists of
    /// an attribute name and a value for that attribute.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>An expression that defines one or more attributes to be updated,
    /// the action to be performed on them, and new value(s) for them.</p>
    #[serde(rename = "UpdateExpression")]
    #[serde(default)]
    pub update_expression: std::option::Option<std::string::String>,
    /// <p>Name of the table for the <code>UpdateItem</code> request.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A condition that must be satisfied in order for a conditional update to
    /// succeed.</p>
    #[serde(rename = "ConditionExpression")]
    #[serde(default)]
    pub condition_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in an expression.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>One or more values that can be substituted in an expression.</p>
    #[serde(rename = "ExpressionAttributeValues")]
    #[serde(default)]
    pub expression_attribute_values: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
    /// get the item attributes if the <code>Update</code> condition fails.
    /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
    /// values are: NONE, ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW.</p>
    #[serde(rename = "ReturnValuesOnConditionCheckFailure")]
    #[serde(default)]
    pub return_values_on_condition_check_failure:
        std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
}
impl std::fmt::Debug for Update {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Update");
        formatter.field("key", &self.key);
        formatter.field("update_expression", &self.update_expression);
        formatter.field("table_name", &self.table_name);
        formatter.field("condition_expression", &self.condition_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.field(
            "expression_attribute_values",
            &self.expression_attribute_values,
        );
        formatter.field(
            "return_values_on_condition_check_failure",
            &self.return_values_on_condition_check_failure,
        );
        formatter.finish()
    }
}
/// See [`Update`](crate::model::Update)
pub mod update {
    /// A builder for [`Update`](crate::model::Update)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) update_expression: std::option::Option<std::string::String>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) condition_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expression_attribute_values: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) return_values_on_condition_check_failure:
            std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
    }
    impl Builder {
        pub fn key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.key = Some(hash_map);
            self
        }
        pub fn set_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = inp;
            self
        }
        /// <p>An expression that defines one or more attributes to be updated,
        /// the action to be performed on them, and new value(s) for them.</p>
        pub fn update_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.update_expression = Some(inp.into());
            self
        }
        pub fn set_update_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_expression = inp;
            self
        }
        /// <p>Name of the table for the <code>UpdateItem</code> request.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A condition that must be satisfied in order for a conditional update to
        /// succeed.</p>
        pub fn condition_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.condition_expression = Some(inp.into());
            self
        }
        pub fn set_condition_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        pub fn expression_attribute_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_values = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_values(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = inp;
            self
        }
        /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
        /// get the item attributes if the <code>Update</code> condition fails.
        /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
        /// values are: NONE, ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW.</p>
        pub fn return_values_on_condition_check_failure(
            mut self,
            inp: crate::model::ReturnValuesOnConditionCheckFailure,
        ) -> Self {
            self.return_values_on_condition_check_failure = Some(inp);
            self
        }
        pub fn set_return_values_on_condition_check_failure(
            mut self,
            inp: std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
        ) -> Self {
            self.return_values_on_condition_check_failure = inp;
            self
        }
        /// Consumes the builder and constructs a [`Update`](crate::model::Update)
        pub fn build(self) -> crate::model::Update {
            crate::model::Update {
                key: self.key,
                update_expression: self.update_expression,
                table_name: self.table_name,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
                return_values_on_condition_check_failure: self
                    .return_values_on_condition_check_failure,
            }
        }
    }
}
impl Update {
    /// Creates a new builder-style object to manufacture [`Update`](crate::model::Update)
    pub fn builder() -> crate::model::update::Builder {
        crate::model::update::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReturnValuesOnConditionCheckFailure {
    AllOld,
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ReturnValuesOnConditionCheckFailure {
    fn from(s: &str) -> Self {
        match s {
            "ALL_OLD" => ReturnValuesOnConditionCheckFailure::AllOld,
            "NONE" => ReturnValuesOnConditionCheckFailure::None,
            other => ReturnValuesOnConditionCheckFailure::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ReturnValuesOnConditionCheckFailure {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ReturnValuesOnConditionCheckFailure::from(s))
    }
}
impl ReturnValuesOnConditionCheckFailure {
    pub fn as_str(&self) -> &str {
        match self {
            ReturnValuesOnConditionCheckFailure::AllOld => "ALL_OLD",
            ReturnValuesOnConditionCheckFailure::None => "NONE",
            ReturnValuesOnConditionCheckFailure::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ReturnValuesOnConditionCheckFailure {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ReturnValuesOnConditionCheckFailure {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents a request to perform a <code>DeleteItem</code> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Delete {
    /// <p>The primary key of the item to be deleted. Each element consists of an
    /// attribute name and a value for that attribute.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Name of the table in which the item to be deleted resides.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A condition that must be satisfied in order for a conditional delete to succeed.</p>
    #[serde(rename = "ConditionExpression")]
    #[serde(default)]
    pub condition_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in an expression.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>One or more values that can be substituted in an expression.</p>
    #[serde(rename = "ExpressionAttributeValues")]
    #[serde(default)]
    pub expression_attribute_values: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
    /// get the item attributes if the <code>Delete</code> condition fails.
    /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
    /// values are: NONE and ALL_OLD.</p>
    #[serde(rename = "ReturnValuesOnConditionCheckFailure")]
    #[serde(default)]
    pub return_values_on_condition_check_failure:
        std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
}
impl std::fmt::Debug for Delete {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Delete");
        formatter.field("key", &self.key);
        formatter.field("table_name", &self.table_name);
        formatter.field("condition_expression", &self.condition_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.field(
            "expression_attribute_values",
            &self.expression_attribute_values,
        );
        formatter.field(
            "return_values_on_condition_check_failure",
            &self.return_values_on_condition_check_failure,
        );
        formatter.finish()
    }
}
/// See [`Delete`](crate::model::Delete)
pub mod delete {
    /// A builder for [`Delete`](crate::model::Delete)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) condition_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expression_attribute_values: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) return_values_on_condition_check_failure:
            std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
    }
    impl Builder {
        pub fn key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.key = Some(hash_map);
            self
        }
        pub fn set_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = inp;
            self
        }
        /// <p>Name of the table in which the item to be deleted resides.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A condition that must be satisfied in order for a conditional delete to succeed.</p>
        pub fn condition_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.condition_expression = Some(inp.into());
            self
        }
        pub fn set_condition_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        pub fn expression_attribute_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_values = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_values(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = inp;
            self
        }
        /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
        /// get the item attributes if the <code>Delete</code> condition fails.
        /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
        /// values are: NONE and ALL_OLD.</p>
        pub fn return_values_on_condition_check_failure(
            mut self,
            inp: crate::model::ReturnValuesOnConditionCheckFailure,
        ) -> Self {
            self.return_values_on_condition_check_failure = Some(inp);
            self
        }
        pub fn set_return_values_on_condition_check_failure(
            mut self,
            inp: std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
        ) -> Self {
            self.return_values_on_condition_check_failure = inp;
            self
        }
        /// Consumes the builder and constructs a [`Delete`](crate::model::Delete)
        pub fn build(self) -> crate::model::Delete {
            crate::model::Delete {
                key: self.key,
                table_name: self.table_name,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
                return_values_on_condition_check_failure: self
                    .return_values_on_condition_check_failure,
            }
        }
    }
}
impl Delete {
    /// Creates a new builder-style object to manufacture [`Delete`](crate::model::Delete)
    pub fn builder() -> crate::model::delete::Builder {
        crate::model::delete::Builder::default()
    }
}

/// <p>Represents a request to perform a <code>PutItem</code> operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Put {
    /// <p>A map of attribute name to attribute values, representing the primary key
    /// of the item to be written by <code>PutItem</code>. All of the table's primary key
    /// attributes must be specified, and their data types must match those of the table's
    /// key schema. If any attributes are present in the item that are part of an index
    /// key schema for the table, their types must match the index key schema. </p>
    #[serde(rename = "Item")]
    #[serde(default)]
    pub item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Name of the table in which to write the item.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A condition that must be satisfied in order for a conditional update to succeed.</p>
    #[serde(rename = "ConditionExpression")]
    #[serde(default)]
    pub condition_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in an expression.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>One or more values that can be substituted in an expression.</p>
    #[serde(rename = "ExpressionAttributeValues")]
    #[serde(default)]
    pub expression_attribute_values: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
    /// get the item attributes if the <code>Put</code> condition fails.
    /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
    /// values are: NONE and ALL_OLD.</p>
    #[serde(rename = "ReturnValuesOnConditionCheckFailure")]
    #[serde(default)]
    pub return_values_on_condition_check_failure:
        std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
}
impl std::fmt::Debug for Put {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Put");
        formatter.field("item", &self.item);
        formatter.field("table_name", &self.table_name);
        formatter.field("condition_expression", &self.condition_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.field(
            "expression_attribute_values",
            &self.expression_attribute_values,
        );
        formatter.field(
            "return_values_on_condition_check_failure",
            &self.return_values_on_condition_check_failure,
        );
        formatter.finish()
    }
}
/// See [`Put`](crate::model::Put)
pub mod put {
    /// A builder for [`Put`](crate::model::Put)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) condition_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expression_attribute_values: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) return_values_on_condition_check_failure:
            std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
    }
    impl Builder {
        pub fn item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item = Some(hash_map);
            self
        }
        pub fn set_item(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = inp;
            self
        }
        /// <p>Name of the table in which to write the item.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A condition that must be satisfied in order for a conditional update to succeed.</p>
        pub fn condition_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.condition_expression = Some(inp.into());
            self
        }
        pub fn set_condition_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        pub fn expression_attribute_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_values = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_values(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = inp;
            self
        }
        /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
        /// get the item attributes if the <code>Put</code> condition fails.
        /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
        /// values are: NONE and ALL_OLD.</p>
        pub fn return_values_on_condition_check_failure(
            mut self,
            inp: crate::model::ReturnValuesOnConditionCheckFailure,
        ) -> Self {
            self.return_values_on_condition_check_failure = Some(inp);
            self
        }
        pub fn set_return_values_on_condition_check_failure(
            mut self,
            inp: std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
        ) -> Self {
            self.return_values_on_condition_check_failure = inp;
            self
        }
        /// Consumes the builder and constructs a [`Put`](crate::model::Put)
        pub fn build(self) -> crate::model::Put {
            crate::model::Put {
                item: self.item,
                table_name: self.table_name,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
                return_values_on_condition_check_failure: self
                    .return_values_on_condition_check_failure,
            }
        }
    }
}
impl Put {
    /// Creates a new builder-style object to manufacture [`Put`](crate::model::Put)
    pub fn builder() -> crate::model::put::Builder {
        crate::model::put::Builder::default()
    }
}

/// <p>Represents a request to perform a check that an item exists or to check the condition of
/// specific attributes of the item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionCheck {
    /// <p>The primary key of the item to be checked. Each element consists of an
    /// attribute name and a value for that attribute.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Name of the table for the check item request.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A condition that must be satisfied in order for a conditional update to succeed.</p>
    #[serde(rename = "ConditionExpression")]
    #[serde(default)]
    pub condition_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in an expression.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>One or more values that can be substituted in an expression.</p>
    #[serde(rename = "ExpressionAttributeValues")]
    #[serde(default)]
    pub expression_attribute_values: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
    /// get the item attributes if the <code>ConditionCheck</code> condition fails.
    /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
    /// values are: NONE and ALL_OLD.</p>
    #[serde(rename = "ReturnValuesOnConditionCheckFailure")]
    #[serde(default)]
    pub return_values_on_condition_check_failure:
        std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
}
impl std::fmt::Debug for ConditionCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionCheck");
        formatter.field("key", &self.key);
        formatter.field("table_name", &self.table_name);
        formatter.field("condition_expression", &self.condition_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.field(
            "expression_attribute_values",
            &self.expression_attribute_values,
        );
        formatter.field(
            "return_values_on_condition_check_failure",
            &self.return_values_on_condition_check_failure,
        );
        formatter.finish()
    }
}
/// See [`ConditionCheck`](crate::model::ConditionCheck)
pub mod condition_check {
    /// A builder for [`ConditionCheck`](crate::model::ConditionCheck)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) condition_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expression_attribute_values: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) return_values_on_condition_check_failure:
            std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
    }
    impl Builder {
        pub fn key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.key = Some(hash_map);
            self
        }
        pub fn set_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = inp;
            self
        }
        /// <p>Name of the table for the check item request.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A condition that must be satisfied in order for a conditional update to succeed.</p>
        pub fn condition_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.condition_expression = Some(inp.into());
            self
        }
        pub fn set_condition_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.condition_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        pub fn expression_attribute_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_values = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_values(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = inp;
            self
        }
        /// <p>Use <code>ReturnValuesOnConditionCheckFailure</code> to
        /// get the item attributes if the <code>ConditionCheck</code> condition fails.
        /// For <code>ReturnValuesOnConditionCheckFailure</code>, the valid
        /// values are: NONE and ALL_OLD.</p>
        pub fn return_values_on_condition_check_failure(
            mut self,
            inp: crate::model::ReturnValuesOnConditionCheckFailure,
        ) -> Self {
            self.return_values_on_condition_check_failure = Some(inp);
            self
        }
        pub fn set_return_values_on_condition_check_failure(
            mut self,
            inp: std::option::Option<crate::model::ReturnValuesOnConditionCheckFailure>,
        ) -> Self {
            self.return_values_on_condition_check_failure = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConditionCheck`](crate::model::ConditionCheck)
        pub fn build(self) -> crate::model::ConditionCheck {
            crate::model::ConditionCheck {
                key: self.key,
                table_name: self.table_name,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
                return_values_on_condition_check_failure: self
                    .return_values_on_condition_check_failure,
            }
        }
    }
}
impl ConditionCheck {
    /// Creates a new builder-style object to manufacture [`ConditionCheck`](crate::model::ConditionCheck)
    pub fn builder() -> crate::model::condition_check::Builder {
        crate::model::condition_check::Builder::default()
    }
}

/// <p>Details for the requested item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemResponse {
    /// <p>Map of attribute data consisting of the data type and attribute value.</p>
    #[serde(rename = "Item")]
    #[serde(default)]
    pub item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
}
impl std::fmt::Debug for ItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemResponse");
        formatter.field("item", &self.item);
        formatter.finish()
    }
}
/// See [`ItemResponse`](crate::model::ItemResponse)
pub mod item_response {
    /// A builder for [`ItemResponse`](crate::model::ItemResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
    }
    impl Builder {
        pub fn item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item = Some(hash_map);
            self
        }
        pub fn set_item(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = inp;
            self
        }
        /// Consumes the builder and constructs a [`ItemResponse`](crate::model::ItemResponse)
        pub fn build(self) -> crate::model::ItemResponse {
            crate::model::ItemResponse { item: self.item }
        }
    }
}
impl ItemResponse {
    /// Creates a new builder-style object to manufacture [`ItemResponse`](crate::model::ItemResponse)
    pub fn builder() -> crate::model::item_response::Builder {
        crate::model::item_response::Builder::default()
    }
}

/// <p>Specifies an item to be retrieved as part of the transaction.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TransactGetItem {
    /// <p>Contains the primary key that identifies the item to get, together
    /// with the name of the table that contains the item, and optionally
    /// the specific attributes of the item to retrieve.</p>
    #[serde(rename = "Get")]
    #[serde(default)]
    pub get: std::option::Option<crate::model::Get>,
}
impl std::fmt::Debug for TransactGetItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransactGetItem");
        formatter.field("get", &self.get);
        formatter.finish()
    }
}
/// See [`TransactGetItem`](crate::model::TransactGetItem)
pub mod transact_get_item {
    /// A builder for [`TransactGetItem`](crate::model::TransactGetItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) get: std::option::Option<crate::model::Get>,
    }
    impl Builder {
        /// <p>Contains the primary key that identifies the item to get, together
        /// with the name of the table that contains the item, and optionally
        /// the specific attributes of the item to retrieve.</p>
        pub fn get(mut self, inp: crate::model::Get) -> Self {
            self.get = Some(inp);
            self
        }
        pub fn set_get(mut self, inp: std::option::Option<crate::model::Get>) -> Self {
            self.get = inp;
            self
        }
        /// Consumes the builder and constructs a [`TransactGetItem`](crate::model::TransactGetItem)
        pub fn build(self) -> crate::model::TransactGetItem {
            crate::model::TransactGetItem { get: self.get }
        }
    }
}
impl TransactGetItem {
    /// Creates a new builder-style object to manufacture [`TransactGetItem`](crate::model::TransactGetItem)
    pub fn builder() -> crate::model::transact_get_item::Builder {
        crate::model::transact_get_item::Builder::default()
    }
}

/// <p>Specifies an item and related attribute values to retrieve in a
/// <code>TransactGetItem</code> object.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Get {
    /// <p>A map of attribute names to <code>AttributeValue</code> objects that
    /// specifies the primary key of the item to retrieve.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
    /// <p>The name of the table from which to retrieve the specified item.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>A string that identifies one or more attributes of the specified item
    /// to retrieve from the table.  The attributes in the expression must be
    /// separated by commas. If no attribute names are specified, then all
    /// attributes of the specified item are returned. If any of the requested
    /// attributes are not found, they do not appear in the result.</p>
    #[serde(rename = "ProjectionExpression")]
    #[serde(default)]
    pub projection_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in the
    /// ProjectionExpression parameter.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for Get {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Get");
        formatter.field("key", &self.key);
        formatter.field("table_name", &self.table_name);
        formatter.field("projection_expression", &self.projection_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.finish()
    }
}
/// See [`Get`](crate::model::Get)
pub mod get {
    /// A builder for [`Get`](crate::model::Get)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) projection_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        pub fn key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.key = Some(hash_map);
            self
        }
        pub fn set_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = inp;
            self
        }
        /// <p>The name of the table from which to retrieve the specified item.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>A string that identifies one or more attributes of the specified item
        /// to retrieve from the table.  The attributes in the expression must be
        /// separated by commas. If no attribute names are specified, then all
        /// attributes of the specified item are returned. If any of the requested
        /// attributes are not found, they do not appear in the result.</p>
        pub fn projection_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.projection_expression = Some(inp.into());
            self
        }
        pub fn set_projection_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.projection_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        /// Consumes the builder and constructs a [`Get`](crate::model::Get)
        pub fn build(self) -> crate::model::Get {
            crate::model::Get {
                key: self.key,
                table_name: self.table_name,
                projection_expression: self.projection_expression,
                expression_attribute_names: self.expression_attribute_names,
            }
        }
    }
}
impl Get {
    /// Creates a new builder-style object to manufacture [`Get`](crate::model::Get)
    pub fn builder() -> crate::model::get::Builder {
        crate::model::get::Builder::default()
    }
}

/// <p>Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single DynamoDB table.
/// </p>
/// <p> AWS-assigned tag names and values are automatically assigned the <code>aws:</code>
/// prefix, which the user cannot assign. AWS-assigned tag names do not count towards the
/// tag limit of 50. User-assigned tag names have the prefix <code>user:</code> in the Cost
/// Allocation Report. You cannot backdate the application of a tag. </p>
/// <p>For an overview on tagging DynamoDB resources, see
/// <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a>
/// in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The key of the tag. Tag keys are case sensitive. Each DynamoDB table can only have up to
    /// one tag with the same key. If you try to add an existing tag (same key), the existing
    /// tag value will be updated to the new value. </p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag. Tag values are case-sensitive and can be null.</p>
    #[serde(rename = "Value")]
    #[serde(default)]
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag. Tag keys are case sensitive. Each DynamoDB table can only have up to
        /// one tag with the same key. If you try to add an existing tag (same key), the existing
        /// tag value will be updated to the new value. </p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key = Some(inp.into());
            self
        }
        pub fn set_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key = inp;
            self
        }
        /// <p>The value of the tag. Tag values are case-sensitive and can be null.</p>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.value = inp;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Represents the selection criteria for a <code>Query</code> or <code>Scan</code> operation:</p>
/// <ul>
/// <li>
/// <p>For a <code>Query</code> operation, <code>Condition</code> is used for specifying the
/// <code>KeyConditions</code> to use when querying a table or an index. For <code>KeyConditions</code>,
/// only the following comparison operators are supported:</p>
/// <p>
/// <code>EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN</code>
/// </p>
/// <p>
/// <code>Condition</code> is also used in a <code>QueryFilter</code>, which evaluates the query results
/// and returns only the desired values.</p>
/// </li>
/// <li>
/// <p>For a <code>Scan</code> operation, <code>Condition</code> is used in a <code>ScanFilter</code>, which
/// evaluates the scan results and returns only the desired values.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Condition {
    /// <p>One or more values to evaluate against the supplied attribute. The number of values in the
    /// list depends on the <code>ComparisonOperator</code> being used.</p>
    /// <p>For type Number, value comparisons are numeric.</p>
    /// <p>String value comparisons for greater than, equals, or less than are based on ASCII character
    /// code values. For example, <code>a</code> is greater than <code>A</code>, and <code>a</code>
    /// is greater than <code>B</code>. For a list of code values, see <a href="http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters">http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters</a>.</p>
    /// <p>For Binary, DynamoDB treats each byte of the binary data as unsigned when it compares binary values.</p>
    #[serde(rename = "AttributeValueList")]
    #[serde(default)]
    pub attribute_value_list: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
    /// <p>A comparator for evaluating attributes. For example, equals, greater than, less than, etc.</p>
    /// <p>The following comparison operators are available:</p>
    /// <p>
    /// <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN | BETWEEN</code>
    /// </p>
    /// <p>The following are descriptions of each comparison operator.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types, including lists and maps.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NE</code> : Not equal. <code>NE</code> is supported for all data types, including lists and maps.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
    /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LE</code> : Less than or equal. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>LT</code> : Less than. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GE</code> : Greater than or equal. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GT</code> : Greater than. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
    /// type than the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported for all data types, including lists and maps.</p>
    /// <note>
    /// <p>This operator tests for the existence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This result is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NOT_NULL</code> comparison operator.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported for all data types, including lists and maps.</p>
    /// <note>
    /// <p>This operator tests for the nonexistence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NULL</code>, the result is a Boolean <code>false</code>. This is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NULL</code> comparison operator.</p>
    /// </note>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If the target attribute of the comparison is of type String, then
    /// the operator checks for a substring match. If the target attribute of the comparison is
    /// of type Binary, then the operator looks for a subsequence of the target that matches the input.
    /// If the target attribute of the comparison is a set ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
    /// operator evaluates to true if it finds an exact match with any member of the set.</p>
    /// <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a value in
    /// a set.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
    /// Number, or Binary (not a set type). If the target attribute of the comparison is a String, then
    /// the operator checks for the absence of a substring match. If the target attribute of the
    /// comparison is Binary, then the operator checks for the absence of a subsequence of the
    /// target that matches the input. If the target attribute of the comparison is a set ("<code>SS</code>",
    /// "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to true if it <i>does not</i> find an exact match with any member of the set.</p>
    /// <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BEGINS_WITH</code> : Checks for a prefix. </p>
    /// <p>
    /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String or
    /// Binary (not a Number or a set type). The target attribute of the comparison must be of type String or
    /// Binary (not a Number or a set type).</p>
    /// <p></p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN</code> : Checks for matching elements in a list.</p>
    /// <p>
    /// <code>AttributeValueList</code> can contain one or more <code>AttributeValue</code>
    /// elements of type String, Number, or Binary. These attributes are compared against an
    /// existing attribute of an item. If any elements of the input are equal to the item
    /// attribute, the expression evaluates to true.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BETWEEN</code> : Greater than or equal to the first value, and less than or equal
    /// to the second value. </p>
    /// <p>
    /// <code>AttributeValueList</code> must contain two <code>AttributeValue</code> elements of the same
    /// type, either String, Number, or Binary (not a set type). A target attribute matches if the
    /// target value is greater than, or equal to, the first element and less than, or equal to,
    /// the second element. If an item contains an <code>AttributeValue</code> element of a different type than
    /// the one provided in the request, the value does not match. For example,
    /// <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
    /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For usage examples of <code>AttributeValueList</code> and <code>ComparisonOperator</code>, see
    /// <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy Conditional Parameters</a>
    /// in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ComparisonOperator")]
    #[serde(default)]
    pub comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
}
impl std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Condition");
        formatter.field("attribute_value_list", &self.attribute_value_list);
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.finish()
    }
}
/// See [`Condition`](crate::model::Condition)
pub mod condition {
    /// A builder for [`Condition`](crate::model::Condition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_value_list:
            std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        pub(crate) comparison_operator: std::option::Option<crate::model::ComparisonOperator>,
    }
    impl Builder {
        pub fn attribute_value_list(
            mut self,
            inp: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut v = self.attribute_value_list.unwrap_or_default();
            v.push(inp.into());
            self.attribute_value_list = Some(v);
            self
        }
        pub fn set_attribute_value_list(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        ) -> Self {
            self.attribute_value_list = inp;
            self
        }
        /// <p>A comparator for evaluating attributes. For example, equals, greater than, less than, etc.</p>
        /// <p>The following comparison operators are available:</p>
        /// <p>
        /// <code>EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH | IN | BETWEEN</code>
        /// </p>
        /// <p>The following are descriptions of each comparison operator.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>EQ</code> : Equal. <code>EQ</code> is supported for all data types, including lists and maps.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NE</code> : Not equal. <code>NE</code> is supported for all data types, including lists and maps.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
        /// Number, Binary, String Set, Number Set, or Binary Set. If an item contains an <code>AttributeValue</code> of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not equal <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LE</code> : Less than or equal. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LT</code> : Less than. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GE</code> : Greater than or equal. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GT</code> : Greater than. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If an item contains an <code>AttributeValue</code> element of a different
        /// type than the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not equal <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>.</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_NULL</code> : The attribute exists. <code>NOT_NULL</code> is supported for all data types, including lists and maps.</p>
        /// <note>
        /// <p>This operator tests for the existence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NOT_NULL</code>, the result is a Boolean <code>true</code>. This result is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NOT_NULL</code> comparison operator.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NULL</code> : The attribute does not exist. <code>NULL</code> is supported for all data types, including lists and maps.</p>
        /// <note>
        /// <p>This operator tests for the nonexistence of an attribute, not its data type.  If the data type of attribute "<code>a</code>" is null, and you evaluate it using <code>NULL</code>, the result is a Boolean <code>false</code>. This is because the attribute "<code>a</code>" exists; its data type is not relevant to the <code>NULL</code> comparison operator.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CONTAINS</code> : Checks for a subsequence, or value in a set.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If the target attribute of the comparison is of type String, then
        /// the operator checks for a substring match. If the target attribute of the comparison is
        /// of type Binary, then the operator looks for a subsequence of the target that matches the input.
        /// If the target attribute of the comparison is a set ("<code>SS</code>", "<code>NS</code>", or "<code>BS</code>"), then the
        /// operator evaluates to true if it finds an exact match with any member of the set.</p>
        /// <p>CONTAINS is supported for lists: When evaluating "<code>a CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CONTAINS</code> : Checks for absence of a subsequence, or absence of a value in
        /// a set.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> element of type String,
        /// Number, or Binary (not a set type). If the target attribute of the comparison is a String, then
        /// the operator checks for the absence of a substring match. If the target attribute of the
        /// comparison is Binary, then the operator checks for the absence of a subsequence of the
        /// target that matches the input. If the target attribute of the comparison is a set ("<code>SS</code>",
        /// "<code>NS</code>", or "<code>BS</code>"), then the operator evaluates to true if it <i>does not</i> find an exact match with any member of the set.</p>
        /// <p>NOT_CONTAINS is supported for lists: When evaluating "<code>a NOT CONTAINS b</code>", "<code>a</code>" can be a list; however, "<code>b</code>" cannot be a set, a map, or a list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BEGINS_WITH</code> : Checks for a prefix. </p>
        /// <p>
        /// <code>AttributeValueList</code> can contain only one <code>AttributeValue</code> of type String or
        /// Binary (not a Number or a set type). The target attribute of the comparison must be of type String or
        /// Binary (not a Number or a set type).</p>
        /// <p></p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN</code> : Checks for matching elements in a list.</p>
        /// <p>
        /// <code>AttributeValueList</code> can contain one or more <code>AttributeValue</code>
        /// elements of type String, Number, or Binary. These attributes are compared against an
        /// existing attribute of an item. If any elements of the input are equal to the item
        /// attribute, the expression evaluates to true.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>BETWEEN</code> : Greater than or equal to the first value, and less than or equal
        /// to the second value. </p>
        /// <p>
        /// <code>AttributeValueList</code> must contain two <code>AttributeValue</code> elements of the same
        /// type, either String, Number, or Binary (not a set type). A target attribute matches if the
        /// target value is greater than, or equal to, the first element and less than, or equal to,
        /// the second element. If an item contains an <code>AttributeValue</code> element of a different type than
        /// the one provided in the request, the value does not match. For example,
        /// <code>{"S":"6"}</code> does not compare to <code>{"N":"6"}</code>. Also,
        /// <code>{"N":"6"}</code> does not compare to <code>{"NS":["6", "2", "1"]}</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For usage examples of <code>AttributeValueList</code> and <code>ComparisonOperator</code>, see
        /// <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy Conditional Parameters</a>
        /// in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn comparison_operator(mut self, inp: crate::model::ComparisonOperator) -> Self {
            self.comparison_operator = Some(inp);
            self
        }
        pub fn set_comparison_operator(
            mut self,
            inp: std::option::Option<crate::model::ComparisonOperator>,
        ) -> Self {
            self.comparison_operator = inp;
            self
        }
        /// Consumes the builder and constructs a [`Condition`](crate::model::Condition)
        pub fn build(self) -> crate::model::Condition {
            crate::model::Condition {
                attribute_value_list: self.attribute_value_list,
                comparison_operator: self.comparison_operator,
            }
        }
    }
}
impl Condition {
    /// Creates a new builder-style object to manufacture [`Condition`](crate::model::Condition)
    pub fn builder() -> crate::model::condition::Builder {
        crate::model::condition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Select {
    AllAttributes,
    AllProjectedAttributes,
    Count,
    SpecificAttributes,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Select {
    fn from(s: &str) -> Self {
        match s {
            "ALL_ATTRIBUTES" => Select::AllAttributes,
            "ALL_PROJECTED_ATTRIBUTES" => Select::AllProjectedAttributes,
            "COUNT" => Select::Count,
            "SPECIFIC_ATTRIBUTES" => Select::SpecificAttributes,
            other => Select::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Select {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Select::from(s))
    }
}
impl Select {
    pub fn as_str(&self) -> &str {
        match self {
            Select::AllAttributes => "ALL_ATTRIBUTES",
            Select::AllProjectedAttributes => "ALL_PROJECTED_ATTRIBUTES",
            Select::Count => "COUNT",
            Select::SpecificAttributes => "SPECIFIC_ATTRIBUTES",
            Select::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Select {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Select {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the properties of a local secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalSecondaryIndex {
    /// <p>The name of the local secondary index. The name must be unique among all other indexes on this table.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into the local
    /// secondary index. These are in addition to the primary key attributes and index key
    /// attributes, which are automatically projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
}
impl std::fmt::Debug for LocalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalSecondaryIndex");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.finish()
    }
}
/// See [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex)
pub mod local_secondary_index {
    /// A builder for [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
    }
    impl Builder {
        /// <p>The name of the local secondary index. The name must be unique among all other indexes on this table.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into the local
        /// secondary index. These are in addition to the primary key attributes and index key
        /// attributes, which are automatically projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// Consumes the builder and constructs a [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex)
        pub fn build(self) -> crate::model::LocalSecondaryIndex {
            crate::model::LocalSecondaryIndex {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
            }
        }
    }
}
impl LocalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex)
    pub fn builder() -> crate::model::local_secondary_index::Builder {
        crate::model::local_secondary_index::Builder::default()
    }
}

/// <p>Represents the properties of a global secondary index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalSecondaryIndex {
    /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into the global
    /// secondary index. These are in addition to the primary key attributes and index key
    /// attributes, which are automatically projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
    /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
    /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
}
impl std::fmt::Debug for GlobalSecondaryIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalSecondaryIndex");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.finish()
    }
}
/// See [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex)
pub mod global_secondary_index {
    /// A builder for [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    }
    impl Builder {
        /// <p>The name of the global secondary index. The name must be unique among all other indexes on this table.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into the global
        /// secondary index. These are in addition to the primary key attributes and index key
        /// attributes, which are automatically projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// <p>Represents the provisioned throughput settings for the specified global secondary index.</p>
        /// <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn provisioned_throughput(mut self, inp: crate::model::ProvisionedThroughput) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex)
        pub fn build(self) -> crate::model::GlobalSecondaryIndex {
            crate::model::GlobalSecondaryIndex {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
                provisioned_throughput: self.provisioned_throughput,
            }
        }
    }
}
impl GlobalSecondaryIndex {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex)
    pub fn builder() -> crate::model::global_secondary_index::Builder {
        crate::model::global_secondary_index::Builder::default()
    }
}

/// <p>Represents the properties of a global table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalTable {
    /// <p>The global table name.</p>
    #[serde(rename = "GlobalTableName")]
    #[serde(default)]
    pub global_table_name: std::option::Option<std::string::String>,
    /// <p>The Regions where the global table has replicas.</p>
    #[serde(rename = "ReplicationGroup")]
    #[serde(default)]
    pub replication_group: std::option::Option<std::vec::Vec<crate::model::Replica>>,
}
impl std::fmt::Debug for GlobalTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalTable");
        formatter.field("global_table_name", &self.global_table_name);
        formatter.field("replication_group", &self.replication_group);
        formatter.finish()
    }
}
/// See [`GlobalTable`](crate::model::GlobalTable)
pub mod global_table {
    /// A builder for [`GlobalTable`](crate::model::GlobalTable)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_table_name: std::option::Option<std::string::String>,
        pub(crate) replication_group: std::option::Option<std::vec::Vec<crate::model::Replica>>,
    }
    impl Builder {
        /// <p>The global table name.</p>
        pub fn global_table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.global_table_name = Some(inp.into());
            self
        }
        pub fn set_global_table_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_table_name = inp;
            self
        }
        pub fn replication_group(mut self, inp: impl Into<crate::model::Replica>) -> Self {
            let mut v = self.replication_group.unwrap_or_default();
            v.push(inp.into());
            self.replication_group = Some(v);
            self
        }
        pub fn set_replication_group(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Replica>>,
        ) -> Self {
            self.replication_group = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTable`](crate::model::GlobalTable)
        pub fn build(self) -> crate::model::GlobalTable {
            crate::model::GlobalTable {
                global_table_name: self.global_table_name,
                replication_group: self.replication_group,
            }
        }
    }
}
impl GlobalTable {
    /// Creates a new builder-style object to manufacture [`GlobalTable`](crate::model::GlobalTable)
    pub fn builder() -> crate::model::global_table::Builder {
        crate::model::global_table::Builder::default()
    }
}

/// <p>Represents the properties of a replica.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Replica {
    /// <p>The Region where the replica needs to be created.</p>
    #[serde(rename = "RegionName")]
    #[serde(default)]
    pub region_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Replica {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Replica");
        formatter.field("region_name", &self.region_name);
        formatter.finish()
    }
}
/// See [`Replica`](crate::model::Replica)
pub mod replica {
    /// A builder for [`Replica`](crate::model::Replica)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Region where the replica needs to be created.</p>
        pub fn region_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region_name = Some(inp.into());
            self
        }
        pub fn set_region_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`Replica`](crate::model::Replica)
        pub fn build(self) -> crate::model::Replica {
            crate::model::Replica {
                region_name: self.region_name,
            }
        }
    }
}
impl Replica {
    /// Creates a new builder-style object to manufacture [`Replica`](crate::model::Replica)
    pub fn builder() -> crate::model::replica::Builder {
        crate::model::replica::Builder::default()
    }
}

/// <p>Summary information about an export task.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportSummary {
    /// <p>The Amazon Resource Name (ARN) of the export.</p>
    #[serde(rename = "ExportArn")]
    #[serde(default)]
    pub export_arn: std::option::Option<std::string::String>,
    /// <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or FAILED.</p>
    #[serde(rename = "ExportStatus")]
    #[serde(default)]
    pub export_status: std::option::Option<crate::model::ExportStatus>,
}
impl std::fmt::Debug for ExportSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportSummary");
        formatter.field("export_arn", &self.export_arn);
        formatter.field("export_status", &self.export_status);
        formatter.finish()
    }
}
/// See [`ExportSummary`](crate::model::ExportSummary)
pub mod export_summary {
    /// A builder for [`ExportSummary`](crate::model::ExportSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_arn: std::option::Option<std::string::String>,
        pub(crate) export_status: std::option::Option<crate::model::ExportStatus>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the export.</p>
        pub fn export_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.export_arn = Some(inp.into());
            self
        }
        pub fn set_export_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.export_arn = inp;
            self
        }
        /// <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or FAILED.</p>
        pub fn export_status(mut self, inp: crate::model::ExportStatus) -> Self {
            self.export_status = Some(inp);
            self
        }
        pub fn set_export_status(
            mut self,
            inp: std::option::Option<crate::model::ExportStatus>,
        ) -> Self {
            self.export_status = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExportSummary`](crate::model::ExportSummary)
        pub fn build(self) -> crate::model::ExportSummary {
            crate::model::ExportSummary {
                export_arn: self.export_arn,
                export_status: self.export_status,
            }
        }
    }
}
impl ExportSummary {
    /// Creates a new builder-style object to manufacture [`ExportSummary`](crate::model::ExportSummary)
    pub fn builder() -> crate::model::export_summary::Builder {
        crate::model::export_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportStatus {
    Completed,
    Failed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExportStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ExportStatus::Completed,
            "FAILED" => ExportStatus::Failed,
            "IN_PROGRESS" => ExportStatus::InProgress,
            other => ExportStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExportStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ExportStatus::from(s))
    }
}
impl ExportStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ExportStatus::Completed => "COMPLETED",
            ExportStatus::Failed => "FAILED",
            ExportStatus::InProgress => "IN_PROGRESS",
            ExportStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ExportStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ExportStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents a Contributor Insights summary entry.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ContributorInsightsSummary {
    /// <p>Name of the table associated with the summary.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>Name of the index associated with the summary, if any.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>Describes the current status for contributor insights for the given table and index, if applicable.</p>
    #[serde(rename = "ContributorInsightsStatus")]
    #[serde(default)]
    pub contributor_insights_status: std::option::Option<crate::model::ContributorInsightsStatus>,
}
impl std::fmt::Debug for ContributorInsightsSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContributorInsightsSummary");
        formatter.field("table_name", &self.table_name);
        formatter.field("index_name", &self.index_name);
        formatter.field(
            "contributor_insights_status",
            &self.contributor_insights_status,
        );
        formatter.finish()
    }
}
/// See [`ContributorInsightsSummary`](crate::model::ContributorInsightsSummary)
pub mod contributor_insights_summary {
    /// A builder for [`ContributorInsightsSummary`](crate::model::ContributorInsightsSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) contributor_insights_status:
            std::option::Option<crate::model::ContributorInsightsStatus>,
    }
    impl Builder {
        /// <p>Name of the table associated with the summary.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>Name of the index associated with the summary, if any.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        /// <p>Describes the current status for contributor insights for the given table and index, if applicable.</p>
        pub fn contributor_insights_status(
            mut self,
            inp: crate::model::ContributorInsightsStatus,
        ) -> Self {
            self.contributor_insights_status = Some(inp);
            self
        }
        pub fn set_contributor_insights_status(
            mut self,
            inp: std::option::Option<crate::model::ContributorInsightsStatus>,
        ) -> Self {
            self.contributor_insights_status = inp;
            self
        }
        /// Consumes the builder and constructs a [`ContributorInsightsSummary`](crate::model::ContributorInsightsSummary)
        pub fn build(self) -> crate::model::ContributorInsightsSummary {
            crate::model::ContributorInsightsSummary {
                table_name: self.table_name,
                index_name: self.index_name,
                contributor_insights_status: self.contributor_insights_status,
            }
        }
    }
}
impl ContributorInsightsSummary {
    /// Creates a new builder-style object to manufacture [`ContributorInsightsSummary`](crate::model::ContributorInsightsSummary)
    pub fn builder() -> crate::model::contributor_insights_summary::Builder {
        crate::model::contributor_insights_summary::Builder::default()
    }
}

/// <p>Contains details for the backup.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupSummary {
    /// <p>Name of the table.</p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier for the table.</p>
    #[serde(rename = "TableId")]
    #[serde(default)]
    pub table_id: std::option::Option<std::string::String>,
    /// <p>ARN associated with the table.</p>
    #[serde(rename = "TableArn")]
    #[serde(default)]
    pub table_arn: std::option::Option<std::string::String>,
    /// <p>ARN associated with the backup.</p>
    #[serde(rename = "BackupArn")]
    #[serde(default)]
    pub backup_arn: std::option::Option<std::string::String>,
    /// <p>Name of the specified backup.</p>
    #[serde(rename = "BackupName")]
    #[serde(default)]
    pub backup_name: std::option::Option<std::string::String>,
    /// <p>Time at which the backup was created.</p>
    #[serde(rename = "BackupCreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub backup_creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Time at which the automatic on-demand backup created by DynamoDB will expire. This
    /// <code>SYSTEM</code> on-demand backup expires automatically 35 days after its
    /// creation.</p>
    #[serde(rename = "BackupExpiryDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub backup_expiry_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED.</p>
    #[serde(rename = "BackupStatus")]
    #[serde(default)]
    pub backup_status: std::option::Option<crate::model::BackupStatus>,
    /// <p>BackupType:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>USER</code> - You create and manage these using the on-demand backup feature.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled, a <code>SYSTEM</code> backup is automatically
    /// created and is retained for 35 days (at no additional cost). System backups allow you to restore the deleted
    /// table to the state it was in just before the point of deletion.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AWS_BACKUP</code> - On-demand backup created by you from AWS Backup service.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "BackupType")]
    #[serde(default)]
    pub backup_type: std::option::Option<crate::model::BackupType>,
    /// <p>Size of the backup in bytes.</p>
    #[serde(rename = "BackupSizeBytes")]
    #[serde(default)]
    pub backup_size_bytes: std::option::Option<i64>,
}
impl std::fmt::Debug for BackupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupSummary");
        formatter.field("table_name", &self.table_name);
        formatter.field("table_id", &self.table_id);
        formatter.field("table_arn", &self.table_arn);
        formatter.field("backup_arn", &self.backup_arn);
        formatter.field("backup_name", &self.backup_name);
        formatter.field("backup_creation_date_time", &self.backup_creation_date_time);
        formatter.field("backup_expiry_date_time", &self.backup_expiry_date_time);
        formatter.field("backup_status", &self.backup_status);
        formatter.field("backup_type", &self.backup_type);
        formatter.field("backup_size_bytes", &self.backup_size_bytes);
        formatter.finish()
    }
}
/// See [`BackupSummary`](crate::model::BackupSummary)
pub mod backup_summary {
    /// A builder for [`BackupSummary`](crate::model::BackupSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) table_id: std::option::Option<std::string::String>,
        pub(crate) table_arn: std::option::Option<std::string::String>,
        pub(crate) backup_arn: std::option::Option<std::string::String>,
        pub(crate) backup_name: std::option::Option<std::string::String>,
        pub(crate) backup_creation_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) backup_expiry_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) backup_status: std::option::Option<crate::model::BackupStatus>,
        pub(crate) backup_type: std::option::Option<crate::model::BackupType>,
        pub(crate) backup_size_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>Name of the table.</p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>Unique identifier for the table.</p>
        pub fn table_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_id = Some(inp.into());
            self
        }
        pub fn set_table_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_id = inp;
            self
        }
        /// <p>ARN associated with the table.</p>
        pub fn table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_arn = Some(inp.into());
            self
        }
        pub fn set_table_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_arn = inp;
            self
        }
        /// <p>ARN associated with the backup.</p>
        pub fn backup_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.backup_arn = Some(inp.into());
            self
        }
        pub fn set_backup_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.backup_arn = inp;
            self
        }
        /// <p>Name of the specified backup.</p>
        pub fn backup_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.backup_name = Some(inp.into());
            self
        }
        pub fn set_backup_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.backup_name = inp;
            self
        }
        /// <p>Time at which the backup was created.</p>
        pub fn backup_creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.backup_creation_date_time = Some(inp);
            self
        }
        pub fn set_backup_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.backup_creation_date_time = inp;
            self
        }
        /// <p>Time at which the automatic on-demand backup created by DynamoDB will expire. This
        /// <code>SYSTEM</code> on-demand backup expires automatically 35 days after its
        /// creation.</p>
        pub fn backup_expiry_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.backup_expiry_date_time = Some(inp);
            self
        }
        pub fn set_backup_expiry_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.backup_expiry_date_time = inp;
            self
        }
        /// <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED.</p>
        pub fn backup_status(mut self, inp: crate::model::BackupStatus) -> Self {
            self.backup_status = Some(inp);
            self
        }
        pub fn set_backup_status(
            mut self,
            inp: std::option::Option<crate::model::BackupStatus>,
        ) -> Self {
            self.backup_status = inp;
            self
        }
        /// <p>BackupType:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>USER</code> - You create and manage these using the on-demand backup feature.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled, a <code>SYSTEM</code> backup is automatically
        /// created and is retained for 35 days (at no additional cost). System backups allow you to restore the deleted
        /// table to the state it was in just before the point of deletion.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AWS_BACKUP</code> - On-demand backup created by you from AWS Backup service.</p>
        /// </li>
        /// </ul>
        pub fn backup_type(mut self, inp: crate::model::BackupType) -> Self {
            self.backup_type = Some(inp);
            self
        }
        pub fn set_backup_type(
            mut self,
            inp: std::option::Option<crate::model::BackupType>,
        ) -> Self {
            self.backup_type = inp;
            self
        }
        /// <p>Size of the backup in bytes.</p>
        pub fn backup_size_bytes(mut self, inp: i64) -> Self {
            self.backup_size_bytes = Some(inp);
            self
        }
        pub fn set_backup_size_bytes(mut self, inp: std::option::Option<i64>) -> Self {
            self.backup_size_bytes = inp;
            self
        }
        /// Consumes the builder and constructs a [`BackupSummary`](crate::model::BackupSummary)
        pub fn build(self) -> crate::model::BackupSummary {
            crate::model::BackupSummary {
                table_name: self.table_name,
                table_id: self.table_id,
                table_arn: self.table_arn,
                backup_arn: self.backup_arn,
                backup_name: self.backup_name,
                backup_creation_date_time: self.backup_creation_date_time,
                backup_expiry_date_time: self.backup_expiry_date_time,
                backup_status: self.backup_status,
                backup_type: self.backup_type,
                backup_size_bytes: self.backup_size_bytes,
            }
        }
    }
}
impl BackupSummary {
    /// Creates a new builder-style object to manufacture [`BackupSummary`](crate::model::BackupSummary)
    pub fn builder() -> crate::model::backup_summary::Builder {
        crate::model::backup_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackupType {
    AwsBackup,
    System,
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BackupType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_BACKUP" => BackupType::AwsBackup,
            "SYSTEM" => BackupType::System,
            "USER" => BackupType::User,
            other => BackupType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BackupType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(BackupType::from(s))
    }
}
impl BackupType {
    pub fn as_str(&self) -> &str {
        match self {
            BackupType::AwsBackup => "AWS_BACKUP",
            BackupType::System => "SYSTEM",
            BackupType::User => "USER",
            BackupType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for BackupType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for BackupType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackupStatus {
    Available,
    Creating,
    Deleted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BackupStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => BackupStatus::Available,
            "CREATING" => BackupStatus::Creating,
            "DELETED" => BackupStatus::Deleted,
            other => BackupStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BackupStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(BackupStatus::from(s))
    }
}
impl BackupStatus {
    pub fn as_str(&self) -> &str {
        match self {
            BackupStatus::Available => "AVAILABLE",
            BackupStatus::Creating => "CREATING",
            BackupStatus::Deleted => "DELETED",
            BackupStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for BackupStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for BackupStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BackupTypeFilter {
    All,
    AwsBackup,
    System,
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BackupTypeFilter {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => BackupTypeFilter::All,
            "AWS_BACKUP" => BackupTypeFilter::AwsBackup,
            "SYSTEM" => BackupTypeFilter::System,
            "USER" => BackupTypeFilter::User,
            other => BackupTypeFilter::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BackupTypeFilter {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(BackupTypeFilter::from(s))
    }
}
impl BackupTypeFilter {
    pub fn as_str(&self) -> &str {
        match self {
            BackupTypeFilter::All => "ALL",
            BackupTypeFilter::AwsBackup => "AWS_BACKUP",
            BackupTypeFilter::System => "SYSTEM",
            BackupTypeFilter::User => "USER",
            BackupTypeFilter::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for BackupTypeFilter {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for BackupTypeFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Represents the properties of the exported table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportDescription {
    /// <p>The Amazon Resource Name (ARN) of the table export.</p>
    #[serde(rename = "ExportArn")]
    #[serde(default)]
    pub export_arn: std::option::Option<std::string::String>,
    /// <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or FAILED.</p>
    #[serde(rename = "ExportStatus")]
    #[serde(default)]
    pub export_status: std::option::Option<crate::model::ExportStatus>,
    /// <p>The time at which the export task began.</p>
    #[serde(rename = "StartTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the export task completed.</p>
    #[serde(rename = "EndTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The name of the manifest file for the export task.</p>
    #[serde(rename = "ExportManifest")]
    #[serde(default)]
    pub export_manifest: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the table that was exported.</p>
    #[serde(rename = "TableArn")]
    #[serde(default)]
    pub table_arn: std::option::Option<std::string::String>,
    /// <p>Unique ID of the table that was exported.</p>
    #[serde(rename = "TableId")]
    #[serde(default)]
    pub table_id: std::option::Option<std::string::String>,
    /// <p>Point in time from which table data was exported.</p>
    #[serde(rename = "ExportTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub export_time: std::option::Option<smithy_types::Instant>,
    /// <p>The client token that was provided for the export task. A client token makes calls to
    /// <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple
    /// identical calls have the same effect as one single call.</p>
    #[serde(rename = "ClientToken")]
    #[serde(default)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon S3 bucket containing the export.</p>
    #[serde(rename = "S3Bucket")]
    #[serde(default)]
    pub s3_bucket: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS account that owns the bucket containing the export.</p>
    #[serde(rename = "S3BucketOwner")]
    #[serde(default)]
    pub s3_bucket_owner: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 bucket prefix used as the file name and path of the exported
    /// snapshot.</p>
    #[serde(rename = "S3Prefix")]
    #[serde(default)]
    pub s3_prefix: std::option::Option<std::string::String>,
    /// <p>Type of encryption used on the bucket where export data is stored. Valid values
    /// for <code>S3SseAlgorithm</code> are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AES256</code> - server-side encryption with Amazon S3 managed keys</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>KMS</code> - server-side encryption with AWS KMS managed keys</p>
    /// </li>
    /// </ul>
    #[serde(rename = "S3SseAlgorithm")]
    #[serde(default)]
    pub s3_sse_algorithm: std::option::Option<crate::model::S3SseAlgorithm>,
    /// <p>The ID of the AWS KMS managed key used to encrypt the S3 bucket where export data is
    /// stored (if applicable).</p>
    #[serde(rename = "S3SseKmsKeyId")]
    #[serde(default)]
    pub s3_sse_kms_key_id: std::option::Option<std::string::String>,
    /// <p>Status code for the result of the failed export.</p>
    #[serde(rename = "FailureCode")]
    #[serde(default)]
    pub failure_code: std::option::Option<std::string::String>,
    /// <p>Export failure reason description.</p>
    #[serde(rename = "FailureMessage")]
    #[serde(default)]
    pub failure_message: std::option::Option<std::string::String>,
    /// <p>The format of the exported data. Valid values for <code>ExportFormat</code> are
    /// <code>DYNAMODB_JSON</code> or <code>ION</code>.</p>
    #[serde(rename = "ExportFormat")]
    #[serde(default)]
    pub export_format: std::option::Option<crate::model::ExportFormat>,
    /// <p>The billable size of the table export.</p>
    #[serde(rename = "BilledSizeBytes")]
    #[serde(default)]
    pub billed_size_bytes: std::option::Option<i64>,
    /// <p>The number of items exported.</p>
    #[serde(rename = "ItemCount")]
    #[serde(default)]
    pub item_count: std::option::Option<i64>,
}
impl std::fmt::Debug for ExportDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportDescription");
        formatter.field("export_arn", &self.export_arn);
        formatter.field("export_status", &self.export_status);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("export_manifest", &self.export_manifest);
        formatter.field("table_arn", &self.table_arn);
        formatter.field("table_id", &self.table_id);
        formatter.field("export_time", &self.export_time);
        formatter.field("client_token", &self.client_token);
        formatter.field("s3_bucket", &self.s3_bucket);
        formatter.field("s3_bucket_owner", &self.s3_bucket_owner);
        formatter.field("s3_prefix", &self.s3_prefix);
        formatter.field("s3_sse_algorithm", &self.s3_sse_algorithm);
        formatter.field("s3_sse_kms_key_id", &self.s3_sse_kms_key_id);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_message", &self.failure_message);
        formatter.field("export_format", &self.export_format);
        formatter.field("billed_size_bytes", &self.billed_size_bytes);
        formatter.field("item_count", &self.item_count);
        formatter.finish()
    }
}
/// See [`ExportDescription`](crate::model::ExportDescription)
pub mod export_description {
    /// A builder for [`ExportDescription`](crate::model::ExportDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) export_arn: std::option::Option<std::string::String>,
        pub(crate) export_status: std::option::Option<crate::model::ExportStatus>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) export_manifest: std::option::Option<std::string::String>,
        pub(crate) table_arn: std::option::Option<std::string::String>,
        pub(crate) table_id: std::option::Option<std::string::String>,
        pub(crate) export_time: std::option::Option<smithy_types::Instant>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) s3_bucket: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_owner: std::option::Option<std::string::String>,
        pub(crate) s3_prefix: std::option::Option<std::string::String>,
        pub(crate) s3_sse_algorithm: std::option::Option<crate::model::S3SseAlgorithm>,
        pub(crate) s3_sse_kms_key_id: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<std::string::String>,
        pub(crate) failure_message: std::option::Option<std::string::String>,
        pub(crate) export_format: std::option::Option<crate::model::ExportFormat>,
        pub(crate) billed_size_bytes: std::option::Option<i64>,
        pub(crate) item_count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the table export.</p>
        pub fn export_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.export_arn = Some(inp.into());
            self
        }
        pub fn set_export_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.export_arn = inp;
            self
        }
        /// <p>Export can be in one of the following states: IN_PROGRESS, COMPLETED, or FAILED.</p>
        pub fn export_status(mut self, inp: crate::model::ExportStatus) -> Self {
            self.export_status = Some(inp);
            self
        }
        pub fn set_export_status(
            mut self,
            inp: std::option::Option<crate::model::ExportStatus>,
        ) -> Self {
            self.export_status = inp;
            self
        }
        /// <p>The time at which the export task began.</p>
        pub fn start_time(mut self, inp: smithy_types::Instant) -> Self {
            self.start_time = Some(inp);
            self
        }
        pub fn set_start_time(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = inp;
            self
        }
        /// <p>The time at which the export task completed.</p>
        pub fn end_time(mut self, inp: smithy_types::Instant) -> Self {
            self.end_time = Some(inp);
            self
        }
        pub fn set_end_time(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = inp;
            self
        }
        /// <p>The name of the manifest file for the export task.</p>
        pub fn export_manifest(mut self, inp: impl Into<std::string::String>) -> Self {
            self.export_manifest = Some(inp.into());
            self
        }
        pub fn set_export_manifest(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.export_manifest = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the table that was exported.</p>
        pub fn table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_arn = Some(inp.into());
            self
        }
        pub fn set_table_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_arn = inp;
            self
        }
        /// <p>Unique ID of the table that was exported.</p>
        pub fn table_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_id = Some(inp.into());
            self
        }
        pub fn set_table_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_id = inp;
            self
        }
        /// <p>Point in time from which table data was exported.</p>
        pub fn export_time(mut self, inp: smithy_types::Instant) -> Self {
            self.export_time = Some(inp);
            self
        }
        pub fn set_export_time(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.export_time = inp;
            self
        }
        /// <p>The client token that was provided for the export task. A client token makes calls to
        /// <code>ExportTableToPointInTimeInput</code> idempotent, meaning that multiple
        /// identical calls have the same effect as one single call.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_token = Some(inp.into());
            self
        }
        pub fn set_client_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.client_token = inp;
            self
        }
        /// <p>The name of the Amazon S3 bucket containing the export.</p>
        pub fn s3_bucket(mut self, inp: impl Into<std::string::String>) -> Self {
            self.s3_bucket = Some(inp.into());
            self
        }
        pub fn set_s3_bucket(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.s3_bucket = inp;
            self
        }
        /// <p>The ID of the AWS account that owns the bucket containing the export.</p>
        pub fn s3_bucket_owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.s3_bucket_owner = Some(inp.into());
            self
        }
        pub fn set_s3_bucket_owner(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_owner = inp;
            self
        }
        /// <p>The Amazon S3 bucket prefix used as the file name and path of the exported
        /// snapshot.</p>
        pub fn s3_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.s3_prefix = Some(inp.into());
            self
        }
        pub fn set_s3_prefix(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.s3_prefix = inp;
            self
        }
        /// <p>Type of encryption used on the bucket where export data is stored. Valid values
        /// for <code>S3SseAlgorithm</code> are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>AES256</code> - server-side encryption with Amazon S3 managed keys</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>KMS</code> - server-side encryption with AWS KMS managed keys</p>
        /// </li>
        /// </ul>
        pub fn s3_sse_algorithm(mut self, inp: crate::model::S3SseAlgorithm) -> Self {
            self.s3_sse_algorithm = Some(inp);
            self
        }
        pub fn set_s3_sse_algorithm(
            mut self,
            inp: std::option::Option<crate::model::S3SseAlgorithm>,
        ) -> Self {
            self.s3_sse_algorithm = inp;
            self
        }
        /// <p>The ID of the AWS KMS managed key used to encrypt the S3 bucket where export data is
        /// stored (if applicable).</p>
        pub fn s3_sse_kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.s3_sse_kms_key_id = Some(inp.into());
            self
        }
        pub fn set_s3_sse_kms_key_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_sse_kms_key_id = inp;
            self
        }
        /// <p>Status code for the result of the failed export.</p>
        pub fn failure_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.failure_code = Some(inp.into());
            self
        }
        pub fn set_failure_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.failure_code = inp;
            self
        }
        /// <p>Export failure reason description.</p>
        pub fn failure_message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.failure_message = Some(inp.into());
            self
        }
        pub fn set_failure_message(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_message = inp;
            self
        }
        /// <p>The format of the exported data. Valid values for <code>ExportFormat</code> are
        /// <code>DYNAMODB_JSON</code> or <code>ION</code>.</p>
        pub fn export_format(mut self, inp: crate::model::ExportFormat) -> Self {
            self.export_format = Some(inp);
            self
        }
        pub fn set_export_format(
            mut self,
            inp: std::option::Option<crate::model::ExportFormat>,
        ) -> Self {
            self.export_format = inp;
            self
        }
        /// <p>The billable size of the table export.</p>
        pub fn billed_size_bytes(mut self, inp: i64) -> Self {
            self.billed_size_bytes = Some(inp);
            self
        }
        pub fn set_billed_size_bytes(mut self, inp: std::option::Option<i64>) -> Self {
            self.billed_size_bytes = inp;
            self
        }
        /// <p>The number of items exported.</p>
        pub fn item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        pub fn set_item_count(mut self, inp: std::option::Option<i64>) -> Self {
            self.item_count = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExportDescription`](crate::model::ExportDescription)
        pub fn build(self) -> crate::model::ExportDescription {
            crate::model::ExportDescription {
                export_arn: self.export_arn,
                export_status: self.export_status,
                start_time: self.start_time,
                end_time: self.end_time,
                export_manifest: self.export_manifest,
                table_arn: self.table_arn,
                table_id: self.table_id,
                export_time: self.export_time,
                client_token: self.client_token,
                s3_bucket: self.s3_bucket,
                s3_bucket_owner: self.s3_bucket_owner,
                s3_prefix: self.s3_prefix,
                s3_sse_algorithm: self.s3_sse_algorithm,
                s3_sse_kms_key_id: self.s3_sse_kms_key_id,
                failure_code: self.failure_code,
                failure_message: self.failure_message,
                export_format: self.export_format,
                billed_size_bytes: self.billed_size_bytes,
                item_count: self.item_count,
            }
        }
    }
}
impl ExportDescription {
    /// Creates a new builder-style object to manufacture [`ExportDescription`](crate::model::ExportDescription)
    pub fn builder() -> crate::model::export_description::Builder {
        crate::model::export_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportFormat {
    DynamodbJson,
    Ion,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExportFormat {
    fn from(s: &str) -> Self {
        match s {
            "DYNAMODB_JSON" => ExportFormat::DynamodbJson,
            "ION" => ExportFormat::Ion,
            other => ExportFormat::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExportFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ExportFormat::from(s))
    }
}
impl ExportFormat {
    pub fn as_str(&self) -> &str {
        match self {
            ExportFormat::DynamodbJson => "DYNAMODB_JSON",
            ExportFormat::Ion => "ION",
            ExportFormat::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ExportFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ExportFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum S3SseAlgorithm {
    Aes256,
    Kms,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for S3SseAlgorithm {
    fn from(s: &str) -> Self {
        match s {
            "AES256" => S3SseAlgorithm::Aes256,
            "KMS" => S3SseAlgorithm::Kms,
            other => S3SseAlgorithm::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for S3SseAlgorithm {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(S3SseAlgorithm::from(s))
    }
}
impl S3SseAlgorithm {
    pub fn as_str(&self) -> &str {
        match self {
            S3SseAlgorithm::Aes256 => "AES256",
            S3SseAlgorithm::Kms => "KMS",
            S3SseAlgorithm::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for S3SseAlgorithm {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for S3SseAlgorithm {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>
/// Represents a PartiQL statment that uses parameters.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterizedStatement {
    /// <p>
    /// A PartiQL statment that uses parameters.
    /// </p>
    #[serde(rename = "Statement")]
    #[serde(default)]
    pub statement: std::option::Option<std::string::String>,
    /// <p>
    /// The parameter values.
    /// </p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
}
impl std::fmt::Debug for ParameterizedStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterizedStatement");
        formatter.field("statement", &self.statement);
        formatter.field("parameters", &self.parameters);
        formatter.finish()
    }
}
/// See [`ParameterizedStatement`](crate::model::ParameterizedStatement)
pub mod parameterized_statement {
    /// A builder for [`ParameterizedStatement`](crate::model::ParameterizedStatement)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
    }
    impl Builder {
        /// <p>
        /// A PartiQL statment that uses parameters.
        /// </p>
        pub fn statement(mut self, inp: impl Into<std::string::String>) -> Self {
            self.statement = Some(inp.into());
            self
        }
        pub fn set_statement(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.statement = inp;
            self
        }
        pub fn parameters(mut self, inp: impl Into<crate::model::AttributeValue>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(inp.into());
            self.parameters = Some(v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        ) -> Self {
            self.parameters = inp;
            self
        }
        /// Consumes the builder and constructs a [`ParameterizedStatement`](crate::model::ParameterizedStatement)
        pub fn build(self) -> crate::model::ParameterizedStatement {
            crate::model::ParameterizedStatement {
                statement: self.statement,
                parameters: self.parameters,
            }
        }
    }
}
impl ParameterizedStatement {
    /// Creates a new builder-style object to manufacture [`ParameterizedStatement`](crate::model::ParameterizedStatement)
    pub fn builder() -> crate::model::parameterized_statement::Builder {
        crate::model::parameterized_statement::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DestinationStatus {
    Active,
    Disabled,
    Disabling,
    EnableFailed,
    Enabling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DestinationStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DestinationStatus::Active,
            "DISABLED" => DestinationStatus::Disabled,
            "DISABLING" => DestinationStatus::Disabling,
            "ENABLE_FAILED" => DestinationStatus::EnableFailed,
            "ENABLING" => DestinationStatus::Enabling,
            other => DestinationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DestinationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DestinationStatus::from(s))
    }
}
impl DestinationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DestinationStatus::Active => "ACTIVE",
            DestinationStatus::Disabled => "DISABLED",
            DestinationStatus::Disabling => "DISABLING",
            DestinationStatus::EnableFailed => "ENABLE_FAILED",
            DestinationStatus::Enabling => "ENABLING",
            DestinationStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DestinationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DestinationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The description of the Time to Live (TTL) status on the specified table. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TimeToLiveDescription {
    /// <p> The TTL status for the table.</p>
    #[serde(rename = "TimeToLiveStatus")]
    #[serde(default)]
    pub time_to_live_status: std::option::Option<crate::model::TimeToLiveStatus>,
    /// <p> The name of the TTL attribute for items in the table.</p>
    #[serde(rename = "AttributeName")]
    #[serde(default)]
    pub attribute_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TimeToLiveDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TimeToLiveDescription");
        formatter.field("time_to_live_status", &self.time_to_live_status);
        formatter.field("attribute_name", &self.attribute_name);
        formatter.finish()
    }
}
/// See [`TimeToLiveDescription`](crate::model::TimeToLiveDescription)
pub mod time_to_live_description {
    /// A builder for [`TimeToLiveDescription`](crate::model::TimeToLiveDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_to_live_status: std::option::Option<crate::model::TimeToLiveStatus>,
        pub(crate) attribute_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The TTL status for the table.</p>
        pub fn time_to_live_status(mut self, inp: crate::model::TimeToLiveStatus) -> Self {
            self.time_to_live_status = Some(inp);
            self
        }
        pub fn set_time_to_live_status(
            mut self,
            inp: std::option::Option<crate::model::TimeToLiveStatus>,
        ) -> Self {
            self.time_to_live_status = inp;
            self
        }
        /// <p> The name of the TTL attribute for items in the table.</p>
        pub fn attribute_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.attribute_name = Some(inp.into());
            self
        }
        pub fn set_attribute_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.attribute_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`TimeToLiveDescription`](crate::model::TimeToLiveDescription)
        pub fn build(self) -> crate::model::TimeToLiveDescription {
            crate::model::TimeToLiveDescription {
                time_to_live_status: self.time_to_live_status,
                attribute_name: self.attribute_name,
            }
        }
    }
}
impl TimeToLiveDescription {
    /// Creates a new builder-style object to manufacture [`TimeToLiveDescription`](crate::model::TimeToLiveDescription)
    pub fn builder() -> crate::model::time_to_live_description::Builder {
        crate::model::time_to_live_description::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TimeToLiveStatus {
    Disabled,
    Disabling,
    Enabled,
    Enabling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TimeToLiveStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => TimeToLiveStatus::Disabled,
            "DISABLING" => TimeToLiveStatus::Disabling,
            "ENABLED" => TimeToLiveStatus::Enabled,
            "ENABLING" => TimeToLiveStatus::Enabling,
            other => TimeToLiveStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TimeToLiveStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TimeToLiveStatus::from(s))
    }
}
impl TimeToLiveStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TimeToLiveStatus::Disabled => "DISABLED",
            TimeToLiveStatus::Disabling => "DISABLING",
            TimeToLiveStatus::Enabled => "ENABLED",
            TimeToLiveStatus::Enabling => "ENABLING",
            TimeToLiveStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TimeToLiveStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TimeToLiveStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes a Kinesis data stream destination.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KinesisDataStreamDestination {
    /// <p>The ARN for a specific Kinesis data stream.</p>
    #[serde(rename = "StreamArn")]
    #[serde(default)]
    pub stream_arn: std::option::Option<std::string::String>,
    /// <p>The current status of replication.</p>
    #[serde(rename = "DestinationStatus")]
    #[serde(default)]
    pub destination_status: std::option::Option<crate::model::DestinationStatus>,
    /// <p>The human-readable string that corresponds to the replica status.</p>
    #[serde(rename = "DestinationStatusDescription")]
    #[serde(default)]
    pub destination_status_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for KinesisDataStreamDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KinesisDataStreamDestination");
        formatter.field("stream_arn", &self.stream_arn);
        formatter.field("destination_status", &self.destination_status);
        formatter.field(
            "destination_status_description",
            &self.destination_status_description,
        );
        formatter.finish()
    }
}
/// See [`KinesisDataStreamDestination`](crate::model::KinesisDataStreamDestination)
pub mod kinesis_data_stream_destination {
    /// A builder for [`KinesisDataStreamDestination`](crate::model::KinesisDataStreamDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_arn: std::option::Option<std::string::String>,
        pub(crate) destination_status: std::option::Option<crate::model::DestinationStatus>,
        pub(crate) destination_status_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN for a specific Kinesis data stream.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stream_arn = Some(inp.into());
            self
        }
        pub fn set_stream_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stream_arn = inp;
            self
        }
        /// <p>The current status of replication.</p>
        pub fn destination_status(mut self, inp: crate::model::DestinationStatus) -> Self {
            self.destination_status = Some(inp);
            self
        }
        pub fn set_destination_status(
            mut self,
            inp: std::option::Option<crate::model::DestinationStatus>,
        ) -> Self {
            self.destination_status = inp;
            self
        }
        /// <p>The human-readable string that corresponds to the replica status.</p>
        pub fn destination_status_description(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.destination_status_description = Some(inp.into());
            self
        }
        pub fn set_destination_status_description(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_status_description = inp;
            self
        }
        /// Consumes the builder and constructs a [`KinesisDataStreamDestination`](crate::model::KinesisDataStreamDestination)
        pub fn build(self) -> crate::model::KinesisDataStreamDestination {
            crate::model::KinesisDataStreamDestination {
                stream_arn: self.stream_arn,
                destination_status: self.destination_status,
                destination_status_description: self.destination_status_description,
            }
        }
    }
}
impl KinesisDataStreamDestination {
    /// Creates a new builder-style object to manufacture [`KinesisDataStreamDestination`](crate::model::KinesisDataStreamDestination)
    pub fn builder() -> crate::model::kinesis_data_stream_destination::Builder {
        crate::model::kinesis_data_stream_destination::Builder::default()
    }
}

/// <p>An endpoint information details.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct Endpoint {
    /// <p>IP address of the endpoint.</p>
    #[serde(rename = "Address")]
    #[serde(default)]
    pub address: std::option::Option<std::string::String>,
    /// <p>Endpoint cache time to live (TTL) value.</p>
    #[serde(rename = "CachePeriodInMinutes")]
    #[serde(default)]
    pub cache_period_in_minutes: i64,
}
impl std::fmt::Debug for Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Endpoint");
        formatter.field("address", &self.address);
        formatter.field("cache_period_in_minutes", &self.cache_period_in_minutes);
        formatter.finish()
    }
}
/// See [`Endpoint`](crate::model::Endpoint)
pub mod endpoint {
    /// A builder for [`Endpoint`](crate::model::Endpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) cache_period_in_minutes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>IP address of the endpoint.</p>
        pub fn address(mut self, inp: impl Into<std::string::String>) -> Self {
            self.address = Some(inp.into());
            self
        }
        pub fn set_address(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.address = inp;
            self
        }
        /// <p>Endpoint cache time to live (TTL) value.</p>
        pub fn cache_period_in_minutes(mut self, inp: i64) -> Self {
            self.cache_period_in_minutes = Some(inp);
            self
        }
        pub fn set_cache_period_in_minutes(mut self, inp: i64) -> Self {
            self.cache_period_in_minutes = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`Endpoint`](crate::model::Endpoint)
        pub fn build(self) -> crate::model::Endpoint {
            crate::model::Endpoint {
                address: self.address,
                cache_period_in_minutes: self.cache_period_in_minutes.unwrap_or_default(),
            }
        }
    }
}
impl Endpoint {
    /// Creates a new builder-style object to manufacture [`Endpoint`](crate::model::Endpoint)
    pub fn builder() -> crate::model::endpoint::Builder {
        crate::model::endpoint::Builder::default()
    }
}

/// <p>Represents a failure a contributor insights operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct FailureException {
    /// <p>Exception name.</p>
    #[serde(rename = "ExceptionName")]
    #[serde(default)]
    pub exception_name: std::option::Option<std::string::String>,
    /// <p>Description of the failure.</p>
    #[serde(rename = "ExceptionDescription")]
    #[serde(default)]
    pub exception_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailureException");
        formatter.field("exception_name", &self.exception_name);
        formatter.field("exception_description", &self.exception_description);
        formatter.finish()
    }
}
/// See [`FailureException`](crate::model::FailureException)
pub mod failure_exception {
    /// A builder for [`FailureException`](crate::model::FailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) exception_name: std::option::Option<std::string::String>,
        pub(crate) exception_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Exception name.</p>
        pub fn exception_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exception_name = Some(inp.into());
            self
        }
        pub fn set_exception_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.exception_name = inp;
            self
        }
        /// <p>Description of the failure.</p>
        pub fn exception_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exception_description = Some(inp.into());
            self
        }
        pub fn set_exception_description(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exception_description = inp;
            self
        }
        /// Consumes the builder and constructs a [`FailureException`](crate::model::FailureException)
        pub fn build(self) -> crate::model::FailureException {
            crate::model::FailureException {
                exception_name: self.exception_name,
                exception_description: self.exception_description,
            }
        }
    }
}
impl FailureException {
    /// Creates a new builder-style object to manufacture [`FailureException`](crate::model::FailureException)
    pub fn builder() -> crate::model::failure_exception::Builder {
        crate::model::failure_exception::Builder::default()
    }
}

/// <p>Contains the description of the backup created for the table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupDescription {
    /// <p>Contains the details of the backup created for the table. </p>
    #[serde(rename = "BackupDetails")]
    #[serde(default)]
    pub backup_details: std::option::Option<crate::model::BackupDetails>,
    /// <p>Contains the details of the table when the backup was created. </p>
    #[serde(rename = "SourceTableDetails")]
    #[serde(default)]
    pub source_table_details: std::option::Option<crate::model::SourceTableDetails>,
    /// <p>Contains the details of the features enabled on the table when the backup was created. For example, LSIs, GSIs, streams, TTL.</p>
    #[serde(rename = "SourceTableFeatureDetails")]
    #[serde(default)]
    pub source_table_feature_details: std::option::Option<crate::model::SourceTableFeatureDetails>,
}
impl std::fmt::Debug for BackupDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupDescription");
        formatter.field("backup_details", &self.backup_details);
        formatter.field("source_table_details", &self.source_table_details);
        formatter.field(
            "source_table_feature_details",
            &self.source_table_feature_details,
        );
        formatter.finish()
    }
}
/// See [`BackupDescription`](crate::model::BackupDescription)
pub mod backup_description {
    /// A builder for [`BackupDescription`](crate::model::BackupDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_details: std::option::Option<crate::model::BackupDetails>,
        pub(crate) source_table_details: std::option::Option<crate::model::SourceTableDetails>,
        pub(crate) source_table_feature_details:
            std::option::Option<crate::model::SourceTableFeatureDetails>,
    }
    impl Builder {
        /// <p>Contains the details of the backup created for the table. </p>
        pub fn backup_details(mut self, inp: crate::model::BackupDetails) -> Self {
            self.backup_details = Some(inp);
            self
        }
        pub fn set_backup_details(
            mut self,
            inp: std::option::Option<crate::model::BackupDetails>,
        ) -> Self {
            self.backup_details = inp;
            self
        }
        /// <p>Contains the details of the table when the backup was created. </p>
        pub fn source_table_details(mut self, inp: crate::model::SourceTableDetails) -> Self {
            self.source_table_details = Some(inp);
            self
        }
        pub fn set_source_table_details(
            mut self,
            inp: std::option::Option<crate::model::SourceTableDetails>,
        ) -> Self {
            self.source_table_details = inp;
            self
        }
        /// <p>Contains the details of the features enabled on the table when the backup was created. For example, LSIs, GSIs, streams, TTL.</p>
        pub fn source_table_feature_details(
            mut self,
            inp: crate::model::SourceTableFeatureDetails,
        ) -> Self {
            self.source_table_feature_details = Some(inp);
            self
        }
        pub fn set_source_table_feature_details(
            mut self,
            inp: std::option::Option<crate::model::SourceTableFeatureDetails>,
        ) -> Self {
            self.source_table_feature_details = inp;
            self
        }
        /// Consumes the builder and constructs a [`BackupDescription`](crate::model::BackupDescription)
        pub fn build(self) -> crate::model::BackupDescription {
            crate::model::BackupDescription {
                backup_details: self.backup_details,
                source_table_details: self.source_table_details,
                source_table_feature_details: self.source_table_feature_details,
            }
        }
    }
}
impl BackupDescription {
    /// Creates a new builder-style object to manufacture [`BackupDescription`](crate::model::BackupDescription)
    pub fn builder() -> crate::model::backup_description::Builder {
        crate::model::backup_description::Builder::default()
    }
}

/// <p>Contains the details of the features enabled on the table when the backup was created. For example, LSIs, GSIs, streams, TTL. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceTableFeatureDetails {
    /// <p>Represents the LSI properties for the table when the backup was created. It includes the IndexName, KeySchema and Projection for the LSIs on the table at the time of backup. </p>
    #[serde(rename = "LocalSecondaryIndexes")]
    #[serde(default)]
    pub local_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexInfo>>,
    /// <p>Represents the GSI properties for the table when the backup was created. It includes the
    /// IndexName, KeySchema, Projection, and ProvisionedThroughput for the GSIs on the table at
    /// the time of backup. </p>
    #[serde(rename = "GlobalSecondaryIndexes")]
    #[serde(default)]
    pub global_secondary_indexes:
        std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexInfo>>,
    /// <p>Stream settings on the table when the backup was created.</p>
    #[serde(rename = "StreamDescription")]
    #[serde(default)]
    pub stream_description: std::option::Option<crate::model::StreamSpecification>,
    /// <p>Time to Live settings on the table when the backup was created.</p>
    #[serde(rename = "TimeToLiveDescription")]
    #[serde(default)]
    pub time_to_live_description: std::option::Option<crate::model::TimeToLiveDescription>,
    /// <p>The description of the server-side encryption status on the table when the backup was created.</p>
    #[serde(rename = "SSEDescription")]
    #[serde(default)]
    pub sse_description: std::option::Option<crate::model::SSEDescription>,
}
impl std::fmt::Debug for SourceTableFeatureDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceTableFeatureDetails");
        formatter.field("local_secondary_indexes", &self.local_secondary_indexes);
        formatter.field("global_secondary_indexes", &self.global_secondary_indexes);
        formatter.field("stream_description", &self.stream_description);
        formatter.field("time_to_live_description", &self.time_to_live_description);
        formatter.field("sse_description", &self.sse_description);
        formatter.finish()
    }
}
/// See [`SourceTableFeatureDetails`](crate::model::SourceTableFeatureDetails)
pub mod source_table_feature_details {
    /// A builder for [`SourceTableFeatureDetails`](crate::model::SourceTableFeatureDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) local_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexInfo>>,
        pub(crate) global_secondary_indexes:
            std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexInfo>>,
        pub(crate) stream_description: std::option::Option<crate::model::StreamSpecification>,
        pub(crate) time_to_live_description:
            std::option::Option<crate::model::TimeToLiveDescription>,
        pub(crate) sse_description: std::option::Option<crate::model::SSEDescription>,
    }
    impl Builder {
        pub fn local_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::LocalSecondaryIndexInfo>,
        ) -> Self {
            let mut v = self.local_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.local_secondary_indexes = Some(v);
            self
        }
        pub fn set_local_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::LocalSecondaryIndexInfo>>,
        ) -> Self {
            self.local_secondary_indexes = inp;
            self
        }
        pub fn global_secondary_indexes(
            mut self,
            inp: impl Into<crate::model::GlobalSecondaryIndexInfo>,
        ) -> Self {
            let mut v = self.global_secondary_indexes.unwrap_or_default();
            v.push(inp.into());
            self.global_secondary_indexes = Some(v);
            self
        }
        pub fn set_global_secondary_indexes(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::GlobalSecondaryIndexInfo>>,
        ) -> Self {
            self.global_secondary_indexes = inp;
            self
        }
        /// <p>Stream settings on the table when the backup was created.</p>
        pub fn stream_description(mut self, inp: crate::model::StreamSpecification) -> Self {
            self.stream_description = Some(inp);
            self
        }
        pub fn set_stream_description(
            mut self,
            inp: std::option::Option<crate::model::StreamSpecification>,
        ) -> Self {
            self.stream_description = inp;
            self
        }
        /// <p>Time to Live settings on the table when the backup was created.</p>
        pub fn time_to_live_description(
            mut self,
            inp: crate::model::TimeToLiveDescription,
        ) -> Self {
            self.time_to_live_description = Some(inp);
            self
        }
        pub fn set_time_to_live_description(
            mut self,
            inp: std::option::Option<crate::model::TimeToLiveDescription>,
        ) -> Self {
            self.time_to_live_description = inp;
            self
        }
        /// <p>The description of the server-side encryption status on the table when the backup was created.</p>
        pub fn sse_description(mut self, inp: crate::model::SSEDescription) -> Self {
            self.sse_description = Some(inp);
            self
        }
        pub fn set_sse_description(
            mut self,
            inp: std::option::Option<crate::model::SSEDescription>,
        ) -> Self {
            self.sse_description = inp;
            self
        }
        /// Consumes the builder and constructs a [`SourceTableFeatureDetails`](crate::model::SourceTableFeatureDetails)
        pub fn build(self) -> crate::model::SourceTableFeatureDetails {
            crate::model::SourceTableFeatureDetails {
                local_secondary_indexes: self.local_secondary_indexes,
                global_secondary_indexes: self.global_secondary_indexes,
                stream_description: self.stream_description,
                time_to_live_description: self.time_to_live_description,
                sse_description: self.sse_description,
            }
        }
    }
}
impl SourceTableFeatureDetails {
    /// Creates a new builder-style object to manufacture [`SourceTableFeatureDetails`](crate::model::SourceTableFeatureDetails)
    pub fn builder() -> crate::model::source_table_feature_details::Builder {
        crate::model::source_table_feature_details::Builder::default()
    }
}

/// <p>Represents the properties of a global secondary index for the table
/// when the backup was created.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalSecondaryIndexInfo {
    /// <p>The name of the global secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into
    /// the global secondary index. These are in addition to the primary
    /// key attributes and index key attributes, which are automatically
    /// projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
    /// <p>Represents the provisioned throughput settings for the specified global secondary index. </p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
}
impl std::fmt::Debug for GlobalSecondaryIndexInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalSecondaryIndexInfo");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.finish()
    }
}
/// See [`GlobalSecondaryIndexInfo`](crate::model::GlobalSecondaryIndexInfo)
pub mod global_secondary_index_info {
    /// A builder for [`GlobalSecondaryIndexInfo`](crate::model::GlobalSecondaryIndexInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    }
    impl Builder {
        /// <p>The name of the global secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into
        /// the global secondary index. These are in addition to the primary
        /// key attributes and index key attributes, which are automatically
        /// projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// <p>Represents the provisioned throughput settings for the specified global secondary index. </p>
        pub fn provisioned_throughput(mut self, inp: crate::model::ProvisionedThroughput) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndexInfo`](crate::model::GlobalSecondaryIndexInfo)
        pub fn build(self) -> crate::model::GlobalSecondaryIndexInfo {
            crate::model::GlobalSecondaryIndexInfo {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
                provisioned_throughput: self.provisioned_throughput,
            }
        }
    }
}
impl GlobalSecondaryIndexInfo {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndexInfo`](crate::model::GlobalSecondaryIndexInfo)
    pub fn builder() -> crate::model::global_secondary_index_info::Builder {
        crate::model::global_secondary_index_info::Builder::default()
    }
}

/// <p>Represents the properties of a local secondary index for the table
/// when the backup was created.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LocalSecondaryIndexInfo {
    /// <p>Represents the name of the local secondary index.</p>
    #[serde(rename = "IndexName")]
    #[serde(default)]
    pub index_name: std::option::Option<std::string::String>,
    /// <p>The complete key schema for a local secondary index, which consists of one or more pairs of attribute names and key types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HASH</code> - partition key</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RANGE</code> - sort key</p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>The partition key of an item is also known as its <i>hash attribute</i>.  The
    /// term "hash attribute" derives from DynamoDB's usage of an internal hash function to
    /// evenly distribute data items across partitions, based on their partition key values.</p>
    /// <p>The sort key of an item is also known as its <i>range attribute</i>.
    /// The term "range attribute" derives from the way DynamoDB stores items with the same
    /// partition key physically close together, in sorted order by the sort key value.</p>
    /// </note>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. </p>
    #[serde(rename = "Projection")]
    #[serde(default)]
    pub projection: std::option::Option<crate::model::Projection>,
}
impl std::fmt::Debug for LocalSecondaryIndexInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LocalSecondaryIndexInfo");
        formatter.field("index_name", &self.index_name);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("projection", &self.projection);
        formatter.finish()
    }
}
/// See [`LocalSecondaryIndexInfo`](crate::model::LocalSecondaryIndexInfo)
pub mod local_secondary_index_info {
    /// A builder for [`LocalSecondaryIndexInfo`](crate::model::LocalSecondaryIndexInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: std::option::Option<std::string::String>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) projection: std::option::Option<crate::model::Projection>,
    }
    impl Builder {
        /// <p>Represents the name of the local secondary index.</p>
        pub fn index_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.index_name = Some(inp.into());
            self
        }
        pub fn set_index_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.index_name = inp;
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. </p>
        pub fn projection(mut self, inp: crate::model::Projection) -> Self {
            self.projection = Some(inp);
            self
        }
        pub fn set_projection(
            mut self,
            inp: std::option::Option<crate::model::Projection>,
        ) -> Self {
            self.projection = inp;
            self
        }
        /// Consumes the builder and constructs a [`LocalSecondaryIndexInfo`](crate::model::LocalSecondaryIndexInfo)
        pub fn build(self) -> crate::model::LocalSecondaryIndexInfo {
            crate::model::LocalSecondaryIndexInfo {
                index_name: self.index_name,
                key_schema: self.key_schema,
                projection: self.projection,
            }
        }
    }
}
impl LocalSecondaryIndexInfo {
    /// Creates a new builder-style object to manufacture [`LocalSecondaryIndexInfo`](crate::model::LocalSecondaryIndexInfo)
    pub fn builder() -> crate::model::local_secondary_index_info::Builder {
        crate::model::local_secondary_index_info::Builder::default()
    }
}

/// <p>Contains the details of the table when the backup was created. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceTableDetails {
    /// <p>The name of the table for which the backup was created. </p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier for the table for which the backup was created. </p>
    #[serde(rename = "TableId")]
    #[serde(default)]
    pub table_id: std::option::Option<std::string::String>,
    /// <p>ARN of the table for which backup was created. </p>
    #[serde(rename = "TableArn")]
    #[serde(default)]
    pub table_arn: std::option::Option<std::string::String>,
    /// <p>Size of the table in bytes. Note that this is an approximate value.</p>
    #[serde(rename = "TableSizeBytes")]
    #[serde(default)]
    pub table_size_bytes: i64,
    /// <p>Schema of the table. </p>
    #[serde(rename = "KeySchema")]
    #[serde(default)]
    pub key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
    /// <p>Time when the source table was created. </p>
    #[serde(rename = "TableCreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub table_creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Read IOPs and Write IOPS on the table when the backup was created.</p>
    #[serde(rename = "ProvisionedThroughput")]
    #[serde(default)]
    pub provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
    /// <p>Number of items in the table. Note that this is an approximate value. </p>
    #[serde(rename = "ItemCount")]
    #[serde(default)]
    pub item_count: std::option::Option<i64>,
    /// <p>Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PROVISIONED</code> - Sets the read/write capacity mode to <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for predictable workloads.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to <code>PAY_PER_REQUEST</code>. We recommend using <code>PAY_PER_REQUEST</code> for unpredictable workloads.
    /// </p>
    /// </li>
    /// </ul>
    #[serde(rename = "BillingMode")]
    #[serde(default)]
    pub billing_mode: std::option::Option<crate::model::BillingMode>,
}
impl std::fmt::Debug for SourceTableDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceTableDetails");
        formatter.field("table_name", &self.table_name);
        formatter.field("table_id", &self.table_id);
        formatter.field("table_arn", &self.table_arn);
        formatter.field("table_size_bytes", &self.table_size_bytes);
        formatter.field("key_schema", &self.key_schema);
        formatter.field("table_creation_date_time", &self.table_creation_date_time);
        formatter.field("provisioned_throughput", &self.provisioned_throughput);
        formatter.field("item_count", &self.item_count);
        formatter.field("billing_mode", &self.billing_mode);
        formatter.finish()
    }
}
/// See [`SourceTableDetails`](crate::model::SourceTableDetails)
pub mod source_table_details {
    /// A builder for [`SourceTableDetails`](crate::model::SourceTableDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) table_id: std::option::Option<std::string::String>,
        pub(crate) table_arn: std::option::Option<std::string::String>,
        pub(crate) table_size_bytes: std::option::Option<i64>,
        pub(crate) key_schema: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        pub(crate) table_creation_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) provisioned_throughput: std::option::Option<crate::model::ProvisionedThroughput>,
        pub(crate) item_count: std::option::Option<i64>,
        pub(crate) billing_mode: std::option::Option<crate::model::BillingMode>,
    }
    impl Builder {
        /// <p>The name of the table for which the backup was created. </p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        /// <p>Unique identifier for the table for which the backup was created. </p>
        pub fn table_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_id = Some(inp.into());
            self
        }
        pub fn set_table_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_id = inp;
            self
        }
        /// <p>ARN of the table for which backup was created. </p>
        pub fn table_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_arn = Some(inp.into());
            self
        }
        pub fn set_table_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_arn = inp;
            self
        }
        /// <p>Size of the table in bytes. Note that this is an approximate value.</p>
        pub fn table_size_bytes(mut self, inp: i64) -> Self {
            self.table_size_bytes = Some(inp);
            self
        }
        pub fn set_table_size_bytes(mut self, inp: i64) -> Self {
            self.table_size_bytes = Some(inp);
            self
        }
        pub fn key_schema(mut self, inp: impl Into<crate::model::KeySchemaElement>) -> Self {
            let mut v = self.key_schema.unwrap_or_default();
            v.push(inp.into());
            self.key_schema = Some(v);
            self
        }
        pub fn set_key_schema(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::KeySchemaElement>>,
        ) -> Self {
            self.key_schema = inp;
            self
        }
        /// <p>Time when the source table was created. </p>
        pub fn table_creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.table_creation_date_time = Some(inp);
            self
        }
        pub fn set_table_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.table_creation_date_time = inp;
            self
        }
        /// <p>Read IOPs and Write IOPS on the table when the backup was created.</p>
        pub fn provisioned_throughput(mut self, inp: crate::model::ProvisionedThroughput) -> Self {
            self.provisioned_throughput = Some(inp);
            self
        }
        pub fn set_provisioned_throughput(
            mut self,
            inp: std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput = inp;
            self
        }
        /// <p>Number of items in the table. Note that this is an approximate value. </p>
        pub fn item_count(mut self, inp: i64) -> Self {
            self.item_count = Some(inp);
            self
        }
        pub fn set_item_count(mut self, inp: std::option::Option<i64>) -> Self {
            self.item_count = inp;
            self
        }
        /// <p>Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>PROVISIONED</code> - Sets the read/write capacity mode to <code>PROVISIONED</code>. We recommend using <code>PROVISIONED</code> for predictable workloads.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PAY_PER_REQUEST</code> - Sets the read/write capacity mode to <code>PAY_PER_REQUEST</code>. We recommend using <code>PAY_PER_REQUEST</code> for unpredictable workloads.
        /// </p>
        /// </li>
        /// </ul>
        pub fn billing_mode(mut self, inp: crate::model::BillingMode) -> Self {
            self.billing_mode = Some(inp);
            self
        }
        pub fn set_billing_mode(
            mut self,
            inp: std::option::Option<crate::model::BillingMode>,
        ) -> Self {
            self.billing_mode = inp;
            self
        }
        /// Consumes the builder and constructs a [`SourceTableDetails`](crate::model::SourceTableDetails)
        pub fn build(self) -> crate::model::SourceTableDetails {
            crate::model::SourceTableDetails {
                table_name: self.table_name,
                table_id: self.table_id,
                table_arn: self.table_arn,
                table_size_bytes: self.table_size_bytes.unwrap_or_default(),
                key_schema: self.key_schema,
                table_creation_date_time: self.table_creation_date_time,
                provisioned_throughput: self.provisioned_throughput,
                item_count: self.item_count,
                billing_mode: self.billing_mode,
            }
        }
    }
}
impl SourceTableDetails {
    /// Creates a new builder-style object to manufacture [`SourceTableDetails`](crate::model::SourceTableDetails)
    pub fn builder() -> crate::model::source_table_details::Builder {
        crate::model::source_table_details::Builder::default()
    }
}

/// <p>Contains the details of the backup created for the table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupDetails {
    /// <p>ARN associated with the backup.</p>
    #[serde(rename = "BackupArn")]
    #[serde(default)]
    pub backup_arn: std::option::Option<std::string::String>,
    /// <p>Name of the requested backup.</p>
    #[serde(rename = "BackupName")]
    #[serde(default)]
    pub backup_name: std::option::Option<std::string::String>,
    /// <p>Size of the backup in bytes.</p>
    #[serde(rename = "BackupSizeBytes")]
    #[serde(default)]
    pub backup_size_bytes: std::option::Option<i64>,
    /// <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED. </p>
    #[serde(rename = "BackupStatus")]
    #[serde(default)]
    pub backup_status: std::option::Option<crate::model::BackupStatus>,
    /// <p>BackupType:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>USER</code> - You create and manage these using the on-demand backup feature.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled, a <code>SYSTEM</code> backup is automatically
    /// created and is retained for 35 days (at no additional cost). System backups allow you to restore the deleted
    /// table to the state it was in just before the point of deletion.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AWS_BACKUP</code> - On-demand backup created by you from AWS Backup service.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "BackupType")]
    #[serde(default)]
    pub backup_type: std::option::Option<crate::model::BackupType>,
    /// <p>Time at which the backup was created. This is the request time of the backup. </p>
    #[serde(rename = "BackupCreationDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub backup_creation_date_time: std::option::Option<smithy_types::Instant>,
    /// <p>Time at which the automatic on-demand backup created by DynamoDB will expire. This <code>SYSTEM</code>
    /// on-demand backup expires automatically 35 days after its creation.</p>
    #[serde(rename = "BackupExpiryDateTime")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub backup_expiry_date_time: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for BackupDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupDetails");
        formatter.field("backup_arn", &self.backup_arn);
        formatter.field("backup_name", &self.backup_name);
        formatter.field("backup_size_bytes", &self.backup_size_bytes);
        formatter.field("backup_status", &self.backup_status);
        formatter.field("backup_type", &self.backup_type);
        formatter.field("backup_creation_date_time", &self.backup_creation_date_time);
        formatter.field("backup_expiry_date_time", &self.backup_expiry_date_time);
        formatter.finish()
    }
}
/// See [`BackupDetails`](crate::model::BackupDetails)
pub mod backup_details {
    /// A builder for [`BackupDetails`](crate::model::BackupDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) backup_arn: std::option::Option<std::string::String>,
        pub(crate) backup_name: std::option::Option<std::string::String>,
        pub(crate) backup_size_bytes: std::option::Option<i64>,
        pub(crate) backup_status: std::option::Option<crate::model::BackupStatus>,
        pub(crate) backup_type: std::option::Option<crate::model::BackupType>,
        pub(crate) backup_creation_date_time: std::option::Option<smithy_types::Instant>,
        pub(crate) backup_expiry_date_time: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>ARN associated with the backup.</p>
        pub fn backup_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.backup_arn = Some(inp.into());
            self
        }
        pub fn set_backup_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.backup_arn = inp;
            self
        }
        /// <p>Name of the requested backup.</p>
        pub fn backup_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.backup_name = Some(inp.into());
            self
        }
        pub fn set_backup_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.backup_name = inp;
            self
        }
        /// <p>Size of the backup in bytes.</p>
        pub fn backup_size_bytes(mut self, inp: i64) -> Self {
            self.backup_size_bytes = Some(inp);
            self
        }
        pub fn set_backup_size_bytes(mut self, inp: std::option::Option<i64>) -> Self {
            self.backup_size_bytes = inp;
            self
        }
        /// <p>Backup can be in one of the following states: CREATING, ACTIVE, DELETED. </p>
        pub fn backup_status(mut self, inp: crate::model::BackupStatus) -> Self {
            self.backup_status = Some(inp);
            self
        }
        pub fn set_backup_status(
            mut self,
            inp: std::option::Option<crate::model::BackupStatus>,
        ) -> Self {
            self.backup_status = inp;
            self
        }
        /// <p>BackupType:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>USER</code> - You create and manage these using the on-demand backup feature.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SYSTEM</code> - If you delete a table with point-in-time recovery enabled, a <code>SYSTEM</code> backup is automatically
        /// created and is retained for 35 days (at no additional cost). System backups allow you to restore the deleted
        /// table to the state it was in just before the point of deletion.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AWS_BACKUP</code> - On-demand backup created by you from AWS Backup service.</p>
        /// </li>
        /// </ul>
        pub fn backup_type(mut self, inp: crate::model::BackupType) -> Self {
            self.backup_type = Some(inp);
            self
        }
        pub fn set_backup_type(
            mut self,
            inp: std::option::Option<crate::model::BackupType>,
        ) -> Self {
            self.backup_type = inp;
            self
        }
        /// <p>Time at which the backup was created. This is the request time of the backup. </p>
        pub fn backup_creation_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.backup_creation_date_time = Some(inp);
            self
        }
        pub fn set_backup_creation_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.backup_creation_date_time = inp;
            self
        }
        /// <p>Time at which the automatic on-demand backup created by DynamoDB will expire. This <code>SYSTEM</code>
        /// on-demand backup expires automatically 35 days after its creation.</p>
        pub fn backup_expiry_date_time(mut self, inp: smithy_types::Instant) -> Self {
            self.backup_expiry_date_time = Some(inp);
            self
        }
        pub fn set_backup_expiry_date_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.backup_expiry_date_time = inp;
            self
        }
        /// Consumes the builder and constructs a [`BackupDetails`](crate::model::BackupDetails)
        pub fn build(self) -> crate::model::BackupDetails {
            crate::model::BackupDetails {
                backup_arn: self.backup_arn,
                backup_name: self.backup_name,
                backup_size_bytes: self.backup_size_bytes,
                backup_status: self.backup_status,
                backup_type: self.backup_type,
                backup_creation_date_time: self.backup_creation_date_time,
                backup_expiry_date_time: self.backup_expiry_date_time,
            }
        }
    }
}
impl BackupDetails {
    /// Creates a new builder-style object to manufacture [`BackupDetails`](crate::model::BackupDetails)
    pub fn builder() -> crate::model::backup_details::Builder {
        crate::model::backup_details::Builder::default()
    }
}

/// <p>Represents an operation to perform - either <code>DeleteItem</code> or
/// <code>PutItem</code>. You can only request one of these operations, not both, in a
/// single <code>WriteRequest</code>. If you do need to perform both of these operations, you
/// need to provide two separate <code>WriteRequest</code> objects.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteRequest {
    /// <p>A request to perform a <code>PutItem</code> operation.</p>
    #[serde(rename = "PutRequest")]
    #[serde(default)]
    pub put_request: std::option::Option<crate::model::PutRequest>,
    /// <p>A request to perform a <code>DeleteItem</code> operation.</p>
    #[serde(rename = "DeleteRequest")]
    #[serde(default)]
    pub delete_request: std::option::Option<crate::model::DeleteRequest>,
}
impl std::fmt::Debug for WriteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteRequest");
        formatter.field("put_request", &self.put_request);
        formatter.field("delete_request", &self.delete_request);
        formatter.finish()
    }
}
/// See [`WriteRequest`](crate::model::WriteRequest)
pub mod write_request {
    /// A builder for [`WriteRequest`](crate::model::WriteRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) put_request: std::option::Option<crate::model::PutRequest>,
        pub(crate) delete_request: std::option::Option<crate::model::DeleteRequest>,
    }
    impl Builder {
        /// <p>A request to perform a <code>PutItem</code> operation.</p>
        pub fn put_request(mut self, inp: crate::model::PutRequest) -> Self {
            self.put_request = Some(inp);
            self
        }
        pub fn set_put_request(
            mut self,
            inp: std::option::Option<crate::model::PutRequest>,
        ) -> Self {
            self.put_request = inp;
            self
        }
        /// <p>A request to perform a <code>DeleteItem</code> operation.</p>
        pub fn delete_request(mut self, inp: crate::model::DeleteRequest) -> Self {
            self.delete_request = Some(inp);
            self
        }
        pub fn set_delete_request(
            mut self,
            inp: std::option::Option<crate::model::DeleteRequest>,
        ) -> Self {
            self.delete_request = inp;
            self
        }
        /// Consumes the builder and constructs a [`WriteRequest`](crate::model::WriteRequest)
        pub fn build(self) -> crate::model::WriteRequest {
            crate::model::WriteRequest {
                put_request: self.put_request,
                delete_request: self.delete_request,
            }
        }
    }
}
impl WriteRequest {
    /// Creates a new builder-style object to manufacture [`WriteRequest`](crate::model::WriteRequest)
    pub fn builder() -> crate::model::write_request::Builder {
        crate::model::write_request::Builder::default()
    }
}

/// <p>Represents a request to perform a <code>DeleteItem</code> operation on an item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRequest {
    /// <p>A map of attribute name to attribute values, representing the primary key of the item to delete. All of the table's primary key attributes must be specified, and their data types must match those of the table's key schema.</p>
    #[serde(rename = "Key")]
    #[serde(default)]
    pub key: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
}
impl std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRequest");
        formatter.field("key", &self.key);
        formatter.finish()
    }
}
/// See [`DeleteRequest`](crate::model::DeleteRequest)
pub mod delete_request {
    /// A builder for [`DeleteRequest`](crate::model::DeleteRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
    }
    impl Builder {
        pub fn key(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.key.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.key = Some(hash_map);
            self
        }
        pub fn set_key(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRequest`](crate::model::DeleteRequest)
        pub fn build(self) -> crate::model::DeleteRequest {
            crate::model::DeleteRequest { key: self.key }
        }
    }
}
impl DeleteRequest {
    /// Creates a new builder-style object to manufacture [`DeleteRequest`](crate::model::DeleteRequest)
    pub fn builder() -> crate::model::delete_request::Builder {
        crate::model::delete_request::Builder::default()
    }
}

/// <p>Represents a request to perform a <code>PutItem</code> operation on an item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRequest {
    /// <p>A map of attribute name to attribute values, representing the primary key of an item to
    /// be processed by <code>PutItem</code>. All of the table's primary key attributes must be
    /// specified, and their data types must match those of the table's key schema. If any
    /// attributes are present in the item that are part of an index key schema for the table,
    /// their types must match the index key schema.</p>
    #[serde(rename = "Item")]
    #[serde(default)]
    pub item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
}
impl std::fmt::Debug for PutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRequest");
        formatter.field("item", &self.item);
        formatter.finish()
    }
}
/// See [`PutRequest`](crate::model::PutRequest)
pub mod put_request {
    /// A builder for [`PutRequest`](crate::model::PutRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
    }
    impl Builder {
        pub fn item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item = Some(hash_map);
            self
        }
        pub fn set_item(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutRequest`](crate::model::PutRequest)
        pub fn build(self) -> crate::model::PutRequest {
            crate::model::PutRequest { item: self.item }
        }
    }
}
impl PutRequest {
    /// Creates a new builder-style object to manufacture [`PutRequest`](crate::model::PutRequest)
    pub fn builder() -> crate::model::put_request::Builder {
        crate::model::put_request::Builder::default()
    }
}

/// <p>Represents a set of primary keys and, for each key, the attributes to retrieve from the table.</p>
/// <p>For each primary key, you must provide <i>all</i> of the key attributes. For example, with a
/// simple primary key, you only need to provide the partition key. For a composite
/// primary key, you must provide <i>both</i> the partition key and the sort key.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct KeysAndAttributes {
    /// <p>The primary key attribute values that define the items and the attributes associated with the items.</p>
    #[serde(rename = "Keys")]
    #[serde(default)]
    pub keys: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, crate::model::AttributeValue>>,
    >,
    /// <p>This is a legacy parameter.  Use <code>ProjectionExpression</code> instead.  For more information, see
    /// <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html">Legacy Conditional Parameters</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "AttributesToGet")]
    #[serde(default)]
    pub attributes_to_get: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The consistency of a read operation. If set to <code>true</code>, then a strongly consistent
    /// read is used; otherwise, an eventually consistent read is used.</p>
    #[serde(rename = "ConsistentRead")]
    #[serde(default)]
    pub consistent_read: std::option::Option<bool>,
    /// <p>A string that identifies one or more attributes to retrieve from the table. These attributes can include scalars,
    /// sets, or elements of a JSON document. The attributes in the <code>ProjectionExpression</code> must be separated by
    /// commas.</p>
    /// <p>If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ProjectionExpression")]
    #[serde(default)]
    pub projection_expression: std::option::Option<std::string::String>,
    /// <p>One or more substitution tokens for attribute names in an expression. The following are some use cases for using <code>ExpressionAttributeNames</code>:</p>
    /// <ul>
    /// <li>
    /// <p>To access an attribute whose name conflicts with a DynamoDB reserved word.</p>
    /// </li>
    /// <li>
    /// <p>To create a placeholder for repeating occurrences of an attribute name in an expression.</p>
    /// </li>
    /// <li>
    /// <p>To prevent special characters in an attribute name from being misinterpreted in an expression.</p>
    /// </li>
    /// </ul>
    /// <p>Use the <b>#</b> character in an expression to dereference an attribute name. For example, consider the following attribute name:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Percentile</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>The name of this attribute conflicts with a reserved word, so it cannot be used directly in an expression. (For the complete list of reserved words, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html">Reserved Words</a> in the <i>Amazon DynamoDB Developer Guide</i>). To work around this, you could specify the following for <code>ExpressionAttributeNames</code>:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>{"#P":"Percentile"}</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>You could then use this substitution in an expression, as in this example:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>#P = :val</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <note>
    /// <p>Tokens that begin with the <b>:</b> character are <i>expression attribute values</i>, which are placeholders for the actual value at runtime.</p>
    /// </note>
    /// <p>For more information on expression attribute names, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
    #[serde(rename = "ExpressionAttributeNames")]
    #[serde(default)]
    pub expression_attribute_names:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for KeysAndAttributes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("KeysAndAttributes");
        formatter.field("keys", &self.keys);
        formatter.field("attributes_to_get", &self.attributes_to_get);
        formatter.field("consistent_read", &self.consistent_read);
        formatter.field("projection_expression", &self.projection_expression);
        formatter.field(
            "expression_attribute_names",
            &self.expression_attribute_names,
        );
        formatter.finish()
    }
}
/// See [`KeysAndAttributes`](crate::model::KeysAndAttributes)
pub mod keys_and_attributes {
    /// A builder for [`KeysAndAttributes`](crate::model::KeysAndAttributes)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) keys: std::option::Option<
            std::vec::Vec<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        >,
        pub(crate) attributes_to_get: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) consistent_read: std::option::Option<bool>,
        pub(crate) projection_expression: std::option::Option<std::string::String>,
        pub(crate) expression_attribute_names: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        pub fn keys(
            mut self,
            inp: impl Into<std::collections::HashMap<std::string::String, crate::model::AttributeValue>>,
        ) -> Self {
            let mut v = self.keys.unwrap_or_default();
            v.push(inp.into());
            self.keys = Some(v);
            self
        }
        pub fn set_keys(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<
                    std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
                >,
            >,
        ) -> Self {
            self.keys = inp;
            self
        }
        pub fn attributes_to_get(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.attributes_to_get.unwrap_or_default();
            v.push(inp.into());
            self.attributes_to_get = Some(v);
            self
        }
        pub fn set_attributes_to_get(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attributes_to_get = inp;
            self
        }
        /// <p>The consistency of a read operation. If set to <code>true</code>, then a strongly consistent
        /// read is used; otherwise, an eventually consistent read is used.</p>
        pub fn consistent_read(mut self, inp: bool) -> Self {
            self.consistent_read = Some(inp);
            self
        }
        pub fn set_consistent_read(mut self, inp: std::option::Option<bool>) -> Self {
            self.consistent_read = inp;
            self
        }
        /// <p>A string that identifies one or more attributes to retrieve from the table. These attributes can include scalars,
        /// sets, or elements of a JSON document. The attributes in the <code>ProjectionExpression</code> must be separated by
        /// commas.</p>
        /// <p>If no attribute names are specified, then all attributes will be returned. If any of the requested attributes are not found, they will not appear in the result.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html">Accessing Item Attributes</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
        pub fn projection_expression(mut self, inp: impl Into<std::string::String>) -> Self {
            self.projection_expression = Some(inp.into());
            self
        }
        pub fn set_projection_expression(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.projection_expression = inp;
            self
        }
        pub fn expression_attribute_names(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.expression_attribute_names.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.expression_attribute_names = Some(hash_map);
            self
        }
        pub fn set_expression_attribute_names(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = inp;
            self
        }
        /// Consumes the builder and constructs a [`KeysAndAttributes`](crate::model::KeysAndAttributes)
        pub fn build(self) -> crate::model::KeysAndAttributes {
            crate::model::KeysAndAttributes {
                keys: self.keys,
                attributes_to_get: self.attributes_to_get,
                consistent_read: self.consistent_read,
                projection_expression: self.projection_expression,
                expression_attribute_names: self.expression_attribute_names,
            }
        }
    }
}
impl KeysAndAttributes {
    /// Creates a new builder-style object to manufacture [`KeysAndAttributes`](crate::model::KeysAndAttributes)
    pub fn builder() -> crate::model::keys_and_attributes::Builder {
        crate::model::keys_and_attributes::Builder::default()
    }
}

/// <p>
/// A PartiQL batch statement response..
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStatementResponse {
    /// <p>
    /// The error associated with a failed PartiQL batch statement.
    /// </p>
    #[serde(rename = "Error")]
    #[serde(default)]
    pub error: std::option::Option<crate::model::BatchStatementError>,
    /// <p>
    /// The table name associated with a failed PartiQL batch statement.
    /// </p>
    #[serde(rename = "TableName")]
    #[serde(default)]
    pub table_name: std::option::Option<std::string::String>,
    /// <p>
    /// A DynamoDB item associated with a BatchStatementResponse
    /// </p>
    #[serde(rename = "Item")]
    #[serde(default)]
    pub item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
    >,
}
impl std::fmt::Debug for BatchStatementResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStatementResponse");
        formatter.field("error", &self.error);
        formatter.field("table_name", &self.table_name);
        formatter.field("item", &self.item);
        formatter.finish()
    }
}
/// See [`BatchStatementResponse`](crate::model::BatchStatementResponse)
pub mod batch_statement_response {
    /// A builder for [`BatchStatementResponse`](crate::model::BatchStatementResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error: std::option::Option<crate::model::BatchStatementError>,
        pub(crate) table_name: std::option::Option<std::string::String>,
        pub(crate) item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
        >,
    }
    impl Builder {
        /// <p>
        /// The error associated with a failed PartiQL batch statement.
        /// </p>
        pub fn error(mut self, inp: crate::model::BatchStatementError) -> Self {
            self.error = Some(inp);
            self
        }
        pub fn set_error(
            mut self,
            inp: std::option::Option<crate::model::BatchStatementError>,
        ) -> Self {
            self.error = inp;
            self
        }
        /// <p>
        /// The table name associated with a failed PartiQL batch statement.
        /// </p>
        pub fn table_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.table_name = Some(inp.into());
            self
        }
        pub fn set_table_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.table_name = inp;
            self
        }
        pub fn item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeValue>,
        ) -> Self {
            let mut hash_map = self.item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.item = Some(hash_map);
            self
        }
        pub fn set_item(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = inp;
            self
        }
        /// Consumes the builder and constructs a [`BatchStatementResponse`](crate::model::BatchStatementResponse)
        pub fn build(self) -> crate::model::BatchStatementResponse {
            crate::model::BatchStatementResponse {
                error: self.error,
                table_name: self.table_name,
                item: self.item,
            }
        }
    }
}
impl BatchStatementResponse {
    /// Creates a new builder-style object to manufacture [`BatchStatementResponse`](crate::model::BatchStatementResponse)
    pub fn builder() -> crate::model::batch_statement_response::Builder {
        crate::model::batch_statement_response::Builder::default()
    }
}

/// <p>
/// An error associated with a statement in a PartiQL batch that was run.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStatementError {
    /// <p>
    /// The error code associated with the failed PartiQL batch statement.
    /// </p>
    #[serde(rename = "Code")]
    #[serde(default)]
    pub code: std::option::Option<crate::model::BatchStatementErrorCodeEnum>,
    /// <p>
    /// The error message associated with the PartiQL batch resposne.
    /// </p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BatchStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStatementError");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`BatchStatementError`](crate::model::BatchStatementError)
pub mod batch_statement_error {
    /// A builder for [`BatchStatementError`](crate::model::BatchStatementError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::BatchStatementErrorCodeEnum>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// The error code associated with the failed PartiQL batch statement.
        /// </p>
        pub fn code(mut self, inp: crate::model::BatchStatementErrorCodeEnum) -> Self {
            self.code = Some(inp);
            self
        }
        pub fn set_code(
            mut self,
            inp: std::option::Option<crate::model::BatchStatementErrorCodeEnum>,
        ) -> Self {
            self.code = inp;
            self
        }
        /// <p>
        /// The error message associated with the PartiQL batch resposne.
        /// </p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`BatchStatementError`](crate::model::BatchStatementError)
        pub fn build(self) -> crate::model::BatchStatementError {
            crate::model::BatchStatementError {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BatchStatementError {
    /// Creates a new builder-style object to manufacture [`BatchStatementError`](crate::model::BatchStatementError)
    pub fn builder() -> crate::model::batch_statement_error::Builder {
        crate::model::batch_statement_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatchStatementErrorCodeEnum {
    AccessDenied,
    ConditionalCheckFailed,
    DuplicateItem,
    InternalServerError,
    ItemCollectionSizeLimitExceeded,
    ProvisionedThroughputExceeded,
    RequestLimitExceeded,
    ResourceNotFound,
    ThrottlingError,
    TransactionConflict,
    ValidationError,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for BatchStatementErrorCodeEnum {
    fn from(s: &str) -> Self {
        match s {
            "AccessDenied" => BatchStatementErrorCodeEnum::AccessDenied,
            "ConditionalCheckFailed" => BatchStatementErrorCodeEnum::ConditionalCheckFailed,
            "DuplicateItem" => BatchStatementErrorCodeEnum::DuplicateItem,
            "InternalServerError" => BatchStatementErrorCodeEnum::InternalServerError,
            "ItemCollectionSizeLimitExceeded" => {
                BatchStatementErrorCodeEnum::ItemCollectionSizeLimitExceeded
            }
            "ProvisionedThroughputExceeded" => {
                BatchStatementErrorCodeEnum::ProvisionedThroughputExceeded
            }
            "RequestLimitExceeded" => BatchStatementErrorCodeEnum::RequestLimitExceeded,
            "ResourceNotFound" => BatchStatementErrorCodeEnum::ResourceNotFound,
            "ThrottlingError" => BatchStatementErrorCodeEnum::ThrottlingError,
            "TransactionConflict" => BatchStatementErrorCodeEnum::TransactionConflict,
            "ValidationError" => BatchStatementErrorCodeEnum::ValidationError,
            other => BatchStatementErrorCodeEnum::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for BatchStatementErrorCodeEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(BatchStatementErrorCodeEnum::from(s))
    }
}
impl BatchStatementErrorCodeEnum {
    pub fn as_str(&self) -> &str {
        match self {
            BatchStatementErrorCodeEnum::AccessDenied => "AccessDenied",
            BatchStatementErrorCodeEnum::ConditionalCheckFailed => "ConditionalCheckFailed",
            BatchStatementErrorCodeEnum::DuplicateItem => "DuplicateItem",
            BatchStatementErrorCodeEnum::InternalServerError => "InternalServerError",
            BatchStatementErrorCodeEnum::ItemCollectionSizeLimitExceeded => {
                "ItemCollectionSizeLimitExceeded"
            }
            BatchStatementErrorCodeEnum::ProvisionedThroughputExceeded => {
                "ProvisionedThroughputExceeded"
            }
            BatchStatementErrorCodeEnum::RequestLimitExceeded => "RequestLimitExceeded",
            BatchStatementErrorCodeEnum::ResourceNotFound => "ResourceNotFound",
            BatchStatementErrorCodeEnum::ThrottlingError => "ThrottlingError",
            BatchStatementErrorCodeEnum::TransactionConflict => "TransactionConflict",
            BatchStatementErrorCodeEnum::ValidationError => "ValidationError",
            BatchStatementErrorCodeEnum::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for BatchStatementErrorCodeEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for BatchStatementErrorCodeEnum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>
/// A PartiQL batch statement request.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BatchStatementRequest {
    /// <p>
    /// A valid PartiQL statement.
    /// </p>
    #[serde(rename = "Statement")]
    #[serde(default)]
    pub statement: std::option::Option<std::string::String>,
    /// <p>
    /// The parameters associated with a PartiQL statement in the batch request.
    /// </p>
    #[serde(rename = "Parameters")]
    #[serde(default)]
    pub parameters: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
    /// <p>
    /// The read consistency of the PartiQL batch request.
    /// </p>
    #[serde(rename = "ConsistentRead")]
    #[serde(default)]
    pub consistent_read: std::option::Option<bool>,
}
impl std::fmt::Debug for BatchStatementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BatchStatementRequest");
        formatter.field("statement", &self.statement);
        formatter.field("parameters", &self.parameters);
        formatter.field("consistent_read", &self.consistent_read);
        formatter.finish()
    }
}
/// See [`BatchStatementRequest`](crate::model::BatchStatementRequest)
pub mod batch_statement_request {
    /// A builder for [`BatchStatementRequest`](crate::model::BatchStatementRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) statement: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        pub(crate) consistent_read: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>
        /// A valid PartiQL statement.
        /// </p>
        pub fn statement(mut self, inp: impl Into<std::string::String>) -> Self {
            self.statement = Some(inp.into());
            self
        }
        pub fn set_statement(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.statement = inp;
            self
        }
        pub fn parameters(mut self, inp: impl Into<crate::model::AttributeValue>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(inp.into());
            self.parameters = Some(v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::AttributeValue>>,
        ) -> Self {
            self.parameters = inp;
            self
        }
        /// <p>
        /// The read consistency of the PartiQL batch request.
        /// </p>
        pub fn consistent_read(mut self, inp: bool) -> Self {
            self.consistent_read = Some(inp);
            self
        }
        pub fn set_consistent_read(mut self, inp: std::option::Option<bool>) -> Self {
            self.consistent_read = inp;
            self
        }
        /// Consumes the builder and constructs a [`BatchStatementRequest`](crate::model::BatchStatementRequest)
        pub fn build(self) -> crate::model::BatchStatementRequest {
            crate::model::BatchStatementRequest {
                statement: self.statement,
                parameters: self.parameters,
                consistent_read: self.consistent_read,
            }
        }
    }
}
impl BatchStatementRequest {
    /// Creates a new builder-style object to manufacture [`BatchStatementRequest`](crate::model::BatchStatementRequest)
    pub fn builder() -> crate::model::batch_statement_request::Builder {
        crate::model::batch_statement_request::Builder::default()
    }
}
