// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn batch_execute_statement_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_execute_statement_output::Builder,
) -> Result<crate::output::batch_execute_statement_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchExecuteStatementOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_responses(parsed_body.responses);
    Ok(builder)
}

pub fn batch_get_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_get_item_output::Builder,
) -> Result<crate::output::batch_get_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchGetItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_responses(parsed_body.responses);
    builder = builder.set_unprocessed_keys(parsed_body.unprocessed_keys);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    Ok(builder)
}

pub fn batch_write_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::batch_write_item_output::Builder,
) -> Result<crate::output::batch_write_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::BatchWriteItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_unprocessed_items(parsed_body.unprocessed_items);
    builder = builder.set_item_collection_metrics(parsed_body.item_collection_metrics);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    Ok(builder)
}

pub fn create_backup_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_backup_output::Builder,
) -> Result<crate::output::create_backup_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateBackupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_backup_details(parsed_body.backup_details);
    Ok(builder)
}

pub fn create_global_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_global_table_output::Builder,
) -> Result<crate::output::create_global_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateGlobalTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_table_description(parsed_body.global_table_description);
    Ok(builder)
}

pub fn create_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::create_table_output::Builder,
) -> Result<crate::output::create_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_description(parsed_body.table_description);
    Ok(builder)
}

pub fn delete_backup_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_backup_output::Builder,
) -> Result<crate::output::delete_backup_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteBackupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_backup_description(parsed_body.backup_description);
    Ok(builder)
}

pub fn delete_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_item_output::Builder,
) -> Result<crate::output::delete_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_attributes(parsed_body.attributes);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    builder = builder.set_item_collection_metrics(parsed_body.item_collection_metrics);
    Ok(builder)
}

pub fn delete_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::delete_table_output::Builder,
) -> Result<crate::output::delete_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_description(parsed_body.table_description);
    Ok(builder)
}

pub fn describe_backup_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_backup_output::Builder,
) -> Result<crate::output::describe_backup_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeBackupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_backup_description(parsed_body.backup_description);
    Ok(builder)
}

pub fn describe_continuous_backups_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_continuous_backups_output::Builder,
) -> Result<crate::output::describe_continuous_backups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeContinuousBackupsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder =
        builder.set_continuous_backups_description(parsed_body.continuous_backups_description);
    Ok(builder)
}

pub fn describe_contributor_insights_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_contributor_insights_output::Builder,
) -> Result<crate::output::describe_contributor_insights_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeContributorInsightsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_name(parsed_body.table_name);
    builder = builder.set_index_name(parsed_body.index_name);
    builder =
        builder.set_contributor_insights_rule_list(parsed_body.contributor_insights_rule_list);
    builder = builder.set_contributor_insights_status(parsed_body.contributor_insights_status);
    builder = builder.set_last_update_date_time(parsed_body.last_update_date_time);
    builder = builder.set_failure_exception(parsed_body.failure_exception);
    Ok(builder)
}

pub fn describe_endpoints_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_endpoints_output::Builder,
) -> Result<crate::output::describe_endpoints_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeEndpointsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_endpoints(parsed_body.endpoints);
    Ok(builder)
}

pub fn describe_export_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_export_output::Builder,
) -> Result<crate::output::describe_export_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeExportOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_export_description(parsed_body.export_description);
    Ok(builder)
}

pub fn describe_global_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_global_table_output::Builder,
) -> Result<crate::output::describe_global_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeGlobalTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_table_description(parsed_body.global_table_description);
    Ok(builder)
}

pub fn describe_global_table_settings_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_global_table_settings_output::Builder,
) -> Result<crate::output::describe_global_table_settings_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeGlobalTableSettingsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_table_name(parsed_body.global_table_name);
    builder = builder.set_replica_settings(parsed_body.replica_settings);
    Ok(builder)
}

pub fn describe_kinesis_streaming_destination_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_kinesis_streaming_destination_output::Builder,
) -> Result<crate::output::describe_kinesis_streaming_destination_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeKinesisStreamingDestinationOutputBody =
        if inp.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(inp)?
        };
    builder = builder.set_table_name(parsed_body.table_name);
    builder =
        builder.set_kinesis_data_stream_destinations(parsed_body.kinesis_data_stream_destinations);
    Ok(builder)
}

pub fn describe_limits_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_limits_output::Builder,
) -> Result<crate::output::describe_limits_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeLimitsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder =
        builder.set_account_max_read_capacity_units(parsed_body.account_max_read_capacity_units);
    builder =
        builder.set_account_max_write_capacity_units(parsed_body.account_max_write_capacity_units);
    builder = builder.set_table_max_read_capacity_units(parsed_body.table_max_read_capacity_units);
    builder =
        builder.set_table_max_write_capacity_units(parsed_body.table_max_write_capacity_units);
    Ok(builder)
}

pub fn describe_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_table_output::Builder,
) -> Result<crate::output::describe_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table(parsed_body.table);
    Ok(builder)
}

pub fn describe_table_replica_auto_scaling_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_table_replica_auto_scaling_output::Builder,
) -> Result<crate::output::describe_table_replica_auto_scaling_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTableReplicaAutoScalingOutputBody =
        if inp.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(inp)?
        };
    builder =
        builder.set_table_auto_scaling_description(parsed_body.table_auto_scaling_description);
    Ok(builder)
}

pub fn describe_time_to_live_deser_operation(
    inp: &[u8],
    mut builder: crate::output::describe_time_to_live_output::Builder,
) -> Result<crate::output::describe_time_to_live_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeTimeToLiveOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_time_to_live_description(parsed_body.time_to_live_description);
    Ok(builder)
}

pub fn disable_kinesis_streaming_destination_deser_operation(
    inp: &[u8],
    mut builder: crate::output::disable_kinesis_streaming_destination_output::Builder,
) -> Result<crate::output::disable_kinesis_streaming_destination_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DisableKinesisStreamingDestinationOutputBody =
        if inp.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(inp)?
        };
    builder = builder.set_table_name(parsed_body.table_name);
    builder = builder.set_stream_arn(parsed_body.stream_arn);
    builder = builder.set_destination_status(parsed_body.destination_status);
    Ok(builder)
}

pub fn enable_kinesis_streaming_destination_deser_operation(
    inp: &[u8],
    mut builder: crate::output::enable_kinesis_streaming_destination_output::Builder,
) -> Result<crate::output::enable_kinesis_streaming_destination_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::EnableKinesisStreamingDestinationOutputBody =
        if inp.is_empty() {
            // To enable JSON parsing to succeed, replace an empty body
            // with an empty JSON body. If a member was required, it will fail slightly later
            // during the operation construction phase when a required field was missing.
            serde_json::from_slice(b"{}")?
        } else {
            serde_json::from_slice(inp)?
        };
    builder = builder.set_table_name(parsed_body.table_name);
    builder = builder.set_stream_arn(parsed_body.stream_arn);
    builder = builder.set_destination_status(parsed_body.destination_status);
    Ok(builder)
}

pub fn execute_statement_deser_operation(
    inp: &[u8],
    mut builder: crate::output::execute_statement_output::Builder,
) -> Result<crate::output::execute_statement_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ExecuteStatementOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_items(parsed_body.items);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn execute_transaction_deser_operation(
    inp: &[u8],
    mut builder: crate::output::execute_transaction_output::Builder,
) -> Result<crate::output::execute_transaction_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ExecuteTransactionOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_responses(parsed_body.responses);
    Ok(builder)
}

pub fn export_table_to_point_in_time_deser_operation(
    inp: &[u8],
    mut builder: crate::output::export_table_to_point_in_time_output::Builder,
) -> Result<crate::output::export_table_to_point_in_time_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ExportTableToPointInTimeOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_export_description(parsed_body.export_description);
    Ok(builder)
}

pub fn get_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::get_item_output::Builder,
) -> Result<crate::output::get_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_item(parsed_body.item);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    Ok(builder)
}

pub fn list_backups_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_backups_output::Builder,
) -> Result<crate::output::list_backups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListBackupsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_backup_summaries(parsed_body.backup_summaries);
    builder = builder.set_last_evaluated_backup_arn(parsed_body.last_evaluated_backup_arn);
    Ok(builder)
}

pub fn list_contributor_insights_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_contributor_insights_output::Builder,
) -> Result<crate::output::list_contributor_insights_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListContributorInsightsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder =
        builder.set_contributor_insights_summaries(parsed_body.contributor_insights_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_exports_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_exports_output::Builder,
) -> Result<crate::output::list_exports_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListExportsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_export_summaries(parsed_body.export_summaries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_global_tables_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_global_tables_output::Builder,
) -> Result<crate::output::list_global_tables_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListGlobalTablesOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_tables(parsed_body.global_tables);
    builder =
        builder.set_last_evaluated_global_table_name(parsed_body.last_evaluated_global_table_name);
    Ok(builder)
}

pub fn list_tables_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_tables_output::Builder,
) -> Result<crate::output::list_tables_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTablesOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_names(parsed_body.table_names);
    builder = builder.set_last_evaluated_table_name(parsed_body.last_evaluated_table_name);
    Ok(builder)
}

pub fn list_tags_of_resource_deser_operation(
    inp: &[u8],
    mut builder: crate::output::list_tags_of_resource_output::Builder,
) -> Result<crate::output::list_tags_of_resource_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsOfResourceOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn put_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::put_item_output::Builder,
) -> Result<crate::output::put_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_attributes(parsed_body.attributes);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    builder = builder.set_item_collection_metrics(parsed_body.item_collection_metrics);
    Ok(builder)
}

pub fn query_deser_operation(
    inp: &[u8],
    mut builder: crate::output::query_output::Builder,
) -> Result<crate::output::query_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::QueryOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_items(parsed_body.items);
    builder = builder.set_count(parsed_body.count);
    builder = builder.set_scanned_count(parsed_body.scanned_count);
    builder = builder.set_last_evaluated_key(parsed_body.last_evaluated_key);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    Ok(builder)
}

pub fn restore_table_from_backup_deser_operation(
    inp: &[u8],
    mut builder: crate::output::restore_table_from_backup_output::Builder,
) -> Result<crate::output::restore_table_from_backup_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::RestoreTableFromBackupOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_description(parsed_body.table_description);
    Ok(builder)
}

pub fn restore_table_to_point_in_time_deser_operation(
    inp: &[u8],
    mut builder: crate::output::restore_table_to_point_in_time_output::Builder,
) -> Result<crate::output::restore_table_to_point_in_time_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::RestoreTableToPointInTimeOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_description(parsed_body.table_description);
    Ok(builder)
}

pub fn scan_deser_operation(
    inp: &[u8],
    mut builder: crate::output::scan_output::Builder,
) -> Result<crate::output::scan_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ScanOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_items(parsed_body.items);
    builder = builder.set_count(parsed_body.count);
    builder = builder.set_scanned_count(parsed_body.scanned_count);
    builder = builder.set_last_evaluated_key(parsed_body.last_evaluated_key);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    Ok(builder)
}

pub fn transact_get_items_deser_operation(
    inp: &[u8],
    mut builder: crate::output::transact_get_items_output::Builder,
) -> Result<crate::output::transact_get_items_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::TransactGetItemsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    builder = builder.set_responses(parsed_body.responses);
    Ok(builder)
}

pub fn transact_write_items_deser_operation(
    inp: &[u8],
    mut builder: crate::output::transact_write_items_output::Builder,
) -> Result<crate::output::transact_write_items_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::TransactWriteItemsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    builder = builder.set_item_collection_metrics(parsed_body.item_collection_metrics);
    Ok(builder)
}

pub fn update_continuous_backups_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_continuous_backups_output::Builder,
) -> Result<crate::output::update_continuous_backups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateContinuousBackupsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder =
        builder.set_continuous_backups_description(parsed_body.continuous_backups_description);
    Ok(builder)
}

pub fn update_contributor_insights_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_contributor_insights_output::Builder,
) -> Result<crate::output::update_contributor_insights_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateContributorInsightsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_name(parsed_body.table_name);
    builder = builder.set_index_name(parsed_body.index_name);
    builder = builder.set_contributor_insights_status(parsed_body.contributor_insights_status);
    Ok(builder)
}

pub fn update_global_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_global_table_output::Builder,
) -> Result<crate::output::update_global_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateGlobalTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_table_description(parsed_body.global_table_description);
    Ok(builder)
}

pub fn update_global_table_settings_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_global_table_settings_output::Builder,
) -> Result<crate::output::update_global_table_settings_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateGlobalTableSettingsOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_global_table_name(parsed_body.global_table_name);
    builder = builder.set_replica_settings(parsed_body.replica_settings);
    Ok(builder)
}

pub fn update_item_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_item_output::Builder,
) -> Result<crate::output::update_item_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateItemOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_attributes(parsed_body.attributes);
    builder = builder.set_consumed_capacity(parsed_body.consumed_capacity);
    builder = builder.set_item_collection_metrics(parsed_body.item_collection_metrics);
    Ok(builder)
}

pub fn update_table_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_table_output::Builder,
) -> Result<crate::output::update_table_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTableOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_table_description(parsed_body.table_description);
    Ok(builder)
}

pub fn update_table_replica_auto_scaling_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_table_replica_auto_scaling_output::Builder,
) -> Result<crate::output::update_table_replica_auto_scaling_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTableReplicaAutoScalingOutputBody = if inp.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder =
        builder.set_table_auto_scaling_description(parsed_body.table_auto_scaling_description);
    Ok(builder)
}

pub fn update_time_to_live_deser_operation(
    inp: &[u8],
    mut builder: crate::output::update_time_to_live_output::Builder,
) -> Result<crate::output::update_time_to_live_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateTimeToLiveOutputBody = if inp.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(inp)?
    };
    builder = builder.set_time_to_live_specification(parsed_body.time_to_live_specification);
    Ok(builder)
}
