// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchExecuteStatementError {
    pub kind: BatchExecuteStatementErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchExecuteStatementErrorKind {
    InternalServerError(crate::error::InternalServerError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchExecuteStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchExecuteStatementErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            BatchExecuteStatementErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchExecuteStatementErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchExecuteStatementError {
    fn code(&self) -> Option<&str> {
        BatchExecuteStatementError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchExecuteStatementError {
    pub fn new(kind: BatchExecuteStatementErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchExecuteStatementErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchExecuteStatementErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for BatchExecuteStatementError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchExecuteStatementErrorKind::InternalServerError(_inner) => Some(_inner),
            BatchExecuteStatementErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            BatchExecuteStatementErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetItemError {
    pub kind: BatchGetItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            BatchGetItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            BatchGetItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            BatchGetItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchGetItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            BatchGetItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetItemError {
    fn code(&self) -> Option<&str> {
        BatchGetItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetItemError {
    pub fn new(kind: BatchGetItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for BatchGetItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetItemErrorKind::InternalServerError(_inner) => Some(_inner),
            BatchGetItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            BatchGetItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            BatchGetItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            BatchGetItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            BatchGetItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchWriteItemError {
    pub kind: BatchWriteItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchWriteItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(crate::error::ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchWriteItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchWriteItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            BatchWriteItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchWriteItemError {
    fn code(&self) -> Option<&str> {
        BatchWriteItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchWriteItemError {
    pub fn new(kind: BatchWriteItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchWriteItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchWriteItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for BatchWriteItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchWriteItemErrorKind::InternalServerError(_inner) => Some(_inner),
            BatchWriteItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            BatchWriteItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            BatchWriteItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            BatchWriteItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            BatchWriteItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            BatchWriteItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBackupError {
    pub kind: CreateBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBackupErrorKind {
    BackupInUseError(crate::error::BackupInUseError),
    ContinuousBackupsUnavailableError(crate::error::ContinuousBackupsUnavailableError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    TableInUseError(crate::error::TableInUseError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBackupErrorKind::BackupInUseError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::ContinuousBackupsUnavailableError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::TableInUseError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            CreateBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBackupError {
    fn code(&self) -> Option<&str> {
        CreateBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBackupError {
    pub fn new(kind: CreateBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBackupErrorKind::BackupInUseError(_inner) => Some(_inner),
            CreateBackupErrorKind::ContinuousBackupsUnavailableError(_inner) => Some(_inner),
            CreateBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateBackupErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            CreateBackupErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateBackupErrorKind::TableInUseError(_inner) => Some(_inner),
            CreateBackupErrorKind::TableNotFoundError(_inner) => Some(_inner),
            CreateBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGlobalTableError {
    pub kind: CreateGlobalTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGlobalTableErrorKind {
    GlobalTableAlreadyExistsError(crate::error::GlobalTableAlreadyExistsError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGlobalTableErrorKind::GlobalTableAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateGlobalTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateGlobalTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateGlobalTableErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateGlobalTableErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            CreateGlobalTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGlobalTableError {
    fn code(&self) -> Option<&str> {
        CreateGlobalTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGlobalTableError {
    pub fn new(kind: CreateGlobalTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGlobalTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGlobalTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateGlobalTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGlobalTableErrorKind::GlobalTableAlreadyExistsError(_inner) => Some(_inner),
            CreateGlobalTableErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateGlobalTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            CreateGlobalTableErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateGlobalTableErrorKind::TableNotFoundError(_inner) => Some(_inner),
            CreateGlobalTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTableError {
    pub kind: CreateTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTableErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            CreateTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateTableErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateTableErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            CreateTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTableError {
    fn code(&self) -> Option<&str> {
        CreateTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTableError {
    pub fn new(kind: CreateTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for CreateTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTableErrorKind::InternalServerError(_inner) => Some(_inner),
            CreateTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            CreateTableErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateTableErrorKind::ResourceInUseError(_inner) => Some(_inner),
            CreateTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBackupError {
    pub kind: DeleteBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBackupErrorKind {
    BackupInUseError(crate::error::BackupInUseError),
    BackupNotFoundError(crate::error::BackupNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBackupErrorKind::BackupInUseError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::BackupNotFoundError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBackupError {
    fn code(&self) -> Option<&str> {
        DeleteBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBackupError {
    pub fn new(kind: DeleteBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBackupErrorKind::BackupInUseError(_inner) => Some(_inner),
            DeleteBackupErrorKind::BackupNotFoundError(_inner) => Some(_inner),
            DeleteBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteBackupErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DeleteBackupErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteItemError {
    pub kind: DeleteItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteItemErrorKind {
    ConditionalCheckFailedError(crate::error::ConditionalCheckFailedError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(crate::error::ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionConflictError(crate::error::TransactionConflictError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteItemErrorKind::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::TransactionConflictError(_inner) => _inner.fmt(f),
            DeleteItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteItemError {
    fn code(&self) -> Option<&str> {
        DeleteItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteItemError {
    pub fn new(kind: DeleteItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteItemErrorKind::ConditionalCheckFailedError(_inner) => Some(_inner),
            DeleteItemErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DeleteItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            DeleteItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            DeleteItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            DeleteItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteItemErrorKind::TransactionConflictError(_inner) => Some(_inner),
            DeleteItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTableError {
    pub kind: DeleteTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTableErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTableError {
    fn code(&self) -> Option<&str> {
        DeleteTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTableError {
    pub fn new(kind: DeleteTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DeleteTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTableErrorKind::InternalServerError(_inner) => Some(_inner),
            DeleteTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DeleteTableErrorKind::LimitExceededError(_inner) => Some(_inner),
            DeleteTableErrorKind::ResourceInUseError(_inner) => Some(_inner),
            DeleteTableErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeBackupError {
    pub kind: DescribeBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeBackupErrorKind {
    BackupNotFoundError(crate::error::BackupNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeBackupErrorKind::BackupNotFoundError(_inner) => _inner.fmt(f),
            DescribeBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeBackupErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeBackupError {
    fn code(&self) -> Option<&str> {
        DescribeBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeBackupError {
    pub fn new(kind: DescribeBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeBackupErrorKind::BackupNotFoundError(_inner) => Some(_inner),
            DescribeBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeBackupErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContinuousBackupsError {
    pub kind: DescribeContinuousBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContinuousBackupsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContinuousBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContinuousBackupsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContinuousBackupsError {
    fn code(&self) -> Option<&str> {
        DescribeContinuousBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContinuousBackupsError {
    pub fn new(kind: DescribeContinuousBackupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContinuousBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContinuousBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeContinuousBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContinuousBackupsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeContinuousBackupsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeContinuousBackupsErrorKind::TableNotFoundError(_inner) => Some(_inner),
            DescribeContinuousBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeContributorInsightsError {
    pub kind: DescribeContributorInsightsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeContributorInsightsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeContributorInsightsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeContributorInsightsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeContributorInsightsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeContributorInsightsError {
    fn code(&self) -> Option<&str> {
        DescribeContributorInsightsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeContributorInsightsError {
    pub fn new(kind: DescribeContributorInsightsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeContributorInsightsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeContributorInsightsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeContributorInsightsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeContributorInsightsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeContributorInsightsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeContributorInsightsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEndpointsError {
    pub kind: DescribeEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEndpointsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEndpointsError {
    fn code(&self) -> Option<&str> {
        DescribeEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEndpointsError {
    pub fn new(kind: DescribeEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportError {
    pub kind: DescribeExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportErrorKind {
    ExportNotFoundError(crate::error::ExportNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    LimitExceededError(crate::error::LimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportErrorKind::ExportNotFoundError(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportError {
    fn code(&self) -> Option<&str> {
        DescribeExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportError {
    pub fn new(kind: DescribeExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportErrorKind::ExportNotFoundError(_inner) => Some(_inner),
            DescribeExportErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeExportErrorKind::LimitExceededError(_inner) => Some(_inner),
            DescribeExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalTableError {
    pub kind: DescribeGlobalTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalTableErrorKind {
    GlobalTableNotFoundError(crate::error::GlobalTableNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalTableErrorKind::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            DescribeGlobalTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeGlobalTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeGlobalTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalTableError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalTableError {
    pub fn new(kind: DescribeGlobalTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeGlobalTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalTableErrorKind::GlobalTableNotFoundError(_inner) => Some(_inner),
            DescribeGlobalTableErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeGlobalTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeGlobalTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalTableSettingsError {
    pub kind: DescribeGlobalTableSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalTableSettingsErrorKind {
    GlobalTableNotFoundError(crate::error::GlobalTableNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalTableSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalTableSettingsErrorKind::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalTableSettingsError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalTableSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalTableSettingsError {
    pub fn new(kind: DescribeGlobalTableSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalTableSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalTableSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeGlobalTableSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalTableSettingsErrorKind::GlobalTableNotFoundError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeKinesisStreamingDestinationError {
    pub kind: DescribeKinesisStreamingDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeKinesisStreamingDestinationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DescribeKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                _inner.fmt(f)
            }
            DescribeKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DescribeKinesisStreamingDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeKinesisStreamingDestinationError {
    fn code(&self) -> Option<&str> {
        DescribeKinesisStreamingDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeKinesisStreamingDestinationError {
    pub fn new(
        kind: DescribeKinesisStreamingDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DescribeKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                Some(_inner)
            }
            DescribeKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            DescribeKinesisStreamingDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLimitsError {
    pub kind: DescribeLimitsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLimitsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLimitsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeLimitsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeLimitsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLimitsError {
    fn code(&self) -> Option<&str> {
        DescribeLimitsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLimitsError {
    pub fn new(kind: DescribeLimitsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLimitsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLimitsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLimitsErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeLimitsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeLimitsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTableError {
    pub kind: DescribeTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTableErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeTableErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTableError {
    fn code(&self) -> Option<&str> {
        DescribeTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTableError {
    pub fn new(kind: DescribeTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTableErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeTableErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTableReplicaAutoScalingError {
    pub kind: DescribeTableReplicaAutoScalingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTableReplicaAutoScalingErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTableReplicaAutoScalingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTableReplicaAutoScalingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTableReplicaAutoScalingErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DescribeTableReplicaAutoScalingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTableReplicaAutoScalingError {
    fn code(&self) -> Option<&str> {
        DescribeTableReplicaAutoScalingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTableReplicaAutoScalingError {
    pub fn new(kind: DescribeTableReplicaAutoScalingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTableReplicaAutoScalingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTableReplicaAutoScalingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeTableReplicaAutoScalingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTableReplicaAutoScalingErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTableReplicaAutoScalingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTableReplicaAutoScalingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTimeToLiveError {
    pub kind: DescribeTimeToLiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTimeToLiveErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTimeToLiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTimeToLiveErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTimeToLiveError {
    fn code(&self) -> Option<&str> {
        DescribeTimeToLiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTimeToLiveError {
    pub fn new(kind: DescribeTimeToLiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTimeToLiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTimeToLiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeTimeToLiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTimeToLiveErrorKind::InternalServerError(_inner) => Some(_inner),
            DescribeTimeToLiveErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            DescribeTimeToLiveErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTimeToLiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableKinesisStreamingDestinationError {
    pub kind: DisableKinesisStreamingDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableKinesisStreamingDestinationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            DisableKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                _inner.fmt(f)
            }
            DisableKinesisStreamingDestinationErrorKind::LimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            DisableKinesisStreamingDestinationErrorKind::ResourceInUseError(_inner) => {
                _inner.fmt(f)
            }
            DisableKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DisableKinesisStreamingDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableKinesisStreamingDestinationError {
    fn code(&self) -> Option<&str> {
        DisableKinesisStreamingDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableKinesisStreamingDestinationError {
    pub fn new(
        kind: DisableKinesisStreamingDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DisableKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => {
                Some(_inner)
            }
            DisableKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                Some(_inner)
            }
            DisableKinesisStreamingDestinationErrorKind::LimitExceededError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationErrorKind::ResourceInUseError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            DisableKinesisStreamingDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableKinesisStreamingDestinationError {
    pub kind: EnableKinesisStreamingDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableKinesisStreamingDestinationErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => {
                _inner.fmt(f)
            }
            EnableKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                _inner.fmt(f)
            }
            EnableKinesisStreamingDestinationErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            EnableKinesisStreamingDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableKinesisStreamingDestinationError {
    fn code(&self) -> Option<&str> {
        EnableKinesisStreamingDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableKinesisStreamingDestinationError {
    pub fn new(
        kind: EnableKinesisStreamingDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableKinesisStreamingDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for EnableKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableKinesisStreamingDestinationErrorKind::InternalServerError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationErrorKind::InvalidEndpointError(_inner) => {
                Some(_inner)
            }
            EnableKinesisStreamingDestinationErrorKind::LimitExceededError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationErrorKind::ResourceInUseError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationErrorKind::ResourceNotFoundError(_inner) => {
                Some(_inner)
            }
            EnableKinesisStreamingDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExecuteStatementError {
    pub kind: ExecuteStatementErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExecuteStatementErrorKind {
    ConditionalCheckFailedError(crate::error::ConditionalCheckFailedError),
    DuplicateItemError(crate::error::DuplicateItemError),
    InternalServerError(crate::error::InternalServerError),
    ItemCollectionSizeLimitExceededError(crate::error::ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionConflictError(crate::error::TransactionConflictError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExecuteStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExecuteStatementErrorKind::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::DuplicateItemError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::ItemCollectionSizeLimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            ExecuteStatementErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::TransactionConflictError(_inner) => _inner.fmt(f),
            ExecuteStatementErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExecuteStatementError {
    fn code(&self) -> Option<&str> {
        ExecuteStatementError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExecuteStatementError {
    pub fn new(kind: ExecuteStatementErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExecuteStatementErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExecuteStatementErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ExecuteStatementError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExecuteStatementErrorKind::ConditionalCheckFailedError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::DuplicateItemError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::InternalServerError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            ExecuteStatementErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::TransactionConflictError(_inner) => Some(_inner),
            ExecuteStatementErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExecuteTransactionError {
    pub kind: ExecuteTransactionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExecuteTransactionErrorKind {
    IdempotentParameterMismatchError(crate::error::IdempotentParameterMismatchError),
    InternalServerError(crate::error::InternalServerError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionCanceledError(crate::error::TransactionCanceledError),
    TransactionInProgressError(crate::error::TransactionInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExecuteTransactionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExecuteTransactionErrorKind::IdempotentParameterMismatchError(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::ProvisionedThroughputExceededError(_inner) => {
                _inner.fmt(f)
            }
            ExecuteTransactionErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::TransactionCanceledError(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::TransactionInProgressError(_inner) => _inner.fmt(f),
            ExecuteTransactionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExecuteTransactionError {
    fn code(&self) -> Option<&str> {
        ExecuteTransactionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExecuteTransactionError {
    pub fn new(kind: ExecuteTransactionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExecuteTransactionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExecuteTransactionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ExecuteTransactionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExecuteTransactionErrorKind::IdempotentParameterMismatchError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::InternalServerError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::TransactionCanceledError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::TransactionInProgressError(_inner) => Some(_inner),
            ExecuteTransactionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportTableToPointInTimeError {
    pub kind: ExportTableToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportTableToPointInTimeErrorKind {
    ExportConflictError(crate::error::ExportConflictError),
    InternalServerError(crate::error::InternalServerError),
    InvalidExportTimeError(crate::error::InvalidExportTimeError),
    LimitExceededError(crate::error::LimitExceededError),
    PointInTimeRecoveryUnavailableError(crate::error::PointInTimeRecoveryUnavailableError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportTableToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExportTableToPointInTimeErrorKind::ExportConflictError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeErrorKind::InvalidExportTimeError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeErrorKind::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            ExportTableToPointInTimeErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExportTableToPointInTimeError {
    fn code(&self) -> Option<&str> {
        ExportTableToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExportTableToPointInTimeError {
    pub fn new(kind: ExportTableToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExportTableToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExportTableToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ExportTableToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExportTableToPointInTimeErrorKind::ExportConflictError(_inner) => Some(_inner),
            ExportTableToPointInTimeErrorKind::InternalServerError(_inner) => Some(_inner),
            ExportTableToPointInTimeErrorKind::InvalidExportTimeError(_inner) => Some(_inner),
            ExportTableToPointInTimeErrorKind::LimitExceededError(_inner) => Some(_inner),
            ExportTableToPointInTimeErrorKind::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner)
            }
            ExportTableToPointInTimeErrorKind::TableNotFoundError(_inner) => Some(_inner),
            ExportTableToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetItemError {
    pub kind: GetItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetItemErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            GetItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            GetItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            GetItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            GetItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetItemError {
    fn code(&self) -> Option<&str> {
        GetItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetItemError {
    pub fn new(kind: GetItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetItemErrorKind::InternalServerError(_inner) => Some(_inner),
            GetItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            GetItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            GetItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            GetItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBackupsError {
    pub kind: ListBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBackupsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBackupsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListBackupsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBackupsError {
    fn code(&self) -> Option<&str> {
        ListBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBackupsError {
    pub fn new(kind: ListBackupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBackupsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListBackupsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            ListBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContributorInsightsError {
    pub kind: ListContributorInsightsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContributorInsightsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContributorInsightsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListContributorInsightsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListContributorInsightsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContributorInsightsError {
    fn code(&self) -> Option<&str> {
        ListContributorInsightsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContributorInsightsError {
    pub fn new(kind: ListContributorInsightsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContributorInsightsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContributorInsightsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListContributorInsightsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContributorInsightsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListContributorInsightsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListContributorInsightsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListExportsError {
    pub kind: ListExportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListExportsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    LimitExceededError(crate::error::LimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListExportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListExportsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListExportsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ListExportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListExportsError {
    fn code(&self) -> Option<&str> {
        ListExportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListExportsError {
    pub fn new(kind: ListExportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListExportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListExportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListExportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListExportsErrorKind::InternalServerError(_inner) => Some(_inner),
            ListExportsErrorKind::LimitExceededError(_inner) => Some(_inner),
            ListExportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGlobalTablesError {
    pub kind: ListGlobalTablesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGlobalTablesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGlobalTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGlobalTablesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListGlobalTablesErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListGlobalTablesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGlobalTablesError {
    fn code(&self) -> Option<&str> {
        ListGlobalTablesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGlobalTablesError {
    pub fn new(kind: ListGlobalTablesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGlobalTablesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGlobalTablesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListGlobalTablesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGlobalTablesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListGlobalTablesErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            ListGlobalTablesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTablesError {
    pub kind: ListTablesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTablesErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTablesErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTablesErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListTablesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTablesError {
    fn code(&self) -> Option<&str> {
        ListTablesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTablesError {
    pub fn new(kind: ListTablesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTablesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTablesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTablesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTablesErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTablesErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            ListTablesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsOfResourceError {
    pub kind: ListTagsOfResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsOfResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsOfResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsOfResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsOfResourceErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListTagsOfResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsOfResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsOfResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsOfResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsOfResourceError {
    pub fn new(kind: ListTagsOfResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsOfResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsOfResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTagsOfResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsOfResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            ListTagsOfResourceErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            ListTagsOfResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsOfResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutItemError {
    pub kind: PutItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutItemErrorKind {
    ConditionalCheckFailedError(crate::error::ConditionalCheckFailedError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(crate::error::ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionConflictError(crate::error::TransactionConflictError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutItemErrorKind::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            PutItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            PutItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            PutItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            PutItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            PutItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutItemErrorKind::TransactionConflictError(_inner) => _inner.fmt(f),
            PutItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutItemError {
    fn code(&self) -> Option<&str> {
        PutItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutItemError {
    pub fn new(kind: PutItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for PutItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutItemErrorKind::ConditionalCheckFailedError(_inner) => Some(_inner),
            PutItemErrorKind::InternalServerError(_inner) => Some(_inner),
            PutItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            PutItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            PutItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            PutItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            PutItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutItemErrorKind::TransactionConflictError(_inner) => Some(_inner),
            PutItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct QueryError {
    pub kind: QueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum QueryErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for QueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            QueryErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            QueryErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            QueryErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            QueryErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            QueryErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            QueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for QueryError {
    fn code(&self) -> Option<&str> {
        QueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl QueryError {
    pub fn new(kind: QueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: QueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: QueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for QueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            QueryErrorKind::InternalServerError(_inner) => Some(_inner),
            QueryErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            QueryErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            QueryErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            QueryErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            QueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreTableFromBackupError {
    pub kind: RestoreTableFromBackupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreTableFromBackupErrorKind {
    BackupInUseError(crate::error::BackupInUseError),
    BackupNotFoundError(crate::error::BackupNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    TableAlreadyExistsError(crate::error::TableAlreadyExistsError),
    TableInUseError(crate::error::TableInUseError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreTableFromBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreTableFromBackupErrorKind::BackupInUseError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::BackupNotFoundError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::TableAlreadyExistsError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::TableInUseError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreTableFromBackupError {
    fn code(&self) -> Option<&str> {
        RestoreTableFromBackupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreTableFromBackupError {
    pub fn new(kind: RestoreTableFromBackupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreTableFromBackupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreTableFromBackupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RestoreTableFromBackupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreTableFromBackupErrorKind::BackupInUseError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::BackupNotFoundError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::InternalServerError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::LimitExceededError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::TableAlreadyExistsError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::TableInUseError(_inner) => Some(_inner),
            RestoreTableFromBackupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreTableToPointInTimeError {
    pub kind: RestoreTableToPointInTimeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreTableToPointInTimeErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    InvalidRestoreTimeError(crate::error::InvalidRestoreTimeError),
    LimitExceededError(crate::error::LimitExceededError),
    PointInTimeRecoveryUnavailableError(crate::error::PointInTimeRecoveryUnavailableError),
    TableAlreadyExistsError(crate::error::TableAlreadyExistsError),
    TableInUseError(crate::error::TableInUseError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreTableToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreTableToPointInTimeErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::InvalidRestoreTimeError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            RestoreTableToPointInTimeErrorKind::TableAlreadyExistsError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::TableInUseError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreTableToPointInTimeError {
    fn code(&self) -> Option<&str> {
        RestoreTableToPointInTimeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreTableToPointInTimeError {
    pub fn new(kind: RestoreTableToPointInTimeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreTableToPointInTimeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreTableToPointInTimeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for RestoreTableToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreTableToPointInTimeErrorKind::InternalServerError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::InvalidRestoreTimeError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::LimitExceededError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner)
            }
            RestoreTableToPointInTimeErrorKind::TableAlreadyExistsError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::TableInUseError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::TableNotFoundError(_inner) => Some(_inner),
            RestoreTableToPointInTimeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ScanError {
    pub kind: ScanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ScanErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ScanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ScanErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            ScanErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            ScanErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            ScanErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ScanErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ScanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ScanError {
    fn code(&self) -> Option<&str> {
        ScanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ScanError {
    pub fn new(kind: ScanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ScanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ScanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ScanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ScanErrorKind::InternalServerError(_inner) => Some(_inner),
            ScanErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            ScanErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ScanErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            ScanErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ScanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceInUseError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransactGetItemsError {
    pub kind: TransactGetItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransactGetItemsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionCanceledError(crate::error::TransactionCanceledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransactGetItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransactGetItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::TransactionCanceledError(_inner) => _inner.fmt(f),
            TransactGetItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransactGetItemsError {
    fn code(&self) -> Option<&str> {
        TransactGetItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransactGetItemsError {
    pub fn new(kind: TransactGetItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransactGetItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransactGetItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TransactGetItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransactGetItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            TransactGetItemsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            TransactGetItemsErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            TransactGetItemsErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            TransactGetItemsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TransactGetItemsErrorKind::TransactionCanceledError(_inner) => Some(_inner),
            TransactGetItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TransactWriteItemsError {
    pub kind: TransactWriteItemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TransactWriteItemsErrorKind {
    IdempotentParameterMismatchError(crate::error::IdempotentParameterMismatchError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionCanceledError(crate::error::TransactionCanceledError),
    TransactionInProgressError(crate::error::TransactionInProgressError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TransactWriteItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TransactWriteItemsErrorKind::IdempotentParameterMismatchError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::ProvisionedThroughputExceededError(_inner) => {
                _inner.fmt(f)
            }
            TransactWriteItemsErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::TransactionCanceledError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::TransactionInProgressError(_inner) => _inner.fmt(f),
            TransactWriteItemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TransactWriteItemsError {
    fn code(&self) -> Option<&str> {
        TransactWriteItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TransactWriteItemsError {
    pub fn new(kind: TransactWriteItemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TransactWriteItemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TransactWriteItemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TransactWriteItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TransactWriteItemsErrorKind::IdempotentParameterMismatchError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::InternalServerError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::TransactionCanceledError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::TransactionInProgressError(_inner) => Some(_inner),
            TransactWriteItemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UntagResourceErrorKind::LimitExceededError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContinuousBackupsError {
    pub kind: UpdateContinuousBackupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContinuousBackupsErrorKind {
    ContinuousBackupsUnavailableError(crate::error::ContinuousBackupsUnavailableError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContinuousBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContinuousBackupsErrorKind::ContinuousBackupsUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            UpdateContinuousBackupsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContinuousBackupsError {
    fn code(&self) -> Option<&str> {
        UpdateContinuousBackupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContinuousBackupsError {
    pub fn new(kind: UpdateContinuousBackupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContinuousBackupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContinuousBackupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateContinuousBackupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContinuousBackupsErrorKind::ContinuousBackupsUnavailableError(_inner) => {
                Some(_inner)
            }
            UpdateContinuousBackupsErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateContinuousBackupsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateContinuousBackupsErrorKind::TableNotFoundError(_inner) => Some(_inner),
            UpdateContinuousBackupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContributorInsightsError {
    pub kind: UpdateContributorInsightsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContributorInsightsErrorKind {
    InternalServerError(crate::error::InternalServerError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContributorInsightsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateContributorInsightsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateContributorInsightsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContributorInsightsError {
    fn code(&self) -> Option<&str> {
        UpdateContributorInsightsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContributorInsightsError {
    pub fn new(kind: UpdateContributorInsightsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContributorInsightsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContributorInsightsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateContributorInsightsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContributorInsightsErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateContributorInsightsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateContributorInsightsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalTableError {
    pub kind: UpdateGlobalTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalTableErrorKind {
    GlobalTableNotFoundError(crate::error::GlobalTableNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ReplicaAlreadyExistsError(crate::error::ReplicaAlreadyExistsError),
    ReplicaNotFoundError(crate::error::ReplicaNotFoundError),
    TableNotFoundError(crate::error::TableNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalTableErrorKind::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::ReplicaAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::ReplicaNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::TableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGlobalTableError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalTableError {
    pub fn new(kind: UpdateGlobalTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGlobalTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGlobalTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateGlobalTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalTableErrorKind::GlobalTableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::ReplicaAlreadyExistsError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::ReplicaNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::TableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGlobalTableSettingsError {
    pub kind: UpdateGlobalTableSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGlobalTableSettingsErrorKind {
    GlobalTableNotFoundError(crate::error::GlobalTableNotFoundError),
    IndexNotFoundError(crate::error::IndexNotFoundError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ReplicaNotFoundError(crate::error::ReplicaNotFoundError),
    ResourceInUseError(crate::error::ResourceInUseError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGlobalTableSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGlobalTableSettingsErrorKind::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::IndexNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::ReplicaNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGlobalTableSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateGlobalTableSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGlobalTableSettingsError {
    pub fn new(kind: UpdateGlobalTableSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGlobalTableSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGlobalTableSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateGlobalTableSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGlobalTableSettingsErrorKind::GlobalTableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::IndexNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::ReplicaNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateItemError {
    pub kind: UpdateItemErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateItemErrorKind {
    ConditionalCheckFailedError(crate::error::ConditionalCheckFailedError),
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(crate::error::ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(crate::error::ProvisionedThroughputExceededError),
    RequestLimitExceeded(crate::error::RequestLimitExceeded),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    TransactionConflictError(crate::error::TransactionConflictError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateItemErrorKind::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::RequestLimitExceeded(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::TransactionConflictError(_inner) => _inner.fmt(f),
            UpdateItemErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateItemError {
    fn code(&self) -> Option<&str> {
        UpdateItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateItemError {
    pub fn new(kind: UpdateItemErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateItemErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateItemErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateItemErrorKind::ConditionalCheckFailedError(_inner) => Some(_inner),
            UpdateItemErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateItemErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateItemErrorKind::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            UpdateItemErrorKind::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            UpdateItemErrorKind::RequestLimitExceeded(_inner) => Some(_inner),
            UpdateItemErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateItemErrorKind::TransactionConflictError(_inner) => Some(_inner),
            UpdateItemErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTableError {
    pub kind: UpdateTableErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTableErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTableErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTableErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTableError {
    fn code(&self) -> Option<&str> {
        UpdateTableError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTableError {
    pub fn new(kind: UpdateTableErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTableErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTableErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateTableError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTableErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateTableErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateTableErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateTableErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UpdateTableErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTableErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTableReplicaAutoScalingError {
    pub kind: UpdateTableReplicaAutoScalingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTableReplicaAutoScalingErrorKind {
    InternalServerError(crate::error::InternalServerError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTableReplicaAutoScalingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTableReplicaAutoScalingErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTableReplicaAutoScalingError {
    fn code(&self) -> Option<&str> {
        UpdateTableReplicaAutoScalingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTableReplicaAutoScalingError {
    pub fn new(kind: UpdateTableReplicaAutoScalingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTableReplicaAutoScalingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTableReplicaAutoScalingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateTableReplicaAutoScalingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTableReplicaAutoScalingErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTimeToLiveError {
    pub kind: UpdateTimeToLiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTimeToLiveErrorKind {
    InternalServerError(crate::error::InternalServerError),
    InvalidEndpointError(crate::error::InvalidEndpointError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceInUseError(crate::error::ResourceInUseError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTimeToLiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTimeToLiveErrorKind::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveErrorKind::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveErrorKind::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTimeToLiveError {
    fn code(&self) -> Option<&str> {
        UpdateTimeToLiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTimeToLiveError {
    pub fn new(kind: UpdateTimeToLiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTimeToLiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTimeToLiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateTimeToLiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTimeToLiveErrorKind::InternalServerError(_inner) => Some(_inner),
            UpdateTimeToLiveErrorKind::InvalidEndpointError(_inner) => Some(_inner),
            UpdateTimeToLiveErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateTimeToLiveErrorKind::ResourceInUseError(_inner) => Some(_inner),
            UpdateTimeToLiveErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTimeToLiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The operation tried to access a nonexistent table or index. The resource might not be specified
/// correctly, or its status might not be <code>ACTIVE</code>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    /// <p>The resource which is being requested does not exist.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource which is being requested does not exist.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to
/// recreate an existing table, or tried to delete a table currently in the <code>CREATING</code>
/// state.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceInUseError {
    /// <p>The resource which is being attempted to be changed is in use.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError [ResourceInUseException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource which is being attempted to be changed is in use.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> crate::error::ResourceInUseError {
            crate::error::ResourceInUseError {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>There is no limit to the number of daily on-demand backups that can be taken. </p>
/// <p>Up to 50 simultaneous table operations are allowed per account. These operations
/// include <code>CreateTable</code>, <code>UpdateTable</code>,
/// <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,
/// <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>. </p>
/// <p>The only exception is when you are creating a table with one or more secondary indexes. You can have up to
/// 25 such requests running at a time; however, if the table or index specifications are complex, DynamoDB might temporarily
/// reduce the number of concurrent operations.</p>
/// <p>There is a soft account quota of 256 tables.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    /// <p>Too many operations for a given subscriber.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Too many operations for a given subscriber.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEndpointError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEndpointError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEndpointError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEndpointError [InvalidEndpointException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEndpointError {}
/// See [`InvalidEndpointError`](crate::error::InvalidEndpointError)
pub mod invalid_endpoint_error {
    /// A builder for [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEndpointError`](crate::error::InvalidEndpointError)
        pub fn build(self) -> crate::error::InvalidEndpointError {
            crate::error::InvalidEndpointError {
                message: self.message,
            }
        }
    }
}
impl InvalidEndpointError {
    /// Creates a new builder-style object to manufacture [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    pub fn builder() -> crate::error::invalid_endpoint_error::Builder {
        crate::error::invalid_endpoint_error::Builder::default()
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerError {
    /// <p>The server encountered an internal error trying to fulfill the request.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The server encountered an internal error trying to fulfill the request.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> crate::error::InternalServerError {
            crate::error::InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>Operation was rejected because there is an ongoing transaction for the item.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TransactionConflictError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransactionConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransactionConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransactionConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransactionConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionConflictError [TransactionConflictException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransactionConflictError {}
/// See [`TransactionConflictError`](crate::error::TransactionConflictError)
pub mod transaction_conflict_error {
    /// A builder for [`TransactionConflictError`](crate::error::TransactionConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TransactionConflictError`](crate::error::TransactionConflictError)
        pub fn build(self) -> crate::error::TransactionConflictError {
            crate::error::TransactionConflictError {
                message: self.message,
            }
        }
    }
}
impl TransactionConflictError {
    /// Creates a new builder-style object to manufacture [`TransactionConflictError`](crate::error::TransactionConflictError)
    pub fn builder() -> crate::error::transaction_conflict_error::Builder {
        crate::error::transaction_conflict_error::Builder::default()
    }
}

/// <p>Throughput exceeds the current throughput quota for your account. Please contact AWS Support at <a href="https://aws.amazon.com/support">AWS Support</a> to request a quota increase.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestLimitExceeded {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestLimitExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestLimitExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestLimitExceeded")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestLimitExceeded {}
/// See [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
pub mod request_limit_exceeded {
    /// A builder for [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
        pub fn build(self) -> crate::error::RequestLimitExceeded {
            crate::error::RequestLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl RequestLimitExceeded {
    /// Creates a new builder-style object to manufacture [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    pub fn builder() -> crate::error::request_limit_exceeded::Builder {
        crate::error::request_limit_exceeded::Builder::default()
    }
}

/// <p>Your request rate is too high. The AWS SDKs for DynamoDB automatically retry requests that
/// receive this exception. Your request is eventually successful, unless your retry queue is too
/// large to finish. Reduce the frequency of requests and use exponential backoff. For more
/// information, go to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error Retries and Exponential
/// Backoff</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ProvisionedThroughputExceededError {
    /// <p>You exceeded your maximum allowed provisioned throughput.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedThroughputExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ProvisionedThroughputExceededError [ProvisionedThroughputExceededException]"
        )?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedThroughputExceededError {}
/// See [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
pub mod provisioned_throughput_exceeded_error {
    /// A builder for [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>You exceeded your maximum allowed provisioned throughput.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
        pub fn build(self) -> crate::error::ProvisionedThroughputExceededError {
            crate::error::ProvisionedThroughputExceededError {
                message: self.message,
            }
        }
    }
}
impl ProvisionedThroughputExceededError {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_error::Builder {
        crate::error::provisioned_throughput_exceeded_error::Builder::default()
    }
}

/// <p>An item collection is too large. This exception is only returned for tables that have one or more local secondary indexes.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemCollectionSizeLimitExceededError {
    /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ItemCollectionSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemCollectionSizeLimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ItemCollectionSizeLimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ItemCollectionSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ItemCollectionSizeLimitExceededError [ItemCollectionSizeLimitExceededException]"
        )?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ItemCollectionSizeLimitExceededError {}
/// See [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
pub mod item_collection_size_limit_exceeded_error {
    /// A builder for [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
        pub fn build(self) -> crate::error::ItemCollectionSizeLimitExceededError {
            crate::error::ItemCollectionSizeLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl ItemCollectionSizeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    pub fn builder() -> crate::error::item_collection_size_limit_exceeded_error::Builder {
        crate::error::item_collection_size_limit_exceeded_error::Builder::default()
    }
}

/// <p>A condition specified in the operation could not be evaluated.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalCheckFailedError {
    /// <p>The conditional request failed.</p>
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConditionalCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalCheckFailedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConditionalCheckFailedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConditionalCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ConditionalCheckFailedError [ConditionalCheckFailedException]"
        )?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConditionalCheckFailedError {}
/// See [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
pub mod conditional_check_failed_error {
    /// A builder for [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The conditional request failed.</p>
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
        pub fn build(self) -> crate::error::ConditionalCheckFailedError {
            crate::error::ConditionalCheckFailedError {
                message: self.message,
            }
        }
    }
}
impl ConditionalCheckFailedError {
    /// Creates a new builder-style object to manufacture [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    pub fn builder() -> crate::error::conditional_check_failed_error::Builder {
        crate::error::conditional_check_failed_error::Builder::default()
    }
}

/// <p>The specified replica is no longer part of the global table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicaNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicaNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicaNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicaNotFoundError [ReplicaNotFoundException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicaNotFoundError {}
/// See [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
pub mod replica_not_found_error {
    /// A builder for [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
        pub fn build(self) -> crate::error::ReplicaNotFoundError {
            crate::error::ReplicaNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ReplicaNotFoundError {
    /// Creates a new builder-style object to manufacture [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    pub fn builder() -> crate::error::replica_not_found_error::Builder {
        crate::error::replica_not_found_error::Builder::default()
    }
}

/// <p>The operation tried to access a nonexistent index.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IndexNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IndexNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IndexNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IndexNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IndexNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IndexNotFoundError [IndexNotFoundException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for IndexNotFoundError {}
/// See [`IndexNotFoundError`](crate::error::IndexNotFoundError)
pub mod index_not_found_error {
    /// A builder for [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`IndexNotFoundError`](crate::error::IndexNotFoundError)
        pub fn build(self) -> crate::error::IndexNotFoundError {
            crate::error::IndexNotFoundError {
                message: self.message,
            }
        }
    }
}
impl IndexNotFoundError {
    /// Creates a new builder-style object to manufacture [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    pub fn builder() -> crate::error::index_not_found_error::Builder {
        crate::error::index_not_found_error::Builder::default()
    }
}

/// <p>The specified global table does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalTableNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalTableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalTableNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalTableNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalTableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalTableNotFoundError [GlobalTableNotFoundException]")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalTableNotFoundError {}
/// See [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
pub mod global_table_not_found_error {
    /// A builder for [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
        pub fn build(self) -> crate::error::GlobalTableNotFoundError {
            crate::error::GlobalTableNotFoundError {
                message: self.message,
            }
        }
    }
}
impl GlobalTableNotFoundError {
    /// Creates a new builder-style object to manufacture [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    pub fn builder() -> crate::error::global_table_not_found_error::Builder {
        crate::error::global_table_not_found_error::Builder::default()
    }
}

/// <p>A source table with the name <code>TableName</code> does not currently exist within the subscriber's account.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TableNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TableNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableNotFoundError [TableNotFoundException]")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for TableNotFoundError {}
/// See [`TableNotFoundError`](crate::error::TableNotFoundError)
pub mod table_not_found_error {
    /// A builder for [`TableNotFoundError`](crate::error::TableNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TableNotFoundError`](crate::error::TableNotFoundError)
        pub fn build(self) -> crate::error::TableNotFoundError {
            crate::error::TableNotFoundError {
                message: self.message,
            }
        }
    }
}
impl TableNotFoundError {
    /// Creates a new builder-style object to manufacture [`TableNotFoundError`](crate::error::TableNotFoundError)
    pub fn builder() -> crate::error::table_not_found_error::Builder {
        crate::error::table_not_found_error::Builder::default()
    }
}

/// <p>The specified replica is already part of the global table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicaAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicaAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicaAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicaAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicaAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ReplicaAlreadyExistsError [ReplicaAlreadyExistsException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicaAlreadyExistsError {}
/// See [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
pub mod replica_already_exists_error {
    /// A builder for [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
        pub fn build(self) -> crate::error::ReplicaAlreadyExistsError {
            crate::error::ReplicaAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl ReplicaAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    pub fn builder() -> crate::error::replica_already_exists_error::Builder {
        crate::error::replica_already_exists_error::Builder::default()
    }
}

/// <p>Backups have not yet been enabled for this table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ContinuousBackupsUnavailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContinuousBackupsUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContinuousBackupsUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ContinuousBackupsUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ContinuousBackupsUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ContinuousBackupsUnavailableError [ContinuousBackupsUnavailableException]"
        )?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for ContinuousBackupsUnavailableError {}
/// See [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
pub mod continuous_backups_unavailable_error {
    /// A builder for [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
        pub fn build(self) -> crate::error::ContinuousBackupsUnavailableError {
            crate::error::ContinuousBackupsUnavailableError {
                message: self.message,
            }
        }
    }
}
impl ContinuousBackupsUnavailableError {
    /// Creates a new builder-style object to manufacture [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    pub fn builder() -> crate::error::continuous_backups_unavailable_error::Builder {
        crate::error::continuous_backups_unavailable_error::Builder::default()
    }
}

/// <p>The transaction with the given request token is already in progress.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TransactionInProgressError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TransactionInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransactionInProgressError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TransactionInProgressError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransactionInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TransactionInProgressError [TransactionInProgressException]"
        )?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransactionInProgressError {}
/// See [`TransactionInProgressError`](crate::error::TransactionInProgressError)
pub mod transaction_in_progress_error {
    /// A builder for [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TransactionInProgressError`](crate::error::TransactionInProgressError)
        pub fn build(self) -> crate::error::TransactionInProgressError {
            crate::error::TransactionInProgressError {
                message: self.message,
            }
        }
    }
}
impl TransactionInProgressError {
    /// Creates a new builder-style object to manufacture [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    pub fn builder() -> crate::error::transaction_in_progress_error::Builder {
        crate::error::transaction_in_progress_error::Builder::default()
    }
}

/// <p>The entire transaction request was canceled.</p>
/// <p>DynamoDB cancels a <code>TransactWriteItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>A condition in one of the condition expressions is not met.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactWriteItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>More than one action in the <code>TransactWriteItems</code> operation targets the same item.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>An item size becomes too large (larger than 400 KB), or a local secondary index (LSI)
/// becomes too large, or a similar validation error occurs because of changes made by the transaction.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <p>DynamoDB cancels a <code>TransactGetItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts with a concurrent
/// <code>PutItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code> or <code>TransactWriteItems</code> request.
/// In this case the <code>TransactGetItems</code> operation fails with a <code>TransactionCanceledException</code>.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactGetItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <note>
/// <p>If using Java, DynamoDB lists the cancellation reasons on the <code>CancellationReasons</code> property.  This property is not set for other languages.
/// Transaction cancellation reasons are ordered in the order of requested items, if an item has no error it will have <code>NONE</code> code and <code>Null</code> message.</p>
/// </note>
/// <p>Cancellation reason codes and possible error messages:</p>
/// <ul>
/// <li>
/// <p>No Errors:</p>
/// <ul>
/// <li>
/// <p>Code: <code>NONE</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: <code>null</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Conditional Check Failed:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ConditionalCheckFailed</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: The conditional request failed. </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Item Collection Size Limit Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ItemCollectionSizeLimitExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Collection size exceeded.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Transaction Conflict:</p>
/// <ul>
/// <li>
/// <p>Code: <code>TransactionConflict</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Transaction is ongoing for the item.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Provisioned Throughput Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ProvisionedThroughputExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>The level of configured provisioned throughput for the table was exceeded. Consider increasing your provisioning level with the
/// UpdateTable API.</p>
/// <note>
/// <p>This Message is received when provisioned throughput is exceeded is on a provisioned DynamoDB table.</p>
/// </note>
/// </li>
/// <li>
/// <p>The level of configured provisioned throughput for one or more global secondary indexes of the table was exceeded.
/// Consider increasing your provisioning level for the under-provisioned global secondary indexes with the UpdateTable API.</p>
/// <note>
/// <p>This message is returned when provisioned throughput is exceeded is on a provisioned GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Throttling Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ThrottlingError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>Throughput exceeds the current capacity of your table or index.
/// DynamoDB is automatically scaling your table or index so please try
/// again shortly. If exceptions persist, check if you have a hot key:
/// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p>
/// <note>
/// <p>This message is returned when writes get throttled on an On-Demand table as DynamoDB is automatically scaling the table.</p>
/// </note>
/// </li>
/// <li>
/// <p>Throughput exceeds the current capacity for one or more global secondary indexes. DynamoDB is automatically scaling your index so
/// please try again shortly.</p>
/// <note>
/// <p>This message is returned when when writes get throttled on an On-Demand GSI as DynamoDB is automatically scaling the GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Validation Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ValidationError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>One or more parameter values were invalid.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key beyond allowed size limits.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key to unsupported type.</p>
/// </li>
/// <li>
/// <p>An operand in the update expression has an incorrect data type.</p>
/// </li>
/// <li>
/// <p>Item size to update has exceeded the maximum allowed size.</p>
/// </li>
/// <li>
/// <p>Number overflow. Attempting to store a number with magnitude larger than supported range.</p>
/// </li>
/// <li>
/// <p>Type mismatch for attribute to update.</p>
/// </li>
/// <li>
/// <p>Nesting Levels have exceeded supported limits.</p>
/// </li>
/// <li>
/// <p>The document path provided in the update expression is invalid for update.</p>
/// </li>
/// <li>
/// <p>The provided expression refers to an attribute that does not exist in the item.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TransactionCanceledError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    /// <p>A list of cancellation reasons.</p>
    #[serde(rename = "CancellationReasons")]
    #[serde(default)]
    pub cancellation_reasons: std::option::Option<std::vec::Vec<crate::model::CancellationReason>>,
}
impl std::fmt::Debug for TransactionCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TransactionCanceledError");
        formatter.field("message", &self.message);
        formatter.field("cancellation_reasons", &self.cancellation_reasons);
        formatter.finish()
    }
}
impl TransactionCanceledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TransactionCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionCanceledError [TransactionCanceledException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for TransactionCanceledError {}
/// See [`TransactionCanceledError`](crate::error::TransactionCanceledError)
pub mod transaction_canceled_error {
    /// A builder for [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) cancellation_reasons:
            std::option::Option<std::vec::Vec<crate::model::CancellationReason>>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        pub fn cancellation_reasons(
            mut self,
            inp: impl Into<crate::model::CancellationReason>,
        ) -> Self {
            let mut v = self.cancellation_reasons.unwrap_or_default();
            v.push(inp.into());
            self.cancellation_reasons = Some(v);
            self
        }
        pub fn set_cancellation_reasons(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::CancellationReason>>,
        ) -> Self {
            self.cancellation_reasons = inp;
            self
        }
        /// Consumes the builder and constructs a [`TransactionCanceledError`](crate::error::TransactionCanceledError)
        pub fn build(self) -> crate::error::TransactionCanceledError {
            crate::error::TransactionCanceledError {
                message: self.message,
                cancellation_reasons: self.cancellation_reasons,
            }
        }
    }
}
impl TransactionCanceledError {
    /// Creates a new builder-style object to manufacture [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    pub fn builder() -> crate::error::transaction_canceled_error::Builder {
        crate::error::transaction_canceled_error::Builder::default()
    }
}

/// <p>DynamoDB rejected the request because you retried a request with a different payload but
/// with an idempotent token that was already used.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotentParameterMismatchError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotentParameterMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotentParameterMismatchError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotentParameterMismatchError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotentParameterMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IdempotentParameterMismatchError [IdempotentParameterMismatchException]"
        )?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotentParameterMismatchError {}
/// See [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
pub mod idempotent_parameter_mismatch_error {
    /// A builder for [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
        pub fn build(self) -> crate::error::IdempotentParameterMismatchError {
            crate::error::IdempotentParameterMismatchError {
                message: self.message,
            }
        }
    }
}
impl IdempotentParameterMismatchError {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_error::Builder {
        crate::error::idempotent_parameter_mismatch_error::Builder::default()
    }
}

/// <p>A target table with the specified name is either being created or deleted. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TableInUseError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TableInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TableInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TableInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableInUseError [TableInUseException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for TableInUseError {}
/// See [`TableInUseError`](crate::error::TableInUseError)
pub mod table_in_use_error {
    /// A builder for [`TableInUseError`](crate::error::TableInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TableInUseError`](crate::error::TableInUseError)
        pub fn build(self) -> crate::error::TableInUseError {
            crate::error::TableInUseError {
                message: self.message,
            }
        }
    }
}
impl TableInUseError {
    /// Creates a new builder-style object to manufacture [`TableInUseError`](crate::error::TableInUseError)
    pub fn builder() -> crate::error::table_in_use_error::Builder {
        crate::error::table_in_use_error::Builder::default()
    }
}

/// <p>A target table with the specified name already exists. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TableAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TableAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableAlreadyExistsError [TableAlreadyExistsException]")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for TableAlreadyExistsError {}
/// See [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
pub mod table_already_exists_error {
    /// A builder for [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
        pub fn build(self) -> crate::error::TableAlreadyExistsError {
            crate::error::TableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl TableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    pub fn builder() -> crate::error::table_already_exists_error::Builder {
        crate::error::table_already_exists_error::Builder::default()
    }
}

/// <p>Point in time recovery has not yet been enabled for this source table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PointInTimeRecoveryUnavailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PointInTimeRecoveryUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PointInTimeRecoveryUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PointInTimeRecoveryUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PointInTimeRecoveryUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PointInTimeRecoveryUnavailableError [PointInTimeRecoveryUnavailableException]"
        )?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for PointInTimeRecoveryUnavailableError {}
/// See [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
pub mod point_in_time_recovery_unavailable_error {
    /// A builder for [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
        pub fn build(self) -> crate::error::PointInTimeRecoveryUnavailableError {
            crate::error::PointInTimeRecoveryUnavailableError {
                message: self.message,
            }
        }
    }
}
impl PointInTimeRecoveryUnavailableError {
    /// Creates a new builder-style object to manufacture [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    pub fn builder() -> crate::error::point_in_time_recovery_unavailable_error::Builder {
        crate::error::point_in_time_recovery_unavailable_error::Builder::default()
    }
}

/// <p>An invalid restore time was specified. RestoreDateTime must be between EarliestRestorableDateTime and LatestRestorableDateTime.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRestoreTimeError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRestoreTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRestoreTimeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRestoreTimeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRestoreTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreTimeError [InvalidRestoreTimeException]")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRestoreTimeError {}
/// See [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
pub mod invalid_restore_time_error {
    /// A builder for [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
        pub fn build(self) -> crate::error::InvalidRestoreTimeError {
            crate::error::InvalidRestoreTimeError {
                message: self.message,
            }
        }
    }
}
impl InvalidRestoreTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    pub fn builder() -> crate::error::invalid_restore_time_error::Builder {
        crate::error::invalid_restore_time_error::Builder::default()
    }
}

/// <p>Backup not found for the given BackupARN. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupNotFoundError [BackupNotFoundException]")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupNotFoundError {}
/// See [`BackupNotFoundError`](crate::error::BackupNotFoundError)
pub mod backup_not_found_error {
    /// A builder for [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`BackupNotFoundError`](crate::error::BackupNotFoundError)
        pub fn build(self) -> crate::error::BackupNotFoundError {
            crate::error::BackupNotFoundError {
                message: self.message,
            }
        }
    }
}
impl BackupNotFoundError {
    /// Creates a new builder-style object to manufacture [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    pub fn builder() -> crate::error::backup_not_found_error::Builder {
        crate::error::backup_not_found_error::Builder::default()
    }
}

/// <p>There is another ongoing conflicting backup control plane operation on the table. The backup is either being created, deleted or restored to a table.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BackupInUseError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BackupInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BackupInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BackupInUseError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BackupInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupInUseError [BackupInUseException]")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for BackupInUseError {}
/// See [`BackupInUseError`](crate::error::BackupInUseError)
pub mod backup_in_use_error {
    /// A builder for [`BackupInUseError`](crate::error::BackupInUseError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`BackupInUseError`](crate::error::BackupInUseError)
        pub fn build(self) -> crate::error::BackupInUseError {
            crate::error::BackupInUseError {
                message: self.message,
            }
        }
    }
}
impl BackupInUseError {
    /// Creates a new builder-style object to manufacture [`BackupInUseError`](crate::error::BackupInUseError)
    pub fn builder() -> crate::error::backup_in_use_error::Builder {
        crate::error::backup_in_use_error::Builder::default()
    }
}

/// <p>The specified <code>ExportTime</code> is outside of the point in time recovery
/// window.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidExportTimeError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidExportTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidExportTimeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidExportTimeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExportTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportTimeError [InvalidExportTimeException]")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExportTimeError {}
/// See [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
pub mod invalid_export_time_error {
    /// A builder for [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
        pub fn build(self) -> crate::error::InvalidExportTimeError {
            crate::error::InvalidExportTimeError {
                message: self.message,
            }
        }
    }
}
impl InvalidExportTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    pub fn builder() -> crate::error::invalid_export_time_error::Builder {
        crate::error::invalid_export_time_error::Builder::default()
    }
}

/// <p>There was a conflict when writing to the specified S3 bucket.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportConflictError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportConflictError [ExportConflictException]")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportConflictError {}
/// See [`ExportConflictError`](crate::error::ExportConflictError)
pub mod export_conflict_error {
    /// A builder for [`ExportConflictError`](crate::error::ExportConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExportConflictError`](crate::error::ExportConflictError)
        pub fn build(self) -> crate::error::ExportConflictError {
            crate::error::ExportConflictError {
                message: self.message,
            }
        }
    }
}
impl ExportConflictError {
    /// Creates a new builder-style object to manufacture [`ExportConflictError`](crate::error::ExportConflictError)
    pub fn builder() -> crate::error::export_conflict_error::Builder {
        crate::error::export_conflict_error::Builder::default()
    }
}

/// <p>
/// There was an attempt to insert an item with the same primary key as an item that already exists in the DynamoDB table.
/// </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateItemError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateItemError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateItemError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateItemError [DuplicateItemException]")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateItemError {}
/// See [`DuplicateItemError`](crate::error::DuplicateItemError)
pub mod duplicate_item_error {
    /// A builder for [`DuplicateItemError`](crate::error::DuplicateItemError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateItemError`](crate::error::DuplicateItemError)
        pub fn build(self) -> crate::error::DuplicateItemError {
            crate::error::DuplicateItemError {
                message: self.message,
            }
        }
    }
}
impl DuplicateItemError {
    /// Creates a new builder-style object to manufacture [`DuplicateItemError`](crate::error::DuplicateItemError)
    pub fn builder() -> crate::error::duplicate_item_error::Builder {
        crate::error::duplicate_item_error::Builder::default()
    }
}

/// <p>The specified export was not found.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExportNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExportNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportNotFoundError [ExportNotFoundException]")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExportNotFoundError {}
/// See [`ExportNotFoundError`](crate::error::ExportNotFoundError)
pub mod export_not_found_error {
    /// A builder for [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ExportNotFoundError`](crate::error::ExportNotFoundError)
        pub fn build(self) -> crate::error::ExportNotFoundError {
            crate::error::ExportNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ExportNotFoundError {
    /// Creates a new builder-style object to manufacture [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    pub fn builder() -> crate::error::export_not_found_error::Builder {
        crate::error::export_not_found_error::Builder::default()
    }
}

/// <p>The specified global table already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalTableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalTableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalTableAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalTableAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalTableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "GlobalTableAlreadyExistsError [GlobalTableAlreadyExistsException]"
        )?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalTableAlreadyExistsError {}
/// See [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
pub mod global_table_already_exists_error {
    /// A builder for [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
        pub fn build(self) -> crate::error::GlobalTableAlreadyExistsError {
            crate::error::GlobalTableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl GlobalTableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    pub fn builder() -> crate::error::global_table_already_exists_error::Builder {
        crate::error::global_table_already_exists_error::Builder::default()
    }
}
