// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_reserved_instances_exchange_quote(
        &self,
    ) -> fluent_builders::AcceptReservedInstancesExchangeQuote<C> {
        fluent_builders::AcceptReservedInstancesExchangeQuote::new(self.handle.clone())
    }
    pub fn accept_transit_gateway_multicast_domain_associations(
        &self,
    ) -> fluent_builders::AcceptTransitGatewayMulticastDomainAssociations<C> {
        fluent_builders::AcceptTransitGatewayMulticastDomainAssociations::new(self.handle.clone())
    }
    pub fn accept_transit_gateway_peering_attachment(
        &self,
    ) -> fluent_builders::AcceptTransitGatewayPeeringAttachment<C> {
        fluent_builders::AcceptTransitGatewayPeeringAttachment::new(self.handle.clone())
    }
    pub fn accept_transit_gateway_vpc_attachment(
        &self,
    ) -> fluent_builders::AcceptTransitGatewayVpcAttachment<C> {
        fluent_builders::AcceptTransitGatewayVpcAttachment::new(self.handle.clone())
    }
    pub fn accept_vpc_endpoint_connections(
        &self,
    ) -> fluent_builders::AcceptVpcEndpointConnections<C> {
        fluent_builders::AcceptVpcEndpointConnections::new(self.handle.clone())
    }
    pub fn accept_vpc_peering_connection(&self) -> fluent_builders::AcceptVpcPeeringConnection<C> {
        fluent_builders::AcceptVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn advertise_byoip_cidr(&self) -> fluent_builders::AdvertiseByoipCidr<C> {
        fluent_builders::AdvertiseByoipCidr::new(self.handle.clone())
    }
    pub fn allocate_address(&self) -> fluent_builders::AllocateAddress<C> {
        fluent_builders::AllocateAddress::new(self.handle.clone())
    }
    pub fn allocate_hosts(&self) -> fluent_builders::AllocateHosts<C> {
        fluent_builders::AllocateHosts::new(self.handle.clone())
    }
    pub fn apply_security_groups_to_client_vpn_target_network(
        &self,
    ) -> fluent_builders::ApplySecurityGroupsToClientVpnTargetNetwork<C> {
        fluent_builders::ApplySecurityGroupsToClientVpnTargetNetwork::new(self.handle.clone())
    }
    pub fn assign_ipv6_addresses(&self) -> fluent_builders::AssignIpv6Addresses<C> {
        fluent_builders::AssignIpv6Addresses::new(self.handle.clone())
    }
    pub fn assign_private_ip_addresses(&self) -> fluent_builders::AssignPrivateIpAddresses<C> {
        fluent_builders::AssignPrivateIpAddresses::new(self.handle.clone())
    }
    pub fn associate_address(&self) -> fluent_builders::AssociateAddress<C> {
        fluent_builders::AssociateAddress::new(self.handle.clone())
    }
    pub fn associate_client_vpn_target_network(
        &self,
    ) -> fluent_builders::AssociateClientVpnTargetNetwork<C> {
        fluent_builders::AssociateClientVpnTargetNetwork::new(self.handle.clone())
    }
    pub fn associate_dhcp_options(&self) -> fluent_builders::AssociateDhcpOptions<C> {
        fluent_builders::AssociateDhcpOptions::new(self.handle.clone())
    }
    pub fn associate_enclave_certificate_iam_role(
        &self,
    ) -> fluent_builders::AssociateEnclaveCertificateIamRole<C> {
        fluent_builders::AssociateEnclaveCertificateIamRole::new(self.handle.clone())
    }
    pub fn associate_iam_instance_profile(
        &self,
    ) -> fluent_builders::AssociateIamInstanceProfile<C> {
        fluent_builders::AssociateIamInstanceProfile::new(self.handle.clone())
    }
    pub fn associate_route_table(&self) -> fluent_builders::AssociateRouteTable<C> {
        fluent_builders::AssociateRouteTable::new(self.handle.clone())
    }
    pub fn associate_subnet_cidr_block(&self) -> fluent_builders::AssociateSubnetCidrBlock<C> {
        fluent_builders::AssociateSubnetCidrBlock::new(self.handle.clone())
    }
    pub fn associate_transit_gateway_multicast_domain(
        &self,
    ) -> fluent_builders::AssociateTransitGatewayMulticastDomain<C> {
        fluent_builders::AssociateTransitGatewayMulticastDomain::new(self.handle.clone())
    }
    pub fn associate_transit_gateway_route_table(
        &self,
    ) -> fluent_builders::AssociateTransitGatewayRouteTable<C> {
        fluent_builders::AssociateTransitGatewayRouteTable::new(self.handle.clone())
    }
    pub fn associate_trunk_interface(&self) -> fluent_builders::AssociateTrunkInterface<C> {
        fluent_builders::AssociateTrunkInterface::new(self.handle.clone())
    }
    pub fn associate_vpc_cidr_block(&self) -> fluent_builders::AssociateVpcCidrBlock<C> {
        fluent_builders::AssociateVpcCidrBlock::new(self.handle.clone())
    }
    pub fn attach_classic_link_vpc(&self) -> fluent_builders::AttachClassicLinkVpc<C> {
        fluent_builders::AttachClassicLinkVpc::new(self.handle.clone())
    }
    pub fn attach_internet_gateway(&self) -> fluent_builders::AttachInternetGateway<C> {
        fluent_builders::AttachInternetGateway::new(self.handle.clone())
    }
    pub fn attach_network_interface(&self) -> fluent_builders::AttachNetworkInterface<C> {
        fluent_builders::AttachNetworkInterface::new(self.handle.clone())
    }
    pub fn attach_volume(&self) -> fluent_builders::AttachVolume<C> {
        fluent_builders::AttachVolume::new(self.handle.clone())
    }
    pub fn attach_vpn_gateway(&self) -> fluent_builders::AttachVpnGateway<C> {
        fluent_builders::AttachVpnGateway::new(self.handle.clone())
    }
    pub fn authorize_client_vpn_ingress(&self) -> fluent_builders::AuthorizeClientVpnIngress<C> {
        fluent_builders::AuthorizeClientVpnIngress::new(self.handle.clone())
    }
    pub fn authorize_security_group_egress(
        &self,
    ) -> fluent_builders::AuthorizeSecurityGroupEgress<C> {
        fluent_builders::AuthorizeSecurityGroupEgress::new(self.handle.clone())
    }
    pub fn authorize_security_group_ingress(
        &self,
    ) -> fluent_builders::AuthorizeSecurityGroupIngress<C> {
        fluent_builders::AuthorizeSecurityGroupIngress::new(self.handle.clone())
    }
    pub fn bundle_instance(&self) -> fluent_builders::BundleInstance<C> {
        fluent_builders::BundleInstance::new(self.handle.clone())
    }
    pub fn cancel_bundle_task(&self) -> fluent_builders::CancelBundleTask<C> {
        fluent_builders::CancelBundleTask::new(self.handle.clone())
    }
    pub fn cancel_capacity_reservation(&self) -> fluent_builders::CancelCapacityReservation<C> {
        fluent_builders::CancelCapacityReservation::new(self.handle.clone())
    }
    pub fn cancel_conversion_task(&self) -> fluent_builders::CancelConversionTask<C> {
        fluent_builders::CancelConversionTask::new(self.handle.clone())
    }
    pub fn cancel_export_task(&self) -> fluent_builders::CancelExportTask<C> {
        fluent_builders::CancelExportTask::new(self.handle.clone())
    }
    pub fn cancel_import_task(&self) -> fluent_builders::CancelImportTask<C> {
        fluent_builders::CancelImportTask::new(self.handle.clone())
    }
    pub fn cancel_reserved_instances_listing(
        &self,
    ) -> fluent_builders::CancelReservedInstancesListing<C> {
        fluent_builders::CancelReservedInstancesListing::new(self.handle.clone())
    }
    pub fn cancel_spot_fleet_requests(&self) -> fluent_builders::CancelSpotFleetRequests<C> {
        fluent_builders::CancelSpotFleetRequests::new(self.handle.clone())
    }
    pub fn cancel_spot_instance_requests(&self) -> fluent_builders::CancelSpotInstanceRequests<C> {
        fluent_builders::CancelSpotInstanceRequests::new(self.handle.clone())
    }
    pub fn confirm_product_instance(&self) -> fluent_builders::ConfirmProductInstance<C> {
        fluent_builders::ConfirmProductInstance::new(self.handle.clone())
    }
    pub fn copy_fpga_image(&self) -> fluent_builders::CopyFpgaImage<C> {
        fluent_builders::CopyFpgaImage::new(self.handle.clone())
    }
    pub fn copy_image(&self) -> fluent_builders::CopyImage<C> {
        fluent_builders::CopyImage::new(self.handle.clone())
    }
    pub fn copy_snapshot(&self) -> fluent_builders::CopySnapshot<C> {
        fluent_builders::CopySnapshot::new(self.handle.clone())
    }
    pub fn create_capacity_reservation(&self) -> fluent_builders::CreateCapacityReservation<C> {
        fluent_builders::CreateCapacityReservation::new(self.handle.clone())
    }
    pub fn create_carrier_gateway(&self) -> fluent_builders::CreateCarrierGateway<C> {
        fluent_builders::CreateCarrierGateway::new(self.handle.clone())
    }
    pub fn create_client_vpn_endpoint(&self) -> fluent_builders::CreateClientVpnEndpoint<C> {
        fluent_builders::CreateClientVpnEndpoint::new(self.handle.clone())
    }
    pub fn create_client_vpn_route(&self) -> fluent_builders::CreateClientVpnRoute<C> {
        fluent_builders::CreateClientVpnRoute::new(self.handle.clone())
    }
    pub fn create_customer_gateway(&self) -> fluent_builders::CreateCustomerGateway<C> {
        fluent_builders::CreateCustomerGateway::new(self.handle.clone())
    }
    pub fn create_default_subnet(&self) -> fluent_builders::CreateDefaultSubnet<C> {
        fluent_builders::CreateDefaultSubnet::new(self.handle.clone())
    }
    pub fn create_default_vpc(&self) -> fluent_builders::CreateDefaultVpc<C> {
        fluent_builders::CreateDefaultVpc::new(self.handle.clone())
    }
    pub fn create_dhcp_options(&self) -> fluent_builders::CreateDhcpOptions<C> {
        fluent_builders::CreateDhcpOptions::new(self.handle.clone())
    }
    pub fn create_egress_only_internet_gateway(
        &self,
    ) -> fluent_builders::CreateEgressOnlyInternetGateway<C> {
        fluent_builders::CreateEgressOnlyInternetGateway::new(self.handle.clone())
    }
    pub fn create_fleet(&self) -> fluent_builders::CreateFleet<C> {
        fluent_builders::CreateFleet::new(self.handle.clone())
    }
    pub fn create_flow_logs(&self) -> fluent_builders::CreateFlowLogs<C> {
        fluent_builders::CreateFlowLogs::new(self.handle.clone())
    }
    pub fn create_fpga_image(&self) -> fluent_builders::CreateFpgaImage<C> {
        fluent_builders::CreateFpgaImage::new(self.handle.clone())
    }
    pub fn create_image(&self) -> fluent_builders::CreateImage<C> {
        fluent_builders::CreateImage::new(self.handle.clone())
    }
    pub fn create_instance_export_task(&self) -> fluent_builders::CreateInstanceExportTask<C> {
        fluent_builders::CreateInstanceExportTask::new(self.handle.clone())
    }
    pub fn create_internet_gateway(&self) -> fluent_builders::CreateInternetGateway<C> {
        fluent_builders::CreateInternetGateway::new(self.handle.clone())
    }
    pub fn create_key_pair(&self) -> fluent_builders::CreateKeyPair<C> {
        fluent_builders::CreateKeyPair::new(self.handle.clone())
    }
    pub fn create_launch_template(&self) -> fluent_builders::CreateLaunchTemplate<C> {
        fluent_builders::CreateLaunchTemplate::new(self.handle.clone())
    }
    pub fn create_launch_template_version(
        &self,
    ) -> fluent_builders::CreateLaunchTemplateVersion<C> {
        fluent_builders::CreateLaunchTemplateVersion::new(self.handle.clone())
    }
    pub fn create_local_gateway_route(&self) -> fluent_builders::CreateLocalGatewayRoute<C> {
        fluent_builders::CreateLocalGatewayRoute::new(self.handle.clone())
    }
    pub fn create_local_gateway_route_table_vpc_association(
        &self,
    ) -> fluent_builders::CreateLocalGatewayRouteTableVpcAssociation<C> {
        fluent_builders::CreateLocalGatewayRouteTableVpcAssociation::new(self.handle.clone())
    }
    pub fn create_managed_prefix_list(&self) -> fluent_builders::CreateManagedPrefixList<C> {
        fluent_builders::CreateManagedPrefixList::new(self.handle.clone())
    }
    pub fn create_nat_gateway(&self) -> fluent_builders::CreateNatGateway<C> {
        fluent_builders::CreateNatGateway::new(self.handle.clone())
    }
    pub fn create_network_acl(&self) -> fluent_builders::CreateNetworkAcl<C> {
        fluent_builders::CreateNetworkAcl::new(self.handle.clone())
    }
    pub fn create_network_acl_entry(&self) -> fluent_builders::CreateNetworkAclEntry<C> {
        fluent_builders::CreateNetworkAclEntry::new(self.handle.clone())
    }
    pub fn create_network_insights_path(&self) -> fluent_builders::CreateNetworkInsightsPath<C> {
        fluent_builders::CreateNetworkInsightsPath::new(self.handle.clone())
    }
    pub fn create_network_interface(&self) -> fluent_builders::CreateNetworkInterface<C> {
        fluent_builders::CreateNetworkInterface::new(self.handle.clone())
    }
    pub fn create_network_interface_permission(
        &self,
    ) -> fluent_builders::CreateNetworkInterfacePermission<C> {
        fluent_builders::CreateNetworkInterfacePermission::new(self.handle.clone())
    }
    pub fn create_placement_group(&self) -> fluent_builders::CreatePlacementGroup<C> {
        fluent_builders::CreatePlacementGroup::new(self.handle.clone())
    }
    pub fn create_replace_root_volume_task(
        &self,
    ) -> fluent_builders::CreateReplaceRootVolumeTask<C> {
        fluent_builders::CreateReplaceRootVolumeTask::new(self.handle.clone())
    }
    pub fn create_reserved_instances_listing(
        &self,
    ) -> fluent_builders::CreateReservedInstancesListing<C> {
        fluent_builders::CreateReservedInstancesListing::new(self.handle.clone())
    }
    pub fn create_restore_image_task(&self) -> fluent_builders::CreateRestoreImageTask<C> {
        fluent_builders::CreateRestoreImageTask::new(self.handle.clone())
    }
    pub fn create_route(&self) -> fluent_builders::CreateRoute<C> {
        fluent_builders::CreateRoute::new(self.handle.clone())
    }
    pub fn create_route_table(&self) -> fluent_builders::CreateRouteTable<C> {
        fluent_builders::CreateRouteTable::new(self.handle.clone())
    }
    pub fn create_security_group(&self) -> fluent_builders::CreateSecurityGroup<C> {
        fluent_builders::CreateSecurityGroup::new(self.handle.clone())
    }
    pub fn create_snapshot(&self) -> fluent_builders::CreateSnapshot<C> {
        fluent_builders::CreateSnapshot::new(self.handle.clone())
    }
    pub fn create_snapshots(&self) -> fluent_builders::CreateSnapshots<C> {
        fluent_builders::CreateSnapshots::new(self.handle.clone())
    }
    pub fn create_spot_datafeed_subscription(
        &self,
    ) -> fluent_builders::CreateSpotDatafeedSubscription<C> {
        fluent_builders::CreateSpotDatafeedSubscription::new(self.handle.clone())
    }
    pub fn create_store_image_task(&self) -> fluent_builders::CreateStoreImageTask<C> {
        fluent_builders::CreateStoreImageTask::new(self.handle.clone())
    }
    pub fn create_subnet(&self) -> fluent_builders::CreateSubnet<C> {
        fluent_builders::CreateSubnet::new(self.handle.clone())
    }
    pub fn create_tags(&self) -> fluent_builders::CreateTags<C> {
        fluent_builders::CreateTags::new(self.handle.clone())
    }
    pub fn create_traffic_mirror_filter(&self) -> fluent_builders::CreateTrafficMirrorFilter<C> {
        fluent_builders::CreateTrafficMirrorFilter::new(self.handle.clone())
    }
    pub fn create_traffic_mirror_filter_rule(
        &self,
    ) -> fluent_builders::CreateTrafficMirrorFilterRule<C> {
        fluent_builders::CreateTrafficMirrorFilterRule::new(self.handle.clone())
    }
    pub fn create_traffic_mirror_session(&self) -> fluent_builders::CreateTrafficMirrorSession<C> {
        fluent_builders::CreateTrafficMirrorSession::new(self.handle.clone())
    }
    pub fn create_traffic_mirror_target(&self) -> fluent_builders::CreateTrafficMirrorTarget<C> {
        fluent_builders::CreateTrafficMirrorTarget::new(self.handle.clone())
    }
    pub fn create_transit_gateway(&self) -> fluent_builders::CreateTransitGateway<C> {
        fluent_builders::CreateTransitGateway::new(self.handle.clone())
    }
    pub fn create_transit_gateway_connect(
        &self,
    ) -> fluent_builders::CreateTransitGatewayConnect<C> {
        fluent_builders::CreateTransitGatewayConnect::new(self.handle.clone())
    }
    pub fn create_transit_gateway_connect_peer(
        &self,
    ) -> fluent_builders::CreateTransitGatewayConnectPeer<C> {
        fluent_builders::CreateTransitGatewayConnectPeer::new(self.handle.clone())
    }
    pub fn create_transit_gateway_multicast_domain(
        &self,
    ) -> fluent_builders::CreateTransitGatewayMulticastDomain<C> {
        fluent_builders::CreateTransitGatewayMulticastDomain::new(self.handle.clone())
    }
    pub fn create_transit_gateway_peering_attachment(
        &self,
    ) -> fluent_builders::CreateTransitGatewayPeeringAttachment<C> {
        fluent_builders::CreateTransitGatewayPeeringAttachment::new(self.handle.clone())
    }
    pub fn create_transit_gateway_prefix_list_reference(
        &self,
    ) -> fluent_builders::CreateTransitGatewayPrefixListReference<C> {
        fluent_builders::CreateTransitGatewayPrefixListReference::new(self.handle.clone())
    }
    pub fn create_transit_gateway_route(&self) -> fluent_builders::CreateTransitGatewayRoute<C> {
        fluent_builders::CreateTransitGatewayRoute::new(self.handle.clone())
    }
    pub fn create_transit_gateway_route_table(
        &self,
    ) -> fluent_builders::CreateTransitGatewayRouteTable<C> {
        fluent_builders::CreateTransitGatewayRouteTable::new(self.handle.clone())
    }
    pub fn create_transit_gateway_vpc_attachment(
        &self,
    ) -> fluent_builders::CreateTransitGatewayVpcAttachment<C> {
        fluent_builders::CreateTransitGatewayVpcAttachment::new(self.handle.clone())
    }
    pub fn create_volume(&self) -> fluent_builders::CreateVolume<C> {
        fluent_builders::CreateVolume::new(self.handle.clone())
    }
    pub fn create_vpc(&self) -> fluent_builders::CreateVpc<C> {
        fluent_builders::CreateVpc::new(self.handle.clone())
    }
    pub fn create_vpc_endpoint(&self) -> fluent_builders::CreateVpcEndpoint<C> {
        fluent_builders::CreateVpcEndpoint::new(self.handle.clone())
    }
    pub fn create_vpc_endpoint_connection_notification(
        &self,
    ) -> fluent_builders::CreateVpcEndpointConnectionNotification<C> {
        fluent_builders::CreateVpcEndpointConnectionNotification::new(self.handle.clone())
    }
    pub fn create_vpc_endpoint_service_configuration(
        &self,
    ) -> fluent_builders::CreateVpcEndpointServiceConfiguration<C> {
        fluent_builders::CreateVpcEndpointServiceConfiguration::new(self.handle.clone())
    }
    pub fn create_vpc_peering_connection(&self) -> fluent_builders::CreateVpcPeeringConnection<C> {
        fluent_builders::CreateVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn create_vpn_connection(&self) -> fluent_builders::CreateVpnConnection<C> {
        fluent_builders::CreateVpnConnection::new(self.handle.clone())
    }
    pub fn create_vpn_connection_route(&self) -> fluent_builders::CreateVpnConnectionRoute<C> {
        fluent_builders::CreateVpnConnectionRoute::new(self.handle.clone())
    }
    pub fn create_vpn_gateway(&self) -> fluent_builders::CreateVpnGateway<C> {
        fluent_builders::CreateVpnGateway::new(self.handle.clone())
    }
    pub fn delete_carrier_gateway(&self) -> fluent_builders::DeleteCarrierGateway<C> {
        fluent_builders::DeleteCarrierGateway::new(self.handle.clone())
    }
    pub fn delete_client_vpn_endpoint(&self) -> fluent_builders::DeleteClientVpnEndpoint<C> {
        fluent_builders::DeleteClientVpnEndpoint::new(self.handle.clone())
    }
    pub fn delete_client_vpn_route(&self) -> fluent_builders::DeleteClientVpnRoute<C> {
        fluent_builders::DeleteClientVpnRoute::new(self.handle.clone())
    }
    pub fn delete_customer_gateway(&self) -> fluent_builders::DeleteCustomerGateway<C> {
        fluent_builders::DeleteCustomerGateway::new(self.handle.clone())
    }
    pub fn delete_dhcp_options(&self) -> fluent_builders::DeleteDhcpOptions<C> {
        fluent_builders::DeleteDhcpOptions::new(self.handle.clone())
    }
    pub fn delete_egress_only_internet_gateway(
        &self,
    ) -> fluent_builders::DeleteEgressOnlyInternetGateway<C> {
        fluent_builders::DeleteEgressOnlyInternetGateway::new(self.handle.clone())
    }
    pub fn delete_fleets(&self) -> fluent_builders::DeleteFleets<C> {
        fluent_builders::DeleteFleets::new(self.handle.clone())
    }
    pub fn delete_flow_logs(&self) -> fluent_builders::DeleteFlowLogs<C> {
        fluent_builders::DeleteFlowLogs::new(self.handle.clone())
    }
    pub fn delete_fpga_image(&self) -> fluent_builders::DeleteFpgaImage<C> {
        fluent_builders::DeleteFpgaImage::new(self.handle.clone())
    }
    pub fn delete_internet_gateway(&self) -> fluent_builders::DeleteInternetGateway<C> {
        fluent_builders::DeleteInternetGateway::new(self.handle.clone())
    }
    pub fn delete_key_pair(&self) -> fluent_builders::DeleteKeyPair<C> {
        fluent_builders::DeleteKeyPair::new(self.handle.clone())
    }
    pub fn delete_launch_template(&self) -> fluent_builders::DeleteLaunchTemplate<C> {
        fluent_builders::DeleteLaunchTemplate::new(self.handle.clone())
    }
    pub fn delete_launch_template_versions(
        &self,
    ) -> fluent_builders::DeleteLaunchTemplateVersions<C> {
        fluent_builders::DeleteLaunchTemplateVersions::new(self.handle.clone())
    }
    pub fn delete_local_gateway_route(&self) -> fluent_builders::DeleteLocalGatewayRoute<C> {
        fluent_builders::DeleteLocalGatewayRoute::new(self.handle.clone())
    }
    pub fn delete_local_gateway_route_table_vpc_association(
        &self,
    ) -> fluent_builders::DeleteLocalGatewayRouteTableVpcAssociation<C> {
        fluent_builders::DeleteLocalGatewayRouteTableVpcAssociation::new(self.handle.clone())
    }
    pub fn delete_managed_prefix_list(&self) -> fluent_builders::DeleteManagedPrefixList<C> {
        fluent_builders::DeleteManagedPrefixList::new(self.handle.clone())
    }
    pub fn delete_nat_gateway(&self) -> fluent_builders::DeleteNatGateway<C> {
        fluent_builders::DeleteNatGateway::new(self.handle.clone())
    }
    pub fn delete_network_acl(&self) -> fluent_builders::DeleteNetworkAcl<C> {
        fluent_builders::DeleteNetworkAcl::new(self.handle.clone())
    }
    pub fn delete_network_acl_entry(&self) -> fluent_builders::DeleteNetworkAclEntry<C> {
        fluent_builders::DeleteNetworkAclEntry::new(self.handle.clone())
    }
    pub fn delete_network_insights_analysis(
        &self,
    ) -> fluent_builders::DeleteNetworkInsightsAnalysis<C> {
        fluent_builders::DeleteNetworkInsightsAnalysis::new(self.handle.clone())
    }
    pub fn delete_network_insights_path(&self) -> fluent_builders::DeleteNetworkInsightsPath<C> {
        fluent_builders::DeleteNetworkInsightsPath::new(self.handle.clone())
    }
    pub fn delete_network_interface(&self) -> fluent_builders::DeleteNetworkInterface<C> {
        fluent_builders::DeleteNetworkInterface::new(self.handle.clone())
    }
    pub fn delete_network_interface_permission(
        &self,
    ) -> fluent_builders::DeleteNetworkInterfacePermission<C> {
        fluent_builders::DeleteNetworkInterfacePermission::new(self.handle.clone())
    }
    pub fn delete_placement_group(&self) -> fluent_builders::DeletePlacementGroup<C> {
        fluent_builders::DeletePlacementGroup::new(self.handle.clone())
    }
    pub fn delete_queued_reserved_instances(
        &self,
    ) -> fluent_builders::DeleteQueuedReservedInstances<C> {
        fluent_builders::DeleteQueuedReservedInstances::new(self.handle.clone())
    }
    pub fn delete_route(&self) -> fluent_builders::DeleteRoute<C> {
        fluent_builders::DeleteRoute::new(self.handle.clone())
    }
    pub fn delete_route_table(&self) -> fluent_builders::DeleteRouteTable<C> {
        fluent_builders::DeleteRouteTable::new(self.handle.clone())
    }
    pub fn delete_security_group(&self) -> fluent_builders::DeleteSecurityGroup<C> {
        fluent_builders::DeleteSecurityGroup::new(self.handle.clone())
    }
    pub fn delete_snapshot(&self) -> fluent_builders::DeleteSnapshot<C> {
        fluent_builders::DeleteSnapshot::new(self.handle.clone())
    }
    pub fn delete_spot_datafeed_subscription(
        &self,
    ) -> fluent_builders::DeleteSpotDatafeedSubscription<C> {
        fluent_builders::DeleteSpotDatafeedSubscription::new(self.handle.clone())
    }
    pub fn delete_subnet(&self) -> fluent_builders::DeleteSubnet<C> {
        fluent_builders::DeleteSubnet::new(self.handle.clone())
    }
    pub fn delete_tags(&self) -> fluent_builders::DeleteTags<C> {
        fluent_builders::DeleteTags::new(self.handle.clone())
    }
    pub fn delete_traffic_mirror_filter(&self) -> fluent_builders::DeleteTrafficMirrorFilter<C> {
        fluent_builders::DeleteTrafficMirrorFilter::new(self.handle.clone())
    }
    pub fn delete_traffic_mirror_filter_rule(
        &self,
    ) -> fluent_builders::DeleteTrafficMirrorFilterRule<C> {
        fluent_builders::DeleteTrafficMirrorFilterRule::new(self.handle.clone())
    }
    pub fn delete_traffic_mirror_session(&self) -> fluent_builders::DeleteTrafficMirrorSession<C> {
        fluent_builders::DeleteTrafficMirrorSession::new(self.handle.clone())
    }
    pub fn delete_traffic_mirror_target(&self) -> fluent_builders::DeleteTrafficMirrorTarget<C> {
        fluent_builders::DeleteTrafficMirrorTarget::new(self.handle.clone())
    }
    pub fn delete_transit_gateway(&self) -> fluent_builders::DeleteTransitGateway<C> {
        fluent_builders::DeleteTransitGateway::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_connect(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayConnect<C> {
        fluent_builders::DeleteTransitGatewayConnect::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_connect_peer(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayConnectPeer<C> {
        fluent_builders::DeleteTransitGatewayConnectPeer::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_multicast_domain(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayMulticastDomain<C> {
        fluent_builders::DeleteTransitGatewayMulticastDomain::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_peering_attachment(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayPeeringAttachment<C> {
        fluent_builders::DeleteTransitGatewayPeeringAttachment::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_prefix_list_reference(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayPrefixListReference<C> {
        fluent_builders::DeleteTransitGatewayPrefixListReference::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_route(&self) -> fluent_builders::DeleteTransitGatewayRoute<C> {
        fluent_builders::DeleteTransitGatewayRoute::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_route_table(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayRouteTable<C> {
        fluent_builders::DeleteTransitGatewayRouteTable::new(self.handle.clone())
    }
    pub fn delete_transit_gateway_vpc_attachment(
        &self,
    ) -> fluent_builders::DeleteTransitGatewayVpcAttachment<C> {
        fluent_builders::DeleteTransitGatewayVpcAttachment::new(self.handle.clone())
    }
    pub fn delete_volume(&self) -> fluent_builders::DeleteVolume<C> {
        fluent_builders::DeleteVolume::new(self.handle.clone())
    }
    pub fn delete_vpc(&self) -> fluent_builders::DeleteVpc<C> {
        fluent_builders::DeleteVpc::new(self.handle.clone())
    }
    pub fn delete_vpc_endpoint_connection_notifications(
        &self,
    ) -> fluent_builders::DeleteVpcEndpointConnectionNotifications<C> {
        fluent_builders::DeleteVpcEndpointConnectionNotifications::new(self.handle.clone())
    }
    pub fn delete_vpc_endpoints(&self) -> fluent_builders::DeleteVpcEndpoints<C> {
        fluent_builders::DeleteVpcEndpoints::new(self.handle.clone())
    }
    pub fn delete_vpc_endpoint_service_configurations(
        &self,
    ) -> fluent_builders::DeleteVpcEndpointServiceConfigurations<C> {
        fluent_builders::DeleteVpcEndpointServiceConfigurations::new(self.handle.clone())
    }
    pub fn delete_vpc_peering_connection(&self) -> fluent_builders::DeleteVpcPeeringConnection<C> {
        fluent_builders::DeleteVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn delete_vpn_connection(&self) -> fluent_builders::DeleteVpnConnection<C> {
        fluent_builders::DeleteVpnConnection::new(self.handle.clone())
    }
    pub fn delete_vpn_connection_route(&self) -> fluent_builders::DeleteVpnConnectionRoute<C> {
        fluent_builders::DeleteVpnConnectionRoute::new(self.handle.clone())
    }
    pub fn delete_vpn_gateway(&self) -> fluent_builders::DeleteVpnGateway<C> {
        fluent_builders::DeleteVpnGateway::new(self.handle.clone())
    }
    pub fn deprovision_byoip_cidr(&self) -> fluent_builders::DeprovisionByoipCidr<C> {
        fluent_builders::DeprovisionByoipCidr::new(self.handle.clone())
    }
    pub fn deregister_image(&self) -> fluent_builders::DeregisterImage<C> {
        fluent_builders::DeregisterImage::new(self.handle.clone())
    }
    pub fn deregister_instance_event_notification_attributes(
        &self,
    ) -> fluent_builders::DeregisterInstanceEventNotificationAttributes<C> {
        fluent_builders::DeregisterInstanceEventNotificationAttributes::new(self.handle.clone())
    }
    pub fn deregister_transit_gateway_multicast_group_members(
        &self,
    ) -> fluent_builders::DeregisterTransitGatewayMulticastGroupMembers<C> {
        fluent_builders::DeregisterTransitGatewayMulticastGroupMembers::new(self.handle.clone())
    }
    pub fn deregister_transit_gateway_multicast_group_sources(
        &self,
    ) -> fluent_builders::DeregisterTransitGatewayMulticastGroupSources<C> {
        fluent_builders::DeregisterTransitGatewayMulticastGroupSources::new(self.handle.clone())
    }
    pub fn describe_account_attributes(&self) -> fluent_builders::DescribeAccountAttributes<C> {
        fluent_builders::DescribeAccountAttributes::new(self.handle.clone())
    }
    pub fn describe_addresses(&self) -> fluent_builders::DescribeAddresses<C> {
        fluent_builders::DescribeAddresses::new(self.handle.clone())
    }
    pub fn describe_addresses_attribute(&self) -> fluent_builders::DescribeAddressesAttribute<C> {
        fluent_builders::DescribeAddressesAttribute::new(self.handle.clone())
    }
    pub fn describe_aggregate_id_format(&self) -> fluent_builders::DescribeAggregateIdFormat<C> {
        fluent_builders::DescribeAggregateIdFormat::new(self.handle.clone())
    }
    pub fn describe_availability_zones(&self) -> fluent_builders::DescribeAvailabilityZones<C> {
        fluent_builders::DescribeAvailabilityZones::new(self.handle.clone())
    }
    pub fn describe_bundle_tasks(&self) -> fluent_builders::DescribeBundleTasks<C> {
        fluent_builders::DescribeBundleTasks::new(self.handle.clone())
    }
    pub fn describe_byoip_cidrs(&self) -> fluent_builders::DescribeByoipCidrs<C> {
        fluent_builders::DescribeByoipCidrs::new(self.handle.clone())
    }
    pub fn describe_capacity_reservations(
        &self,
    ) -> fluent_builders::DescribeCapacityReservations<C> {
        fluent_builders::DescribeCapacityReservations::new(self.handle.clone())
    }
    pub fn describe_carrier_gateways(&self) -> fluent_builders::DescribeCarrierGateways<C> {
        fluent_builders::DescribeCarrierGateways::new(self.handle.clone())
    }
    pub fn describe_classic_link_instances(
        &self,
    ) -> fluent_builders::DescribeClassicLinkInstances<C> {
        fluent_builders::DescribeClassicLinkInstances::new(self.handle.clone())
    }
    pub fn describe_client_vpn_authorization_rules(
        &self,
    ) -> fluent_builders::DescribeClientVpnAuthorizationRules<C> {
        fluent_builders::DescribeClientVpnAuthorizationRules::new(self.handle.clone())
    }
    pub fn describe_client_vpn_connections(
        &self,
    ) -> fluent_builders::DescribeClientVpnConnections<C> {
        fluent_builders::DescribeClientVpnConnections::new(self.handle.clone())
    }
    pub fn describe_client_vpn_endpoints(&self) -> fluent_builders::DescribeClientVpnEndpoints<C> {
        fluent_builders::DescribeClientVpnEndpoints::new(self.handle.clone())
    }
    pub fn describe_client_vpn_routes(&self) -> fluent_builders::DescribeClientVpnRoutes<C> {
        fluent_builders::DescribeClientVpnRoutes::new(self.handle.clone())
    }
    pub fn describe_client_vpn_target_networks(
        &self,
    ) -> fluent_builders::DescribeClientVpnTargetNetworks<C> {
        fluent_builders::DescribeClientVpnTargetNetworks::new(self.handle.clone())
    }
    pub fn describe_coip_pools(&self) -> fluent_builders::DescribeCoipPools<C> {
        fluent_builders::DescribeCoipPools::new(self.handle.clone())
    }
    pub fn describe_conversion_tasks(&self) -> fluent_builders::DescribeConversionTasks<C> {
        fluent_builders::DescribeConversionTasks::new(self.handle.clone())
    }
    pub fn describe_customer_gateways(&self) -> fluent_builders::DescribeCustomerGateways<C> {
        fluent_builders::DescribeCustomerGateways::new(self.handle.clone())
    }
    pub fn describe_dhcp_options(&self) -> fluent_builders::DescribeDhcpOptions<C> {
        fluent_builders::DescribeDhcpOptions::new(self.handle.clone())
    }
    pub fn describe_egress_only_internet_gateways(
        &self,
    ) -> fluent_builders::DescribeEgressOnlyInternetGateways<C> {
        fluent_builders::DescribeEgressOnlyInternetGateways::new(self.handle.clone())
    }
    pub fn describe_elastic_gpus(&self) -> fluent_builders::DescribeElasticGpus<C> {
        fluent_builders::DescribeElasticGpus::new(self.handle.clone())
    }
    pub fn describe_export_image_tasks(&self) -> fluent_builders::DescribeExportImageTasks<C> {
        fluent_builders::DescribeExportImageTasks::new(self.handle.clone())
    }
    pub fn describe_export_tasks(&self) -> fluent_builders::DescribeExportTasks<C> {
        fluent_builders::DescribeExportTasks::new(self.handle.clone())
    }
    pub fn describe_fast_snapshot_restores(
        &self,
    ) -> fluent_builders::DescribeFastSnapshotRestores<C> {
        fluent_builders::DescribeFastSnapshotRestores::new(self.handle.clone())
    }
    pub fn describe_fleet_history(&self) -> fluent_builders::DescribeFleetHistory<C> {
        fluent_builders::DescribeFleetHistory::new(self.handle.clone())
    }
    pub fn describe_fleet_instances(&self) -> fluent_builders::DescribeFleetInstances<C> {
        fluent_builders::DescribeFleetInstances::new(self.handle.clone())
    }
    pub fn describe_fleets(&self) -> fluent_builders::DescribeFleets<C> {
        fluent_builders::DescribeFleets::new(self.handle.clone())
    }
    pub fn describe_flow_logs(&self) -> fluent_builders::DescribeFlowLogs<C> {
        fluent_builders::DescribeFlowLogs::new(self.handle.clone())
    }
    pub fn describe_fpga_image_attribute(&self) -> fluent_builders::DescribeFpgaImageAttribute<C> {
        fluent_builders::DescribeFpgaImageAttribute::new(self.handle.clone())
    }
    pub fn describe_fpga_images(&self) -> fluent_builders::DescribeFpgaImages<C> {
        fluent_builders::DescribeFpgaImages::new(self.handle.clone())
    }
    pub fn describe_host_reservation_offerings(
        &self,
    ) -> fluent_builders::DescribeHostReservationOfferings<C> {
        fluent_builders::DescribeHostReservationOfferings::new(self.handle.clone())
    }
    pub fn describe_host_reservations(&self) -> fluent_builders::DescribeHostReservations<C> {
        fluent_builders::DescribeHostReservations::new(self.handle.clone())
    }
    pub fn describe_hosts(&self) -> fluent_builders::DescribeHosts<C> {
        fluent_builders::DescribeHosts::new(self.handle.clone())
    }
    pub fn describe_iam_instance_profile_associations(
        &self,
    ) -> fluent_builders::DescribeIamInstanceProfileAssociations<C> {
        fluent_builders::DescribeIamInstanceProfileAssociations::new(self.handle.clone())
    }
    pub fn describe_identity_id_format(&self) -> fluent_builders::DescribeIdentityIdFormat<C> {
        fluent_builders::DescribeIdentityIdFormat::new(self.handle.clone())
    }
    pub fn describe_id_format(&self) -> fluent_builders::DescribeIdFormat<C> {
        fluent_builders::DescribeIdFormat::new(self.handle.clone())
    }
    pub fn describe_image_attribute(&self) -> fluent_builders::DescribeImageAttribute<C> {
        fluent_builders::DescribeImageAttribute::new(self.handle.clone())
    }
    pub fn describe_images(&self) -> fluent_builders::DescribeImages<C> {
        fluent_builders::DescribeImages::new(self.handle.clone())
    }
    pub fn describe_import_image_tasks(&self) -> fluent_builders::DescribeImportImageTasks<C> {
        fluent_builders::DescribeImportImageTasks::new(self.handle.clone())
    }
    pub fn describe_import_snapshot_tasks(
        &self,
    ) -> fluent_builders::DescribeImportSnapshotTasks<C> {
        fluent_builders::DescribeImportSnapshotTasks::new(self.handle.clone())
    }
    pub fn describe_instance_attribute(&self) -> fluent_builders::DescribeInstanceAttribute<C> {
        fluent_builders::DescribeInstanceAttribute::new(self.handle.clone())
    }
    pub fn describe_instance_credit_specifications(
        &self,
    ) -> fluent_builders::DescribeInstanceCreditSpecifications<C> {
        fluent_builders::DescribeInstanceCreditSpecifications::new(self.handle.clone())
    }
    pub fn describe_instance_event_notification_attributes(
        &self,
    ) -> fluent_builders::DescribeInstanceEventNotificationAttributes<C> {
        fluent_builders::DescribeInstanceEventNotificationAttributes::new(self.handle.clone())
    }
    pub fn describe_instances(&self) -> fluent_builders::DescribeInstances<C> {
        fluent_builders::DescribeInstances::new(self.handle.clone())
    }
    pub fn describe_instance_status(&self) -> fluent_builders::DescribeInstanceStatus<C> {
        fluent_builders::DescribeInstanceStatus::new(self.handle.clone())
    }
    pub fn describe_instance_type_offerings(
        &self,
    ) -> fluent_builders::DescribeInstanceTypeOfferings<C> {
        fluent_builders::DescribeInstanceTypeOfferings::new(self.handle.clone())
    }
    pub fn describe_instance_types(&self) -> fluent_builders::DescribeInstanceTypes<C> {
        fluent_builders::DescribeInstanceTypes::new(self.handle.clone())
    }
    pub fn describe_internet_gateways(&self) -> fluent_builders::DescribeInternetGateways<C> {
        fluent_builders::DescribeInternetGateways::new(self.handle.clone())
    }
    pub fn describe_ipv6_pools(&self) -> fluent_builders::DescribeIpv6Pools<C> {
        fluent_builders::DescribeIpv6Pools::new(self.handle.clone())
    }
    pub fn describe_key_pairs(&self) -> fluent_builders::DescribeKeyPairs<C> {
        fluent_builders::DescribeKeyPairs::new(self.handle.clone())
    }
    pub fn describe_launch_templates(&self) -> fluent_builders::DescribeLaunchTemplates<C> {
        fluent_builders::DescribeLaunchTemplates::new(self.handle.clone())
    }
    pub fn describe_launch_template_versions(
        &self,
    ) -> fluent_builders::DescribeLaunchTemplateVersions<C> {
        fluent_builders::DescribeLaunchTemplateVersions::new(self.handle.clone())
    }
    pub fn describe_local_gateway_route_tables(
        &self,
    ) -> fluent_builders::DescribeLocalGatewayRouteTables<C> {
        fluent_builders::DescribeLocalGatewayRouteTables::new(self.handle.clone())
    }
    pub fn describe_local_gateway_route_table_virtual_interface_group_associations(
        &self,
    ) -> fluent_builders::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations<C> {
        fluent_builders::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations::new(
            self.handle.clone(),
        )
    }
    pub fn describe_local_gateway_route_table_vpc_associations(
        &self,
    ) -> fluent_builders::DescribeLocalGatewayRouteTableVpcAssociations<C> {
        fluent_builders::DescribeLocalGatewayRouteTableVpcAssociations::new(self.handle.clone())
    }
    pub fn describe_local_gateways(&self) -> fluent_builders::DescribeLocalGateways<C> {
        fluent_builders::DescribeLocalGateways::new(self.handle.clone())
    }
    pub fn describe_local_gateway_virtual_interface_groups(
        &self,
    ) -> fluent_builders::DescribeLocalGatewayVirtualInterfaceGroups<C> {
        fluent_builders::DescribeLocalGatewayVirtualInterfaceGroups::new(self.handle.clone())
    }
    pub fn describe_local_gateway_virtual_interfaces(
        &self,
    ) -> fluent_builders::DescribeLocalGatewayVirtualInterfaces<C> {
        fluent_builders::DescribeLocalGatewayVirtualInterfaces::new(self.handle.clone())
    }
    pub fn describe_managed_prefix_lists(&self) -> fluent_builders::DescribeManagedPrefixLists<C> {
        fluent_builders::DescribeManagedPrefixLists::new(self.handle.clone())
    }
    pub fn describe_moving_addresses(&self) -> fluent_builders::DescribeMovingAddresses<C> {
        fluent_builders::DescribeMovingAddresses::new(self.handle.clone())
    }
    pub fn describe_nat_gateways(&self) -> fluent_builders::DescribeNatGateways<C> {
        fluent_builders::DescribeNatGateways::new(self.handle.clone())
    }
    pub fn describe_network_acls(&self) -> fluent_builders::DescribeNetworkAcls<C> {
        fluent_builders::DescribeNetworkAcls::new(self.handle.clone())
    }
    pub fn describe_network_insights_analyses(
        &self,
    ) -> fluent_builders::DescribeNetworkInsightsAnalyses<C> {
        fluent_builders::DescribeNetworkInsightsAnalyses::new(self.handle.clone())
    }
    pub fn describe_network_insights_paths(
        &self,
    ) -> fluent_builders::DescribeNetworkInsightsPaths<C> {
        fluent_builders::DescribeNetworkInsightsPaths::new(self.handle.clone())
    }
    pub fn describe_network_interface_attribute(
        &self,
    ) -> fluent_builders::DescribeNetworkInterfaceAttribute<C> {
        fluent_builders::DescribeNetworkInterfaceAttribute::new(self.handle.clone())
    }
    pub fn describe_network_interface_permissions(
        &self,
    ) -> fluent_builders::DescribeNetworkInterfacePermissions<C> {
        fluent_builders::DescribeNetworkInterfacePermissions::new(self.handle.clone())
    }
    pub fn describe_network_interfaces(&self) -> fluent_builders::DescribeNetworkInterfaces<C> {
        fluent_builders::DescribeNetworkInterfaces::new(self.handle.clone())
    }
    pub fn describe_placement_groups(&self) -> fluent_builders::DescribePlacementGroups<C> {
        fluent_builders::DescribePlacementGroups::new(self.handle.clone())
    }
    pub fn describe_prefix_lists(&self) -> fluent_builders::DescribePrefixLists<C> {
        fluent_builders::DescribePrefixLists::new(self.handle.clone())
    }
    pub fn describe_principal_id_format(&self) -> fluent_builders::DescribePrincipalIdFormat<C> {
        fluent_builders::DescribePrincipalIdFormat::new(self.handle.clone())
    }
    pub fn describe_public_ipv4_pools(&self) -> fluent_builders::DescribePublicIpv4Pools<C> {
        fluent_builders::DescribePublicIpv4Pools::new(self.handle.clone())
    }
    pub fn describe_regions(&self) -> fluent_builders::DescribeRegions<C> {
        fluent_builders::DescribeRegions::new(self.handle.clone())
    }
    pub fn describe_replace_root_volume_tasks(
        &self,
    ) -> fluent_builders::DescribeReplaceRootVolumeTasks<C> {
        fluent_builders::DescribeReplaceRootVolumeTasks::new(self.handle.clone())
    }
    pub fn describe_reserved_instances(&self) -> fluent_builders::DescribeReservedInstances<C> {
        fluent_builders::DescribeReservedInstances::new(self.handle.clone())
    }
    pub fn describe_reserved_instances_listings(
        &self,
    ) -> fluent_builders::DescribeReservedInstancesListings<C> {
        fluent_builders::DescribeReservedInstancesListings::new(self.handle.clone())
    }
    pub fn describe_reserved_instances_modifications(
        &self,
    ) -> fluent_builders::DescribeReservedInstancesModifications<C> {
        fluent_builders::DescribeReservedInstancesModifications::new(self.handle.clone())
    }
    pub fn describe_reserved_instances_offerings(
        &self,
    ) -> fluent_builders::DescribeReservedInstancesOfferings<C> {
        fluent_builders::DescribeReservedInstancesOfferings::new(self.handle.clone())
    }
    pub fn describe_route_tables(&self) -> fluent_builders::DescribeRouteTables<C> {
        fluent_builders::DescribeRouteTables::new(self.handle.clone())
    }
    pub fn describe_scheduled_instance_availability(
        &self,
    ) -> fluent_builders::DescribeScheduledInstanceAvailability<C> {
        fluent_builders::DescribeScheduledInstanceAvailability::new(self.handle.clone())
    }
    pub fn describe_scheduled_instances(&self) -> fluent_builders::DescribeScheduledInstances<C> {
        fluent_builders::DescribeScheduledInstances::new(self.handle.clone())
    }
    pub fn describe_security_group_references(
        &self,
    ) -> fluent_builders::DescribeSecurityGroupReferences<C> {
        fluent_builders::DescribeSecurityGroupReferences::new(self.handle.clone())
    }
    pub fn describe_security_groups(&self) -> fluent_builders::DescribeSecurityGroups<C> {
        fluent_builders::DescribeSecurityGroups::new(self.handle.clone())
    }
    pub fn describe_snapshot_attribute(&self) -> fluent_builders::DescribeSnapshotAttribute<C> {
        fluent_builders::DescribeSnapshotAttribute::new(self.handle.clone())
    }
    pub fn describe_snapshots(&self) -> fluent_builders::DescribeSnapshots<C> {
        fluent_builders::DescribeSnapshots::new(self.handle.clone())
    }
    pub fn describe_spot_datafeed_subscription(
        &self,
    ) -> fluent_builders::DescribeSpotDatafeedSubscription<C> {
        fluent_builders::DescribeSpotDatafeedSubscription::new(self.handle.clone())
    }
    pub fn describe_spot_fleet_instances(&self) -> fluent_builders::DescribeSpotFleetInstances<C> {
        fluent_builders::DescribeSpotFleetInstances::new(self.handle.clone())
    }
    pub fn describe_spot_fleet_request_history(
        &self,
    ) -> fluent_builders::DescribeSpotFleetRequestHistory<C> {
        fluent_builders::DescribeSpotFleetRequestHistory::new(self.handle.clone())
    }
    pub fn describe_spot_fleet_requests(&self) -> fluent_builders::DescribeSpotFleetRequests<C> {
        fluent_builders::DescribeSpotFleetRequests::new(self.handle.clone())
    }
    pub fn describe_spot_instance_requests(
        &self,
    ) -> fluent_builders::DescribeSpotInstanceRequests<C> {
        fluent_builders::DescribeSpotInstanceRequests::new(self.handle.clone())
    }
    pub fn describe_spot_price_history(&self) -> fluent_builders::DescribeSpotPriceHistory<C> {
        fluent_builders::DescribeSpotPriceHistory::new(self.handle.clone())
    }
    pub fn describe_stale_security_groups(
        &self,
    ) -> fluent_builders::DescribeStaleSecurityGroups<C> {
        fluent_builders::DescribeStaleSecurityGroups::new(self.handle.clone())
    }
    pub fn describe_store_image_tasks(&self) -> fluent_builders::DescribeStoreImageTasks<C> {
        fluent_builders::DescribeStoreImageTasks::new(self.handle.clone())
    }
    pub fn describe_subnets(&self) -> fluent_builders::DescribeSubnets<C> {
        fluent_builders::DescribeSubnets::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn describe_traffic_mirror_filters(
        &self,
    ) -> fluent_builders::DescribeTrafficMirrorFilters<C> {
        fluent_builders::DescribeTrafficMirrorFilters::new(self.handle.clone())
    }
    pub fn describe_traffic_mirror_sessions(
        &self,
    ) -> fluent_builders::DescribeTrafficMirrorSessions<C> {
        fluent_builders::DescribeTrafficMirrorSessions::new(self.handle.clone())
    }
    pub fn describe_traffic_mirror_targets(
        &self,
    ) -> fluent_builders::DescribeTrafficMirrorTargets<C> {
        fluent_builders::DescribeTrafficMirrorTargets::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_attachments(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayAttachments<C> {
        fluent_builders::DescribeTransitGatewayAttachments::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_connect_peers(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayConnectPeers<C> {
        fluent_builders::DescribeTransitGatewayConnectPeers::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_connects(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayConnects<C> {
        fluent_builders::DescribeTransitGatewayConnects::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_multicast_domains(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayMulticastDomains<C> {
        fluent_builders::DescribeTransitGatewayMulticastDomains::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_peering_attachments(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayPeeringAttachments<C> {
        fluent_builders::DescribeTransitGatewayPeeringAttachments::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_route_tables(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayRouteTables<C> {
        fluent_builders::DescribeTransitGatewayRouteTables::new(self.handle.clone())
    }
    pub fn describe_transit_gateways(&self) -> fluent_builders::DescribeTransitGateways<C> {
        fluent_builders::DescribeTransitGateways::new(self.handle.clone())
    }
    pub fn describe_transit_gateway_vpc_attachments(
        &self,
    ) -> fluent_builders::DescribeTransitGatewayVpcAttachments<C> {
        fluent_builders::DescribeTransitGatewayVpcAttachments::new(self.handle.clone())
    }
    pub fn describe_trunk_interface_associations(
        &self,
    ) -> fluent_builders::DescribeTrunkInterfaceAssociations<C> {
        fluent_builders::DescribeTrunkInterfaceAssociations::new(self.handle.clone())
    }
    pub fn describe_volume_attribute(&self) -> fluent_builders::DescribeVolumeAttribute<C> {
        fluent_builders::DescribeVolumeAttribute::new(self.handle.clone())
    }
    pub fn describe_volumes(&self) -> fluent_builders::DescribeVolumes<C> {
        fluent_builders::DescribeVolumes::new(self.handle.clone())
    }
    pub fn describe_volumes_modifications(
        &self,
    ) -> fluent_builders::DescribeVolumesModifications<C> {
        fluent_builders::DescribeVolumesModifications::new(self.handle.clone())
    }
    pub fn describe_volume_status(&self) -> fluent_builders::DescribeVolumeStatus<C> {
        fluent_builders::DescribeVolumeStatus::new(self.handle.clone())
    }
    pub fn describe_vpc_attribute(&self) -> fluent_builders::DescribeVpcAttribute<C> {
        fluent_builders::DescribeVpcAttribute::new(self.handle.clone())
    }
    pub fn describe_vpc_classic_link(&self) -> fluent_builders::DescribeVpcClassicLink<C> {
        fluent_builders::DescribeVpcClassicLink::new(self.handle.clone())
    }
    pub fn describe_vpc_classic_link_dns_support(
        &self,
    ) -> fluent_builders::DescribeVpcClassicLinkDnsSupport<C> {
        fluent_builders::DescribeVpcClassicLinkDnsSupport::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoint_connection_notifications(
        &self,
    ) -> fluent_builders::DescribeVpcEndpointConnectionNotifications<C> {
        fluent_builders::DescribeVpcEndpointConnectionNotifications::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoint_connections(
        &self,
    ) -> fluent_builders::DescribeVpcEndpointConnections<C> {
        fluent_builders::DescribeVpcEndpointConnections::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoints(&self) -> fluent_builders::DescribeVpcEndpoints<C> {
        fluent_builders::DescribeVpcEndpoints::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoint_service_configurations(
        &self,
    ) -> fluent_builders::DescribeVpcEndpointServiceConfigurations<C> {
        fluent_builders::DescribeVpcEndpointServiceConfigurations::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoint_service_permissions(
        &self,
    ) -> fluent_builders::DescribeVpcEndpointServicePermissions<C> {
        fluent_builders::DescribeVpcEndpointServicePermissions::new(self.handle.clone())
    }
    pub fn describe_vpc_endpoint_services(
        &self,
    ) -> fluent_builders::DescribeVpcEndpointServices<C> {
        fluent_builders::DescribeVpcEndpointServices::new(self.handle.clone())
    }
    pub fn describe_vpc_peering_connections(
        &self,
    ) -> fluent_builders::DescribeVpcPeeringConnections<C> {
        fluent_builders::DescribeVpcPeeringConnections::new(self.handle.clone())
    }
    pub fn describe_vpcs(&self) -> fluent_builders::DescribeVpcs<C> {
        fluent_builders::DescribeVpcs::new(self.handle.clone())
    }
    pub fn describe_vpn_connections(&self) -> fluent_builders::DescribeVpnConnections<C> {
        fluent_builders::DescribeVpnConnections::new(self.handle.clone())
    }
    pub fn describe_vpn_gateways(&self) -> fluent_builders::DescribeVpnGateways<C> {
        fluent_builders::DescribeVpnGateways::new(self.handle.clone())
    }
    pub fn detach_classic_link_vpc(&self) -> fluent_builders::DetachClassicLinkVpc<C> {
        fluent_builders::DetachClassicLinkVpc::new(self.handle.clone())
    }
    pub fn detach_internet_gateway(&self) -> fluent_builders::DetachInternetGateway<C> {
        fluent_builders::DetachInternetGateway::new(self.handle.clone())
    }
    pub fn detach_network_interface(&self) -> fluent_builders::DetachNetworkInterface<C> {
        fluent_builders::DetachNetworkInterface::new(self.handle.clone())
    }
    pub fn detach_volume(&self) -> fluent_builders::DetachVolume<C> {
        fluent_builders::DetachVolume::new(self.handle.clone())
    }
    pub fn detach_vpn_gateway(&self) -> fluent_builders::DetachVpnGateway<C> {
        fluent_builders::DetachVpnGateway::new(self.handle.clone())
    }
    pub fn disable_ebs_encryption_by_default(
        &self,
    ) -> fluent_builders::DisableEbsEncryptionByDefault<C> {
        fluent_builders::DisableEbsEncryptionByDefault::new(self.handle.clone())
    }
    pub fn disable_fast_snapshot_restores(
        &self,
    ) -> fluent_builders::DisableFastSnapshotRestores<C> {
        fluent_builders::DisableFastSnapshotRestores::new(self.handle.clone())
    }
    pub fn disable_image_deprecation(&self) -> fluent_builders::DisableImageDeprecation<C> {
        fluent_builders::DisableImageDeprecation::new(self.handle.clone())
    }
    pub fn disable_serial_console_access(&self) -> fluent_builders::DisableSerialConsoleAccess<C> {
        fluent_builders::DisableSerialConsoleAccess::new(self.handle.clone())
    }
    pub fn disable_transit_gateway_route_table_propagation(
        &self,
    ) -> fluent_builders::DisableTransitGatewayRouteTablePropagation<C> {
        fluent_builders::DisableTransitGatewayRouteTablePropagation::new(self.handle.clone())
    }
    pub fn disable_vgw_route_propagation(&self) -> fluent_builders::DisableVgwRoutePropagation<C> {
        fluent_builders::DisableVgwRoutePropagation::new(self.handle.clone())
    }
    pub fn disable_vpc_classic_link(&self) -> fluent_builders::DisableVpcClassicLink<C> {
        fluent_builders::DisableVpcClassicLink::new(self.handle.clone())
    }
    pub fn disable_vpc_classic_link_dns_support(
        &self,
    ) -> fluent_builders::DisableVpcClassicLinkDnsSupport<C> {
        fluent_builders::DisableVpcClassicLinkDnsSupport::new(self.handle.clone())
    }
    pub fn disassociate_address(&self) -> fluent_builders::DisassociateAddress<C> {
        fluent_builders::DisassociateAddress::new(self.handle.clone())
    }
    pub fn disassociate_client_vpn_target_network(
        &self,
    ) -> fluent_builders::DisassociateClientVpnTargetNetwork<C> {
        fluent_builders::DisassociateClientVpnTargetNetwork::new(self.handle.clone())
    }
    pub fn disassociate_enclave_certificate_iam_role(
        &self,
    ) -> fluent_builders::DisassociateEnclaveCertificateIamRole<C> {
        fluent_builders::DisassociateEnclaveCertificateIamRole::new(self.handle.clone())
    }
    pub fn disassociate_iam_instance_profile(
        &self,
    ) -> fluent_builders::DisassociateIamInstanceProfile<C> {
        fluent_builders::DisassociateIamInstanceProfile::new(self.handle.clone())
    }
    pub fn disassociate_route_table(&self) -> fluent_builders::DisassociateRouteTable<C> {
        fluent_builders::DisassociateRouteTable::new(self.handle.clone())
    }
    pub fn disassociate_subnet_cidr_block(
        &self,
    ) -> fluent_builders::DisassociateSubnetCidrBlock<C> {
        fluent_builders::DisassociateSubnetCidrBlock::new(self.handle.clone())
    }
    pub fn disassociate_transit_gateway_multicast_domain(
        &self,
    ) -> fluent_builders::DisassociateTransitGatewayMulticastDomain<C> {
        fluent_builders::DisassociateTransitGatewayMulticastDomain::new(self.handle.clone())
    }
    pub fn disassociate_transit_gateway_route_table(
        &self,
    ) -> fluent_builders::DisassociateTransitGatewayRouteTable<C> {
        fluent_builders::DisassociateTransitGatewayRouteTable::new(self.handle.clone())
    }
    pub fn disassociate_trunk_interface(&self) -> fluent_builders::DisassociateTrunkInterface<C> {
        fluent_builders::DisassociateTrunkInterface::new(self.handle.clone())
    }
    pub fn disassociate_vpc_cidr_block(&self) -> fluent_builders::DisassociateVpcCidrBlock<C> {
        fluent_builders::DisassociateVpcCidrBlock::new(self.handle.clone())
    }
    pub fn enable_ebs_encryption_by_default(
        &self,
    ) -> fluent_builders::EnableEbsEncryptionByDefault<C> {
        fluent_builders::EnableEbsEncryptionByDefault::new(self.handle.clone())
    }
    pub fn enable_fast_snapshot_restores(&self) -> fluent_builders::EnableFastSnapshotRestores<C> {
        fluent_builders::EnableFastSnapshotRestores::new(self.handle.clone())
    }
    pub fn enable_image_deprecation(&self) -> fluent_builders::EnableImageDeprecation<C> {
        fluent_builders::EnableImageDeprecation::new(self.handle.clone())
    }
    pub fn enable_serial_console_access(&self) -> fluent_builders::EnableSerialConsoleAccess<C> {
        fluent_builders::EnableSerialConsoleAccess::new(self.handle.clone())
    }
    pub fn enable_transit_gateway_route_table_propagation(
        &self,
    ) -> fluent_builders::EnableTransitGatewayRouteTablePropagation<C> {
        fluent_builders::EnableTransitGatewayRouteTablePropagation::new(self.handle.clone())
    }
    pub fn enable_vgw_route_propagation(&self) -> fluent_builders::EnableVgwRoutePropagation<C> {
        fluent_builders::EnableVgwRoutePropagation::new(self.handle.clone())
    }
    pub fn enable_volume_io(&self) -> fluent_builders::EnableVolumeIO<C> {
        fluent_builders::EnableVolumeIO::new(self.handle.clone())
    }
    pub fn enable_vpc_classic_link(&self) -> fluent_builders::EnableVpcClassicLink<C> {
        fluent_builders::EnableVpcClassicLink::new(self.handle.clone())
    }
    pub fn enable_vpc_classic_link_dns_support(
        &self,
    ) -> fluent_builders::EnableVpcClassicLinkDnsSupport<C> {
        fluent_builders::EnableVpcClassicLinkDnsSupport::new(self.handle.clone())
    }
    pub fn export_client_vpn_client_certificate_revocation_list(
        &self,
    ) -> fluent_builders::ExportClientVpnClientCertificateRevocationList<C> {
        fluent_builders::ExportClientVpnClientCertificateRevocationList::new(self.handle.clone())
    }
    pub fn export_client_vpn_client_configuration(
        &self,
    ) -> fluent_builders::ExportClientVpnClientConfiguration<C> {
        fluent_builders::ExportClientVpnClientConfiguration::new(self.handle.clone())
    }
    pub fn export_image(&self) -> fluent_builders::ExportImage<C> {
        fluent_builders::ExportImage::new(self.handle.clone())
    }
    pub fn export_transit_gateway_routes(&self) -> fluent_builders::ExportTransitGatewayRoutes<C> {
        fluent_builders::ExportTransitGatewayRoutes::new(self.handle.clone())
    }
    pub fn get_associated_enclave_certificate_iam_roles(
        &self,
    ) -> fluent_builders::GetAssociatedEnclaveCertificateIamRoles<C> {
        fluent_builders::GetAssociatedEnclaveCertificateIamRoles::new(self.handle.clone())
    }
    pub fn get_associated_ipv6_pool_cidrs(&self) -> fluent_builders::GetAssociatedIpv6PoolCidrs<C> {
        fluent_builders::GetAssociatedIpv6PoolCidrs::new(self.handle.clone())
    }
    pub fn get_capacity_reservation_usage(
        &self,
    ) -> fluent_builders::GetCapacityReservationUsage<C> {
        fluent_builders::GetCapacityReservationUsage::new(self.handle.clone())
    }
    pub fn get_coip_pool_usage(&self) -> fluent_builders::GetCoipPoolUsage<C> {
        fluent_builders::GetCoipPoolUsage::new(self.handle.clone())
    }
    pub fn get_console_output(&self) -> fluent_builders::GetConsoleOutput<C> {
        fluent_builders::GetConsoleOutput::new(self.handle.clone())
    }
    pub fn get_console_screenshot(&self) -> fluent_builders::GetConsoleScreenshot<C> {
        fluent_builders::GetConsoleScreenshot::new(self.handle.clone())
    }
    pub fn get_default_credit_specification(
        &self,
    ) -> fluent_builders::GetDefaultCreditSpecification<C> {
        fluent_builders::GetDefaultCreditSpecification::new(self.handle.clone())
    }
    pub fn get_ebs_default_kms_key_id(&self) -> fluent_builders::GetEbsDefaultKmsKeyId<C> {
        fluent_builders::GetEbsDefaultKmsKeyId::new(self.handle.clone())
    }
    pub fn get_ebs_encryption_by_default(&self) -> fluent_builders::GetEbsEncryptionByDefault<C> {
        fluent_builders::GetEbsEncryptionByDefault::new(self.handle.clone())
    }
    pub fn get_flow_logs_integration_template(
        &self,
    ) -> fluent_builders::GetFlowLogsIntegrationTemplate<C> {
        fluent_builders::GetFlowLogsIntegrationTemplate::new(self.handle.clone())
    }
    pub fn get_groups_for_capacity_reservation(
        &self,
    ) -> fluent_builders::GetGroupsForCapacityReservation<C> {
        fluent_builders::GetGroupsForCapacityReservation::new(self.handle.clone())
    }
    pub fn get_host_reservation_purchase_preview(
        &self,
    ) -> fluent_builders::GetHostReservationPurchasePreview<C> {
        fluent_builders::GetHostReservationPurchasePreview::new(self.handle.clone())
    }
    pub fn get_launch_template_data(&self) -> fluent_builders::GetLaunchTemplateData<C> {
        fluent_builders::GetLaunchTemplateData::new(self.handle.clone())
    }
    pub fn get_managed_prefix_list_associations(
        &self,
    ) -> fluent_builders::GetManagedPrefixListAssociations<C> {
        fluent_builders::GetManagedPrefixListAssociations::new(self.handle.clone())
    }
    pub fn get_managed_prefix_list_entries(
        &self,
    ) -> fluent_builders::GetManagedPrefixListEntries<C> {
        fluent_builders::GetManagedPrefixListEntries::new(self.handle.clone())
    }
    pub fn get_password_data(&self) -> fluent_builders::GetPasswordData<C> {
        fluent_builders::GetPasswordData::new(self.handle.clone())
    }
    pub fn get_reserved_instances_exchange_quote(
        &self,
    ) -> fluent_builders::GetReservedInstancesExchangeQuote<C> {
        fluent_builders::GetReservedInstancesExchangeQuote::new(self.handle.clone())
    }
    pub fn get_serial_console_access_status(
        &self,
    ) -> fluent_builders::GetSerialConsoleAccessStatus<C> {
        fluent_builders::GetSerialConsoleAccessStatus::new(self.handle.clone())
    }
    pub fn get_transit_gateway_attachment_propagations(
        &self,
    ) -> fluent_builders::GetTransitGatewayAttachmentPropagations<C> {
        fluent_builders::GetTransitGatewayAttachmentPropagations::new(self.handle.clone())
    }
    pub fn get_transit_gateway_multicast_domain_associations(
        &self,
    ) -> fluent_builders::GetTransitGatewayMulticastDomainAssociations<C> {
        fluent_builders::GetTransitGatewayMulticastDomainAssociations::new(self.handle.clone())
    }
    pub fn get_transit_gateway_prefix_list_references(
        &self,
    ) -> fluent_builders::GetTransitGatewayPrefixListReferences<C> {
        fluent_builders::GetTransitGatewayPrefixListReferences::new(self.handle.clone())
    }
    pub fn get_transit_gateway_route_table_associations(
        &self,
    ) -> fluent_builders::GetTransitGatewayRouteTableAssociations<C> {
        fluent_builders::GetTransitGatewayRouteTableAssociations::new(self.handle.clone())
    }
    pub fn get_transit_gateway_route_table_propagations(
        &self,
    ) -> fluent_builders::GetTransitGatewayRouteTablePropagations<C> {
        fluent_builders::GetTransitGatewayRouteTablePropagations::new(self.handle.clone())
    }
    pub fn import_client_vpn_client_certificate_revocation_list(
        &self,
    ) -> fluent_builders::ImportClientVpnClientCertificateRevocationList<C> {
        fluent_builders::ImportClientVpnClientCertificateRevocationList::new(self.handle.clone())
    }
    pub fn import_image(&self) -> fluent_builders::ImportImage<C> {
        fluent_builders::ImportImage::new(self.handle.clone())
    }
    pub fn import_instance(&self) -> fluent_builders::ImportInstance<C> {
        fluent_builders::ImportInstance::new(self.handle.clone())
    }
    pub fn import_key_pair(&self) -> fluent_builders::ImportKeyPair<C> {
        fluent_builders::ImportKeyPair::new(self.handle.clone())
    }
    pub fn import_snapshot(&self) -> fluent_builders::ImportSnapshot<C> {
        fluent_builders::ImportSnapshot::new(self.handle.clone())
    }
    pub fn import_volume(&self) -> fluent_builders::ImportVolume<C> {
        fluent_builders::ImportVolume::new(self.handle.clone())
    }
    pub fn modify_address_attribute(&self) -> fluent_builders::ModifyAddressAttribute<C> {
        fluent_builders::ModifyAddressAttribute::new(self.handle.clone())
    }
    pub fn modify_availability_zone_group(
        &self,
    ) -> fluent_builders::ModifyAvailabilityZoneGroup<C> {
        fluent_builders::ModifyAvailabilityZoneGroup::new(self.handle.clone())
    }
    pub fn modify_capacity_reservation(&self) -> fluent_builders::ModifyCapacityReservation<C> {
        fluent_builders::ModifyCapacityReservation::new(self.handle.clone())
    }
    pub fn modify_client_vpn_endpoint(&self) -> fluent_builders::ModifyClientVpnEndpoint<C> {
        fluent_builders::ModifyClientVpnEndpoint::new(self.handle.clone())
    }
    pub fn modify_default_credit_specification(
        &self,
    ) -> fluent_builders::ModifyDefaultCreditSpecification<C> {
        fluent_builders::ModifyDefaultCreditSpecification::new(self.handle.clone())
    }
    pub fn modify_ebs_default_kms_key_id(&self) -> fluent_builders::ModifyEbsDefaultKmsKeyId<C> {
        fluent_builders::ModifyEbsDefaultKmsKeyId::new(self.handle.clone())
    }
    pub fn modify_fleet(&self) -> fluent_builders::ModifyFleet<C> {
        fluent_builders::ModifyFleet::new(self.handle.clone())
    }
    pub fn modify_fpga_image_attribute(&self) -> fluent_builders::ModifyFpgaImageAttribute<C> {
        fluent_builders::ModifyFpgaImageAttribute::new(self.handle.clone())
    }
    pub fn modify_hosts(&self) -> fluent_builders::ModifyHosts<C> {
        fluent_builders::ModifyHosts::new(self.handle.clone())
    }
    pub fn modify_identity_id_format(&self) -> fluent_builders::ModifyIdentityIdFormat<C> {
        fluent_builders::ModifyIdentityIdFormat::new(self.handle.clone())
    }
    pub fn modify_id_format(&self) -> fluent_builders::ModifyIdFormat<C> {
        fluent_builders::ModifyIdFormat::new(self.handle.clone())
    }
    pub fn modify_image_attribute(&self) -> fluent_builders::ModifyImageAttribute<C> {
        fluent_builders::ModifyImageAttribute::new(self.handle.clone())
    }
    pub fn modify_instance_attribute(&self) -> fluent_builders::ModifyInstanceAttribute<C> {
        fluent_builders::ModifyInstanceAttribute::new(self.handle.clone())
    }
    pub fn modify_instance_capacity_reservation_attributes(
        &self,
    ) -> fluent_builders::ModifyInstanceCapacityReservationAttributes<C> {
        fluent_builders::ModifyInstanceCapacityReservationAttributes::new(self.handle.clone())
    }
    pub fn modify_instance_credit_specification(
        &self,
    ) -> fluent_builders::ModifyInstanceCreditSpecification<C> {
        fluent_builders::ModifyInstanceCreditSpecification::new(self.handle.clone())
    }
    pub fn modify_instance_event_start_time(
        &self,
    ) -> fluent_builders::ModifyInstanceEventStartTime<C> {
        fluent_builders::ModifyInstanceEventStartTime::new(self.handle.clone())
    }
    pub fn modify_instance_metadata_options(
        &self,
    ) -> fluent_builders::ModifyInstanceMetadataOptions<C> {
        fluent_builders::ModifyInstanceMetadataOptions::new(self.handle.clone())
    }
    pub fn modify_instance_placement(&self) -> fluent_builders::ModifyInstancePlacement<C> {
        fluent_builders::ModifyInstancePlacement::new(self.handle.clone())
    }
    pub fn modify_launch_template(&self) -> fluent_builders::ModifyLaunchTemplate<C> {
        fluent_builders::ModifyLaunchTemplate::new(self.handle.clone())
    }
    pub fn modify_managed_prefix_list(&self) -> fluent_builders::ModifyManagedPrefixList<C> {
        fluent_builders::ModifyManagedPrefixList::new(self.handle.clone())
    }
    pub fn modify_network_interface_attribute(
        &self,
    ) -> fluent_builders::ModifyNetworkInterfaceAttribute<C> {
        fluent_builders::ModifyNetworkInterfaceAttribute::new(self.handle.clone())
    }
    pub fn modify_reserved_instances(&self) -> fluent_builders::ModifyReservedInstances<C> {
        fluent_builders::ModifyReservedInstances::new(self.handle.clone())
    }
    pub fn modify_snapshot_attribute(&self) -> fluent_builders::ModifySnapshotAttribute<C> {
        fluent_builders::ModifySnapshotAttribute::new(self.handle.clone())
    }
    pub fn modify_spot_fleet_request(&self) -> fluent_builders::ModifySpotFleetRequest<C> {
        fluent_builders::ModifySpotFleetRequest::new(self.handle.clone())
    }
    pub fn modify_subnet_attribute(&self) -> fluent_builders::ModifySubnetAttribute<C> {
        fluent_builders::ModifySubnetAttribute::new(self.handle.clone())
    }
    pub fn modify_traffic_mirror_filter_network_services(
        &self,
    ) -> fluent_builders::ModifyTrafficMirrorFilterNetworkServices<C> {
        fluent_builders::ModifyTrafficMirrorFilterNetworkServices::new(self.handle.clone())
    }
    pub fn modify_traffic_mirror_filter_rule(
        &self,
    ) -> fluent_builders::ModifyTrafficMirrorFilterRule<C> {
        fluent_builders::ModifyTrafficMirrorFilterRule::new(self.handle.clone())
    }
    pub fn modify_traffic_mirror_session(&self) -> fluent_builders::ModifyTrafficMirrorSession<C> {
        fluent_builders::ModifyTrafficMirrorSession::new(self.handle.clone())
    }
    pub fn modify_transit_gateway(&self) -> fluent_builders::ModifyTransitGateway<C> {
        fluent_builders::ModifyTransitGateway::new(self.handle.clone())
    }
    pub fn modify_transit_gateway_prefix_list_reference(
        &self,
    ) -> fluent_builders::ModifyTransitGatewayPrefixListReference<C> {
        fluent_builders::ModifyTransitGatewayPrefixListReference::new(self.handle.clone())
    }
    pub fn modify_transit_gateway_vpc_attachment(
        &self,
    ) -> fluent_builders::ModifyTransitGatewayVpcAttachment<C> {
        fluent_builders::ModifyTransitGatewayVpcAttachment::new(self.handle.clone())
    }
    pub fn modify_volume(&self) -> fluent_builders::ModifyVolume<C> {
        fluent_builders::ModifyVolume::new(self.handle.clone())
    }
    pub fn modify_volume_attribute(&self) -> fluent_builders::ModifyVolumeAttribute<C> {
        fluent_builders::ModifyVolumeAttribute::new(self.handle.clone())
    }
    pub fn modify_vpc_attribute(&self) -> fluent_builders::ModifyVpcAttribute<C> {
        fluent_builders::ModifyVpcAttribute::new(self.handle.clone())
    }
    pub fn modify_vpc_endpoint(&self) -> fluent_builders::ModifyVpcEndpoint<C> {
        fluent_builders::ModifyVpcEndpoint::new(self.handle.clone())
    }
    pub fn modify_vpc_endpoint_connection_notification(
        &self,
    ) -> fluent_builders::ModifyVpcEndpointConnectionNotification<C> {
        fluent_builders::ModifyVpcEndpointConnectionNotification::new(self.handle.clone())
    }
    pub fn modify_vpc_endpoint_service_configuration(
        &self,
    ) -> fluent_builders::ModifyVpcEndpointServiceConfiguration<C> {
        fluent_builders::ModifyVpcEndpointServiceConfiguration::new(self.handle.clone())
    }
    pub fn modify_vpc_endpoint_service_permissions(
        &self,
    ) -> fluent_builders::ModifyVpcEndpointServicePermissions<C> {
        fluent_builders::ModifyVpcEndpointServicePermissions::new(self.handle.clone())
    }
    pub fn modify_vpc_peering_connection_options(
        &self,
    ) -> fluent_builders::ModifyVpcPeeringConnectionOptions<C> {
        fluent_builders::ModifyVpcPeeringConnectionOptions::new(self.handle.clone())
    }
    pub fn modify_vpc_tenancy(&self) -> fluent_builders::ModifyVpcTenancy<C> {
        fluent_builders::ModifyVpcTenancy::new(self.handle.clone())
    }
    pub fn modify_vpn_connection(&self) -> fluent_builders::ModifyVpnConnection<C> {
        fluent_builders::ModifyVpnConnection::new(self.handle.clone())
    }
    pub fn modify_vpn_connection_options(&self) -> fluent_builders::ModifyVpnConnectionOptions<C> {
        fluent_builders::ModifyVpnConnectionOptions::new(self.handle.clone())
    }
    pub fn modify_vpn_tunnel_certificate(&self) -> fluent_builders::ModifyVpnTunnelCertificate<C> {
        fluent_builders::ModifyVpnTunnelCertificate::new(self.handle.clone())
    }
    pub fn modify_vpn_tunnel_options(&self) -> fluent_builders::ModifyVpnTunnelOptions<C> {
        fluent_builders::ModifyVpnTunnelOptions::new(self.handle.clone())
    }
    pub fn monitor_instances(&self) -> fluent_builders::MonitorInstances<C> {
        fluent_builders::MonitorInstances::new(self.handle.clone())
    }
    pub fn move_address_to_vpc(&self) -> fluent_builders::MoveAddressToVpc<C> {
        fluent_builders::MoveAddressToVpc::new(self.handle.clone())
    }
    pub fn provision_byoip_cidr(&self) -> fluent_builders::ProvisionByoipCidr<C> {
        fluent_builders::ProvisionByoipCidr::new(self.handle.clone())
    }
    pub fn purchase_host_reservation(&self) -> fluent_builders::PurchaseHostReservation<C> {
        fluent_builders::PurchaseHostReservation::new(self.handle.clone())
    }
    pub fn purchase_reserved_instances_offering(
        &self,
    ) -> fluent_builders::PurchaseReservedInstancesOffering<C> {
        fluent_builders::PurchaseReservedInstancesOffering::new(self.handle.clone())
    }
    pub fn purchase_scheduled_instances(&self) -> fluent_builders::PurchaseScheduledInstances<C> {
        fluent_builders::PurchaseScheduledInstances::new(self.handle.clone())
    }
    pub fn reboot_instances(&self) -> fluent_builders::RebootInstances<C> {
        fluent_builders::RebootInstances::new(self.handle.clone())
    }
    pub fn register_image(&self) -> fluent_builders::RegisterImage<C> {
        fluent_builders::RegisterImage::new(self.handle.clone())
    }
    pub fn register_instance_event_notification_attributes(
        &self,
    ) -> fluent_builders::RegisterInstanceEventNotificationAttributes<C> {
        fluent_builders::RegisterInstanceEventNotificationAttributes::new(self.handle.clone())
    }
    pub fn register_transit_gateway_multicast_group_members(
        &self,
    ) -> fluent_builders::RegisterTransitGatewayMulticastGroupMembers<C> {
        fluent_builders::RegisterTransitGatewayMulticastGroupMembers::new(self.handle.clone())
    }
    pub fn register_transit_gateway_multicast_group_sources(
        &self,
    ) -> fluent_builders::RegisterTransitGatewayMulticastGroupSources<C> {
        fluent_builders::RegisterTransitGatewayMulticastGroupSources::new(self.handle.clone())
    }
    pub fn reject_transit_gateway_multicast_domain_associations(
        &self,
    ) -> fluent_builders::RejectTransitGatewayMulticastDomainAssociations<C> {
        fluent_builders::RejectTransitGatewayMulticastDomainAssociations::new(self.handle.clone())
    }
    pub fn reject_transit_gateway_peering_attachment(
        &self,
    ) -> fluent_builders::RejectTransitGatewayPeeringAttachment<C> {
        fluent_builders::RejectTransitGatewayPeeringAttachment::new(self.handle.clone())
    }
    pub fn reject_transit_gateway_vpc_attachment(
        &self,
    ) -> fluent_builders::RejectTransitGatewayVpcAttachment<C> {
        fluent_builders::RejectTransitGatewayVpcAttachment::new(self.handle.clone())
    }
    pub fn reject_vpc_endpoint_connections(
        &self,
    ) -> fluent_builders::RejectVpcEndpointConnections<C> {
        fluent_builders::RejectVpcEndpointConnections::new(self.handle.clone())
    }
    pub fn reject_vpc_peering_connection(&self) -> fluent_builders::RejectVpcPeeringConnection<C> {
        fluent_builders::RejectVpcPeeringConnection::new(self.handle.clone())
    }
    pub fn release_address(&self) -> fluent_builders::ReleaseAddress<C> {
        fluent_builders::ReleaseAddress::new(self.handle.clone())
    }
    pub fn release_hosts(&self) -> fluent_builders::ReleaseHosts<C> {
        fluent_builders::ReleaseHosts::new(self.handle.clone())
    }
    pub fn replace_iam_instance_profile_association(
        &self,
    ) -> fluent_builders::ReplaceIamInstanceProfileAssociation<C> {
        fluent_builders::ReplaceIamInstanceProfileAssociation::new(self.handle.clone())
    }
    pub fn replace_network_acl_association(
        &self,
    ) -> fluent_builders::ReplaceNetworkAclAssociation<C> {
        fluent_builders::ReplaceNetworkAclAssociation::new(self.handle.clone())
    }
    pub fn replace_network_acl_entry(&self) -> fluent_builders::ReplaceNetworkAclEntry<C> {
        fluent_builders::ReplaceNetworkAclEntry::new(self.handle.clone())
    }
    pub fn replace_route(&self) -> fluent_builders::ReplaceRoute<C> {
        fluent_builders::ReplaceRoute::new(self.handle.clone())
    }
    pub fn replace_route_table_association(
        &self,
    ) -> fluent_builders::ReplaceRouteTableAssociation<C> {
        fluent_builders::ReplaceRouteTableAssociation::new(self.handle.clone())
    }
    pub fn replace_transit_gateway_route(&self) -> fluent_builders::ReplaceTransitGatewayRoute<C> {
        fluent_builders::ReplaceTransitGatewayRoute::new(self.handle.clone())
    }
    pub fn report_instance_status(&self) -> fluent_builders::ReportInstanceStatus<C> {
        fluent_builders::ReportInstanceStatus::new(self.handle.clone())
    }
    pub fn request_spot_fleet(&self) -> fluent_builders::RequestSpotFleet<C> {
        fluent_builders::RequestSpotFleet::new(self.handle.clone())
    }
    pub fn request_spot_instances(&self) -> fluent_builders::RequestSpotInstances<C> {
        fluent_builders::RequestSpotInstances::new(self.handle.clone())
    }
    pub fn reset_address_attribute(&self) -> fluent_builders::ResetAddressAttribute<C> {
        fluent_builders::ResetAddressAttribute::new(self.handle.clone())
    }
    pub fn reset_ebs_default_kms_key_id(&self) -> fluent_builders::ResetEbsDefaultKmsKeyId<C> {
        fluent_builders::ResetEbsDefaultKmsKeyId::new(self.handle.clone())
    }
    pub fn reset_fpga_image_attribute(&self) -> fluent_builders::ResetFpgaImageAttribute<C> {
        fluent_builders::ResetFpgaImageAttribute::new(self.handle.clone())
    }
    pub fn reset_image_attribute(&self) -> fluent_builders::ResetImageAttribute<C> {
        fluent_builders::ResetImageAttribute::new(self.handle.clone())
    }
    pub fn reset_instance_attribute(&self) -> fluent_builders::ResetInstanceAttribute<C> {
        fluent_builders::ResetInstanceAttribute::new(self.handle.clone())
    }
    pub fn reset_network_interface_attribute(
        &self,
    ) -> fluent_builders::ResetNetworkInterfaceAttribute<C> {
        fluent_builders::ResetNetworkInterfaceAttribute::new(self.handle.clone())
    }
    pub fn reset_snapshot_attribute(&self) -> fluent_builders::ResetSnapshotAttribute<C> {
        fluent_builders::ResetSnapshotAttribute::new(self.handle.clone())
    }
    pub fn restore_address_to_classic(&self) -> fluent_builders::RestoreAddressToClassic<C> {
        fluent_builders::RestoreAddressToClassic::new(self.handle.clone())
    }
    pub fn restore_managed_prefix_list_version(
        &self,
    ) -> fluent_builders::RestoreManagedPrefixListVersion<C> {
        fluent_builders::RestoreManagedPrefixListVersion::new(self.handle.clone())
    }
    pub fn revoke_client_vpn_ingress(&self) -> fluent_builders::RevokeClientVpnIngress<C> {
        fluent_builders::RevokeClientVpnIngress::new(self.handle.clone())
    }
    pub fn revoke_security_group_egress(&self) -> fluent_builders::RevokeSecurityGroupEgress<C> {
        fluent_builders::RevokeSecurityGroupEgress::new(self.handle.clone())
    }
    pub fn revoke_security_group_ingress(&self) -> fluent_builders::RevokeSecurityGroupIngress<C> {
        fluent_builders::RevokeSecurityGroupIngress::new(self.handle.clone())
    }
    pub fn run_instances(&self) -> fluent_builders::RunInstances<C> {
        fluent_builders::RunInstances::new(self.handle.clone())
    }
    pub fn run_scheduled_instances(&self) -> fluent_builders::RunScheduledInstances<C> {
        fluent_builders::RunScheduledInstances::new(self.handle.clone())
    }
    pub fn search_local_gateway_routes(&self) -> fluent_builders::SearchLocalGatewayRoutes<C> {
        fluent_builders::SearchLocalGatewayRoutes::new(self.handle.clone())
    }
    pub fn search_transit_gateway_multicast_groups(
        &self,
    ) -> fluent_builders::SearchTransitGatewayMulticastGroups<C> {
        fluent_builders::SearchTransitGatewayMulticastGroups::new(self.handle.clone())
    }
    pub fn search_transit_gateway_routes(&self) -> fluent_builders::SearchTransitGatewayRoutes<C> {
        fluent_builders::SearchTransitGatewayRoutes::new(self.handle.clone())
    }
    pub fn send_diagnostic_interrupt(&self) -> fluent_builders::SendDiagnosticInterrupt<C> {
        fluent_builders::SendDiagnosticInterrupt::new(self.handle.clone())
    }
    pub fn start_instances(&self) -> fluent_builders::StartInstances<C> {
        fluent_builders::StartInstances::new(self.handle.clone())
    }
    pub fn start_network_insights_analysis(
        &self,
    ) -> fluent_builders::StartNetworkInsightsAnalysis<C> {
        fluent_builders::StartNetworkInsightsAnalysis::new(self.handle.clone())
    }
    pub fn start_vpc_endpoint_service_private_dns_verification(
        &self,
    ) -> fluent_builders::StartVpcEndpointServicePrivateDnsVerification<C> {
        fluent_builders::StartVpcEndpointServicePrivateDnsVerification::new(self.handle.clone())
    }
    pub fn stop_instances(&self) -> fluent_builders::StopInstances<C> {
        fluent_builders::StopInstances::new(self.handle.clone())
    }
    pub fn terminate_client_vpn_connections(
        &self,
    ) -> fluent_builders::TerminateClientVpnConnections<C> {
        fluent_builders::TerminateClientVpnConnections::new(self.handle.clone())
    }
    pub fn terminate_instances(&self) -> fluent_builders::TerminateInstances<C> {
        fluent_builders::TerminateInstances::new(self.handle.clone())
    }
    pub fn unassign_ipv6_addresses(&self) -> fluent_builders::UnassignIpv6Addresses<C> {
        fluent_builders::UnassignIpv6Addresses::new(self.handle.clone())
    }
    pub fn unassign_private_ip_addresses(&self) -> fluent_builders::UnassignPrivateIpAddresses<C> {
        fluent_builders::UnassignPrivateIpAddresses::new(self.handle.clone())
    }
    pub fn unmonitor_instances(&self) -> fluent_builders::UnmonitorInstances<C> {
        fluent_builders::UnmonitorInstances::new(self.handle.clone())
    }
    pub fn update_security_group_rule_descriptions_egress(
        &self,
    ) -> fluent_builders::UpdateSecurityGroupRuleDescriptionsEgress<C> {
        fluent_builders::UpdateSecurityGroupRuleDescriptionsEgress::new(self.handle.clone())
    }
    pub fn update_security_group_rule_descriptions_ingress(
        &self,
    ) -> fluent_builders::UpdateSecurityGroupRuleDescriptionsIngress<C> {
        fluent_builders::UpdateSecurityGroupRuleDescriptionsIngress::new(self.handle.clone())
    }
    pub fn withdraw_byoip_cidr(&self) -> fluent_builders::WithdrawByoipCidr<C> {
        fluent_builders::WithdrawByoipCidr::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptReservedInstancesExchangeQuote<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_reserved_instances_exchange_quote_input::Builder,
    }
    impl<C> AcceptReservedInstancesExchangeQuote<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptReservedInstancesExchangeQuoteOutput,
            smithy_http::result::SdkError<crate::error::AcceptReservedInstancesExchangeQuoteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the Convertible Reserved Instances to exchange for another Convertible
        /// Reserved Instance of the same or higher value.</p>
        pub fn reserved_instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instance_ids(inp);
            self
        }
        pub fn set_reserved_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instance_ids(input);
            self
        }
        /// <p>The configuration of the target Convertible Reserved Instance to exchange for your
        /// current Convertible Reserved Instances.</p>
        pub fn target_configurations(
            mut self,
            inp: impl Into<crate::model::TargetConfigurationRequest>,
        ) -> Self {
            self.inner = self.inner.target_configurations(inp);
            self
        }
        pub fn set_target_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetConfigurationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_target_configurations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcceptTransitGatewayMulticastDomainAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_transit_gateway_multicast_domain_associations_input::Builder,
    }
    impl<C> AcceptTransitGatewayMulticastDomainAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptTransitGatewayMulticastDomainAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::AcceptTransitGatewayMulticastDomainAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The IDs of the subnets to associate with the transit gateway multicast domain.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcceptTransitGatewayPeeringAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_transit_gateway_peering_attachment_input::Builder,
    }
    impl<C> AcceptTransitGatewayPeeringAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptTransitGatewayPeeringAttachmentOutput,
            smithy_http::result::SdkError<crate::error::AcceptTransitGatewayPeeringAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcceptTransitGatewayVpcAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_transit_gateway_vpc_attachment_input::Builder,
    }
    impl<C> AcceptTransitGatewayVpcAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptTransitGatewayVpcAttachmentOutput,
            smithy_http::result::SdkError<crate::error::AcceptTransitGatewayVpcAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcceptVpcEndpointConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_vpc_endpoint_connections_input::Builder,
    }
    impl<C> AcceptVpcEndpointConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptVpcEndpointConnectionsOutput,
            smithy_http::result::SdkError<crate::error::AcceptVpcEndpointConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC endpoint service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The IDs of one or more interface VPC endpoints.</p>
        pub fn vpc_endpoint_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_ids(inp);
            self
        }
        pub fn set_vpc_endpoint_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AcceptVpcPeeringConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_vpc_peering_connection_input::Builder,
    }
    impl<C> AcceptVpcPeeringConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::AcceptVpcPeeringConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC peering connection. You must specify this parameter in the
        /// request.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AdvertiseByoipCidr<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::advertise_byoip_cidr_input::Builder,
    }
    impl<C> AdvertiseByoipCidr<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AdvertiseByoipCidrOutput,
            smithy_http::result::SdkError<crate::error::AdvertiseByoipCidrError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The address range, in CIDR notation. This must be the exact range that you provisioned.
        /// You can't advertise only a portion of the provisioned range.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr(input);
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AllocateAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::allocate_address_input::Builder,
    }
    impl<C> AllocateAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AllocateAddressOutput,
            smithy_http::result::SdkError<crate::error::AllocateAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether the Elastic IP address is for use with instances in a VPC or instances in EC2-Classic.</p>
        /// <p>Default: If the Region supports EC2-Classic, the default is <code>standard</code>. Otherwise, the default
        /// is <code>vpc</code>.</p>
        pub fn domain(mut self, input: crate::model::DomainType) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<crate::model::DomainType>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>[EC2-VPC] The Elastic IP address to recover or an IPv4 address from an address pool.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address(input);
            self
        }
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_address(input);
            self
        }
        /// <p>The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool.
        /// To specify a specific address from the address pool, use the <code>Address</code> parameter instead.</p>
        pub fn public_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ipv4_pool(input);
            self
        }
        pub fn set_public_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_public_ipv4_pool(input);
            self
        }
        /// <p> A unique set of Availability Zones, Local Zones, or Wavelength Zones from which AWS
        /// advertises IP addresses. Use this parameter to limit the IP address to this location. IP
        /// addresses cannot move between network border groups.</p>
        /// <p>Use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeAvailabilityZones.html">DescribeAvailabilityZones</a> to view the network border groups.</p>
        /// <note>
        /// <p>You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 classic, you will receive an <code>InvalidParameterCombination</code> error. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
        /// </note>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_border_group(input);
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_border_group(input);
            self
        }
        /// <p>The ID of a customer-owned address pool. Use this parameter to let Amazon EC2
        /// select an address from the address pool. Alternatively, specify a specific
        /// address from the address pool.</p>
        pub fn customer_owned_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_owned_ipv4_pool(input);
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_owned_ipv4_pool(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to assign to the Elastic IP address.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AllocateHosts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::allocate_hosts_input::Builder,
    }
    impl<C> AllocateHosts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AllocateHostsOutput,
            smithy_http::result::SdkError<crate::error::AllocateHostsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether the host accepts any untargeted instance launches that
        /// match its instance type configuration, or if it only accepts Host tenancy
        /// instance launches that specify its unique host ID. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding">
        /// Understanding auto-placement and affinity</a> in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p>Default: <code>on</code>
        /// </p>
        pub fn auto_placement(mut self, input: crate::model::AutoPlacement) -> Self {
            self.inner = self.inner.auto_placement(input);
            self
        }
        pub fn set_auto_placement(
            mut self,
            input: std::option::Option<crate::model::AutoPlacement>,
        ) -> Self {
            self.inner = self.inner.set_auto_placement(input);
            self
        }
        /// <p>The Availability Zone in which to allocate the Dedicated Host.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Specifies the instance type to be supported by the Dedicated Hosts. If you
        /// specify an instance type, the Dedicated Hosts support instances of the
        /// specified instance type only.</p>
        /// <p>If you want the Dedicated Hosts to support multiple instance types in a specific
        /// instance family, omit this parameter and specify <b>InstanceFamily</b>
        /// instead. You cannot specify <b>InstanceType</b> and
        /// <b>InstanceFamily</b> in the same request.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>Specifies the instance family to be supported by the Dedicated Hosts. If you specify
        /// an instance family, the Dedicated Hosts support multiple instance types within that
        /// instance family.</p>
        /// <p>If you want the Dedicated Hosts to support a specific instance type only, omit this
        /// parameter and specify <b>InstanceType</b>
        /// instead. You cannot specify <b>InstanceFamily</b> and
        /// <b>InstanceType</b> in the same request.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_family(input);
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_family(input);
            self
        }
        /// <p>The number of Dedicated Hosts to allocate to your account with these parameters.</p>
        pub fn quantity(mut self, input: i32) -> Self {
            self.inner = self.inner.quantity(input);
            self
        }
        pub fn set_quantity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_quantity(input);
            self
        }
        /// <p>The tags to apply to the Dedicated Host during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Indicates whether to enable or disable host recovery for the Dedicated Host.
        /// Host recovery is disabled by default. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html">
        /// Host recovery</a> in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p>Default: <code>off</code>
        /// </p>
        pub fn host_recovery(mut self, input: crate::model::HostRecovery) -> Self {
            self.inner = self.inner.host_recovery(input);
            self
        }
        pub fn set_host_recovery(
            mut self,
            input: std::option::Option<crate::model::HostRecovery>,
        ) -> Self {
            self.inner = self.inner.set_host_recovery(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ApplySecurityGroupsToClientVpnTargetNetwork<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::apply_security_groups_to_client_vpn_target_network_input::Builder,
    }
    impl<C> ApplySecurityGroupsToClientVpnTargetNetwork<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ApplySecurityGroupsToClientVpnTargetNetworkOutput,
            smithy_http::result::SdkError<
                crate::error::ApplySecurityGroupsToClientVpnTargetNetworkError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ID of the VPC in which the associated target network is located.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The IDs of the security groups to apply to the associated target network. Up to 5 security groups can
        /// be applied to an associated target network.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssignIpv6Addresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assign_ipv6_addresses_input::Builder,
    }
    impl<C> AssignIpv6Addresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssignIpv6AddressesOutput,
            smithy_http::result::SdkError<crate::error::AssignIpv6AddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of additional IPv6 addresses to assign to the network interface.
        /// The specified number of IPv6 addresses are assigned in addition to the
        /// existing IPv6 addresses that are already assigned to the network interface.
        /// Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You
        /// can't use this option if specifying specific IPv6 addresses.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.inner = self.inner.ipv6_address_count(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_ipv6_address_count(input);
            self
        }
        /// <p>One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.</p>
        pub fn ipv6_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_addresses(inp);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_addresses(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssignPrivateIpAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assign_private_ip_addresses_input::Builder,
    }
    impl<C> AssignPrivateIpAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssignPrivateIpAddressesOutput,
            smithy_http::result::SdkError<crate::error::AssignPrivateIpAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.</p>
        pub fn allow_reassignment(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_reassignment(input);
            self
        }
        pub fn set_allow_reassignment(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_reassignment(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses.</p>
        /// <p>If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.</p>
        pub fn private_ip_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_ip_addresses(inp);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_addresses(input);
            self
        }
        /// <p>The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.inner = self.inner.secondary_private_ip_address_count(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_secondary_private_ip_address_count(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_address_input::Builder,
    }
    impl<C> AssociateAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateAddressOutput,
            smithy_http::result::SdkError<crate::error::AssociateAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The allocation ID. This is required for EC2-VPC.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_id(input);
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allocation_id(input);
            self
        }
        /// <p>The ID of the instance. The instance must have exactly one attached network interface.
        /// For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both.
        /// For EC2-Classic, you must specify an instance ID and the instance must be in the running
        /// state.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>[EC2-Classic] The Elastic IP address to associate with the instance. This is required for
        /// EC2-Classic.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
        /// <p>[EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.</p>
        pub fn allow_reassociation(mut self, input: bool) -> Self {
            self.inner = self.inner.allow_reassociation(input);
            self
        }
        pub fn set_allow_reassociation(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_allow_reassociation(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>[EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.</p>
        /// <p>For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. </p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_ip_address(input);
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_address(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateClientVpnTargetNetwork<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_client_vpn_target_network_input::Builder,
    }
    impl<C> AssociateClientVpnTargetNetwork<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateClientVpnTargetNetworkOutput,
            smithy_http::result::SdkError<crate::error::AssociateClientVpnTargetNetworkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ID of the subnet to associate with the Client VPN endpoint.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateDhcpOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_dhcp_options_input::Builder,
    }
    impl<C> AssociateDhcpOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateDhcpOptionsOutput,
            smithy_http::result::SdkError<crate::error::AssociateDhcpOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the DHCP options set, or <code>default</code> to associate
        /// no DHCP options with the VPC.</p>
        pub fn dhcp_options_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dhcp_options_id(input);
            self
        }
        pub fn set_dhcp_options_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dhcp_options_id(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateEnclaveCertificateIamRole<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_enclave_certificate_iam_role_input::Builder,
    }
    impl<C> AssociateEnclaveCertificateIamRole<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateEnclaveCertificateIamRoleOutput,
            smithy_http::result::SdkError<crate::error::AssociateEnclaveCertificateIamRoleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the ACM certificate with which to associate the IAM role.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM
        /// certificate.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateIamInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_iam_instance_profile_input::Builder,
    }
    impl<C> AssociateIamInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateIamInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::AssociateIamInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.inner = self.inner.iam_instance_profile(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.inner = self.inner.set_iam_instance_profile(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_route_table_input::Builder,
    }
    impl<C> AssociateRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateRouteTableOutput,
            smithy_http::result::SdkError<crate::error::AssociateRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The ID of the internet gateway or virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_id(input);
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateSubnetCidrBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_subnet_cidr_block_input::Builder,
    }
    impl<C> AssociateSubnetCidrBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateSubnetCidrBlockOutput,
            smithy_http::result::SdkError<crate::error::AssociateSubnetCidrBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix
        /// length.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of your subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateTransitGatewayMulticastDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_transit_gateway_multicast_domain_input::Builder,
    }
    impl<C> AssociateTransitGatewayMulticastDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTransitGatewayMulticastDomainOutput,
            smithy_http::result::SdkError<
                crate::error::AssociateTransitGatewayMulticastDomainError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The ID of the transit gateway attachment to associate with the transit gateway multicast domain.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The IDs of the subnets to associate with the transit gateway multicast domain.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateTransitGatewayRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_transit_gateway_route_table_input::Builder,
    }
    impl<C> AssociateTransitGatewayRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTransitGatewayRouteTableOutput,
            smithy_http::result::SdkError<crate::error::AssociateTransitGatewayRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateTrunkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_trunk_interface_input::Builder,
    }
    impl<C> AssociateTrunkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateTrunkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::AssociateTrunkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the branch network interface.</p>
        pub fn branch_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_interface_id(input);
            self
        }
        pub fn set_branch_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_branch_interface_id(input);
            self
        }
        /// <p>The ID of the trunk network interface.</p>
        pub fn trunk_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.trunk_interface_id(input);
            self
        }
        pub fn set_trunk_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_trunk_interface_id(input);
            self
        }
        /// <p>The ID of the VLAN. This applies to the VLAN protocol.</p>
        pub fn vlan_id(mut self, input: i32) -> Self {
            self.inner = self.inner.vlan_id(input);
            self
        }
        pub fn set_vlan_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_vlan_id(input);
            self
        }
        /// <p>The application key. This applies to the GRE protocol.</p>
        pub fn gre_key(mut self, input: i32) -> Self {
            self.inner = self.inner.gre_key(input);
            self
        }
        pub fn set_gre_key(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_gre_key(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateVpcCidrBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_vpc_cidr_block_input::Builder,
    }
    impl<C> AssociateVpcCidrBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateVpcCidrBlockOutput,
            smithy_http::result::SdkError<crate::error::AssociateVpcCidrBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.</p>
        pub fn amazon_provided_ipv6_cidr_block(mut self, input: bool) -> Self {
            self.inner = self.inner.amazon_provided_ipv6_cidr_block(input);
            self
        }
        pub fn set_amazon_provided_ipv6_cidr_block(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_amazon_provided_ipv6_cidr_block(input);
            self
        }
        /// <p>An IPv4 CIDR block to associate with the VPC.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_block(input);
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_block(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The name of the location from which we advertise the IPV6 CIDR block. Use this parameter
        /// to limit the CIDR block to this location.</p>
        /// <p> You must set <code>AmazonProvidedIpv6CidrBlock</code> to <code>true</code> to use this parameter.</p>
        /// <p> You can have one IPv6 CIDR block association per network border group.</p>
        pub fn ipv6_cidr_block_network_border_group(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.ipv6_cidr_block_network_border_group(input);
            self
        }
        pub fn set_ipv6_cidr_block_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block_network_border_group(input);
            self
        }
        /// <p>The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.</p>
        pub fn ipv6_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_pool(input);
            self
        }
        pub fn set_ipv6_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ipv6_pool(input);
            self
        }
        /// <p>An IPv6 CIDR block from the IPv6 address pool. You must also specify <code>Ipv6Pool</code> in the request.</p>
        /// <p>To let Amazon choose the IPv6 CIDR block for you, omit this parameter.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachClassicLinkVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_classic_link_vpc_input::Builder,
    }
    impl<C> AttachClassicLinkVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachClassicLinkVpcOutput,
            smithy_http::result::SdkError<crate::error::AttachClassicLinkVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.</p>
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// <p>The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of a ClassicLink-enabled VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_internet_gateway_input::Builder,
    }
    impl<C> AttachInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::AttachInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the internet gateway.</p>
        pub fn internet_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.internet_gateway_id(input);
            self
        }
        pub fn set_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_internet_gateway_id(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachNetworkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_network_interface_input::Builder,
    }
    impl<C> AttachNetworkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachNetworkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::AttachNetworkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The index of the device for the network interface attachment.</p>
        pub fn device_index(mut self, input: i32) -> Self {
            self.inner = self.inner.device_index(input);
            self
        }
        pub fn set_device_index(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_device_index(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The index of the network card. Some instance types support multiple network cards.
        /// The primary network interface must be assigned to network card index 0.
        /// The default is network card index 0.</p>
        pub fn network_card_index(mut self, input: i32) -> Self {
            self.inner = self.inner.network_card_index(input);
            self
        }
        pub fn set_network_card_index(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_network_card_index(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_volume_input::Builder,
    }
    impl<C> AttachVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachVolumeOutput,
            smithy_http::result::SdkError<crate::error::AttachVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        pub fn device(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device(input);
            self
        }
        pub fn set_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the EBS volume. The volume and instance must be within the same Availability
        /// Zone.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachVpnGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_vpn_gateway_input::Builder,
    }
    impl<C> AttachVpnGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachVpnGatewayOutput,
            smithy_http::result::SdkError<crate::error::AttachVpnGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The ID of the virtual private gateway.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_id(input);
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AuthorizeClientVpnIngress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::authorize_client_vpn_ingress_input::Builder,
    }
    impl<C> AuthorizeClientVpnIngress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AuthorizeClientVpnIngressOutput,
            smithy_http::result::SdkError<crate::error::AuthorizeClientVpnIngressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the network for which access is being authorized.</p>
        pub fn target_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_network_cidr(input);
            self
        }
        pub fn set_target_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_network_cidr(input);
            self
        }
        /// <p>The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if <code>AuthorizeAllGroups</code> is <code>false</code> or not specified.</p>
        pub fn access_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_group_id(input);
            self
        }
        pub fn set_access_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_group_id(input);
            self
        }
        /// <p>Indicates whether to grant access to all clients. Specify <code>true</code> to grant all
        /// clients who successfully establish a VPN connection access to the network. Must be set
        /// to <code>true</code> if <code>AccessGroupId</code> is not specified.</p>
        pub fn authorize_all_groups(mut self, input: bool) -> Self {
            self.inner = self.inner.authorize_all_groups(input);
            self
        }
        pub fn set_authorize_all_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_authorize_all_groups(input);
            self
        }
        /// <p>A brief description of the authorization rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AuthorizeSecurityGroupEgress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::authorize_security_group_egress_input::Builder,
    }
    impl<C> AuthorizeSecurityGroupEgress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AuthorizeSecurityGroupEgressOutput,
            smithy_http::result::SdkError<crate::error::AuthorizeSecurityGroupEgressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>The sets of IP permissions. You can't specify a destination security group and a CIDR IP
        /// address range in the same set of permissions.</p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the CIDR.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_ip(input);
            self
        }
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_ip(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the port.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.inner = self.inner.from_port(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_from_port(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the protocol name or
        /// number.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_protocol(input);
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_protocol(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the port.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.inner = self.inner.to_port(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_to_port(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify a
        /// destination security group.</p>
        pub fn source_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_security_group_name(input);
            self
        }
        pub fn set_source_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_name(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify a
        /// destination security group.</p>
        pub fn source_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.source_security_group_owner_id(input);
            self
        }
        pub fn set_source_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_owner_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AuthorizeSecurityGroupIngress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::authorize_security_group_ingress_input::Builder,
    }
    impl<C> AuthorizeSecurityGroupIngress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AuthorizeSecurityGroupIngressOutput,
            smithy_http::result::SdkError<crate::error::AuthorizeSecurityGroupIngressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 address range, in CIDR format. You can't specify this parameter when specifying a source
        /// security group. To specify an IPv6 address range, use a set of IP permissions.</p>
        /// <p>Alternatively, use a set of IP permissions to specify multiple rules and a description for the rule.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_ip(input);
            self
        }
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_ip(input);
            self
        }
        /// <p>The start of port range for the TCP and UDP protocols, or an ICMP type number.
        /// For the ICMP type number, use <code>-1</code> to specify all types. If you
        /// specify all ICMP types, you must specify all codes.</p>
        /// <p>Alternatively, use a set of IP permissions to specify multiple rules and a description for the rule.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.inner = self.inner.from_port(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_from_port(input);
            self
        }
        /// <p>The ID of the security group. You must specify either the security group ID or the
        /// security group name in the request. For security groups in a nondefault VPC, you must
        /// specify the security group ID.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the
        /// security group ID or the security group name in the request.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The sets of IP permissions.</p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number
        /// (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). To specify <code>icmpv6</code>, use a set of IP permissions.</p>
        /// <p>[VPC only] Use <code>-1</code> to specify all protocols. If you specify <code>-1</code> or a
        /// protocol other than <code>tcp</code>, <code>udp</code>, or <code>icmp</code>, traffic on all ports
        /// is allowed, regardless of any ports you specify.</p>
        /// <p>Alternatively, use a set of IP permissions to specify multiple rules and a description for the rule.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_protocol(input);
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_protocol(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter
        /// in combination with the following parameters: the CIDR IP address range, the start of the port range,
        /// the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access.
        /// To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For
        /// EC2-VPC, the source security group must be in the same VPC.</p>
        pub fn source_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_security_group_name(input);
            self
        }
        pub fn set_source_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_name(input);
            self
        }
        /// <p>[nondefault VPC] The AWS account ID for the source security group, if the source security group is
        /// in a different account. You can't specify this parameter in combination with the following parameters:
        /// the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range.
        /// Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol
        /// and port range, use a set of IP permissions instead.</p>
        pub fn source_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.source_security_group_owner_id(input);
            self
        }
        pub fn set_source_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_owner_id(input);
            self
        }
        /// <p>The end of port range for the TCP and UDP protocols, or an ICMP code number.
        /// For the ICMP code number, use <code>-1</code> to specify all codes. If you
        /// specify all ICMP types, you must specify all codes.</p>
        /// <p>Alternatively, use a set of IP permissions to specify multiple rules and a description for the rule.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.inner = self.inner.to_port(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_to_port(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BundleInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::bundle_instance_input::Builder,
    }
    impl<C> BundleInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BundleInstanceOutput,
            smithy_http::result::SdkError<crate::error::BundleInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance to bundle.</p>
        /// <p>Type: String</p>
        /// <p>Default: None</p>
        /// <p>Required: Yes</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
        pub fn storage(mut self, input: crate::model::Storage) -> Self {
            self.inner = self.inner.storage(input);
            self
        }
        pub fn set_storage(mut self, input: std::option::Option<crate::model::Storage>) -> Self {
            self.inner = self.inner.set_storage(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelBundleTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_bundle_task_input::Builder,
    }
    impl<C> CancelBundleTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelBundleTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelBundleTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the bundle task.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_id(input);
            self
        }
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bundle_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelCapacityReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_capacity_reservation_input::Builder,
    }
    impl<C> CancelCapacityReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelCapacityReservationOutput,
            smithy_http::result::SdkError<crate::error::CancelCapacityReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Capacity Reservation to be cancelled.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_reservation_id(input);
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelConversionTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_conversion_task_input::Builder,
    }
    impl<C> CancelConversionTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelConversionTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelConversionTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the conversion task.</p>
        pub fn conversion_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conversion_task_id(input);
            self
        }
        pub fn set_conversion_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_conversion_task_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The reason for canceling the conversion task.</p>
        pub fn reason_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reason_message(input);
            self
        }
        pub fn set_reason_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reason_message(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelExportTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_export_task_input::Builder,
    }
    impl<C> CancelExportTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelExportTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the export task. This is the ID returned by <code>CreateInstanceExportTask</code>.</p>
        pub fn export_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.export_task_id(input);
            self
        }
        pub fn set_export_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_export_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelImportTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_import_task_input::Builder,
    }
    impl<C> CancelImportTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelImportTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelImportTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The reason for canceling the task.</p>
        pub fn cancel_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cancel_reason(input);
            self
        }
        pub fn set_cancel_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_cancel_reason(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the import image or import snapshot task to be canceled.</p>
        pub fn import_task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.import_task_id(input);
            self
        }
        pub fn set_import_task_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_import_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelReservedInstancesListing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_reserved_instances_listing_input::Builder,
    }
    impl<C> CancelReservedInstancesListing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelReservedInstancesListingOutput,
            smithy_http::result::SdkError<crate::error::CancelReservedInstancesListingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Reserved Instance listing.</p>
        pub fn reserved_instances_listing_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.reserved_instances_listing_id(input);
            self
        }
        pub fn set_reserved_instances_listing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_listing_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelSpotFleetRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_spot_fleet_requests_input::Builder,
    }
    impl<C> CancelSpotFleetRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelSpotFleetRequestsOutput,
            smithy_http::result::SdkError<crate::error::CancelSpotFleetRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the Spot Fleet requests.</p>
        pub fn spot_fleet_request_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_fleet_request_ids(inp);
            self
        }
        pub fn set_spot_fleet_request_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_ids(input);
            self
        }
        /// <p>Indicates whether to terminate instances for a Spot Fleet request if it is canceled
        /// successfully.</p>
        pub fn terminate_instances(mut self, input: bool) -> Self {
            self.inner = self.inner.terminate_instances(input);
            self
        }
        pub fn set_terminate_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_terminate_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelSpotInstanceRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_spot_instance_requests_input::Builder,
    }
    impl<C> CancelSpotInstanceRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelSpotInstanceRequestsOutput,
            smithy_http::result::SdkError<crate::error::CancelSpotInstanceRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more Spot Instance request IDs.</p>
        pub fn spot_instance_request_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_instance_request_ids(inp);
            self
        }
        pub fn set_spot_instance_request_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_spot_instance_request_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ConfirmProductInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::confirm_product_instance_input::Builder,
    }
    impl<C> ConfirmProductInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ConfirmProductInstanceOutput,
            smithy_http::result::SdkError<crate::error::ConfirmProductInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The product code. This must be a product code that you own.</p>
        pub fn product_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_code(input);
            self
        }
        pub fn set_product_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_product_code(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopyFpgaImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_fpga_image_input::Builder,
    }
    impl<C> CopyFpgaImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopyFpgaImageOutput,
            smithy_http::result::SdkError<crate::error::CopyFpgaImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the source AFI.</p>
        pub fn source_fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_fpga_image_id(input);
            self
        }
        pub fn set_source_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_fpga_image_id(input);
            self
        }
        /// <p>The description for the new AFI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The name for the new AFI. The default is the name of the source AFI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Region that contains the source AFI.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_region(input);
            self
        }
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_region(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopyImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_image_input::Builder,
    }
    impl<C> CopyImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopyImageOutput,
            smithy_http::result::SdkError<crate::error::CopyImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure
        /// idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring idempotency</a>
        /// in the <i>Amazon EC2 API Reference</i>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A description for the new AMI in the destination Region.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Specifies whether the destination snapshots of the copied image should be encrypted.
        /// You can encrypt a copy of an unencrypted snapshot, but you cannot create an unencrypted
        /// copy of an encrypted snapshot. The default CMK for EBS is used unless you specify a non-default
        /// AWS Key Management Service (AWS KMS) CMK using <code>KmsKeyId</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>The identifier of the symmetric AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating
        /// encrypted volumes. If this parameter is not specified, your AWS managed CMK for EBS is used.
        /// If you specify a CMK, you must also set the encrypted state to <code>true</code>.</p>
        /// <p>You can specify a CMK using any of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Key alias. For example, alias/ExampleAlias.</p>
        /// </li>
        /// <li>
        /// <p>Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.</p>
        /// </li>
        /// </ul>
        /// <p>AWS authenticates the CMK asynchronously. Therefore, if you specify an identifier that is not valid,
        /// the action can appear to complete, but eventually fails.</p>
        /// <p>The specified CMK must exist in the destination Region.</p>
        /// <p>Amazon EBS does not support asymmetric CMKs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The name of the new AMI in the destination Region.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the AMI to copy.</p>
        pub fn source_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_image_id(input);
            self
        }
        pub fn set_source_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_image_id(input);
            self
        }
        /// <p>The name of the Region that contains the AMI to copy.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_region(input);
            self
        }
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_region(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost to which to copy the AMI. Only
        /// specify this parameter when copying an AMI from an AWS Region to an Outpost.
        /// The AMI must be in the Region of the destination Outpost. You cannot copy an
        /// AMI from an Outpost to a Region, from one Outpost to another, or within the same
        /// Outpost.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html#copy-amis">
        /// Copying AMIs from an AWS Region to an Outpost</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn destination_outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_outpost_arn(input);
            self
        }
        pub fn set_destination_outpost_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_outpost_arn(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CopySnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::copy_snapshot_input::Builder,
    }
    impl<C> CopySnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CopySnapshotOutput,
            smithy_http::result::SdkError<crate::error::CopySnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the EBS snapshot.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost to which to copy the snapshot. Only
        /// specify this parameter when copying a snapshot from an AWS Region to an Outpost.
        /// The snapshot must be in the Region for the destination Outpost. You cannot copy a
        /// snapshot from an Outpost to a Region, from one Outpost to another, or within the same
        /// Outpost.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html#copy-snapshots">
        /// Copying snapshots from an AWS Region to an Outpost</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn destination_outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_outpost_arn(input);
            self
        }
        pub fn set_destination_outpost_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_outpost_arn(input);
            self
        }
        /// <p>The destination Region to use in the <code>PresignedUrl</code> parameter of a snapshot
        /// copy operation. This parameter is only valid for specifying the destination Region in a
        /// <code>PresignedUrl</code> parameter, where it is required.</p>
        /// <p>The snapshot copy is sent to the regional endpoint that you sent the HTTP
        /// request to (for example, <code>ec2.us-east-1.amazonaws.com</code>). With the AWS CLI, this is
        /// specified using the <code>--region</code> parameter or the default Region in your AWS
        /// configuration file.</p>
        pub fn destination_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_region(input);
            self
        }
        pub fn set_destination_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_region(input);
            self
        }
        /// <p>To encrypt a copy of an unencrypted snapshot if encryption by default is not enabled,
        /// enable encryption using this parameter. Otherwise, omit this parameter. Encrypted snapshots
        /// are encrypted, even if you omit this parameter and encryption by default is not enabled. You
        /// cannot set this parameter to false. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS encryption</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>The identifier of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for Amazon EBS encryption.
        /// If this parameter is not specified, your AWS managed CMK for EBS is used. If <code>KmsKeyId</code> is
        /// specified, the encrypted state must be <code>true</code>.</p>
        /// <p>You can specify the CMK using any of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Key alias. For example, alias/ExampleAlias.</p>
        /// </li>
        /// <li>
        /// <p>Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.</p>
        /// </li>
        /// </ul>
        /// <p>AWS authenticates the CMK asynchronously. Therefore, if you specify an ID, alias, or ARN that is not valid,
        /// the action can appear to complete, but eventually fails.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>When you copy an encrypted source snapshot using the Amazon EC2 Query API, you must supply a
        /// pre-signed URL. This parameter is optional for unencrypted snapshots. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html">Query
        /// requests</a>.</p>
        /// <p>The <code>PresignedUrl</code> should use the snapshot source endpoint, the
        /// <code>CopySnapshot</code> action, and include the <code>SourceRegion</code>,
        /// <code>SourceSnapshotId</code>, and <code>DestinationRegion</code> parameters. The
        /// <code>PresignedUrl</code> must be signed using AWS Signature Version 4. Because EBS
        /// snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic
        /// that is described in <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests: Using Query
        /// Parameters (AWS Signature Version 4)</a> in the <i>Amazon Simple Storage Service API Reference</i>. An
        /// invalid or improperly signed <code>PresignedUrl</code> will cause the copy operation to fail
        /// asynchronously, and the snapshot will move to an <code>error</code> state.</p>
        pub fn presigned_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.presigned_url(input);
            self
        }
        pub fn set_presigned_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_presigned_url(input);
            self
        }
        /// <p>The ID of the Region that contains the snapshot to be copied.</p>
        pub fn source_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_region(input);
            self
        }
        pub fn set_source_region(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_region(input);
            self
        }
        /// <p>The ID of the EBS snapshot to copy.</p>
        pub fn source_snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_snapshot_id(input);
            self
        }
        pub fn set_source_snapshot_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_snapshot_id(input);
            self
        }
        /// <p>The tags to apply to the new snapshot.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCapacityReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_capacity_reservation_input::Builder,
    }
    impl<C> CreateCapacityReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCapacityReservationOutput,
            smithy_http::result::SdkError<crate::error::CreateCapacityReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The instance type for which to reserve capacity. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>The type of operating system for which to reserve capacity.</p>
        pub fn instance_platform(
            mut self,
            input: crate::model::CapacityReservationInstancePlatform,
        ) -> Self {
            self.inner = self.inner.instance_platform(input);
            self
        }
        pub fn set_instance_platform(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationInstancePlatform>,
        ) -> Self {
            self.inner = self.inner.set_instance_platform(input);
            self
        }
        /// <p>The Availability Zone in which to create the Capacity Reservation.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The ID of the Availability Zone in which to create the Capacity Reservation.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone_id(input);
            self
        }
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone_id(input);
            self
        }
        /// <p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>default</code> - The Capacity Reservation is created on hardware that is shared with other accounts.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single account.</p>
        /// </li>
        /// </ul>
        pub fn tenancy(mut self, input: crate::model::CapacityReservationTenancy) -> Self {
            self.inner = self.inner.tenancy(input);
            self
        }
        pub fn set_tenancy(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationTenancy>,
        ) -> Self {
            self.inner = self.inner.set_tenancy(input);
            self
        }
        /// <p>The number of instances for which to reserve capacity.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides
        /// dedicated throughput to Amazon EBS and an optimized configuration stack to provide
        /// optimal I/O performance. This optimization isn't available with all instance types.
        /// Additional usage charges apply when using an EBS- optimized instance.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.inner = self.inner.ebs_optimized(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ebs_optimized(input);
            self
        }
        /// <p>Indicates whether the Capacity Reservation supports instances with temporary, block-level
        /// storage.</p>
        pub fn ephemeral_storage(mut self, input: bool) -> Self {
            self.inner = self.inner.ephemeral_storage(input);
            self
        }
        pub fn set_ephemeral_storage(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ephemeral_storage(input);
            self
        }
        /// <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity
        /// is released and you can no longer launch instances into it. The Capacity Reservation's state changes to
        /// <code>expired</code> when it reaches its end date and time.</p>  
        /// <p>You must provide an <code>EndDate</code> value if <code>EndDateType</code> is
        /// <code>limited</code>. Omit <code>EndDate</code> if <code>EndDateType</code> is
        /// <code>unlimited</code>.</p>
        /// <p>If the <code>EndDateType</code> is <code>limited</code>, the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify
        /// 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.</p>
        pub fn end_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_date(input);
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_date(input);
            self
        }
        /// <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end
        /// types:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it. Do not
        /// provide an <code>EndDate</code> if the <code>EndDateType</code> is
        /// <code>unlimited</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time. You must
        /// provide an <code>EndDate</code> value if the <code>EndDateType</code> value is
        /// <code>limited</code>.</p>
        /// </li>
        /// </ul>
        pub fn end_date_type(mut self, input: crate::model::EndDateType) -> Self {
            self.inner = self.inner.end_date_type(input);
            self
        }
        pub fn set_end_date_type(
            mut self,
            input: std::option::Option<crate::model::EndDateType>,
        ) -> Self {
            self.inner = self.inner.set_end_date_type(input);
            self
        }
        /// <p>Indicates the type of instance launches that the Capacity Reservation accepts. The options
        /// include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform,
        /// and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying
        /// any additional parameters.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes
        /// (instance type, platform, and Availability Zone), and explicitly target the
        /// Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p>
        /// </li>
        /// </ul>
        /// <p>Default: <code>open</code>
        /// </p>
        pub fn instance_match_criteria(
            mut self,
            input: crate::model::InstanceMatchCriteria,
        ) -> Self {
            self.inner = self.inner.instance_match_criteria(input);
            self
        }
        pub fn set_instance_match_criteria(
            mut self,
            input: std::option::Option<crate::model::InstanceMatchCriteria>,
        ) -> Self {
            self.inner = self.inner.set_instance_match_criteria(input);
            self
        }
        /// <p>The tags to apply to the Capacity Reservation during launch.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_arn(input);
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCarrierGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_carrier_gateway_input::Builder,
    }
    impl<C> CreateCarrierGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCarrierGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateCarrierGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC to associate with the carrier gateway.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to associate with the carrier gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateClientVpnEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_client_vpn_endpoint_input::Builder,
    }
    impl<C> CreateClientVpnEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClientVpnEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreateClientVpnEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. The CIDR block should be /22 or greater.</p>
        pub fn client_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_cidr_block(input);
            self
        }
        pub fn set_client_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_cidr_block(input);
            self
        }
        /// <p>The ARN of the server certificate. For more information, see
        /// the <a href="https://docs.aws.amazon.com/acm/latest/userguide/">AWS Certificate Manager User Guide</a>.</p>
        pub fn server_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_arn(input);
            self
        }
        pub fn set_server_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_arn(input);
            self
        }
        /// <p>Information about the authentication method to be used to authenticate clients.</p>
        pub fn authentication_options(
            mut self,
            inp: impl Into<crate::model::ClientVpnAuthenticationRequest>,
        ) -> Self {
            self.inner = self.inner.authentication_options(inp);
            self
        }
        pub fn set_authentication_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ClientVpnAuthenticationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_authentication_options(input);
            self
        }
        /// <p>Information about the client connection logging options.</p>
        /// <p>If you enable client connection logging, data about client connections is sent to a
        /// Cloudwatch Logs log stream. The following information is logged:</p>
        /// <ul>
        /// <li>
        /// <p>Client connection requests</p>
        /// </li>
        /// <li>
        /// <p>Client connection results (successful and unsuccessful)</p>
        /// </li>
        /// <li>
        /// <p>Reasons for unsuccessful client connection requests</p>
        /// </li>
        /// <li>
        /// <p>Client connection termination time</p>
        /// </li>
        /// </ul>
        pub fn connection_log_options(mut self, input: crate::model::ConnectionLogOptions) -> Self {
            self.inner = self.inner.connection_log_options(input);
            self
        }
        pub fn set_connection_log_options(
            mut self,
            input: std::option::Option<crate::model::ConnectionLogOptions>,
        ) -> Self {
            self.inner = self.inner.set_connection_log_options(input);
            self
        }
        /// <p>Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can
        /// have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.</p>
        pub fn dns_servers(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dns_servers(inp);
            self
        }
        pub fn set_dns_servers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dns_servers(input);
            self
        }
        /// <p>The transport protocol to be used by the VPN session.</p>
        /// <p>Default value: <code>udp</code>
        /// </p>
        pub fn transport_protocol(mut self, input: crate::model::TransportProtocol) -> Self {
            self.inner = self.inner.transport_protocol(input);
            self
        }
        pub fn set_transport_protocol(
            mut self,
            input: std::option::Option<crate::model::TransportProtocol>,
        ) -> Self {
            self.inner = self.inner.set_transport_protocol(input);
            self
        }
        /// <p>The port number to assign to the Client VPN endpoint for TCP and UDP traffic.</p>
        /// <p>Valid Values: <code>443</code> | <code>1194</code>
        /// </p>
        /// <p>Default Value: <code>443</code>
        /// </p>
        pub fn vpn_port(mut self, input: i32) -> Self {
            self.inner = self.inner.vpn_port(input);
            self
        }
        pub fn set_vpn_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_vpn_port(input);
            self
        }
        /// <p>A brief description of the Client VPN endpoint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.</p>
        /// <p>By default, split-tunnel on a VPN endpoint is disabled.</p>
        /// <p>For information about split-tunnel VPN endpoints, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html">Split-Tunnel AWS Client VPN Endpoint</a> in the <i>AWS
        /// Client VPN Administrator Guide</i>.</p>
        pub fn split_tunnel(mut self, input: bool) -> Self {
            self.inner = self.inner.split_tunnel(input);
            self
        }
        pub fn set_split_tunnel(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_split_tunnel(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The tags to apply to the Client VPN endpoint during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Specify whether to enable the self-service portal for the Client VPN endpoint.</p>
        /// <p>Default Value: <code>enabled</code>
        /// </p>
        pub fn self_service_portal(mut self, input: crate::model::SelfServicePortal) -> Self {
            self.inner = self.inner.self_service_portal(input);
            self
        }
        pub fn set_self_service_portal(
            mut self,
            input: std::option::Option<crate::model::SelfServicePortal>,
        ) -> Self {
            self.inner = self.inner.set_self_service_portal(input);
            self
        }
        /// <p>The options for managing connection authorization for new client connections.</p>
        pub fn client_connect_options(mut self, input: crate::model::ClientConnectOptions) -> Self {
            self.inner = self.inner.client_connect_options(input);
            self
        }
        pub fn set_client_connect_options(
            mut self,
            input: std::option::Option<crate::model::ClientConnectOptions>,
        ) -> Self {
            self.inner = self.inner.set_client_connect_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateClientVpnRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_client_vpn_route_input::Builder,
    }
    impl<C> CreateClientVpnRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClientVpnRouteOutput,
            smithy_http::result::SdkError<crate::error::CreateClientVpnRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint to which to add the route.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the route destination. For example:</p>
        /// <ul>
        /// <li>
        /// <p>To add a route for Internet access, enter <code>0.0.0.0/0</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range</p>
        /// </li>
        /// <li>
        /// <p>To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range</p>
        /// </li>
        /// <li>
        /// <p>To add a route for the local network, enter the client CIDR range</p>
        /// </li>
        /// </ul>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the subnet through which you want to route traffic. The specified subnet must be
        /// an existing target network of the Client VPN endpoint.</p>
        /// <p>Alternatively, if you're adding a route for the local network, specify <code>local</code>.</p>
        pub fn target_vpc_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_vpc_subnet_id(input);
            self
        }
        pub fn set_target_vpc_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_vpc_subnet_id(input);
            self
        }
        /// <p>A brief description of the route.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCustomerGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_customer_gateway_input::Builder,
    }
    impl<C> CreateCustomerGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCustomerGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateCustomerGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>For devices that support BGP, the customer gateway's BGP ASN.</p>
        /// <p>Default: 65000</p>
        pub fn bgp_asn(mut self, input: i32) -> Self {
            self.inner = self.inner.bgp_asn(input);
            self
        }
        pub fn set_bgp_asn(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_bgp_asn(input);
            self
        }
        /// <p>The Internet-routable IP address for the customer gateway's outside interface. The address must be static.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the customer gateway certificate.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The type of VPN connection that this customer gateway supports (<code>ipsec.1</code>).</p>
        pub fn r#type(mut self, input: crate::model::GatewayType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::GatewayType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The tags to apply to the customer gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>A name for the customer gateway device.</p>
        /// <p>Length Constraints: Up to 255 characters.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device_name(input);
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device_name(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDefaultSubnet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_default_subnet_input::Builder,
    }
    impl<C> CreateDefaultSubnet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDefaultSubnetOutput,
            smithy_http::result::SdkError<crate::error::CreateDefaultSubnetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Availability Zone in which to create the default subnet.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDefaultVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_default_vpc_input::Builder,
    }
    impl<C> CreateDefaultVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDefaultVpcOutput,
            smithy_http::result::SdkError<crate::error::CreateDefaultVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDhcpOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_dhcp_options_input::Builder,
    }
    impl<C> CreateDhcpOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDhcpOptionsOutput,
            smithy_http::result::SdkError<crate::error::CreateDhcpOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A DHCP configuration option.</p>
        pub fn dhcp_configurations(
            mut self,
            inp: impl Into<crate::model::NewDhcpConfiguration>,
        ) -> Self {
            self.inner = self.inner.dhcp_configurations(inp);
            self
        }
        pub fn set_dhcp_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NewDhcpConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_dhcp_configurations(input);
            self
        }
        /// <p>The tags to assign to the DHCP option.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateEgressOnlyInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_egress_only_internet_gateway_input::Builder,
    }
    impl<C> CreateEgressOnlyInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateEgressOnlyInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateEgressOnlyInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC for which to create the egress-only internet gateway.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to assign to the egress-only internet gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFleet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_fleet_input::Builder,
    }
    impl<C> CreateFleet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFleetOutput,
            smithy_http::result::SdkError<crate::error::CreateFleetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>
        pub fn spot_options(mut self, input: crate::model::SpotOptionsRequest) -> Self {
            self.inner = self.inner.spot_options(input);
            self
        }
        pub fn set_spot_options(
            mut self,
            input: std::option::Option<crate::model::SpotOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_spot_options(input);
            self
        }
        /// <p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>
        pub fn on_demand_options(mut self, input: crate::model::OnDemandOptionsRequest) -> Self {
            self.inner = self.inner.on_demand_options(input);
            self
        }
        pub fn set_on_demand_options(
            mut self,
            input: std::option::Option<crate::model::OnDemandOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_on_demand_options(input);
            self
        }
        /// <p>Indicates whether running instances should be terminated if the total target capacity of
        /// the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
        pub fn excess_capacity_termination_policy(
            mut self,
            input: crate::model::FleetExcessCapacityTerminationPolicy,
        ) -> Self {
            self.inner = self.inner.excess_capacity_termination_policy(input);
            self
        }
        pub fn set_excess_capacity_termination_policy(
            mut self,
            input: std::option::Option<crate::model::FleetExcessCapacityTerminationPolicy>,
        ) -> Self {
            self.inner = self.inner.set_excess_capacity_termination_policy(input);
            self
        }
        /// <p>The configuration for the EC2 Fleet.</p>
        pub fn launch_template_configs(
            mut self,
            inp: impl Into<crate::model::FleetLaunchTemplateConfigRequest>,
        ) -> Self {
            self.inner = self.inner.launch_template_configs(inp);
            self
        }
        pub fn set_launch_template_configs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FleetLaunchTemplateConfigRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_launch_template_configs(input);
            self
        }
        /// <p>The number of units to request.</p>
        pub fn target_capacity_specification(
            mut self,
            input: crate::model::TargetCapacitySpecificationRequest,
        ) -> Self {
            self.inner = self.inner.target_capacity_specification(input);
            self
        }
        pub fn set_target_capacity_specification(
            mut self,
            input: std::option::Option<crate::model::TargetCapacitySpecificationRequest>,
        ) -> Self {
            self.inner = self.inner.set_target_capacity_specification(input);
            self
        }
        /// <p>Indicates whether running instances should be terminated when the EC2 Fleet expires.</p>
        pub fn terminate_instances_with_expiration(mut self, input: bool) -> Self {
            self.inner = self.inner.terminate_instances_with_expiration(input);
            self
        }
        pub fn set_terminate_instances_with_expiration(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_terminate_instances_with_expiration(input);
            self
        }
        /// <p>The fleet type. The default value is <code>maintain</code>.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>maintain</code> - The EC2 Fleet places an asynchronous request for your desired
        /// capacity, and continues to maintain your desired Spot capacity by replenishing
        /// interrupted Spot Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>request</code> - The EC2 Fleet places an asynchronous one-time request for your
        /// desired capacity, but does submit Spot requests in alternative capacity pools if Spot
        /// capacity is unavailable, and does not maintain Spot capacity if Spot Instances are
        /// interrupted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instant</code> - The EC2 Fleet places a synchronous one-time request for your
        /// desired capacity, and returns errors for any instances that could not be
        /// launched.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-configuration-strategies.html#ec2-fleet-request-type">EC2 Fleet
        /// request types</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn r#type(mut self, input: crate::model::FleetType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::FleetType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The start date and time of the request, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// The default is to start fulfilling the request immediately.</p>
        pub fn valid_from(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.valid_from(input);
            self
        }
        pub fn set_valid_from(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_valid_from(input);
            self
        }
        /// <p>The end date and time of the request, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.</p>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.valid_until(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_valid_until(input);
            self
        }
        /// <p>Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for
        /// fleets of type <code>maintain</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks">EC2 Fleet
        /// health checks</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn replace_unhealthy_instances(mut self, input: bool) -> Self {
            self.inner = self.inner.replace_unhealthy_instances(input);
            self
        }
        pub fn set_replace_unhealthy_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_replace_unhealthy_instances(input);
            self
        }
        /// <p>The key-value pair for tagging the EC2 Fleet request on creation. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources">Tagging your resources</a>.</p>
        /// <p>If the fleet type is <code>instant</code>, specify a resource type of <code>fleet</code>
        /// to tag the fleet or <code>instance</code> to tag the instances at launch.</p>
        /// <p>If the fleet type is <code>maintain</code> or <code>request</code>, specify a resource
        /// type of <code>fleet</code> to tag the fleet. You cannot specify a resource type of
        /// <code>instance</code>. To tag instances at launch, specify the tags in a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template">launch template</a>.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFlowLogs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_flow_logs_input::Builder,
    }
    impl<C> CreateFlowLogs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFlowLogsOutput,
            smithy_http::result::SdkError<crate::error::CreateFlowLogsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group
        /// in your account.</p>
        /// <p>If you specify <code>LogDestinationType</code> as <code>s3</code>, do not specify
        /// <code>DeliverLogsPermissionArn</code> or <code>LogGroupName</code>.</p>
        pub fn deliver_logs_permission_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.deliver_logs_permission_arn(input);
            self
        }
        pub fn set_deliver_logs_permission_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deliver_logs_permission_arn(input);
            self
        }
        /// <p>The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.</p>
        /// <p>If you specify <code>LogDestinationType</code> as <code>s3</code>, do not specify
        /// <code>DeliverLogsPermissionArn</code> or <code>LogGroupName</code>.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The ID of the subnet, network interface, or VPC for which you want to create a flow log.</p>
        /// <p>Constraints: Maximum of 1000 resources</p>
        pub fn resource_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_ids(inp);
            self
        }
        pub fn set_resource_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resource_ids(input);
            self
        }
        /// <p>The type of resource for which to create the flow log. For example, if you specified a VPC ID for
        /// the <code>ResourceId</code> property, specify <code>VPC</code> for this property.</p>
        pub fn resource_type(mut self, input: crate::model::FlowLogsResourceType) -> Self {
            self.inner = self.inner.resource_type(input);
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::FlowLogsResourceType>,
        ) -> Self {
            self.inner = self.inner.set_resource_type(input);
            self
        }
        /// <p>The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.</p>
        pub fn traffic_type(mut self, input: crate::model::TrafficType) -> Self {
            self.inner = self.inner.traffic_type(input);
            self
        }
        pub fn set_traffic_type(
            mut self,
            input: std::option::Option<crate::model::TrafficType>,
        ) -> Self {
            self.inner = self.inner.set_traffic_type(input);
            self
        }
        /// <p>Specifies the type of destination to which the flow log data is to be published. Flow log data can be
        /// published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify <code>cloud-watch-logs</code>. To
        /// publish flow log data to Amazon S3, specify <code>s3</code>.</p>
        /// <p>If you specify <code>LogDestinationType</code> as <code>s3</code>, do not specify
        /// <code>DeliverLogsPermissionArn</code> or <code>LogGroupName</code>.</p>
        /// <p>Default: <code>cloud-watch-logs</code>
        /// </p>
        pub fn log_destination_type(mut self, input: crate::model::LogDestinationType) -> Self {
            self.inner = self.inner.log_destination_type(input);
            self
        }
        pub fn set_log_destination_type(
            mut self,
            input: std::option::Option<crate::model::LogDestinationType>,
        ) -> Self {
            self.inner = self.inner.set_log_destination_type(input);
            self
        }
        /// <p>Specifies the destination to which the flow log data is to be published. Flow log data can be published
        /// to a CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified
        /// for <code>LogDestinationType</code>.</p>
        /// <p>If <code>LogDestinationType</code> is not specified or <code>cloud-watch-logs</code>,
        /// specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group. For example, to publish
        /// to a log group called <code>my-logs</code>, specify
        /// <code>arn:aws:logs:us-east-1:123456789012:log-group:my-logs</code>. Alternatively,
        /// use <code>LogGroupName</code> instead.</p>
        /// <p>If LogDestinationType is <code>s3</code>, specify the ARN of the Amazon S3 bucket. You can also specify a
        /// subfolder in the bucket. To specify a subfolder in the bucket, use the following  ARN format:
        /// <code>bucket_ARN/subfolder_name/</code>. For example, to specify a subfolder named <code>my-logs</code> in a
        /// bucket named <code>my-bucket</code>, use the following ARN: <code>arn:aws:s3:::my-bucket/my-logs/</code>. You
        /// cannot use <code>AWSLogs</code> as a subfolder name. This is a reserved term.</p>
        pub fn log_destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_destination(input);
            self
        }
        pub fn set_log_destination(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_destination(input);
            self
        }
        /// <p>The fields to include in the flow log record, in the order in which they should
        /// appear. For a list of available fields, see <a href="https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records">Flow Log Records</a>. If you
        /// omit this parameter, the flow log is created using the default format. If you specify this parameter, you must specify at least one field.</p>
        /// <p>Specify the fields using the <code>${field-id}</code> format, separated by spaces. For
        /// the AWS CLI, use single quotation marks (' ') to surround the parameter value.</p>
        pub fn log_format(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_format(input);
            self
        }
        pub fn set_log_format(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_log_format(input);
            self
        }
        /// <p>The tags to apply to the flow logs.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).</p>
        /// <p>When a network interface is attached to a <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Nitro-based
        /// instance</a>, the aggregation interval is always 60 seconds or less, regardless
        /// of the value that you specify.</p>
        /// <p>Default: 600</p>
        pub fn max_aggregation_interval(mut self, input: i32) -> Self {
            self.inner = self.inner.max_aggregation_interval(input);
            self
        }
        pub fn set_max_aggregation_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_aggregation_interval(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFpgaImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_fpga_image_input::Builder,
    }
    impl<C> CreateFpgaImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFpgaImageOutput,
            smithy_http::result::SdkError<crate::error::CreateFpgaImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The location of the encrypted design checkpoint in Amazon S3. The input must be a tarball.</p>
        pub fn input_storage_location(mut self, input: crate::model::StorageLocation) -> Self {
            self.inner = self.inner.input_storage_location(input);
            self
        }
        pub fn set_input_storage_location(
            mut self,
            input: std::option::Option<crate::model::StorageLocation>,
        ) -> Self {
            self.inner = self.inner.set_input_storage_location(input);
            self
        }
        /// <p>The location in Amazon S3 for the output logs.</p>
        pub fn logs_storage_location(mut self, input: crate::model::StorageLocation) -> Self {
            self.inner = self.inner.logs_storage_location(input);
            self
        }
        pub fn set_logs_storage_location(
            mut self,
            input: std::option::Option<crate::model::StorageLocation>,
        ) -> Self {
            self.inner = self.inner.set_logs_storage_location(input);
            self
        }
        /// <p>A description for the AFI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A name for the AFI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The tags to apply to the FPGA image during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_image_input::Builder,
    }
    impl<C> CreateImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateImageOutput,
            smithy_http::result::SdkError<crate::error::CreateImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The block device mappings. This parameter cannot be used to modify the encryption
        /// status of existing volumes or snapshots. To create an AMI with encrypted snapshots,
        /// use the <a>CopyImage</a> action.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p>A description for the new image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>A name for the new image.</p>
        /// <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the <code>No Reboot</code> option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.</p>
        pub fn no_reboot(mut self, input: bool) -> Self {
            self.inner = self.inner.no_reboot(input);
            self
        }
        pub fn set_no_reboot(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_no_reboot(input);
            self
        }
        /// <p>The tags to apply to the AMI and snapshots on creation. You can tag the AMI, the
        /// snapshots, or both.</p>
        /// <ul>
        /// <li>
        /// <p>To tag the AMI, the value for <code>ResourceType</code> must be
        /// <code>image</code>.</p>
        /// </li>
        /// <li>
        /// <p>To tag the snapshots that are created of the root volume and of other EBS volumes that
        /// are attached to the instance, the value for <code>ResourceType</code> must be
        /// <code>snapshot</code>. The same tag is applied to all of the snapshots that are
        /// created.</p>
        /// </li>
        /// </ul>
        /// <p>If you specify other values for <code>ResourceType</code>, the request fails.</p>
        /// <p>To tag an AMI or snapshot after it has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>. </p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInstanceExportTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_instance_export_task_input::Builder,
    }
    impl<C> CreateInstanceExportTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInstanceExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateInstanceExportTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the conversion task or the resource being exported. The maximum length is 255 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The format and location for an export instance task.</p>
        pub fn export_to_s3_task(
            mut self,
            input: crate::model::ExportToS3TaskSpecification,
        ) -> Self {
            self.inner = self.inner.export_to_s3_task(input);
            self
        }
        pub fn set_export_to_s3_task(
            mut self,
            input: std::option::Option<crate::model::ExportToS3TaskSpecification>,
        ) -> Self {
            self.inner = self.inner.set_export_to_s3_task(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The target virtualization environment.</p>
        pub fn target_environment(mut self, input: crate::model::ExportEnvironment) -> Self {
            self.inner = self.inner.target_environment(input);
            self
        }
        pub fn set_target_environment(
            mut self,
            input: std::option::Option<crate::model::ExportEnvironment>,
        ) -> Self {
            self.inner = self.inner.set_target_environment(input);
            self
        }
        /// <p>The tags to apply to the export instance task during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_internet_gateway_input::Builder,
    }
    impl<C> CreateInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tags to assign to the internet gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_key_pair_input::Builder,
    }
    impl<C> CreateKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateKeyPairOutput,
            smithy_http::result::SdkError<crate::error::CreateKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique name for the key pair.</p>
        /// <p>Constraints: Up to 255 ASCII characters</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_name(input);
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_name(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to apply to the new key pair.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLaunchTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_launch_template_input::Builder,
    }
    impl<C> CreateLaunchTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLaunchTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateLaunchTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraint: Maximum 128 ASCII characters.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A name for the launch template.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
        /// <p>A description for the first version of the launch template.</p>
        pub fn version_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_description(input);
            self
        }
        pub fn set_version_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_version_description(input);
            self
        }
        /// <p>The information for the launch template.</p>
        pub fn launch_template_data(
            mut self,
            input: crate::model::RequestLaunchTemplateData,
        ) -> Self {
            self.inner = self.inner.launch_template_data(input);
            self
        }
        pub fn set_launch_template_data(
            mut self,
            input: std::option::Option<crate::model::RequestLaunchTemplateData>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_data(input);
            self
        }
        /// <p>The tags to apply to the launch template during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLaunchTemplateVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_launch_template_version_input::Builder,
    }
    impl<C> CreateLaunchTemplateVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLaunchTemplateVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateLaunchTemplateVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraint: Maximum 128 ASCII characters.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_id(input);
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_id(input);
            self
        }
        /// <p>The name of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
        /// <p>The version number of the launch template version on which to base the new version.
        /// The new version inherits the same launch parameters as the source version, except for
        /// parameters that you specify in <code>LaunchTemplateData</code>. Snapshots applied
        /// to the block device mapping are ignored when creating a new version unless they
        /// are explicitly included.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_version(input);
            self
        }
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_version(input);
            self
        }
        /// <p>A description for the version of the launch template.</p>
        pub fn version_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_description(input);
            self
        }
        pub fn set_version_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_version_description(input);
            self
        }
        /// <p>The information for the launch template.</p>
        pub fn launch_template_data(
            mut self,
            input: crate::model::RequestLaunchTemplateData,
        ) -> Self {
            self.inner = self.inner.launch_template_data(input);
            self
        }
        pub fn set_launch_template_data(
            mut self,
            input: std::option::Option<crate::model::RequestLaunchTemplateData>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_data(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocalGatewayRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_local_gateway_route_input::Builder,
    }
    impl<C> CreateLocalGatewayRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocalGatewayRouteOutput,
            smithy_http::result::SdkError<crate::error::CreateLocalGatewayRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR range used for destination matches. Routing decisions are based on
        /// the most specific match.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_route_table_id(input);
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_route_table_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the virtual interface group.</p>
        pub fn local_gateway_virtual_interface_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_virtual_interface_group_id(input);
            self
        }
        pub fn set_local_gateway_virtual_interface_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_local_gateway_virtual_interface_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLocalGatewayRouteTableVpcAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_local_gateway_route_table_vpc_association_input::Builder,
    }
    impl<C> CreateLocalGatewayRouteTableVpcAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLocalGatewayRouteTableVpcAssociationOutput,
            smithy_http::result::SdkError<
                crate::error::CreateLocalGatewayRouteTableVpcAssociationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_route_table_id(input);
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to assign to the local gateway route table VPC association.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateManagedPrefixList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_managed_prefix_list_input::Builder,
    }
    impl<C> CreateManagedPrefixList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateManagedPrefixListOutput,
            smithy_http::result::SdkError<crate::error::CreateManagedPrefixListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>A name for the prefix list.</p>
        /// <p>Constraints: Up to 255 characters in length. The name cannot start with <code>com.amazonaws</code>.</p>
        pub fn prefix_list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_name(input);
            self
        }
        pub fn set_prefix_list_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_name(input);
            self
        }
        /// <p>One or more entries for the prefix list.</p>
        pub fn entries(mut self, inp: impl Into<crate::model::AddPrefixListEntry>) -> Self {
            self.inner = self.inner.entries(inp);
            self
        }
        pub fn set_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddPrefixListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_entries(input);
            self
        }
        /// <p>The maximum number of entries for the prefix list.</p>
        pub fn max_entries(mut self, input: i32) -> Self {
            self.inner = self.inner.max_entries(input);
            self
        }
        pub fn set_max_entries(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_entries(input);
            self
        }
        /// <p>The tags to apply to the prefix list during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The IP address type.</p>
        /// <p>Valid Values: <code>IPv4</code> | <code>IPv6</code>
        /// </p>
        pub fn address_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.address_family(input);
            self
        }
        pub fn set_address_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_address_family(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraints: Up to 255 UTF-8 characters in length.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNatGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_nat_gateway_input::Builder,
    }
    impl<C> CreateNatGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNatGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateNatGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[Public NAT gateways only] The allocation ID of an Elastic IP address to associate
        /// with the NAT gateway. You cannot specify an Elastic IP address with a private NAT gateway.
        /// If the Elastic IP address is associated with another resource, you must first disassociate it.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_id(input);
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allocation_id(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        /// <p>Constraint: Maximum 64 ASCII characters.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The subnet in which to create the NAT gateway.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The tags to assign to the NAT gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Indicates whether the NAT gateway supports public or private connectivity.
        /// The default is public connectivity.</p>
        pub fn connectivity_type(mut self, input: crate::model::ConnectivityType) -> Self {
            self.inner = self.inner.connectivity_type(input);
            self
        }
        pub fn set_connectivity_type(
            mut self,
            input: std::option::Option<crate::model::ConnectivityType>,
        ) -> Self {
            self.inner = self.inner.set_connectivity_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_acl_input::Builder,
    }
    impl<C> CreateNetworkAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkAclOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to assign to the network ACL.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkAclEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_acl_entry_input::Builder,
    }
    impl<C> CreateNetworkAclEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkAclEntryOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkAclEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 network range to allow or deny, in CIDR notation (for example
        /// <code>172.16.0.0/24</code>). We modify the specified CIDR block to its canonical form; for example, if you specify <code>100.68.0.18/18</code>, we modify it to <code>100.68.0.0/18</code>.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_block(input);
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_block(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.inner = self.inner.egress(input);
            self
        }
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_egress(input);
            self
        }
        /// <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying protocol
        /// 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
        pub fn icmp_type_code(mut self, input: crate::model::IcmpTypeCode) -> Self {
            self.inner = self.inner.icmp_type_code(input);
            self
        }
        pub fn set_icmp_type_code(
            mut self,
            input: std::option::Option<crate::model::IcmpTypeCode>,
        ) -> Self {
            self.inner = self.inner.set_icmp_type_code(input);
            self
        }
        /// <p>The IPv6 network range to allow or deny, in CIDR notation (for example
        /// <code>2001:db8:1234:1a00::/64</code>).</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_id(input);
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_id(input);
            self
        }
        /// <p>TCP or UDP protocols: The range of ports the rule applies to.
        /// Required if specifying protocol 6 (TCP) or 17 (UDP).</p>
        pub fn port_range(mut self, input: crate::model::PortRange) -> Self {
            self.inner = self.inner.port_range(input);
            self
        }
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.inner = self.inner.set_port_range(input);
            self
        }
        /// <p>The protocol number. A value of "-1" means all protocols. If you specify "-1" or a
        /// protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is
        /// allowed, regardless of any ports or ICMP types or codes that you specify. If you specify
        /// protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and
        /// codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6)
        /// and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
        pub fn rule_action(mut self, input: crate::model::RuleAction) -> Self {
            self.inner = self.inner.rule_action(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::RuleAction>,
        ) -> Self {
            self.inner = self.inner.set_rule_action(input);
            self
        }
        /// <p>The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number.</p>
        /// <p>Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.inner = self.inner.rule_number(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_rule_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkInsightsPath<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_insights_path_input::Builder,
    }
    impl<C> CreateNetworkInsightsPath<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkInsightsPathOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkInsightsPathError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IP address of the AWS resource that is the source of the path.</p>
        pub fn source_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_ip(input);
            self
        }
        pub fn set_source_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_ip(input);
            self
        }
        /// <p>The IP address of the AWS resource that is the destination of the path.</p>
        pub fn destination_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_ip(input);
            self
        }
        pub fn set_destination_ip(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_ip(input);
            self
        }
        /// <p>The AWS resource that is the source of the path.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source(input);
            self
        }
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source(input);
            self
        }
        /// <p>The AWS resource that is the destination of the path.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination(input);
            self
        }
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_destination(input);
            self
        }
        /// <p>The protocol.</p>
        pub fn protocol(mut self, input: crate::model::Protocol) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::Protocol>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The destination port.</p>
        pub fn destination_port(mut self, input: i32) -> Self {
            self.inner = self.inner.destination_port(input);
            self
        }
        pub fn set_destination_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_destination_port(input);
            self
        }
        /// <p>The tags to add to the path.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_interface_input::Builder,
    }
    impl<C> CreateNetworkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the network interface.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of one or more security groups.</p>
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2
        /// automatically selects the IPv6 addresses from the subnet range. You can't use this
        /// option if specifying specific IPv6 addresses. If your subnet has the <code>AssignIpv6AddressOnCreation</code> attribute set
        /// to <code>true</code>, you can specify <code>0</code> to override this setting.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.inner = self.inner.ipv6_address_count(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_ipv6_address_count(input);
            self
        }
        /// <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        /// You can't use this option if you're specifying a number of IPv6 addresses.</p>
        pub fn ipv6_addresses(mut self, inp: impl Into<crate::model::InstanceIpv6Address>) -> Self {
            self.inner = self.inner.ipv6_addresses(inp);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_addresses(input);
            self
        }
        /// <p>The primary private IPv4 address of the network interface. If you don't specify an
        /// IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you
        /// specify an IP address, you cannot indicate any IP addresses specified in
        /// <code>privateIpAddresses</code> as primary (only one IP address can be designated as
        /// primary).</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_ip_address(input);
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_address(input);
            self
        }
        /// <p>One or more private IPv4 addresses.</p>
        pub fn private_ip_addresses(
            mut self,
            inp: impl Into<crate::model::PrivateIpAddressSpecification>,
        ) -> Self {
            self.inner = self.inner.private_ip_addresses(inp);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PrivateIpAddressSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_addresses(input);
            self
        }
        /// <p>The number of secondary private IPv4 addresses to assign to a network interface. When
        /// you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses
        /// within the subnet's IPv4 CIDR range. You can't specify this option and specify more than
        /// one private IP address using <code>privateIpAddresses</code>.</p>
        /// <p>The number of IP addresses you can assign to a network interface varies by instance
        /// type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI">IP Addresses Per ENI Per
        /// Instance Type</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
        pub fn secondary_private_ip_address_count(mut self, input: i32) -> Self {
            self.inner = self.inner.secondary_private_ip_address_count(input);
            self
        }
        pub fn set_secondary_private_ip_address_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.inner = self.inner.set_secondary_private_ip_address_count(input);
            self
        }
        /// <p>Indicates the type of network interface. To create an Elastic Fabric Adapter (EFA), specify
        /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">
        /// Elastic Fabric Adapter</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. To create a trunk network interface, specify
        /// <code>efa</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/eni-trunking.html">
        /// Network interface trunking</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn interface_type(mut self, input: crate::model::NetworkInterfaceCreationType) -> Self {
            self.inner = self.inner.interface_type(input);
            self
        }
        pub fn set_interface_type(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceCreationType>,
        ) -> Self {
            self.inner = self.inner.set_interface_type(input);
            self
        }
        /// <p>The ID of the subnet to associate with the network interface.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The tags to apply to the new network interface.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNetworkInterfacePermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_network_interface_permission_input::Builder,
    }
    impl<C> CreateNetworkInterfacePermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNetworkInterfacePermissionOutput,
            smithy_http::result::SdkError<crate::error::CreateNetworkInterfacePermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The account ID.</p>
        pub fn aws_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_account_id(input);
            self
        }
        pub fn set_aws_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_aws_account_id(input);
            self
        }
        /// <p>The Amazon Web Service. Currently not supported.</p>
        pub fn aws_service(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.aws_service(input);
            self
        }
        pub fn set_aws_service(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_aws_service(input);
            self
        }
        /// <p>The type of permission to grant.</p>
        pub fn permission(mut self, input: crate::model::InterfacePermissionType) -> Self {
            self.inner = self.inner.permission(input);
            self
        }
        pub fn set_permission(
            mut self,
            input: std::option::Option<crate::model::InterfacePermissionType>,
        ) -> Self {
            self.inner = self.inner.set_permission(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePlacementGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_placement_group_input::Builder,
    }
    impl<C> CreatePlacementGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePlacementGroupOutput,
            smithy_http::result::SdkError<crate::error::CreatePlacementGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>A name for the placement group. Must be unique within the scope of your account for
        /// the Region.</p>
        /// <p>Constraints: Up to 255 ASCII characters</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The placement strategy.</p>
        pub fn strategy(mut self, input: crate::model::PlacementStrategy) -> Self {
            self.inner = self.inner.strategy(input);
            self
        }
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::PlacementStrategy>,
        ) -> Self {
            self.inner = self.inner.set_strategy(input);
            self
        }
        /// <p>The number of partitions. Valid only when <b>Strategy</b> is
        /// set to <code>partition</code>.</p>
        pub fn partition_count(mut self, input: i32) -> Self {
            self.inner = self.inner.partition_count(input);
            self
        }
        pub fn set_partition_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_partition_count(input);
            self
        }
        /// <p>The tags to apply to the new placement group.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReplaceRootVolumeTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_replace_root_volume_task_input::Builder,
    }
    impl<C> CreateReplaceRootVolumeTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReplaceRootVolumeTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateReplaceRootVolumeTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance for which to replace the root volume.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the snapshot from which to restore the replacement root volume. If you want to
        /// restore the volume to the initial launch state, omit this parameter.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.
        /// If you do not specify a client token, a randomly generated token is used for the request
        /// to ensure idempotency. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to apply to the root volume replacement task.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateReservedInstancesListing<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_reserved_instances_listing_input::Builder,
    }
    impl<C> CreateReservedInstancesListing<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateReservedInstancesListingOutput,
            smithy_http::result::SdkError<crate::error::CreateReservedInstancesListingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure idempotency of your
        /// listings. This helps avoid duplicate listings. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.</p>
        pub fn price_schedules(
            mut self,
            inp: impl Into<crate::model::PriceScheduleSpecification>,
        ) -> Self {
            self.inner = self.inner.price_schedules(inp);
            self
        }
        pub fn set_price_schedules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PriceScheduleSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_price_schedules(input);
            self
        }
        /// <p>The ID of the active Standard Reserved Instance.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instances_id(input);
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRestoreImageTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_restore_image_task_input::Builder,
    }
    impl<C> CreateRestoreImageTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRestoreImageTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateRestoreImageTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the S3 bucket that contains the stored AMI object.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>The name of the stored AMI object in the bucket.</p>
        pub fn object_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.object_key(input);
            self
        }
        pub fn set_object_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_object_key(input);
            self
        }
        /// <p>The name for the restored AMI. The name must be unique for AMIs in the Region for this
        /// account. If you do not provide a name, the new AMI gets the same name as the original
        /// AMI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The tags to apply to the AMI and snapshots on restoration. You can tag the AMI, the
        /// snapshots, or both.</p>
        /// <ul>
        /// <li>
        /// <p>To tag the AMI, the value for <code>ResourceType</code> must be <code>image</code>.</p>
        /// </li>
        /// <li>
        /// <p>To
        /// tag the snapshots, the value for <code>ResourceType</code> must be <code>snapshot</code>. The
        /// same tag is applied to all of the snapshots that are created.</p>
        /// </li>
        /// </ul>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_route_input::Builder,
    }
    impl<C> CreateRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRouteOutput,
            smithy_http::result::SdkError<crate::error::CreateRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match. We modify the specified CIDR block to its canonical form; for example, if you specify <code>100.68.0.18/18</code>, we modify it to <code>100.68.0.0/18</code>.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.</p>
        pub fn destination_ipv6_cidr_block(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_ipv6_cidr_block(input);
            self
        }
        pub fn set_destination_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of a prefix list used for the destination match.</p>
        pub fn destination_prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_prefix_list_id(input);
            self
        }
        pub fn set_destination_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_prefix_list_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_id(input);
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_id(input);
            self
        }
        /// <p>[IPv6 traffic only] The ID of an egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.egress_only_internet_gateway_id(input);
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_egress_only_internet_gateway_id(input);
            self
        }
        /// <p>The ID of an internet gateway or virtual private gateway attached to your
        /// VPC.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_id(input);
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_id(input);
            self
        }
        /// <p>The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nat_gateway_id(input);
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nat_gateway_id(input);
            self
        }
        /// <p>The ID of a transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_gateway_id(input);
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_id(input);
            self
        }
        /// <p>The ID of the carrier gateway.</p>
        /// <p>You can only use this option when the VPC contains a subnet which is associated with a Wavelength Zone.</p>
        pub fn carrier_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.carrier_gateway_id(input);
            self
        }
        pub fn set_carrier_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_carrier_gateway_id(input);
            self
        }
        /// <p>The ID of a network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The ID of the route table for the route.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
        /// <p>The ID of a VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_route_table_input::Builder,
    }
    impl<C> CreateRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRouteTableOutput,
            smithy_http::result::SdkError<crate::error::CreateRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to assign to the route table.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_security_group_input::Builder,
    }
    impl<C> CreateSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the security group. This is informational only.</p>
        /// <p>Constraints: Up to 255 characters in length</p>
        /// <p>Constraints for EC2-Classic: ASCII characters</p>
        /// <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The name of the security group.</p>
        /// <p>Constraints: Up to 255 characters in length. Cannot start with
        /// <code>sg-</code>.</p>
        /// <p>Constraints for EC2-Classic: ASCII characters</p>
        /// <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>[EC2-VPC] The ID of the VPC. Required for EC2-VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The tags to assign to the security group.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_snapshot_input::Builder,
    }
    impl<C> CreateSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSnapshotOutput,
            smithy_http::result::SdkError<crate::error::CreateSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the snapshot.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Outpost on which to create a local  
        /// snapshot.</p>
        /// <ul>
        /// <li>
        /// <p>To create a snapshot of a volume in a Region, omit this parameter. The snapshot
        /// is created in the same Region as the volume.</p>
        /// </li>
        /// <li>
        /// <p>To create a snapshot of a volume on an Outpost and store the snapshot in the
        /// Region, omit this parameter. The snapshot is created in the Region for the
        /// Outpost.</p>
        /// </li>
        /// <li>
        /// <p>To create a snapshot of a volume on an Outpost and store the snapshot on an
        /// Outpost, specify the ARN of the destination Outpost. The snapshot must be created on
        /// the same Outpost as the volume.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html#create-snapshot">
        /// Creating local snapshots from volumes on an Outpost</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_arn(input);
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_arn(input);
            self
        }
        /// <p>The ID of the EBS volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>The tags to apply to the snapshot during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_snapshots_input::Builder,
    }
    impl<C> CreateSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::CreateSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> A description propagated to every snapshot specified by the instance.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The instance to specify which volumes should be included in the snapshots.</p>
        pub fn instance_specification(
            mut self,
            input: crate::model::InstanceSpecification,
        ) -> Self {
            self.inner = self.inner.instance_specification(input);
            self
        }
        pub fn set_instance_specification(
            mut self,
            input: std::option::Option<crate::model::InstanceSpecification>,
        ) -> Self {
            self.inner = self.inner.set_instance_specification(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Outpost on which to create the local  
        /// snapshots.</p>
        /// <ul>
        /// <li>
        /// <p>To create snapshots from an instance in a Region, omit this parameter. The
        /// snapshots are created in the same Region as the instance.</p>
        /// </li>
        /// <li>
        /// <p>To create snapshots from an instance on an Outpost and store the snapshots
        /// in the Region, omit this parameter. The snapshots are created in the Region
        /// for the Outpost.</p>
        /// </li>
        /// <li>
        /// <p>To create snapshots from an instance on an Outpost and store the snapshots
        /// on an Outpost, specify the ARN of the destination Outpost. The snapshots must
        /// be created on the same Outpost as the instance.</p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html#create-multivol-snapshot">
        /// Creating multi-volume local snapshots from instances on an Outpost</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_arn(input);
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_arn(input);
            self
        }
        /// <p>Tags to apply to every snapshot specified by the instance.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Copies the tags from the specified volume to corresponding snapshot.</p>
        pub fn copy_tags_from_source(mut self, input: crate::model::CopyTagsFromSource) -> Self {
            self.inner = self.inner.copy_tags_from_source(input);
            self
        }
        pub fn set_copy_tags_from_source(
            mut self,
            input: std::option::Option<crate::model::CopyTagsFromSource>,
        ) -> Self {
            self.inner = self.inner.set_copy_tags_from_source(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSpotDatafeedSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_spot_datafeed_subscription_input::Builder,
    }
    impl<C> CreateSpotDatafeedSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSpotDatafeedSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::CreateSpotDatafeedSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon S3 bucket in which to store the Spot Instance data feed. For
        /// more information about bucket names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html#bucketnamingrules">Rules for bucket
        /// naming</a> in the <i>Amazon S3 Developer Guide</i>.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The prefix for the data feed file names.</p>
        pub fn prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix(input);
            self
        }
        pub fn set_prefix(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_prefix(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStoreImageTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_store_image_task_input::Builder,
    }
    impl<C> CreateStoreImageTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStoreImageTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateStoreImageTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>The name of the S3 bucket in which the AMI object will be stored. The bucket must be in
        /// the Region in which the request is being made. The AMI object appears in the bucket only after
        /// the upload task has completed. </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>The tags to apply to the AMI object that will be stored in the S3 bucket. </p>
        pub fn s3_object_tags(mut self, inp: impl Into<crate::model::S3ObjectTag>) -> Self {
            self.inner = self.inner.s3_object_tags(inp);
            self
        }
        pub fn set_s3_object_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3ObjectTag>>,
        ) -> Self {
            self.inner = self.inner.set_s3_object_tags(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSubnet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_subnet_input::Builder,
    }
    impl<C> CreateSubnet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSubnetOutput,
            smithy_http::result::SdkError<crate::error::CreateSubnetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tags to assign to the subnet.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The Availability Zone or Local Zone for the subnet.</p>
        /// <p>Default: AWS selects one for you. If you create more than one subnet in your VPC, we
        /// do not necessarily select a different zone for each subnet.</p>
        /// <p>To create a subnet in a Local Zone, set this value to the Local Zone ID, for example
        /// <code>us-west-2-lax-1a</code>. For information about the Regions that support Local Zones,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">Available Regions</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>To create a subnet in an Outpost, set this value to the Availability Zone for the
        /// Outpost and specify the Outpost ARN.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The AZ ID or the Local Zone ID of the subnet.</p>
        pub fn availability_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone_id(input);
            self
        }
        pub fn set_availability_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone_id(input);
            self
        }
        /// <p>The IPv4 network range for the subnet, in CIDR notation. For example, <code>10.0.0.0/24</code>. We modify the specified CIDR block to its canonical form; for example, if you specify <code>100.68.0.18/18</code>, we modify it to <code>100.68.0.0/18</code>.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_block(input);
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_block(input);
            self
        }
        /// <p>The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a
        /// /64 prefix length.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost. If you specify an Outpost ARN, you must also
        /// specify the Availability Zone of the Outpost subnet.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_arn(input);
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_arn(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tags_input::Builder,
    }
    impl<C> CreateTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the resources, separated by spaces.</p>
        /// <p>Constraints: Up to 1000 resource IDs. We recommend breaking up this request into smaller batches.</p>
        pub fn resources(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>The tags. The <code>value</code> parameter is required, but if you don't want the tag to have a value,
        /// specify the parameter with no value, and we set the value to an empty string.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficMirrorFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_mirror_filter_input::Builder,
    }
    impl<C> CreateTrafficMirrorFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrafficMirrorFilterOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficMirrorFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The description of the Traffic Mirror filter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The tags to assign to a Traffic Mirror filter.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficMirrorFilterRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_mirror_filter_rule_input::Builder,
    }
    impl<C> CreateTrafficMirrorFilterRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrafficMirrorFilterRuleOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficMirrorFilterRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the filter that this rule is associated with.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_id(input);
            self
        }
        /// <p>The type of traffic (<code>ingress</code> | <code>egress</code>).</p>
        pub fn traffic_direction(mut self, input: crate::model::TrafficDirection) -> Self {
            self.inner = self.inner.traffic_direction(input);
            self
        }
        pub fn set_traffic_direction(
            mut self,
            input: std::option::Option<crate::model::TrafficDirection>,
        ) -> Self {
            self.inner = self.inner.set_traffic_direction(input);
            self
        }
        /// <p>The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given
        /// direction. The rules are processed in ascending order by rule number.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.inner = self.inner.rule_number(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_rule_number(input);
            self
        }
        /// <p>The action to take (<code>accept</code> | <code>reject</code>) on the filtered traffic.</p>
        pub fn rule_action(mut self, input: crate::model::TrafficMirrorRuleAction) -> Self {
            self.inner = self.inner.rule_action(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorRuleAction>,
        ) -> Self {
            self.inner = self.inner.set_rule_action(input);
            self
        }
        /// <p>The destination port range.</p>
        pub fn destination_port_range(
            mut self,
            input: crate::model::TrafficMirrorPortRangeRequest,
        ) -> Self {
            self.inner = self.inner.destination_port_range(input);
            self
        }
        pub fn set_destination_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_destination_port_range(input);
            self
        }
        /// <p>The source port range.</p>
        pub fn source_port_range(
            mut self,
            input: crate::model::TrafficMirrorPortRangeRequest,
        ) -> Self {
            self.inner = self.inner.source_port_range(input);
            self
        }
        pub fn set_source_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_source_port_range(input);
            self
        }
        /// <p>The protocol, for example UDP, to assign to the Traffic Mirror rule.</p>
        /// <p>For information about the protocol value, see <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a> on the  Internet Assigned Numbers Authority (IANA) website.</p>
        pub fn protocol(mut self, input: i32) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The destination CIDR block to assign to the Traffic Mirror rule.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The source CIDR block to assign to the Traffic Mirror rule.</p>
        pub fn source_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_cidr_block(input);
            self
        }
        pub fn set_source_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_cidr_block(input);
            self
        }
        /// <p>The description of the Traffic Mirror rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficMirrorSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_mirror_session_input::Builder,
    }
    impl<C> CreateTrafficMirrorSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrafficMirrorSessionOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficMirrorSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the source network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The ID of the Traffic Mirror target.</p>
        pub fn traffic_mirror_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_target_id(input);
            self
        }
        pub fn set_traffic_mirror_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_target_id(input);
            self
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_id(input);
            self
        }
        /// <p>The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do
        /// not specify this parameter when you want to mirror the entire packet. To mirror a subset of
        /// the packet, set this to the length (in bytes) that you want to mirror. For example, if you
        /// set this value to 100, then the first 100 bytes that meet the filter criteria are copied to
        /// the target.</p>
        /// <p>If you do not want to mirror the entire packet, use the <code>PacketLength</code> parameter to specify the number of bytes in each packet to mirror.</p>
        pub fn packet_length(mut self, input: i32) -> Self {
            self.inner = self.inner.packet_length(input);
            self
        }
        pub fn set_packet_length(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_packet_length(input);
            self
        }
        /// <p>The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets.</p>
        /// <p>Valid values are 1-32766.</p>
        pub fn session_number(mut self, input: i32) -> Self {
            self.inner = self.inner.session_number(input);
            self
        }
        pub fn set_session_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_session_number(input);
            self
        }
        /// <p>The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN
        /// protocol, see <a href="https://tools.ietf.org/html/rfc7348">RFC 7348</a>. If you do
        /// not specify a <code>VirtualNetworkId</code>, an account-wide unique id is chosen at
        /// random.</p>
        pub fn virtual_network_id(mut self, input: i32) -> Self {
            self.inner = self.inner.virtual_network_id(input);
            self
        }
        pub fn set_virtual_network_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_virtual_network_id(input);
            self
        }
        /// <p>The description of the Traffic Mirror session.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The tags to assign to a Traffic Mirror session.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTrafficMirrorTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_traffic_mirror_target_input::Builder,
    }
    impl<C> CreateTrafficMirrorTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTrafficMirrorTargetOutput,
            smithy_http::result::SdkError<crate::error::CreateTrafficMirrorTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The network interface ID that is associated with the target.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.</p>
        pub fn network_load_balancer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_load_balancer_arn(input);
            self
        }
        pub fn set_network_load_balancer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_load_balancer_arn(input);
            self
        }
        /// <p>The description of the Traffic Mirror target.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The tags to assign to the Traffic Mirror target.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_input::Builder,
    }
    impl<C> CreateTransitGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description of the transit gateway.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The transit gateway options.</p>
        pub fn options(mut self, input: crate::model::TransitGatewayRequestOptions) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayRequestOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The tags to apply to the transit gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayConnect<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_connect_input::Builder,
    }
    impl<C> CreateTransitGatewayConnect<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayConnectOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayConnectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway attachment. You can specify a VPC attachment or a AWS Direct Connect attachment.</p>
        pub fn transport_transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transport_transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transport_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_transport_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The Connect attachment options.</p>
        pub fn options(
            mut self,
            input: crate::model::CreateTransitGatewayConnectRequestOptions,
        ) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::CreateTransitGatewayConnectRequestOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The tags to apply to the Connect attachment.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayConnectPeer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_connect_peer_input::Builder,
    }
    impl<C> CreateTransitGatewayConnectPeer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayConnectPeerOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayConnectPeerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Connect attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The peer IP address (GRE outer IP address) on the transit gateway side of the Connect peer, which must be
        /// specified from a transit gateway CIDR block. If not specified, Amazon automatically assigns
        /// the first available IP address from the transit gateway CIDR block.</p>
        pub fn transit_gateway_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_address(input);
            self
        }
        pub fn set_transit_gateway_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_address(input);
            self
        }
        /// <p>The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_address(input);
            self
        }
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_address(input);
            self
        }
        /// <p>The BGP options for the Connect peer.</p>
        pub fn bgp_options(
            mut self,
            input: crate::model::TransitGatewayConnectRequestBgpOptions,
        ) -> Self {
            self.inner = self.inner.bgp_options(input);
            self
        }
        pub fn set_bgp_options(
            mut self,
            input: std::option::Option<crate::model::TransitGatewayConnectRequestBgpOptions>,
        ) -> Self {
            self.inner = self.inner.set_bgp_options(input);
            self
        }
        /// <p>The range of inside IP addresses that are used for BGP peering. You must specify a
        /// size /29 IPv4 CIDR block from the <code>169.254.0.0/16</code> range. The first address
        /// from the range must be configured on the appliance as the BGP IP address. You can also
        /// optionally specify a size /125 IPv6 CIDR block from the <code>fd00::/8</code>
        /// range.</p>
        pub fn inside_cidr_blocks(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.inside_cidr_blocks(inp);
            self
        }
        pub fn set_inside_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_inside_cidr_blocks(input);
            self
        }
        /// <p>The tags to apply to the Connect peer.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayMulticastDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_multicast_domain_input::Builder,
    }
    impl<C> CreateTransitGatewayMulticastDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayMulticastDomainOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayMulticastDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The options for the transit gateway multicast domain.</p>
        pub fn options(
            mut self,
            input: crate::model::CreateTransitGatewayMulticastDomainRequestOptions,
        ) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<
                crate::model::CreateTransitGatewayMulticastDomainRequestOptions,
            >,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The tags for the transit gateway multicast domain.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayPeeringAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_peering_attachment_input::Builder,
    }
    impl<C> CreateTransitGatewayPeeringAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayPeeringAttachmentOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayPeeringAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The ID of the peer transit gateway with which to create the peering attachment.</p>
        pub fn peer_transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_transit_gateway_id(input);
            self
        }
        pub fn set_peer_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_peer_transit_gateway_id(input);
            self
        }
        /// <p>The AWS account ID of the owner of the peer transit gateway.</p>
        pub fn peer_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_account_id(input);
            self
        }
        pub fn set_peer_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_peer_account_id(input);
            self
        }
        /// <p>The Region where the peer transit gateway is located.</p>
        pub fn peer_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_region(input);
            self
        }
        pub fn set_peer_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_region(input);
            self
        }
        /// <p>The tags to apply to the transit gateway peering attachment.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayPrefixListReference<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_prefix_list_reference_input::Builder,
    }
    impl<C> CreateTransitGatewayPrefixListReference<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayPrefixListReferenceOutput,
            smithy_http::result::SdkError<
                crate::error::CreateTransitGatewayPrefixListReferenceError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the prefix list that is used for destination matches.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The ID of the attachment to which traffic is routed.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Indicates whether to drop traffic that matches this route.</p>
        pub fn blackhole(mut self, input: bool) -> Self {
            self.inner = self.inner.blackhole(input);
            self
        }
        pub fn set_blackhole(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_blackhole(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_route_input::Builder,
    }
    impl<C> CreateTransitGatewayRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayRouteOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR range used for destination matches. Routing decisions are based on the
        /// most specific match.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Indicates whether to drop traffic that matches this route.</p>
        pub fn blackhole(mut self, input: bool) -> Self {
            self.inner = self.inner.blackhole(input);
            self
        }
        pub fn set_blackhole(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_blackhole(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_route_table_input::Builder,
    }
    impl<C> CreateTransitGatewayRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayRouteTableOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The tags to apply to the transit gateway route table.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTransitGatewayVpcAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_transit_gateway_vpc_attachment_input::Builder,
    }
    impl<C> CreateTransitGatewayVpcAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTransitGatewayVpcAttachmentOutput,
            smithy_http::result::SdkError<crate::error::CreateTransitGatewayVpcAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The IDs of one or more subnets. You can specify only one subnet per Availability Zone.
        /// You must specify at least one subnet, but we recommend that you specify two subnets for better availability.
        /// The transit gateway uses one IP address from each specified subnet.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>The VPC attachment options.</p>
        pub fn options(
            mut self,
            input: crate::model::CreateTransitGatewayVpcAttachmentRequestOptions,
        ) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<
                crate::model::CreateTransitGatewayVpcAttachmentRequestOptions,
            >,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The tags to apply to the VPC attachment.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_volume_input::Builder,
    }
    impl<C> CreateVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVolumeOutput,
            smithy_http::result::SdkError<crate::error::CreateVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Availability Zone in which to create the volume.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>Indicates whether the volume should be encrypted.
        /// The effect of setting the encryption state to <code>true</code> depends on
        /// the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default">Encryption by default</a>
        /// in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances">Supported
        /// instance types</a>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this represents
        /// the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline
        /// performance of the volume and the rate at which the volume accumulates I/O credits for bursting.</p>
        /// <p>The following are the supported values for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp3</code>: 3,000-16,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 100-64,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io2</code>: 100-64,000 IOPS</p>
        /// </li>
        /// </ul>
        /// <p>For <code>io1</code> and <code>io2</code> volumes, we guarantee 64,000 IOPS only for  
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a>. Other instance families guarantee performance
        /// up to 32,000 IOPS.</p>
        /// <p>This parameter is required for <code>io1</code> and <code>io2</code> volumes.
        /// The default for <code>gp3</code> volumes is 3,000 IOPS.
        /// This parameter is not supported for <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.inner = self.inner.iops(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_iops(input);
            self
        }
        /// <p>The identifier of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for Amazon EBS encryption.
        /// If this parameter is not specified, your AWS managed CMK for EBS is used. If <code>KmsKeyId</code> is
        /// specified, the encrypted state must be <code>true</code>.</p>
        /// <p>You can specify the CMK using any of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Key alias. For example, alias/ExampleAlias.</p>
        /// </li>
        /// <li>
        /// <p>Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.</p>
        /// </li>
        /// </ul>
        /// <p>AWS authenticates the CMK asynchronously. Therefore, if you specify an ID, alias, or ARN that is not valid,
        /// the action can appear to complete, but eventually fails.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        pub fn outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_arn(input);
            self
        }
        pub fn set_outpost_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_arn(input);
            self
        }
        /// <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        /// If you specify a snapshot, the default is the snapshot size. You can specify a volume
        /// size that is equal to or larger than the snapshot size.</p>
        /// <p>The following are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>standard</code>: 1-1,024</p>
        /// </li>
        /// </ul>
        pub fn size(mut self, input: i32) -> Self {
            self.inner = self.inner.size(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_size(input);
            self
        }
        /// <p>The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>The volume type. This parameter can be one of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>General Purpose SSD: <code>gp2</code> | <code>gp3</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Provisioned IOPS SSD: <code>io1</code> | <code>io2</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Throughput Optimized HDD: <code>st1</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Cold HDD: <code>sc1</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>Magnetic: <code>standard</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>Default: <code>gp2</code>
        /// </p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.inner = self.inner.volume_type(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.inner = self.inner.set_volume_type(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to apply to the volume during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Indicates whether to enable Amazon EBS Multi-Attach. If you enable Multi-Attach, you can attach the
        /// volume to up to 16 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances built on the Nitro System</a> in the same Availability Zone. This parameter is
        /// supported with <code>io1</code> and <code>io2</code> volumes only. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html">
        /// Amazon EBS Multi-Attach</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn multi_attach_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.multi_attach_enabled(input);
            self
        }
        pub fn set_multi_attach_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_multi_attach_enabled(input);
            self
        }
        /// <p>The throughput to provision for a volume, with a maximum of 1,000 MiB/s.</p>
        /// <p>This parameter is valid only for <code>gp3</code> volumes.</p>
        /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.inner = self.inner.throughput(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_throughput(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_input::Builder,
    }
    impl<C> CreateVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 network range for the VPC, in CIDR notation. For example,
        /// <code>10.0.0.0/16</code>. We modify the specified CIDR block to its canonical form; for example, if you specify <code>100.68.0.18/18</code>, we modify it to <code>100.68.0.0/18</code>.</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_block(input);
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_block(input);
            self
        }
        /// <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.
        /// You cannot specify the range of IP addresses, or the size of the CIDR block.</p>
        pub fn amazon_provided_ipv6_cidr_block(mut self, input: bool) -> Self {
            self.inner = self.inner.amazon_provided_ipv6_cidr_block(input);
            self
        }
        pub fn set_amazon_provided_ipv6_cidr_block(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_amazon_provided_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.</p>
        pub fn ipv6_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_pool(input);
            self
        }
        pub fn set_ipv6_pool(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ipv6_pool(input);
            self
        }
        /// <p>The IPv6 CIDR block from the IPv6 address pool. You must also specify <code>Ipv6Pool</code> in the request.</p>
        /// <p>To let Amazon choose the IPv6 CIDR block for you, omit this parameter.</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tenancy options for instances launched into the VPC. For <code>default</code>, instances
        /// are launched with shared tenancy by default. You can launch instances with any tenancy into a
        /// shared tenancy VPC. For <code>dedicated</code>, instances are launched as dedicated tenancy
        /// instances by default. You can only launch instances with a tenancy of <code>dedicated</code>
        /// or <code>host</code> into a dedicated tenancy VPC. </p>
        /// <p>
        /// <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p>
        /// <p>Default: <code>default</code>
        /// </p>
        pub fn instance_tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.inner = self.inner.instance_tenancy(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::Tenancy>,
        ) -> Self {
            self.inner = self.inner.set_instance_tenancy(input);
            self
        }
        /// <p>The name of the location from which we advertise the IPV6 CIDR block. Use this parameter to limit the address to this location.</p>
        /// <p> You must set <code>AmazonProvidedIpv6CidrBlock</code> to <code>true</code> to use this parameter.</p>
        pub fn ipv6_cidr_block_network_border_group(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.ipv6_cidr_block_network_border_group(input);
            self
        }
        pub fn set_ipv6_cidr_block_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block_network_border_group(input);
            self
        }
        /// <p>The tags to assign to the VPC.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_endpoint_input::Builder,
    }
    impl<C> CreateVpcEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcEndpointOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The type of endpoint.</p>
        /// <p>Default: Gateway</p>
        pub fn vpc_endpoint_type(mut self, input: crate::model::VpcEndpointType) -> Self {
            self.inner = self.inner.vpc_endpoint_type(input);
            self
        }
        pub fn set_vpc_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::VpcEndpointType>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_type(input);
            self
        }
        /// <p>The ID of the VPC in which the endpoint will be used.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The service name. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request, or get the name from the service
        /// provider.</p>
        pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_name(input);
            self
        }
        pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_name(input);
            self
        }
        /// <p>(Interface and gateway endpoints) A policy to attach to the endpoint that controls access to the
        /// service. The policy must be in valid JSON format. If this parameter is not specified, we
        /// attach a default policy that allows full access to the service.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
        /// <p>(Gateway endpoint) One or more route table IDs.</p>
        pub fn route_table_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_ids(inp);
            self
        }
        pub fn set_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_route_table_ids(input);
            self
        }
        /// <p>(Interface and Gateway Load Balancer endpoints) The ID of one or more subnets in which to create an endpoint
        /// network interface. For a Gateway Load Balancer endpoint, you can specify one subnet only.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>(Interface endpoint) The ID of one or more security groups to associate with the
        /// endpoint network interface.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>(Interface endpoint) Indicates whether to associate a private hosted zone with the
        /// specified VPC. The private hosted zone contains a record set for the default public DNS
        /// name for the service for the Region (for example,
        /// <code>kinesis.us-east-1.amazonaws.com</code>), which resolves to the private IP
        /// addresses of the endpoint network interfaces in the VPC. This enables you to make
        /// requests to the default public DNS name for the service instead of the public DNS names
        /// that are automatically generated by the VPC endpoint service.</p>
        /// <p>To use a private hosted zone, you must set the following VPC attributes to
        /// <code>true</code>: <code>enableDnsHostnames</code> and
        /// <code>enableDnsSupport</code>. Use <a>ModifyVpcAttribute</a> to set the VPC
        /// attributes.</p>
        /// <p>Default: <code>true</code>
        /// </p>
        pub fn private_dns_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.private_dns_enabled(input);
            self
        }
        pub fn set_private_dns_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_private_dns_enabled(input);
            self
        }
        /// <p>The tags to associate with the endpoint.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcEndpointConnectionNotification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_endpoint_connection_notification_input::Builder,
    }
    impl<C> CreateVpcEndpointConnectionNotification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcEndpointConnectionNotificationOutput,
            smithy_http::result::SdkError<
                crate::error::CreateVpcEndpointConnectionNotificationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the endpoint service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The ID of the endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_id(input);
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_id(input);
            self
        }
        /// <p>The ARN of the SNS topic for the notifications.</p>
        pub fn connection_notification_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.connection_notification_arn(input);
            self
        }
        pub fn set_connection_notification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_notification_arn(input);
            self
        }
        /// <p>One or more endpoint events for which to receive notifications. Valid values are
        /// <code>Accept</code>, <code>Connect</code>, <code>Delete</code>, and
        /// <code>Reject</code>.</p>
        pub fn connection_events(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_events(inp);
            self
        }
        pub fn set_connection_events(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_connection_events(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcEndpointServiceConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_endpoint_service_configuration_input::Builder,
    }
    impl<C> CreateVpcEndpointServiceConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcEndpointServiceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcEndpointServiceConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether requests from service consumers to create an endpoint to your service must
        /// be accepted. To accept a request, use <a>AcceptVpcEndpointConnections</a>.</p>
        pub fn acceptance_required(mut self, input: bool) -> Self {
            self.inner = self.inner.acceptance_required(input);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_acceptance_required(input);
            self
        }
        /// <p>(Interface endpoint configuration) The private DNS name to assign to the VPC endpoint service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_dns_name(input);
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_private_dns_name(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your
        /// service.</p>
        pub fn network_load_balancer_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_load_balancer_arns(inp);
            self
        }
        pub fn set_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_load_balancer_arns(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.</p>
        pub fn gateway_load_balancer_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_load_balancer_arns(inp);
            self
        }
        pub fn set_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_gateway_load_balancer_arns(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The tags to associate with the service.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpcPeeringConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpc_peering_connection_input::Builder,
    }
    impl<C> CreateVpcPeeringConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::CreateVpcPeeringConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The AWS account ID of the owner of the accepter VPC.</p>
        /// <p>Default: Your AWS account ID</p>
        pub fn peer_owner_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_owner_id(input);
            self
        }
        pub fn set_peer_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_peer_owner_id(input);
            self
        }
        /// <p>The ID of the VPC with which you are creating the VPC peering connection. You must
        /// specify this parameter in the request.</p>
        pub fn peer_vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_vpc_id(input);
            self
        }
        pub fn set_peer_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_vpc_id(input);
            self
        }
        /// <p>The ID of the requester VPC. You must specify this parameter in the
        /// request.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The Region code for the accepter VPC, if the accepter VPC is located in a Region
        /// other than the Region in which you make the request.</p>
        /// <p>Default: The Region in which you make the request.</p>
        pub fn peer_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.peer_region(input);
            self
        }
        pub fn set_peer_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_peer_region(input);
            self
        }
        /// <p>The tags to assign to the peering connection.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpnConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpn_connection_input::Builder,
    }
    impl<C> CreateVpnConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpnConnectionOutput,
            smithy_http::result::SdkError<crate::error::CreateVpnConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the customer gateway.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_gateway_id(input);
            self
        }
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_gateway_id(input);
            self
        }
        /// <p>The type of VPN connection (<code>ipsec.1</code>).</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The ID of the virtual private gateway. If you specify a virtual private gateway, you cannot specify a transit gateway.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_id(input);
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_id(input);
            self
        }
        /// <p>The ID of the transit gateway. If you specify a transit gateway, you cannot specify a virtual private gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The options for the VPN connection.</p>
        pub fn options(mut self, input: crate::model::VpnConnectionOptionsSpecification) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::VpnConnectionOptionsSpecification>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>The tags to apply to the VPN connection.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpnConnectionRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpn_connection_route_input::Builder,
    }
    impl<C> CreateVpnConnectionRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpnConnectionRouteOutput,
            smithy_http::result::SdkError<crate::error::CreateVpnConnectionRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR block associated with the local subnet of the customer network.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateVpnGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_vpn_gateway_input::Builder,
    }
    impl<C> CreateVpnGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateVpnGatewayOutput,
            smithy_http::result::SdkError<crate::error::CreateVpnGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Availability Zone for the virtual private gateway.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>The type of VPN connection this virtual private gateway supports.</p>
        pub fn r#type(mut self, input: crate::model::GatewayType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::GatewayType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The tags to apply to the virtual private gateway.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. If you're using a 16-bit ASN, it must be in the 64512 to 65534 range. If you're using a 32-bit ASN, it must be in the 4200000000 to 4294967294 range.</p>
        /// <p>Default: 64512</p>
        pub fn amazon_side_asn(mut self, input: i64) -> Self {
            self.inner = self.inner.amazon_side_asn(input);
            self
        }
        pub fn set_amazon_side_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_amazon_side_asn(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCarrierGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_carrier_gateway_input::Builder,
    }
    impl<C> DeleteCarrierGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCarrierGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteCarrierGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the carrier gateway.</p>
        pub fn carrier_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.carrier_gateway_id(input);
            self
        }
        pub fn set_carrier_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_carrier_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteClientVpnEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_client_vpn_endpoint_input::Builder,
    }
    impl<C> DeleteClientVpnEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClientVpnEndpointOutput,
            smithy_http::result::SdkError<crate::error::DeleteClientVpnEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN to be deleted.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteClientVpnRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_client_vpn_route_input::Builder,
    }
    impl<C> DeleteClientVpnRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClientVpnRouteOutput,
            smithy_http::result::SdkError<crate::error::DeleteClientVpnRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint from which the route is to be deleted.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ID of the target subnet used by the route.</p>
        pub fn target_vpc_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_vpc_subnet_id(input);
            self
        }
        pub fn set_target_vpc_subnet_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_vpc_subnet_id(input);
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the route to be deleted.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCustomerGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_customer_gateway_input::Builder,
    }
    impl<C> DeleteCustomerGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCustomerGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteCustomerGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the customer gateway.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_gateway_id(input);
            self
        }
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDhcpOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_dhcp_options_input::Builder,
    }
    impl<C> DeleteDhcpOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDhcpOptionsOutput,
            smithy_http::result::SdkError<crate::error::DeleteDhcpOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the DHCP options set.</p>
        pub fn dhcp_options_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dhcp_options_id(input);
            self
        }
        pub fn set_dhcp_options_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_dhcp_options_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteEgressOnlyInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_egress_only_internet_gateway_input::Builder,
    }
    impl<C> DeleteEgressOnlyInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteEgressOnlyInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteEgressOnlyInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.egress_only_internet_gateway_id(input);
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_egress_only_internet_gateway_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFleets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_fleets_input::Builder,
    }
    impl<C> DeleteFleets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFleetsOutput,
            smithy_http::result::SdkError<crate::error::DeleteFleetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the EC2 Fleets.</p>
        pub fn fleet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_ids(inp);
            self
        }
        pub fn set_fleet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fleet_ids(input);
            self
        }
        /// <p>Indicates whether to terminate the instances when the EC2 Fleet is deleted. The default is to
        /// terminate the instances.</p>
        /// <p>To let the instances continue to run after the EC2 Fleet is deleted, specify
        /// <code>NoTerminateInstances</code>. Supported only for fleets of type
        /// <code>maintain</code> and <code>request</code>.</p>
        /// <p>For <code>instant</code> fleets, you cannot specify <code>NoTerminateInstances</code>. A
        /// deleted <code>instant</code> fleet with running instances is not supported.</p>
        pub fn terminate_instances(mut self, input: bool) -> Self {
            self.inner = self.inner.terminate_instances(input);
            self
        }
        pub fn set_terminate_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_terminate_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFlowLogs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_flow_logs_input::Builder,
    }
    impl<C> DeleteFlowLogs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFlowLogsOutput,
            smithy_http::result::SdkError<crate::error::DeleteFlowLogsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more flow log IDs.</p>
        /// <p>Constraint: Maximum of 1000 flow log IDs.</p>
        pub fn flow_log_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_log_ids(inp);
            self
        }
        pub fn set_flow_log_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_flow_log_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFpgaImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_fpga_image_input::Builder,
    }
    impl<C> DeleteFpgaImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFpgaImageOutput,
            smithy_http::result::SdkError<crate::error::DeleteFpgaImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the AFI.</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fpga_image_id(input);
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fpga_image_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_internet_gateway_input::Builder,
    }
    impl<C> DeleteInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the internet gateway.</p>
        pub fn internet_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.internet_gateway_id(input);
            self
        }
        pub fn set_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_internet_gateway_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_key_pair_input::Builder,
    }
    impl<C> DeleteKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteKeyPairOutput,
            smithy_http::result::SdkError<crate::error::DeleteKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_name(input);
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_name(input);
            self
        }
        /// <p>The ID of the key pair.</p>
        pub fn key_pair_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_id(input);
            self
        }
        pub fn set_key_pair_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_pair_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_launch_template_input::Builder,
    }
    impl<C> DeleteLaunchTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_id(input);
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_id(input);
            self
        }
        /// <p>The name of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchTemplateVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_launch_template_versions_input::Builder,
    }
    impl<C> DeleteLaunchTemplateVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchTemplateVersionsOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchTemplateVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_id(input);
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_id(input);
            self
        }
        /// <p>The name of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
        /// <p>The version numbers of one or more launch template versions to delete.</p>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLocalGatewayRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_local_gateway_route_input::Builder,
    }
    impl<C> DeleteLocalGatewayRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLocalGatewayRouteOutput,
            smithy_http::result::SdkError<crate::error::DeleteLocalGatewayRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR range for the route. This must match the CIDR for the route exactly.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_route_table_id(input);
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_route_table_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLocalGatewayRouteTableVpcAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_local_gateway_route_table_vpc_association_input::Builder,
    }
    impl<C> DeleteLocalGatewayRouteTableVpcAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLocalGatewayRouteTableVpcAssociationOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteLocalGatewayRouteTableVpcAssociationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the association.</p>
        pub fn local_gateway_route_table_vpc_association_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .local_gateway_route_table_vpc_association_id(input);
            self
        }
        pub fn set_local_gateway_route_table_vpc_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .set_local_gateway_route_table_vpc_association_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteManagedPrefixList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_managed_prefix_list_input::Builder,
    }
    impl<C> DeleteManagedPrefixList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteManagedPrefixListOutput,
            smithy_http::result::SdkError<crate::error::DeleteManagedPrefixListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNatGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_nat_gateway_input::Builder,
    }
    impl<C> DeleteNatGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNatGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteNatGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nat_gateway_id(input);
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nat_gateway_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkAcl<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_acl_input::Builder,
    }
    impl<C> DeleteNetworkAcl<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkAclOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkAclError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_id(input);
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkAclEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_acl_entry_input::Builder,
    }
    impl<C> DeleteNetworkAclEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkAclEntryOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkAclEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether the rule is an egress rule.</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.inner = self.inner.egress(input);
            self
        }
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_egress(input);
            self
        }
        /// <p>The ID of the network ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_id(input);
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_id(input);
            self
        }
        /// <p>The rule number of the entry to delete.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.inner = self.inner.rule_number(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_rule_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkInsightsAnalysis<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_insights_analysis_input::Builder,
    }
    impl<C> DeleteNetworkInsightsAnalysis<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkInsightsAnalysisOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkInsightsAnalysisError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the network insights analysis.</p>
        pub fn network_insights_analysis_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.network_insights_analysis_id(input);
            self
        }
        pub fn set_network_insights_analysis_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_analysis_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkInsightsPath<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_insights_path_input::Builder,
    }
    impl<C> DeleteNetworkInsightsPath<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkInsightsPathOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkInsightsPathError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the path.</p>
        pub fn network_insights_path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_insights_path_id(input);
            self
        }
        pub fn set_network_insights_path_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_path_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_interface_input::Builder,
    }
    impl<C> DeleteNetworkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNetworkInterfacePermission<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_network_interface_permission_input::Builder,
    }
    impl<C> DeleteNetworkInterfacePermission<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNetworkInterfacePermissionOutput,
            smithy_http::result::SdkError<crate::error::DeleteNetworkInterfacePermissionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the network interface permission.</p>
        pub fn network_interface_permission_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.network_interface_permission_id(input);
            self
        }
        pub fn set_network_interface_permission_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_permission_id(input);
            self
        }
        /// <p>Specify <code>true</code> to remove the permission even if the network interface is
        /// attached to an instance.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePlacementGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_placement_group_input::Builder,
    }
    impl<C> DeletePlacementGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePlacementGroupOutput,
            smithy_http::result::SdkError<crate::error::DeletePlacementGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The name of the placement group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQueuedReservedInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_queued_reserved_instances_input::Builder,
    }
    impl<C> DeleteQueuedReservedInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteQueuedReservedInstancesOutput,
            smithy_http::result::SdkError<crate::error::DeleteQueuedReservedInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the Reserved Instances.</p>
        pub fn reserved_instances_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instances_ids(inp);
            self
        }
        pub fn set_reserved_instances_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_route_input::Builder,
    }
    impl<C> DeleteRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRouteOutput,
            smithy_http::result::SdkError<crate::error::DeleteRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
        pub fn destination_ipv6_cidr_block(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_ipv6_cidr_block(input);
            self
        }
        pub fn set_destination_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of the prefix list for the route.</p>
        pub fn destination_prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_prefix_list_id(input);
            self
        }
        pub fn set_destination_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_prefix_list_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_route_table_input::Builder,
    }
    impl<C> DeleteRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRouteTableOutput,
            smithy_http::result::SdkError<crate::error::DeleteRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSecurityGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_security_group_input::Builder,
    }
    impl<C> DeleteSecurityGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSecurityGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteSecurityGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the security group. Required for a nondefault VPC.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_snapshot_input::Builder,
    }
    impl<C> DeleteSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSnapshotOutput,
            smithy_http::result::SdkError<crate::error::DeleteSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the EBS snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSpotDatafeedSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_spot_datafeed_subscription_input::Builder,
    }
    impl<C> DeleteSpotDatafeedSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSpotDatafeedSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DeleteSpotDatafeedSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSubnet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_subnet_input::Builder,
    }
    impl<C> DeleteSubnet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSubnetOutput,
            smithy_http::result::SdkError<crate::error::DeleteSubnetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_input::Builder,
    }
    impl<C> DeleteTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the resources, separated by spaces.</p>
        /// <p>Constraints: Up to 1000 resource IDs. We recommend breaking up this request into smaller batches.</p>
        pub fn resources(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>The tags to delete. Specify a tag key and an optional tag value to delete
        /// specific tags. If you specify a tag key without a tag value, we delete any tag with this
        /// key regardless of its value. If you specify a tag key with an empty string as the tag
        /// value, we delete the tag only if its value is an empty string.</p>
        /// <p>If you omit this parameter, we delete all user-defined tags for the specified
        /// resources. We do not delete AWS-generated tags (tags that have the <code>aws:</code>
        /// prefix).</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficMirrorFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_mirror_filter_input::Builder,
    }
    impl<C> DeleteTrafficMirrorFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrafficMirrorFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficMirrorFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficMirrorFilterRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_mirror_filter_rule_input::Builder,
    }
    impl<C> DeleteTrafficMirrorFilterRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrafficMirrorFilterRuleOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficMirrorFilterRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror rule.</p>
        pub fn traffic_mirror_filter_rule_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_mirror_filter_rule_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_rule_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficMirrorSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_mirror_session_input::Builder,
    }
    impl<C> DeleteTrafficMirrorSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrafficMirrorSessionOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficMirrorSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror session.</p>
        pub fn traffic_mirror_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_session_id(input);
            self
        }
        pub fn set_traffic_mirror_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_session_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTrafficMirrorTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_traffic_mirror_target_input::Builder,
    }
    impl<C> DeleteTrafficMirrorTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTrafficMirrorTargetOutput,
            smithy_http::result::SdkError<crate::error::DeleteTrafficMirrorTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror target.</p>
        pub fn traffic_mirror_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_target_id(input);
            self
        }
        pub fn set_traffic_mirror_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_target_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_input::Builder,
    }
    impl<C> DeleteTransitGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayConnect<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_connect_input::Builder,
    }
    impl<C> DeleteTransitGatewayConnect<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayConnectOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayConnectError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Connect attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayConnectPeer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_connect_peer_input::Builder,
    }
    impl<C> DeleteTransitGatewayConnectPeer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayConnectPeerOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayConnectPeerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn transit_gateway_connect_peer_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_connect_peer_id(input);
            self
        }
        pub fn set_transit_gateway_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_connect_peer_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayMulticastDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_multicast_domain_input::Builder,
    }
    impl<C> DeleteTransitGatewayMulticastDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayMulticastDomainOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayMulticastDomainError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayPeeringAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_peering_attachment_input::Builder,
    }
    impl<C> DeleteTransitGatewayPeeringAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayPeeringAttachmentOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayPeeringAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway peering attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayPrefixListReference<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_prefix_list_reference_input::Builder,
    }
    impl<C> DeleteTransitGatewayPrefixListReference<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayPrefixListReferenceOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteTransitGatewayPrefixListReferenceError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_route_input::Builder,
    }
    impl<C> DeleteTransitGatewayRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayRouteOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The CIDR range for the route. This must match the CIDR for the route exactly.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_route_table_input::Builder,
    }
    impl<C> DeleteTransitGatewayRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayRouteTableOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTransitGatewayVpcAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_transit_gateway_vpc_attachment_input::Builder,
    }
    impl<C> DeleteTransitGatewayVpcAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTransitGatewayVpcAttachmentOutput,
            smithy_http::result::SdkError<crate::error::DeleteTransitGatewayVpcAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_volume_input::Builder,
    }
    impl<C> DeleteVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVolumeOutput,
            smithy_http::result::SdkError<crate::error::DeleteVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_input::Builder,
    }
    impl<C> DeleteVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcEndpointConnectionNotifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_endpoint_connection_notifications_input::Builder,
    }
    impl<C> DeleteVpcEndpointConnectionNotifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcEndpointConnectionNotificationsOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteVpcEndpointConnectionNotificationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more notification IDs.</p>
        pub fn connection_notification_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_notification_ids(inp);
            self
        }
        pub fn set_connection_notification_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_connection_notification_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_endpoints_input::Builder,
    }
    impl<C> DeleteVpcEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcEndpointsOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpcEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more VPC endpoint IDs.</p>
        pub fn vpc_endpoint_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_ids(inp);
            self
        }
        pub fn set_vpc_endpoint_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcEndpointServiceConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_endpoint_service_configurations_input::Builder,
    }
    impl<C> DeleteVpcEndpointServiceConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcEndpointServiceConfigurationsOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteVpcEndpointServiceConfigurationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of one or more services.</p>
        pub fn service_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_ids(inp);
            self
        }
        pub fn set_service_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_service_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpcPeeringConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpc_peering_connection_input::Builder,
    }
    impl<C> DeleteVpcPeeringConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpcPeeringConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpnConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpn_connection_input::Builder,
    }
    impl<C> DeleteVpnConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpnConnectionOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpnConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpnConnectionRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpn_connection_route_input::Builder,
    }
    impl<C> DeleteVpnConnectionRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpnConnectionRouteOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpnConnectionRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR block associated with the local subnet of the customer network.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteVpnGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_vpn_gateway_input::Builder,
    }
    impl<C> DeleteVpnGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteVpnGatewayOutput,
            smithy_http::result::SdkError<crate::error::DeleteVpnGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the virtual private gateway.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_id(input);
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeprovisionByoipCidr<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deprovision_byoip_cidr_input::Builder,
    }
    impl<C> DeprovisionByoipCidr<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeprovisionByoipCidrOutput,
            smithy_http::result::SdkError<crate::error::DeprovisionByoipCidrError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The address range, in CIDR notation. The prefix must be the same prefix
        /// that you specified when you provisioned the address range.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr(input);
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_image_input::Builder,
    }
    impl<C> DeregisterImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterImageOutput,
            smithy_http::result::SdkError<crate::error::DeregisterImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterInstanceEventNotificationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_instance_event_notification_attributes_input::Builder,
    }
    impl<C> DeregisterInstanceEventNotificationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterInstanceEventNotificationAttributesOutput,
            smithy_http::result::SdkError<
                crate::error::DeregisterInstanceEventNotificationAttributesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Information about the tag keys to deregister.</p>
        pub fn instance_tag_attribute(
            mut self,
            input: crate::model::DeregisterInstanceTagAttributeRequest,
        ) -> Self {
            self.inner = self.inner.instance_tag_attribute(input);
            self
        }
        pub fn set_instance_tag_attribute(
            mut self,
            input: std::option::Option<crate::model::DeregisterInstanceTagAttributeRequest>,
        ) -> Self {
            self.inner = self.inner.set_instance_tag_attribute(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterTransitGatewayMulticastGroupMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_transit_gateway_multicast_group_members_input::Builder,
    }
    impl<C> DeregisterTransitGatewayMulticastGroupMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterTransitGatewayMulticastGroupMembersOutput,
            smithy_http::result::SdkError<
                crate::error::DeregisterTransitGatewayMulticastGroupMembersError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ip_address(input);
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_group_ip_address(input);
            self
        }
        /// <p>The IDs of the group members' network interfaces.</p>
        pub fn network_interface_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_ids(inp);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterTransitGatewayMulticastGroupSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_transit_gateway_multicast_group_sources_input::Builder,
    }
    impl<C> DeregisterTransitGatewayMulticastGroupSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterTransitGatewayMulticastGroupSourcesOutput,
            smithy_http::result::SdkError<
                crate::error::DeregisterTransitGatewayMulticastGroupSourcesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ip_address(input);
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_group_ip_address(input);
            self
        }
        /// <p>The IDs of the group sources' network interfaces.</p>
        pub fn network_interface_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_ids(inp);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_attributes_input::Builder,
    }
    impl<C> DescribeAccountAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountAttributesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountAttributesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account attribute names.</p>
        pub fn attribute_names(
            mut self,
            inp: impl Into<crate::model::AccountAttributeName>,
        ) -> Self {
            self.inner = self.inner.attribute_names(inp);
            self
        }
        pub fn set_attribute_names(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AccountAttributeName>>,
        ) -> Self {
            self.inner = self.inner.set_attribute_names(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_addresses_input::Builder,
    }
    impl<C> DescribeAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>allocation-id</code> - [EC2-VPC] The allocation ID for the address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association-id</code> - [EC2-VPC] The association ID for the address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>domain</code> - Indicates whether the address is for use in EC2-Classic (<code>standard</code>)
        /// or in a VPC (<code>vpc</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance the address is associated with, if any.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-border-group</code> -  A unique set of Availability Zones, Local Zones,
        /// or Wavelength Zones from where Amazon Web Services advertises IP addresses. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-id</code> - [EC2-VPC] The ID of the network interface that the address is associated with, if any.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-owner-id</code> - The account ID of the owner.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>private-ip-address</code> - [EC2-VPC] The private IP address associated with the Elastic IP address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>public-ip</code> - The Elastic IP address, or the carrier IP address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more Elastic IP addresses.</p>
        /// <p>Default: Describes all your Elastic IP addresses.</p>
        pub fn public_ips(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ips(inp);
            self
        }
        pub fn set_public_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_public_ips(input);
            self
        }
        /// <p>[EC2-VPC] Information about the allocation IDs.</p>
        pub fn allocation_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_ids(inp);
            self
        }
        pub fn set_allocation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_allocation_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddressesAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_addresses_attribute_input::Builder,
    }
    impl<C> DescribeAddressesAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddressesAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddressesAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The allocation IDs.</p>
        pub fn allocation_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_ids(inp);
            self
        }
        pub fn set_allocation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_allocation_ids(input);
            self
        }
        /// <p>The attribute of the IP address.</p>
        pub fn attribute(mut self, input: crate::model::AddressAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::AddressAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAggregateIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_aggregate_id_format_input::Builder,
    }
    impl<C> DescribeAggregateIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAggregateIdFormatOutput,
            smithy_http::result::SdkError<crate::error::DescribeAggregateIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAvailabilityZones<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_availability_zones_input::Builder,
    }
    impl<C> DescribeAvailabilityZones<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAvailabilityZonesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAvailabilityZonesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>group-name</code> - For Availability Zones, use the Region name. For Local
        /// Zones, use the name of the group associated with the Local Zone (for example,
        /// <code>us-west-2-lax-1</code>) For Wavelength Zones, use the name of the group associated
        /// with the Wavelength Zone (for example, <code>us-east-1-wl1-bos-wlz-1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>message</code> - The Zone message.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>opt-in-status</code> - The opt-in status (<code>opted-in</code>, and
        /// <code>not-opted-in</code> | <code>opt-in-not-required</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>parent-zoneID</code> - The ID of the zone that handles some of the Local Zone
        /// and Wavelength Zone control plane operations, such as API calls.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>parent-zoneName</code> - The ID of the zone that handles some of the Local Zone
        /// and Wavelength Zone control plane operations, such as API calls.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>region-name</code> - The name of the Region for the Zone (for example,
        /// <code>us-east-1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the Availability Zone, the Local Zone, or the
        /// Wavelength Zone (<code>available</code> | <code>information</code> | <code>impaired</code>
        /// | <code>unavailable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zone-id</code> - The ID of the Availability Zone (for example,
        /// <code>use1-az1</code>), the Local Zone (for example, <code>usw2-lax1-az1</code>), or the
        /// Wavelength Zone (for example, <code>us-east-1-wl1-bos-wlz-1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zone-type</code> - The type of zone, for example, <code>local-zone</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zone-name</code> - The name of the Availability Zone (for example,
        /// <code>us-east-1a</code>), the Local Zone (for example, <code>us-west-2-lax-1a</code>), or
        /// the Wavelength Zone (for example, <code>us-east-1-wl1-bos-wlz-1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>zone-type</code> - The type of zone, for example, <code>local-zone</code>.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The names of the Availability Zones, Local Zones, and Wavelength Zones.</p>
        pub fn zone_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.zone_names(inp);
            self
        }
        pub fn set_zone_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_zone_names(input);
            self
        }
        /// <p>The IDs of the Availability Zones, Local Zones, and Wavelength Zones.</p>
        pub fn zone_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.zone_ids(inp);
            self
        }
        pub fn set_zone_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_zone_ids(input);
            self
        }
        /// <p>Include all Availability Zones, Local Zones, and Wavelength Zones regardless of your
        /// opt-in status.</p>
        /// <p>If you do not use this parameter, the results include only the zones for the Regions where you have chosen the option to opt in.</p>
        pub fn all_availability_zones(mut self, input: bool) -> Self {
            self.inner = self.inner.all_availability_zones(input);
            self
        }
        pub fn set_all_availability_zones(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_all_availability_zones(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBundleTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_bundle_tasks_input::Builder,
    }
    impl<C> DescribeBundleTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBundleTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeBundleTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The bundle task IDs.</p>
        /// <p>Default: Describes all your bundle tasks.</p>
        pub fn bundle_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bundle_ids(inp);
            self
        }
        pub fn set_bundle_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_bundle_ids(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>bundle-id</code> - The ID of the bundle task.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>error-code</code> - If the task failed, the error code returned.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>error-message</code> - If the task failed, the error message returned.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>progress</code> - The level of task completion, as a percentage (for example, 20%).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>s3-bucket</code> - The Amazon S3 bucket to store the AMI.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>s3-prefix</code> - The beginning of the AMI name.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>start-time</code> - The time the task started (for example, 2013-09-15T17:15:20.000Z).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the task (<code>pending</code> | <code>waiting-for-shutdown</code> | <code>bundling</code> |
        /// <code>storing</code> | <code>cancelling</code> | <code>complete</code> | <code>failed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>update-time</code> - The time of the most recent update for the task.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeByoipCidrs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_byoip_cidrs_input::Builder,
    }
    impl<C> DescribeByoipCidrs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeByoipCidrsOutput,
            smithy_http::result::SdkError<crate::error::DescribeByoipCidrsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCapacityReservations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_capacity_reservations_input::Builder,
    }
    impl<C> DescribeCapacityReservations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCapacityReservationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeCapacityReservationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_reservation_ids(inp);
            self
        }
        pub fn set_capacity_reservation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_ids(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The type of instance for which the Capacity Reservation reserves capacity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the account that owns the Capacity Reservation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone-id</code> - The Availability Zone ID of the Capacity Reservation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-platform</code> - The type of operating system for which the Capacity Reservation reserves capacity.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone ID of the Capacity Reservation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tenancy</code> - Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the
        /// following tenancy settings:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>default</code> - The Capacity Reservation is created on hardware that is shared with other accounts.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single account.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>outpost-arn</code> - The Amazon Resource Name (ARN) of the Outpost on which the Capacity Reservation was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>active</code>- The Capacity Reservation is active and the capacity is available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>expired</code> - The Capacity Reservation expired automatically at the date and time specified in your request.
        /// The reserved capacity is no longer available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cancelled</code> - The Capacity Reservation was cancelled. The reserved capacity is no longer available for your use.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>pending</code> - The Capacity Reservation request was successful but the capacity provisioning is still pending.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>failed</code> - The Capacity Reservation request has failed. A request might fail due to invalid request parameters,
        /// capacity constraints, or instance limit constraints. Failed requests are retained for 60 minutes.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>start-date</code> - The date and time at which the Capacity Reservation was started.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>end-date</code> - The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is
        /// released and you can no longer launch instances into it. The Capacity Reservation's state changes to expired when it reaches its end date and time.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>end-date-type</code> - Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-match-criteria</code> - Indicates the type of instance launches that the Capacity Reservation accepts. The options include:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>open</code> - The Capacity Reservation accepts all instances that have matching
        /// attributes (instance type, platform, and Availability Zone). Instances
        /// that have matching attributes launch into the Capacity Reservation
        /// automatically without specifying any additional parameters.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>targeted</code> - The Capacity Reservation only accepts instances that have matching
        /// attributes (instance type, platform, and Availability Zone), and
        /// explicitly target the Capacity Reservation. This ensures that only
        /// permitted instances can use the reserved capacity.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCarrierGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_carrier_gateways_input::Builder,
    }
    impl<C> DescribeCarrierGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCarrierGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeCarrierGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more carrier gateway IDs.</p>
        pub fn carrier_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.carrier_gateway_ids(inp);
            self
        }
        pub fn set_carrier_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_carrier_gateway_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>carrier-gateway-id</code> - The ID of the carrier gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the carrier gateway (<code>pending</code> |
        /// <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The AWS account ID of the owner of the carrier gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC associated with the carrier gateway.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClassicLinkInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_classic_link_instances_input::Builder,
    }
    impl<C> DescribeClassicLinkInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClassicLinkInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeClassicLinkInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>group-id</code> - The ID of a VPC security group that's associated with the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC to which the instance is
        /// linked.</p>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC that the instance is linked to.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more instance IDs. Must be instances linked to a VPC through ClassicLink.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        /// <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientVpnAuthorizationRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_client_vpn_authorization_rules_input::Builder,
    }
    impl<C> DescribeClientVpnAuthorizationRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientVpnAuthorizationRulesOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientVpnAuthorizationRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code> - The description of the authorization rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>destination-cidr</code> - The CIDR of the network to which the authorization rule
        /// applies.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-id</code> - The ID of the Active Directory group to which the authorization rule grants access.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientVpnConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_client_vpn_connections_input::Builder,
    }
    impl<C> DescribeClientVpnConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientVpnConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientVpnConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>connection-id</code> - The ID of the connection.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>username</code> - For Active Directory client authentication, the user name of the
        /// client who established the client connection.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientVpnEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_client_vpn_endpoints_input::Builder,
    }
    impl<C> DescribeClientVpnEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientVpnEndpointsOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientVpnEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_ids(inp);
            self
        }
        pub fn set_client_vpn_endpoint_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_ids(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>endpoint-id</code> - The ID of the Client VPN endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transport-protocol</code> - The transport protocol (<code>tcp</code> |
        /// <code>udp</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientVpnRoutes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_client_vpn_routes_input::Builder,
    }
    impl<C> DescribeClientVpnRoutes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientVpnRoutesOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientVpnRoutesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>destination-cidr</code> - The CIDR of the route destination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>origin</code> - How the route was associated with the Client VPN endpoint (<code>associate</code> | <code>add-route</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>target-subnet</code> - The ID of the subnet through which traffic is routed.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeClientVpnTargetNetworks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_client_vpn_target_networks_input::Builder,
    }
    impl<C> DescribeClientVpnTargetNetworks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClientVpnTargetNetworksOutput,
            smithy_http::result::SdkError<crate::error::DescribeClientVpnTargetNetworksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The IDs of the target network associations.</p>
        pub fn association_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_ids(inp);
            self
        }
        pub fn set_association_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_association_ids(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the nextToken value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>association-id</code> - The ID of the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>target-network-id</code> - The ID of the subnet specified as the target network.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC in which the target network is located.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCoipPools<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_coip_pools_input::Builder,
    }
    impl<C> DescribeCoipPools<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCoipPoolsOutput,
            smithy_http::result::SdkError<crate::error::DescribeCoipPoolsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the address pools.</p>
        pub fn pool_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_ids(inp);
            self
        }
        pub fn set_pool_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_pool_ids(input);
            self
        }
        /// <p>The filters. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-pool.pool-id</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-pool.local-gateway-route-table-id</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeConversionTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_conversion_tasks_input::Builder,
    }
    impl<C> DescribeConversionTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeConversionTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeConversionTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The conversion task IDs.</p>
        pub fn conversion_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.conversion_task_ids(inp);
            self
        }
        pub fn set_conversion_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_conversion_task_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCustomerGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_customer_gateways_input::Builder,
    }
    impl<C> DescribeCustomerGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeCustomerGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeCustomerGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more customer gateway IDs.</p>
        /// <p>Default: Describes all your customer gateways.</p>
        pub fn customer_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_gateway_ids(inp);
            self
        }
        pub fn set_customer_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_customer_gateway_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>bgp-asn</code> - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>customer-gateway-id</code> - The ID of the customer gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-address</code> - The IP address of the customer gateway's Internet-routable external interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the customer gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of customer gateway. Currently, the only supported type is <code>ipsec.1</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDhcpOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_dhcp_options_input::Builder,
    }
    impl<C> DescribeDhcpOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDhcpOptionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeDhcpOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of one or more DHCP options sets.</p>
        /// <p>Default: Describes all your DHCP options sets.</p>
        pub fn dhcp_options_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.dhcp_options_ids(inp);
            self
        }
        pub fn set_dhcp_options_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_dhcp_options_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>dhcp-options-id</code> - The ID of a DHCP options set.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>key</code> - The key for one of the options (for example, <code>domain-name</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>value</code> - The value for one of the options.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the DHCP options set.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeEgressOnlyInternetGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_egress_only_internet_gateways_input::Builder,
    }
    impl<C> DescribeEgressOnlyInternetGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeEgressOnlyInternetGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeEgressOnlyInternetGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more egress-only internet gateway IDs.</p>
        pub fn egress_only_internet_gateway_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.egress_only_internet_gateway_ids(inp);
            self
        }
        pub fn set_egress_only_internet_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_egress_only_internet_gateway_ids(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeElasticGpus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_elastic_gpus_input::Builder,
    }
    impl<C> DescribeElasticGpus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeElasticGpusOutput,
            smithy_http::result::SdkError<crate::error::DescribeElasticGpusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Elastic Graphics accelerator IDs.</p>
        pub fn elastic_gpu_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.elastic_gpu_ids(inp);
            self
        }
        pub fn set_elastic_gpu_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_elastic_gpu_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone in which the
        /// Elastic Graphics accelerator resides.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elastic-gpu-health</code> - The status of the Elastic Graphics accelerator
        /// (<code>OK</code> | <code>IMPAIRED</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elastic-gpu-state</code> - The state of the Elastic Graphics accelerator
        /// (<code>ATTACHED</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>elastic-gpu-type</code> - The type of Elastic Graphics accelerator; for example,
        /// <code>eg1.medium</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance to which the
        /// Elastic Graphics accelerator is associated.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 5 and 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeExportImageTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_export_image_tasks_input::Builder,
    }
    impl<C> DescribeExportImageTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeExportImageTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeExportImageTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Filter tasks using the <code>task-state</code> filter and one of the following values: <code>active</code>,
        /// <code>completed</code>, <code>deleting</code>, or <code>deleted</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The IDs of the export image tasks.</p>
        pub fn export_image_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.export_image_task_ids(inp);
            self
        }
        pub fn set_export_image_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_export_image_task_ids(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token that indicates the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeExportTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_export_tasks_input::Builder,
    }
    impl<C> DescribeExportTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeExportTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeExportTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The export task IDs.</p>
        pub fn export_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.export_task_ids(inp);
            self
        }
        pub fn set_export_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_export_task_ids(input);
            self
        }
        /// <p>the filters for the export tasks.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFastSnapshotRestores<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fast_snapshot_restores_input::Builder,
    }
    impl<C> DescribeFastSnapshotRestores<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFastSnapshotRestoresOutput,
            smithy_http::result::SdkError<crate::error::DescribeFastSnapshotRestoresError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code>: The Availability Zone of the snapshot.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code>: The ID of the AWS account that enabled fast snapshot restore on the snapshot.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>snapshot-id</code>: The ID of the snapshot.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code>: The state of fast snapshot restores for the snapshot
        /// (<code>enabling</code> |
        /// <code>optimizing</code> |
        /// <code>enabled</code> |
        /// <code>disabling</code> |
        /// <code>disabled</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fleet_history_input::Builder,
    }
    impl<C> DescribeFleetHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetHistoryOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The type of events to describe. By default, all events are described.</p>
        pub fn event_type(mut self, input: crate::model::FleetEventType) -> Self {
            self.inner = self.inner.event_type(input);
            self
        }
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::FleetEventType>,
        ) -> Self {
            self.inner = self.inner.set_event_type(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1 and
        /// 1000. The default value is 1000. To retrieve the remaining results, make another call with
        /// the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(input);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The start date and time for the events, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleetInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fleet_instances_input::Builder,
    }
    impl<C> DescribeFleetInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1 and
        /// 1000. The default value is 1000. To retrieve the remaining results, make another call with
        /// the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(input);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFleets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fleets_input::Builder,
    }
    impl<C> DescribeFleets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFleetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFleetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1 and
        /// 1000. The default value is 1000. To retrieve the remaining results, make another call with
        /// the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the EC2 Fleets.</p>
        pub fn fleet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_ids(inp);
            self
        }
        pub fn set_fleet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fleet_ids(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>activity-status</code> - The progress of the EC2 Fleet ( <code>error</code> |
        /// <code>pending-fulfillment</code> | <code>pending-termination</code> |
        /// <code>fulfilled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>excess-capacity-termination-policy</code> - Indicates whether to terminate
        /// running instances if the target capacity is decreased below the current EC2 Fleet size
        /// (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fleet-state</code> - The state of the EC2 Fleet (<code>submitted</code> |
        /// <code>active</code> | <code>deleted</code> | <code>failed</code> |
        /// <code>deleted-running</code> | <code>deleted-terminating</code> |
        /// <code>modifying</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>replace-unhealthy-instances</code> - Indicates whether EC2 Fleet should replace
        /// unhealthy instances (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of request (<code>instant</code> |
        /// <code>request</code> | <code>maintain</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFlowLogs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_flow_logs_input::Builder,
    }
    impl<C> DescribeFlowLogs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFlowLogsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFlowLogsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>deliver-log-status</code> - The status of the logs delivery (<code>SUCCESS</code> |
        /// <code>FAILED</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>log-destination-type</code> - The type of destination to which the flow
        /// log publishes data. Possible destination types include
        /// <code>cloud-watch-logs</code> and <code>s3</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>flow-log-id</code> - The ID of the flow log.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>log-group-name</code> - The name of the log group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the VPC, subnet, or network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-type</code> - The type of traffic (<code>ACCEPT</code> |
        /// <code>REJECT</code> | <code>ALL</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>One or more flow log IDs.</p>
        /// <p>Constraint: Maximum of 1000 flow log IDs.</p>
        pub fn flow_log_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_log_ids(inp);
            self
        }
        pub fn set_flow_log_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_flow_log_ids(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFpgaImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fpga_image_attribute_input::Builder,
    }
    impl<C> DescribeFpgaImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFpgaImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeFpgaImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the AFI.</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fpga_image_id(input);
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fpga_image_id(input);
            self
        }
        /// <p>The AFI attribute.</p>
        pub fn attribute(mut self, input: crate::model::FpgaImageAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::FpgaImageAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFpgaImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fpga_images_input::Builder,
    }
    impl<C> DescribeFpgaImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFpgaImagesOutput,
            smithy_http::result::SdkError<crate::error::DescribeFpgaImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The AFI IDs.</p>
        pub fn fpga_image_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fpga_image_ids(inp);
            self
        }
        pub fn set_fpga_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fpga_image_ids(input);
            self
        }
        /// <p>Filters the AFI by owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code>).</p>
        pub fn owners(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owners(inp);
            self
        }
        pub fn set_owners(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_owners(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>create-time</code> - The creation time of the AFI.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fpga-image-id</code> - The FPGA image identifier (AFI ID).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fpga-image-global-id</code> - The global FPGA image identifier (AGFI ID).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>name</code> - The name of the AFI.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The AWS account ID of the AFI owner.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-code</code> - The product code.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>shell-version</code> - The version of the AWS Shell that was used to create the bitstream.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the AFI (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>unavailable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>update-time</code> - The time of the most recent update.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeHostReservationOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_host_reservation_offerings_input::Builder,
    }
    impl<C> DescribeHostReservationOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeHostReservationOfferingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeHostReservationOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-family</code> - The instance family of the offering (for example,
        /// <code>m4</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>payment-option</code> - The payment option (<code>NoUpfront</code> |
        /// <code>PartialUpfront</code> | <code>AllUpfront</code>).</p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>This is the maximum duration of the reservation to purchase, specified in seconds.
        /// Reservations are available in one-year and three-year terms. The number of seconds
        /// specified must be the number of seconds in a year (365x24x60x60) times one of the
        /// supported durations (1 or 3). For example, specify 94608000 for three years.</p>
        pub fn max_duration(mut self, input: i32) -> Self {
            self.inner = self.inner.max_duration(input);
            self
        }
        pub fn set_max_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_duration(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>This is the minimum duration of the reservation you'd like to purchase, specified
        /// in seconds. Reservations are available in one-year and three-year terms. The number of
        /// seconds specified must be the number of seconds in a year (365x24x60x60) times one of
        /// the supported durations (1 or 3). For example, specify 31536000 for one year.</p>
        pub fn min_duration(mut self, input: i32) -> Self {
            self.inner = self.inner.min_duration(input);
            self
        }
        pub fn set_min_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_duration(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the reservation offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(input);
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeHostReservations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_host_reservations_input::Builder,
    }
    impl<C> DescribeHostReservations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeHostReservationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeHostReservationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-family</code> - The instance family (for example,
        /// <code>m4</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>payment-option</code> - The payment option (<code>NoUpfront</code> |
        /// <code>PartialUpfront</code> | <code>AllUpfront</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the reservation (<code>payment-pending</code>
        /// | <code>payment-failed</code> | <code>active</code> |
        /// <code>retired</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The host reservation IDs.</p>
        pub fn host_reservation_id_set(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_reservation_id_set(inp);
            self
        }
        pub fn set_host_reservation_id_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_reservation_id_set(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeHosts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_hosts_input::Builder,
    }
    impl<C> DescribeHosts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeHostsOutput,
            smithy_http::result::SdkError<crate::error::DescribeHostsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>auto-placement</code> - Whether auto-placement is enabled or disabled
        /// (<code>on</code> | <code>off</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone of the
        /// host.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>client-token</code> - The idempotency token that you provided when you
        /// allocated the host.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>host-reservation-id</code> - The ID of the reservation assigned to
        /// this host.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type size that the Dedicated Host
        /// is configured to support.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The allocation state of the Dedicated Host
        /// (<code>available</code> | <code>under-assessment</code> |
        /// <code>permanent-failure</code> | <code>released</code> |
        /// <code>released-permanent-failure</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The IDs of the Dedicated Hosts. The IDs are used for targeted instance
        /// launches.</p>
        pub fn host_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_ids(inp);
            self
        }
        pub fn set_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_ids(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        /// <p>You cannot specify this parameter and the host IDs parameter in the same request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIamInstanceProfileAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_iam_instance_profile_associations_input::Builder,
    }
    impl<C> DescribeIamInstanceProfileAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIamInstanceProfileAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeIamInstanceProfileAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM instance profile associations.</p>
        pub fn association_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_ids(inp);
            self
        }
        pub fn set_association_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_association_ids(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the association (<code>associating</code> |
        /// <code>associated</code> | <code>disassociating</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIdentityIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_identity_id_format_input::Builder,
    }
    impl<C> DescribeIdentityIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIdentityIdFormatOutput,
            smithy_http::result::SdkError<crate::error::DescribeIdentityIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the principal, which can be an IAM role, IAM user, or the root user.</p>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(input);
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_principal_arn(input);
            self
        }
        /// <p>The type of resource: <code>bundle</code> |
        /// <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> |
        /// <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> |
        /// <code>export-task</code> | <code>flow-log</code> | <code>image</code> |
        /// <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> |
        /// <code>network-acl</code> | <code>network-acl-association</code> |
        /// <code>network-interface</code> | <code>network-interface-attachment</code> |
        /// <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> |
        /// <code>route-table-association</code> | <code>security-group</code> |
        /// <code>snapshot</code> | <code>subnet</code> |
        /// <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code>
        /// | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> |
        /// <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>
        /// </p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_id_format_input::Builder,
    }
    impl<C> DescribeIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIdFormatOutput,
            smithy_http::result::SdkError<crate::error::DescribeIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of resource: <code>bundle</code> |
        /// <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> |
        /// <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> |
        /// <code>export-task</code> | <code>flow-log</code> | <code>image</code> |
        /// <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> |
        /// <code>network-acl</code> | <code>network-acl-association</code> |
        /// <code>network-interface</code> | <code>network-interface-attachment</code> |
        /// <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> |
        /// <code>route-table-association</code> | <code>security-group</code> |
        /// <code>snapshot</code> | <code>subnet</code> |
        /// <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code>
        /// | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> |
        /// <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>
        /// </p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_image_attribute_input::Builder,
    }
    impl<C> DescribeImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AMI attribute.</p>
        /// <p>
        /// <b>Note</b>: The <code>blockDeviceMapping</code> attribute is deprecated.
        /// Using this attribute returns the <code>Client.AuthFailure</code> error. To get information about
        /// the block device mappings for an AMI, use the <a>DescribeImages</a> action.</p>
        pub fn attribute(mut self, input: crate::model::ImageAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::ImageAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_images_input::Builder,
    }
    impl<C> DescribeImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeImagesOutput,
            smithy_http::result::SdkError<crate::error::DescribeImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Scopes the images by users with explicit launch permissions.
        /// Specify an AWS account ID, <code>self</code> (the sender of the request),
        /// or <code>all</code> (public AMIs).</p>
        pub fn executable_users(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.executable_users(inp);
            self
        }
        pub fn set_executable_users(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_executable_users(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>architecture</code> - The image architecture (<code>i386</code> |
        /// <code>x86_64</code> | <code>arm64</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.delete-on-termination</code> - A Boolean value that indicates
        /// whether the Amazon EBS volume is deleted on instance termination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.device-name</code> - The device name specified in the block device mapping (for
        /// example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the EBS
        /// volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.volume-size</code> - The volume size of the EBS volume, in GiB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.volume-type</code> - The volume type of the EBS volume
        /// (<code>gp2</code> | <code>io1</code> | <code>io2</code> | <code>st1 </code>| <code>sc1</code> |
        /// <code>standard</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.encrypted</code> - A Boolean that indicates whether the EBS volume is encrypted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>description</code> - The description of the image (provided during image
        /// creation).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ena-support</code> - A Boolean that indicates whether enhanced networking
        /// with ENA is enabled.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hypervisor</code> - The hypervisor type (<code>ovm</code> |
        /// <code>xen</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>image-id</code> - The ID of the image.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>image-type</code> - The image type (<code>machine</code> | <code>kernel</code> |
        /// <code>ramdisk</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>is-public</code> - A Boolean that indicates whether the image is public.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kernel-id</code> - The kernel ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>manifest-location</code> - The location of the image manifest.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>name</code> - The name of the AMI (provided during image creation).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-alias</code> - The owner alias (<code>amazon</code> | <code>aws-marketplace</code>).
        /// The valid aliases are defined in an Amazon-maintained list. This is not the AWS account alias that can be
        /// set using the IAM console. We recommend that you use the <b>Owner</b>
        /// request parameter instead of this filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The AWS account ID of the owner. We recommend that you use the
        /// <b>Owner</b> request parameter instead of this filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code> - The platform. To only list Windows-based AMIs, use
        /// <code>windows</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-code</code> - The product code.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-code.type</code> - The type of the product code (<code>devpay</code> |
        /// <code>marketplace</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ramdisk-id</code> - The RAM disk ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>root-device-name</code> - The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> |
        /// <code>instance-store</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the image (<code>available</code> | <code>pending</code>
        /// | <code>failed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state-reason-code</code> - The reason code for the state change.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state-reason-message</code> - The message for the state change.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>sriov-net-support</code> - A value of <code>simple</code> indicates
        /// that enhanced networking with the Intel 82599 VF interface is enabled.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>virtualization-type</code> - The virtualization type (<code>paravirtual</code> |
        /// <code>hvm</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The image IDs.</p>
        /// <p>Default: Describes all images available to you.</p>
        pub fn image_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_ids(inp);
            self
        }
        pub fn set_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_image_ids(input);
            self
        }
        /// <p>Scopes the results to images with the specified owners. You can specify a combination of  
        /// AWS account IDs, <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.
        /// If you omit this parameter, the results include all images for which you have launch permissions,
        /// regardless of ownership.</p>
        pub fn owners(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owners(inp);
            self
        }
        pub fn set_owners(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_owners(input);
            self
        }
        /// <p>If <code>true</code>, all deprecated AMIs are included in the response. If
        /// <code>false</code>, no deprecated AMIs are included in the response. If no value is
        /// specified, the default value is <code>false</code>.</p>
        /// <note>
        /// <p>If you are the AMI owner, all deprecated AMIs appear in the response regardless of the value (<code>true</code> or <code>false</code>) that you set for this parameter.</p>
        /// </note>
        pub fn include_deprecated(mut self, input: bool) -> Self {
            self.inner = self.inner.include_deprecated(input);
            self
        }
        pub fn set_include_deprecated(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deprecated(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeImportImageTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_import_image_tasks_input::Builder,
    }
    impl<C> DescribeImportImageTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeImportImageTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeImportImageTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Filter tasks using the <code>task-state</code> filter and one of the following values: <code>active</code>,
        /// <code>completed</code>, <code>deleting</code>, or <code>deleted</code>.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The IDs of the import image tasks.</p>
        pub fn import_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.import_task_ids(inp);
            self
        }
        pub fn set_import_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_import_task_ids(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token that indicates the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeImportSnapshotTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_import_snapshot_tasks_input::Builder,
    }
    impl<C> DescribeImportSnapshotTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeImportSnapshotTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeImportSnapshotTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>A list of import snapshot task IDs.</p>
        pub fn import_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.import_task_ids(inp);
            self
        }
        pub fn set_import_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_import_task_ids(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call
        /// with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token that indicates the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_attribute_input::Builder,
    }
    impl<C> DescribeInstanceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The instance attribute.</p>
        /// <p>Note: The <code>enaSupport</code> attribute is not supported at this time.</p>
        pub fn attribute(mut self, input: crate::model::InstanceAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceCreditSpecifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_credit_specifications_input::Builder,
    }
    impl<C> DescribeInstanceCreditSpecifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceCreditSpecificationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceCreditSpecificationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The instance IDs.</p>
        /// <p>Default: Describes all your instances.</p>
        /// <p>Constraints: Maximum 1000 explicitly specified instance IDs.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 5 and 1000. You cannot specify this parameter and the instance IDs
        /// parameter in the same call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceEventNotificationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_event_notification_attributes_input::Builder,
    }
    impl<C> DescribeInstanceEventNotificationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceEventNotificationAttributesOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeInstanceEventNotificationAttributesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instances_input::Builder,
    }
    impl<C> DescribeInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>affinity</code> - The affinity setting for an instance running on a
        /// Dedicated Host (<code>default</code> | <code>host</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>architecture</code> - The instance architecture (<code>i386</code> |
        /// <code>x86_64</code> | <code>arm64</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.attach-time</code> - The attach time for an EBS
        /// volume mapped to the instance, for example,
        /// <code>2010-09-15T17:15:20.000Z</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.delete-on-termination</code> - A Boolean that
        /// indicates whether the EBS volume is deleted on instance termination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.device-name</code> - The device name specified in the
        /// block device mapping (for example, <code>/dev/sdh</code> or
        /// <code>xvdh</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.status</code> - The status for the EBS volume
        /// (<code>attaching</code> | <code>attached</code> | <code>detaching</code> |
        /// <code>detached</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>block-device-mapping.volume-id</code> - The volume ID of the EBS
        /// volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>client-token</code> - The idempotency token you provided when you launched
        /// the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dns-name</code> - The public DNS name of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-id</code> - The ID of the security group for the instance.
        /// EC2-Classic only.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-name</code> - The name of the security group for the instance.
        /// EC2-Classic only.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hibernation-options.configured</code> - A Boolean that indicates whether
        /// the instance is enabled for hibernation. A value of <code>true</code> means that
        /// the instance is enabled for hibernation. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>host-id</code> - The ID of the Dedicated Host on which the instance is
        /// running, if applicable.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hypervisor</code> - The hypervisor type of the instance
        /// (<code>ovm</code> | <code>xen</code>). The value <code>xen</code>
        /// is used for both Xen and Nitro hypervisors.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>iam-instance-profile.arn</code> - The instance profile associated with
        /// the instance. Specified as an ARN.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>image-id</code> - The ID of the image used to launch the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-lifecycle</code> - Indicates whether this is a Spot Instance or
        /// a Scheduled Instance (<code>spot</code> | <code>scheduled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-state-code</code> - The state of the instance, as a 16-bit
        /// unsigned integer. The high byte is used for internal purposes and should be
        /// ignored. The low byte is set based on the state represented. The valid values
        /// are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64
        /// (stopping), and 80 (stopped).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-state-name</code> - The state of the instance
        /// (<code>pending</code> | <code>running</code> | <code>shutting-down</code> |
        /// <code>terminated</code> | <code>stopping</code> |
        /// <code>stopped</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The type of instance (for example,
        /// <code>t2.micro</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance.group-id</code> - The ID of the security group for the
        /// instance. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance.group-name</code> - The name of the security group for the
        /// instance. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-address</code> - The public IPv4 address of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kernel-id</code> - The kernel ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>key-name</code> - The name of the key pair used when the instance was
        /// launched.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch-index</code> - When launching multiple instances, this is the
        /// index for the instance in the launch group (for example, 0, 1, 2, and so on). </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch-time</code> - The time when the instance was launched.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>metadata-options.http-tokens</code> - The metadata request authorization
        /// state (<code>optional</code> | <code>required</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>metadata-options.http-put-response-hop-limit</code> - The http metadata
        /// request put response hop limit (integer, possible values <code>1</code> to
        /// <code>64</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>metadata-options.http-endpoint</code> - Enable or disable metadata
        /// access on http endpoint (<code>enabled</code> | <code>disabled</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>monitoring-state</code> - Indicates whether detailed monitoring is
        /// enabled (<code>disabled</code> | <code>enabled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.addresses.private-ip-address</code> - The private IPv4
        /// address associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.addresses.primary</code> - Specifies whether the IPv4
        /// address of the network interface is the primary private IPv4 address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.addresses.association.public-ip</code> - The ID of the
        /// association of an Elastic IP address (IPv4) with a network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.addresses.association.ip-owner-id</code> - The owner
        /// ID of the private IPv4 address associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.association.public-ip</code> - The address of the
        /// Elastic IP address (IPv4) bound to the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.association.ip-owner-id</code> - The owner of the
        /// Elastic IP address (IPv4) associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.association.allocation-id</code> - The allocation ID
        /// returned when you allocated the Elastic IP address (IPv4) for your network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.association.association-id</code> - The association ID
        /// returned when the network interface was associated with an IPv4 address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.attachment-id</code> - The ID of the
        /// interface attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.instance-id</code> - The ID of the instance
        /// to which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.instance-owner-id</code> - The owner ID of
        /// the instance to which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.device-index</code> - The device index to
        /// which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.status</code> - The status of the
        /// attachment (<code>attaching</code> | <code>attached</code> |
        /// <code>detaching</code> | <code>detached</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.attach-time</code> - The time that the
        /// network interface was attached to an instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.attachment.delete-on-termination</code> - Specifies
        /// whether the attachment is deleted when an instance is terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.availability-zone</code> - The Availability Zone for
        /// the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.description</code> - The description of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.group-id</code> - The ID of a security group
        /// associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.group-name</code> - The name of a security group
        /// associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.ipv6-addresses.ipv6-address</code> - The IPv6 address
        /// associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.mac-address</code> - The MAC address of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.network-interface-id</code> - The ID of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.owner-id</code> - The ID of the owner of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.private-dns-name</code> - The private DNS name of the
        /// network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.requester-id</code> - The requester ID for the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.requester-managed</code> - Indicates whether the
        /// network interface is being managed by Amazon Web Services.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.status</code> - The status of the network interface
        /// (<code>available</code>) | <code>in-use</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.source-dest-check</code> - Whether the network
        /// interface performs source/destination checking. A value of <code>true</code>
        /// means that checking is enabled, and <code>false</code> means that checking is
        /// disabled. The value must be <code>false</code> for the network interface to
        /// perform network address translation (NAT) in your VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.subnet-id</code> - The ID of the subnet for the
        /// network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.vpc-id</code> - The ID of the VPC for the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>outpost-arn</code> - The Amazon Resource Name (ARN) of the Outpost.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The account ID of the instance owner.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>placement-group-name</code> - The name of the placement group for the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>placement-partition-number</code> - The partition in which the instance is
        /// located.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code> - The platform. To list only Windows instances, use
        /// <code>windows</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>private-dns-name</code> - The private IPv4 DNS name of the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>private-ip-address</code> - The private IPv4 address of the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-code</code> - The product code associated with the AMI used to
        /// launch the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-code.type</code> - The type of product code (<code>devpay</code> |
        /// <code>marketplace</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ramdisk-id</code> - The RAM disk ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reason</code> - The reason for the current state of the instance (for
        /// example, shows "User Initiated [date]" when you stop or terminate the instance).
        /// Similar to the state-reason-code filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-id</code> - The ID of the entity that launched the instance on
        /// your behalf (for example, Management Console, Auto Scaling, and so
        /// on).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reservation-id</code> - The ID of the instance's reservation. A
        /// reservation ID is created any time you launch an instance. A reservation ID has
        /// a one-to-one relationship with an instance launch request, but can be associated
        /// with more than one instance if you launch multiple instances using the same
        /// launch request. For example, if you launch one instance, you get one reservation
        /// ID. If you launch ten instances using the same launch request, you also get one
        /// reservation ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>root-device-name</code> - The device name of the root device volume (for
        /// example, <code>/dev/sda1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>root-device-type</code> - The type of the root device volume
        /// (<code>ebs</code> | <code>instance-store</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>source-dest-check</code> - Indicates whether the instance performs
        /// source/destination checking. A value of <code>true</code> means that checking is
        /// enabled, and <code>false</code> means that checking is disabled. The value must
        /// be <code>false</code> for the instance to perform network address translation
        /// (NAT) in your VPC. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spot-instance-request-id</code> - The ID of the Spot Instance
        /// request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state-reason-code</code> - The reason code for the state change.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state-reason-message</code> - A message that describes the state
        /// change.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet for the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources that have a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tenancy</code> - The tenancy of an instance (<code>dedicated</code> |
        /// <code>default</code> | <code>host</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>virtualization-type</code> - The virtualization type of the instance
        /// (<code>paravirtual</code> | <code>hvm</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC that the instance is running in.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The instance IDs.</p>
        /// <p>Default: Describes all your instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 5 and 1000. You cannot specify this parameter and the instance IDs
        /// parameter in the same call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_status_input::Builder,
    }
    impl<C> DescribeInstanceStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceStatusOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.code</code> - The code for the scheduled event
        /// (<code>instance-reboot</code> | <code>system-reboot</code> |
        /// <code>system-maintenance</code> | <code>instance-retirement</code> |
        /// <code>instance-stop</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.description</code> - A description of the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.instance-event-id</code> - The ID of the event whose date and time
        /// you are modifying.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.not-after</code> - The latest end time for the scheduled event
        /// (for example, <code>2014-09-15T17:15:20.000Z</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.not-before</code> - The earliest start time for the scheduled
        /// event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.not-before-deadline</code> - The deadline for starting the event
        /// (for example, <code>2014-09-15T17:15:20.000Z</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-state-code</code> - The code for the instance state, as a
        /// 16-bit unsigned integer. The high byte is used for internal purposes and should
        /// be ignored. The low byte is set based on the state represented. The valid values
        /// are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64
        /// (stopping), and 80 (stopped).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-state-name</code> - The state of the instance
        /// (<code>pending</code> | <code>running</code> | <code>shutting-down</code> |
        /// <code>terminated</code> | <code>stopping</code> |
        /// <code>stopped</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-status.reachability</code> - Filters on instance status where
        /// the name is <code>reachability</code> (<code>passed</code> | <code>failed</code>
        /// | <code>initializing</code> | <code>insufficient-data</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-status.status</code> - The status of the instance
        /// (<code>ok</code> | <code>impaired</code> | <code>initializing</code> |
        /// <code>insufficient-data</code> | <code>not-applicable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>system-status.reachability</code> - Filters on system status where the
        /// name is <code>reachability</code> (<code>passed</code> | <code>failed</code> |
        /// <code>initializing</code> | <code>insufficient-data</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>system-status.status</code> - The system status of the instance
        /// (<code>ok</code> | <code>impaired</code> | <code>initializing</code> |
        /// <code>insufficient-data</code> | <code>not-applicable</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The instance IDs.</p>
        /// <p>Default: Describes all your instances.</p>
        /// <p>Constraints: Maximum 100 explicitly specified instance IDs.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 5 and 1000. You cannot specify this parameter and the instance IDs
        /// parameter in the same call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>When <code>true</code>, includes the health status for all instances. When
        /// <code>false</code>, includes the health status for running instances only.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn include_all_instances(mut self, input: bool) -> Self {
            self.inner = self.inner.include_all_instances(input);
            self
        }
        pub fn set_include_all_instances(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_all_instances(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceTypeOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_type_offerings_input::Builder,
    }
    impl<C> DescribeInstanceTypeOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceTypeOfferingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceTypeOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is
        /// <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The location type.</p>
        pub fn location_type(mut self, input: crate::model::LocationType) -> Self {
            self.inner = self.inner.location_type(input);
            self
        }
        pub fn set_location_type(
            mut self,
            input: std::option::Option<crate::model::LocationType>,
        ) -> Self {
            self.inner = self.inner.set_location_type(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>location</code> - This depends on the location type. For example, if the location type is
        /// <code>region</code> (default), the location is the Region code (for example, <code>us-east-2</code>.)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type. For example,
        /// <code>c5.2xlarge</code>.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results
        /// can be seen by sending another request with the next token value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_types_input::Builder,
    }
    impl<C> DescribeInstanceTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is
        /// <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The instance types. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn instance_types(mut self, inp: impl Into<crate::model::InstanceType>) -> Self {
            self.inner = self.inner.instance_types(inp);
            self
        }
        pub fn set_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceType>>,
        ) -> Self {
            self.inner = self.inner.set_instance_types(input);
            self
        }
        /// <p>One or more filters. Filter names and values are case-sensitive.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>auto-recovery-supported</code> - Indicates whether auto recovery is supported
        /// (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>bare-metal</code> - Indicates whether it is a bare metal instance type
        /// (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>burstable-performance-supported</code> - Indicates whether it is a burstable
        /// performance instance type  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>current-generation</code> - Indicates whether this instance type is the latest
        /// generation instance type of an instance family  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.baseline-bandwidth-in-mbps</code> - The baseline
        /// bandwidth performance for an EBS-optimized instance type, in Mbps.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.baseline-iops</code> - The baseline input/output storage
        /// operations per second for an EBS-optimized instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.baseline-throughput-in-mbps</code> - The baseline
        /// throughput performance for an EBS-optimized instance type, in MB/s.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.maximum-bandwidth-in-mbps</code> - The maximum bandwidth
        /// performance for an EBS-optimized instance type, in Mbps.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.maximum-iops</code> - The maximum input/output storage
        /// operations per second for an EBS-optimized instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-info.maximum-throughput-in-mbps</code> - The maximum
        /// throughput performance for an EBS-optimized instance type, in MB/s.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.ebs-optimized-support</code> - Indicates whether the instance type is
        /// EBS-optimized (<code>supported</code> | <code>unsupported</code> |
        /// <code>default</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.encryption-support</code> - Indicates whether EBS encryption is supported
        /// (<code>supported</code> | <code>unsupported</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-info.nvme-support</code> - Indicates whether non-volatile memory express (NVMe)
        /// is supported for EBS volumes (<code>required</code> | <code>supported</code> |
        /// <code>unsupported</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>free-tier-eligible</code> - Indicates whether the instance type is eligible to use
        /// in the free tier  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hibernation-supported</code> - Indicates whether On-Demand hibernation is supported
        /// (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>hypervisor</code> - The hypervisor (<code>nitro</code> | <code>xen</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-info.disk.count</code> - The number of local disks.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-info.disk.size-in-gb</code> - The storage size of each instance storage disk, in
        /// GB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-info.disk.type</code> - The storage technology for the local
        /// instance storage disks (<code>hdd</code> | <code>ssd</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-info.nvme-support</code> - Indicates whether non-volatile memory
        /// express (NVMe) is supported for instance store (<code>required</code> | <code>supported</code>)
        /// | <code>unsupported</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-info.total-size-in-gb</code> - The total amount of storage available from all local
        /// instance storage, in GB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-storage-supported</code> - Indicates whether the instance type has local
        /// instance storage  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type (for example <code>c5.2xlarge</code> or
        /// c5*).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>memory-info.size-in-mib</code> - The memory size.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.efa-info.maximum-efa-interfaces</code> - The maximum number of Elastic
        /// Fabric Adapters (EFAs) per instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.efa-supported</code> - Indicates whether the instance type supports
        /// Elastic Fabric Adapter (EFA)  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.ena-support</code> - Indicates whether Elastic Network Adapter (ENA) is
        /// supported or required (<code>required</code> | <code>supported</code> |
        /// <code>unsupported</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.ipv4-addresses-per-interface</code> - The maximum number of private IPv4 addresses per
        /// network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.ipv6-addresses-per-interface</code> - The maximum number of private IPv6 addresses per
        /// network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.ipv6-supported</code> - Indicates whether the instance type supports
        /// IPv6  (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.maximum-network-interfaces</code> - The maximum number of network interfaces per instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-info.network-performance</code> - The network performance (for example, "25
        /// Gigabit").</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>processor-info.supported-architecture</code> - The CPU architecture
        /// (<code>arm64</code> | <code>i386</code> | <code>x86_64</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>processor-info.sustained-clock-speed-in-ghz</code> - The CPU clock speed, in GHz.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>supported-boot-mode</code> - The boot mode (<code>legacy-bios</code> |
        /// <code>uefi</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>supported-root-device-type</code> - The root device type (<code>ebs</code> |
        /// <code>instance-store</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>supported-usage-class</code> - The usage class (<code>on-demand</code> |
        /// <code>spot</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>supported-virtualization-type</code> - The virtualization type (<code>hvm</code> |
        /// <code>paravirtual</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vcpu-info.default-cores</code> - The default number of cores for the instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vcpu-info.default-threads-per-core</code> - The default number of threads per core for the instance
        /// type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vcpu-info.default-vcpus</code> - The default number of vCPUs for the instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vcpu-info.valid-cores</code> - The number of cores that can be configured for the instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vcpu-info.valid-threads-per-core</code> - The number of threads per core that can be configured for the instance type.
        /// For example, "1" or "1,2".</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results
        /// can be seen by sending another request with the next token value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInternetGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_internet_gateways_input::Builder,
    }
    impl<C> DescribeInternetGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInternetGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeInternetGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>attachment.state</code> - The current state of the attachment between the gateway
        /// and the VPC (<code>available</code>). Present only if a VPC is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.vpc-id</code> - The ID of an attached VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>internet-gateway-id</code> - The ID of the Internet gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the internet gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more internet gateway IDs.</p>
        /// <p>Default: Describes all your internet gateways.</p>
        pub fn internet_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.internet_gateway_ids(inp);
            self
        }
        pub fn set_internet_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_internet_gateway_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIpv6Pools<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_ipv6_pools_input::Builder,
    }
    impl<C> DescribeIpv6Pools<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIpv6PoolsOutput,
            smithy_http::result::SdkError<crate::error::DescribeIpv6PoolsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the IPv6 address pools.</p>
        pub fn pool_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_ids(inp);
            self
        }
        pub fn set_pool_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_pool_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeKeyPairs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_key_pairs_input::Builder,
    }
    impl<C> DescribeKeyPairs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeKeyPairsOutput,
            smithy_http::result::SdkError<crate::error::DescribeKeyPairsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>key-pair-id</code> - The ID of the key pair.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fingerprint</code> - The fingerprint of the key pair.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>key-name</code> - The name of the key pair.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The key pair names.</p>
        /// <p>Default: Describes all your key pairs.</p>
        pub fn key_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_names(inp);
            self
        }
        pub fn set_key_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_key_names(input);
            self
        }
        /// <p>The IDs of the key pairs.</p>
        pub fn key_pair_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_pair_ids(inp);
            self
        }
        pub fn set_key_pair_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_key_pair_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLaunchTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_launch_templates_input::Builder,
    }
    impl<C> DescribeLaunchTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLaunchTemplatesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLaunchTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more launch template IDs.</p>
        pub fn launch_template_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_ids(inp);
            self
        }
        pub fn set_launch_template_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_ids(input);
            self
        }
        /// <p>One or more launch template names.</p>
        pub fn launch_template_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_names(inp);
            self
        }
        pub fn set_launch_template_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_names(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>create-time</code> - The time the launch template was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch-template-name</code> - The name of the launch template.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 1 and 200.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLaunchTemplateVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_launch_template_versions_input::Builder,
    }
    impl<C> DescribeLaunchTemplateVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLaunchTemplateVersionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLaunchTemplateVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the launch template. To describe one or more versions of a specified launch
        /// template, you must specify either the launch template ID or the launch template name in
        /// the request. To describe all the latest or default launch template versions in your
        /// account, you must omit this parameter.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_id(input);
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_id(input);
            self
        }
        /// <p>The name of the launch template. To describe one or more versions of a specified
        /// launch template, you must specify either the launch template ID or the launch template
        /// name in the request. To describe all the latest or default launch template versions in
        /// your account, you must omit this parameter.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
        /// <p>One or more versions of the launch template. Valid values depend on whether you are describing a specified launch template (by ID or name) or all launch templates in your account.</p>
        /// <p>To describe one or more versions of a specified launch template, valid values are <code>$Latest</code>, <code>$Default</code>, and numbers.</p>
        /// <p>To describe all launch templates in your account that are defined as the latest
        /// version, the valid value is <code>$Latest</code>. To describe all launch templates in
        /// your account that are defined as the default version, the valid value is
        /// <code>$Default</code>. You can specify <code>$Latest</code> and
        /// <code>$Default</code> in the same call. You cannot specify numbers.</p>
        pub fn versions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.versions(inp);
            self
        }
        pub fn set_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_versions(input);
            self
        }
        /// <p>The version number after which to describe launch template versions.</p>
        pub fn min_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.min_version(input);
            self
        }
        pub fn set_min_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_min_version(input);
            self
        }
        /// <p>The version number up to which to describe launch template versions.</p>
        pub fn max_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.max_version(input);
            self
        }
        pub fn set_max_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_max_version(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value
        /// can be between 1 and 200.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>create-time</code> - The time the launch template version was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ebs-optimized</code> - A boolean that indicates whether the instance
        /// is optimized for Amazon EBS I/O.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>iam-instance-profile</code> - The ARN of the IAM instance
        /// profile.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>image-id</code> - The ID of the AMI.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>is-default-version</code> - A boolean that indicates whether the
        /// launch template version is the default version.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>kernel-id</code> - The kernel ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ram-disk-id</code> - The RAM disk ID.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGatewayRouteTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_local_gateway_route_tables_input::Builder,
    }
    impl<C> DescribeLocalGatewayRouteTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewayRouteTablesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocalGatewayRouteTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the local gateway route tables.</p>
        pub fn local_gateway_route_table_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_route_table_ids(inp);
            self
        }
        pub fn set_local_gateway_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_route_table_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>local-gateway-id</code> - The ID of a local gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-id</code> - The ID of a local gateway route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>outpost-arn</code> - The Amazon Resource Name (ARN) of the Outpost.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the local gateway route table.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations<C = aws_hyper::DynConnector> {
                            handle: std::sync::Arc<super::Handle<C>>,
                            inner: crate::input::describe_local_gateway_route_table_virtual_interface_group_associations_input::Builder
                        }
    impl<C> DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the associations.</p>
        pub fn local_gateway_route_table_virtual_interface_group_association_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .local_gateway_route_table_virtual_interface_group_association_ids(inp);
            self
        }
        pub fn set_local_gateway_route_table_virtual_interface_group_association_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self
                .inner
                .set_local_gateway_route_table_virtual_interface_group_association_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>local-gateway-id</code> - The ID of a local gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-id</code> - The ID of the local gateway route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-virtual-interface-group-association-id</code> - The ID of the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-virtual-interface-group-id</code> - The ID of the virtual interface group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the association.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGatewayRouteTableVpcAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_local_gateway_route_table_vpc_associations_input::Builder,
    }
    impl<C> DescribeLocalGatewayRouteTableVpcAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewayRouteTableVpcAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeLocalGatewayRouteTableVpcAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the associations.</p>
        pub fn local_gateway_route_table_vpc_association_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self
                .inner
                .local_gateway_route_table_vpc_association_ids(inp);
            self
        }
        pub fn set_local_gateway_route_table_vpc_association_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self
                .inner
                .set_local_gateway_route_table_vpc_association_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>local-gateway-id</code> - The ID of a local gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-id</code> - The ID of the local gateway route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-vpc-association-id</code> - The ID of the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_local_gateways_input::Builder,
    }
    impl<C> DescribeLocalGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocalGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>local-gateway-id</code> - The ID of a local gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-id</code> - The ID of the local gateway route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-virtual-interface-group-association-id</code> - The ID of the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-route-table-virtual-interface-group-id</code> - The ID of the virtual interface group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>outpost-arn</code> - The Amazon Resource Name (ARN) of the Outpost.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the association.</p>
        /// </li>
        /// </ul>
        pub fn local_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_gateway_ids(inp);
            self
        }
        pub fn set_local_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGatewayVirtualInterfaceGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_local_gateway_virtual_interface_groups_input::Builder,
    }
    impl<C> DescribeLocalGatewayVirtualInterfaceGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewayVirtualInterfaceGroupsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeLocalGatewayVirtualInterfaceGroupsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the virtual interface groups.</p>
        pub fn local_gateway_virtual_interface_group_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_virtual_interface_group_ids(inp);
            self
        }
        pub fn set_local_gateway_virtual_interface_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self
                .inner
                .set_local_gateway_virtual_interface_group_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>local-gateway-id</code> - The ID of a local gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-virtual-interface-id</code> - The ID of the virtual interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-gateway-virtual-interface-group-id</code> - The ID of the virtual interface group.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLocalGatewayVirtualInterfaces<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_local_gateway_virtual_interfaces_input::Builder,
    }
    impl<C> DescribeLocalGatewayVirtualInterfaces<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLocalGatewayVirtualInterfacesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLocalGatewayVirtualInterfacesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the virtual interfaces.</p>
        pub fn local_gateway_virtual_interface_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_virtual_interface_ids(inp);
            self
        }
        pub fn set_local_gateway_virtual_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_virtual_interface_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeManagedPrefixLists<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_managed_prefix_lists_input::Builder,
    }
    impl<C> DescribeManagedPrefixLists<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeManagedPrefixListsOutput,
            smithy_http::result::SdkError<crate::error::DescribeManagedPrefixListsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the prefix list owner.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-id</code> - The ID of the prefix list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-name</code> - The name of the prefix list.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more prefix list IDs.</p>
        pub fn prefix_list_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_ids(inp);
            self
        }
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMovingAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_moving_addresses_input::Builder,
    }
    impl<C> DescribeMovingAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMovingAddressesOutput,
            smithy_http::result::SdkError<crate::error::DescribeMovingAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>moving-status</code> - The status of the Elastic IP address
        /// (<code>MovingToVpc</code> | <code>RestoringToClassic</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining
        /// results of the initial request can be seen by sending another request with the returned
        /// <code>NextToken</code> value. This value can be between 5 and 1000; if
        /// <code>MaxResults</code> is given a value outside of this range, an error is returned.</p>
        /// <p>Default: If no value is provided, the default is 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more Elastic IP addresses.</p>
        pub fn public_ips(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ips(inp);
            self
        }
        pub fn set_public_ips(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_public_ips(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNatGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_nat_gateways_input::Builder,
    }
    impl<C> DescribeNatGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNatGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeNatGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>nat-gateway-id</code> - The ID of the NAT gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the NAT gateway (<code>pending</code> |
        /// <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet in which the NAT gateway resides.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC in which the NAT gateway resides.</p>
        /// </li>
        /// </ul>
        pub fn filter(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filter(inp);
            self
        }
        pub fn set_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filter(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>One or more NAT gateway IDs.</p>
        pub fn nat_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nat_gateway_ids(inp);
            self
        }
        pub fn set_nat_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_nat_gateway_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkAcls<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_acls_input::Builder,
    }
    impl<C> DescribeNetworkAcls<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkAclsOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkAclsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>association.association-id</code> - The ID of an association ID for the ACL.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.network-acl-id</code> - The ID of the network ACL involved in the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>default</code> - Indicates whether the ACL is the default network ACL for the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.cidr</code> - The IPv4 CIDR range specified in the entry.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.icmp.code</code> - The ICMP code specified in the entry, if any.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.icmp.type</code> - The ICMP type specified in the entry, if any.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.ipv6-cidr</code> - The IPv6 CIDR range specified in the entry.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.port-range.from</code> - The start of the port range specified in the entry. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.port-range.to</code> - The end of the port range specified in the entry. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.protocol</code> - The protocol specified in the entry (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.rule-action</code> - Allows or denies the matching traffic (<code>allow</code> | <code>deny</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>entry.rule-number</code> - The number of an entry (in other words, rule) in
        /// the set of ACL entries.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-acl-id</code> - The ID of the network ACL.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the network ACL.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC for the network ACL.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more network ACL IDs.</p>
        /// <p>Default: Describes all your network ACLs.</p>
        pub fn network_acl_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_ids(inp);
            self
        }
        pub fn set_network_acl_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkInsightsAnalyses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_insights_analyses_input::Builder,
    }
    impl<C> DescribeNetworkInsightsAnalyses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkInsightsAnalysesOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkInsightsAnalysesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the network insights analyses. You must specify either analysis IDs or a path ID.</p>
        pub fn network_insights_analysis_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.network_insights_analysis_ids(inp);
            self
        }
        pub fn set_network_insights_analysis_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_analysis_ids(input);
            self
        }
        /// <p>The ID of the path. You must specify either a path ID or analysis IDs.</p>
        pub fn network_insights_path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_insights_path_id(input);
            self
        }
        pub fn set_network_insights_path_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_path_id(input);
            self
        }
        /// <p>The time when the network insights analyses started.</p>
        pub fn analysis_start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.analysis_start_time(input);
            self
        }
        pub fn set_analysis_start_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_analysis_start_time(input);
            self
        }
        /// <p>The time when the network insights analyses ended.</p>
        pub fn analysis_end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.analysis_end_time(input);
            self
        }
        pub fn set_analysis_end_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_analysis_end_time(input);
            self
        }
        /// <p>The filters. The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>PathFound - A Boolean value that indicates whether a feasible path is found.</p>
        /// </li>
        /// <li>
        /// <p>Status - The status of the analysis (running | succeeded | failed).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkInsightsPaths<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_insights_paths_input::Builder,
    }
    impl<C> DescribeNetworkInsightsPaths<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkInsightsPathsOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkInsightsPathsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the paths.</p>
        pub fn network_insights_path_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_insights_path_ids(inp);
            self
        }
        pub fn set_network_insights_path_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_path_ids(input);
            self
        }
        /// <p>The filters. The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>Destination - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>DestinationPort - The destination port.</p>
        /// </li>
        /// <li>
        /// <p>Name - The path name.</p>
        /// </li>
        /// <li>
        /// <p>Protocol - The protocol.</p>
        /// </li>
        /// <li>
        /// <p>Source - The ID of the resource.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkInterfaceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_interface_attribute_input::Builder,
    }
    impl<C> DescribeNetworkInterfaceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkInterfaceAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkInterfaceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The attribute of the network interface. This parameter is required.</p>
        pub fn attribute(mut self, input: crate::model::NetworkInterfaceAttribute) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceAttribute>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkInterfacePermissions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_interface_permissions_input::Builder,
    }
    impl<C> DescribeNetworkInterfacePermissions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkInterfacePermissionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkInterfacePermissionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more network interface permission IDs.</p>
        pub fn network_interface_permission_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.network_interface_permission_ids(inp);
            self
        }
        pub fn set_network_interface_permission_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_permission_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>network-interface-permission.network-interface-permission-id</code> - The ID of the
        /// permission.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-permission.network-interface-id</code> - The ID of
        /// the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-permission.aws-account-id</code> - The account ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-permission.aws-service</code> - The Amazon Web Service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-permission.permission</code> - The type of
        /// permission (<code>INSTANCE-ATTACH</code> |
        /// <code>EIP-ASSOCIATE</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining results,
        /// make another call with the returned <code>NextToken</code> value. If this parameter is not specified, up to 50 results are returned by default.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNetworkInterfaces<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_network_interfaces_input::Builder,
    }
    impl<C> DescribeNetworkInterfaces<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNetworkInterfacesOutput,
            smithy_http::result::SdkError<crate::error::DescribeNetworkInterfacesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>addresses.private-ip-address</code> - The private IPv4 addresses
        /// associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>addresses.primary</code> - Whether the private IPv4 address is the primary
        /// IP address associated with the network interface. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>addresses.association.public-ip</code> - The association ID returned when
        /// the network interface was associated with the Elastic IP address
        /// (IPv4).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>addresses.association.owner-id</code> - The owner ID of the addresses associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.association-id</code> - The association ID returned when the
        /// network interface was associated with an IPv4 address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.allocation-id</code> - The allocation ID returned when you
        /// allocated the Elastic IP address (IPv4) for your network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.ip-owner-id</code> - The owner of the Elastic IP address
        /// (IPv4) associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.public-ip</code> - The address of the Elastic IP address
        /// (IPv4) bound to the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.public-dns-name</code> - The public DNS name for the network
        /// interface (IPv4).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.attachment-id</code> - The ID of the interface attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.attach-time</code> - The time that the network interface was attached to an instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.delete-on-termination</code> - Indicates whether the attachment is deleted when an instance is terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.device-index</code> - The device index to which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone of the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>description</code> - The description of the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-id</code> - The ID of a security group associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-name</code> - The name of a security group associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-addresses.ipv6-address</code> - An IPv6 address associated with
        /// the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>mac-address</code> - The MAC address of the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-id</code> - The ID of the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The account ID of the network interface owner.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>private-ip-address</code> - The private IPv4 address or addresses of the
        /// network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>private-dns-name</code> - The private DNS name of the network interface (IPv4).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-id</code> - The alias or account ID of the principal or service that created the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-managed</code> - Indicates whether the network interface is being managed by an Amazon Web Service
        /// (for example, Management Console, Auto Scaling, and so on).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>source-dest-check</code> - Indicates whether the network interface performs source/destination checking.
        /// A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled.
        /// The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code> - The status of the network interface. If the network interface is not attached to an instance, the status is <code>available</code>;
        /// if a network interface is attached to an instance the status is <code>in-use</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet for the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC for the network interface.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more network interface IDs.</p>
        /// <p>Default: Describes all your network interfaces.</p>
        pub fn network_interface_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_ids(inp);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_ids(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return for this request. The request returns a token that you
        /// can specify in a subsequent call to get the next set of results. You cannot specify this
        /// parameter and the network interface IDs parameter in the same request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePlacementGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_placement_groups_input::Builder,
    }
    impl<C> DescribePlacementGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePlacementGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribePlacementGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>group-name</code> - The name of the placement group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the placement group (<code>pending</code> |
        /// <code>available</code> | <code>deleting</code> |
        /// <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>strategy</code> - The strategy of the placement group
        /// (<code>cluster</code> | <code>spread</code> |
        /// <code>partition</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources that have a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The names of the placement groups.</p>
        /// <p>Default: Describes all your placement groups, or only those otherwise
        /// specified.</p>
        pub fn group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_names(inp);
            self
        }
        pub fn set_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_names(input);
            self
        }
        /// <p>The IDs of the placement groups.</p>
        pub fn group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ids(inp);
            self
        }
        pub fn set_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePrefixLists<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_prefix_lists_input::Builder,
    }
    impl<C> DescribePrefixLists<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePrefixListsOutput,
            smithy_http::result::SdkError<crate::error::DescribePrefixListsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>prefix-list-id</code>: The ID of a prefix list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-name</code>: The name of a prefix list.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more prefix list IDs.</p>
        pub fn prefix_list_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_ids(inp);
            self
        }
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePrincipalIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_principal_id_format_input::Builder,
    }
    impl<C> DescribePrincipalIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePrincipalIdFormatOutput,
            smithy_http::result::SdkError<crate::error::DescribePrincipalIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The type of resource: <code>bundle</code> |
        /// <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> |
        /// <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> |
        /// <code>export-task</code> | <code>flow-log</code> | <code>image</code> |
        /// <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> |
        /// <code>network-acl</code> | <code>network-acl-association</code> |
        /// <code>network-interface</code> | <code>network-interface-attachment</code> |
        /// <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> |
        /// <code>route-table-association</code> | <code>security-group</code> |
        /// <code>snapshot</code> | <code>subnet</code> |
        /// <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code>
        /// | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> |
        /// <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>
        /// </p>
        pub fn resources(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resources(inp);
            self
        }
        pub fn set_resources(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_resources(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned NextToken value. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePublicIpv4Pools<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_public_ipv4_pools_input::Builder,
    }
    impl<C> DescribePublicIpv4Pools<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePublicIpv4PoolsOutput,
            smithy_http::result::SdkError<crate::error::DescribePublicIpv4PoolsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the address pools.</p>
        pub fn pool_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_ids(inp);
            self
        }
        pub fn set_pool_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_pool_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRegions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_regions_input::Builder,
    }
    impl<C> DescribeRegions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRegionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeRegionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>endpoint</code> - The endpoint of the Region (for example, <code>ec2.us-east-1.amazonaws.com</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>opt-in-status</code> - The opt-in status of the Region (<code>opt-in-not-required</code> | <code>opted-in</code> |
        /// <code>not-opted-in</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>region-name</code> - The name of the Region (for example, <code>us-east-1</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The names of the Regions. You can specify any Regions, whether they are enabled and disabled for your account.</p>
        pub fn region_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.region_names(inp);
            self
        }
        pub fn set_region_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_region_names(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether to display all Regions, including Regions that are disabled for your account.</p>
        pub fn all_regions(mut self, input: bool) -> Self {
            self.inner = self.inner.all_regions(input);
            self
        }
        pub fn set_all_regions(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_all_regions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReplaceRootVolumeTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_replace_root_volume_tasks_input::Builder,
    }
    impl<C> DescribeReplaceRootVolumeTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReplaceRootVolumeTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeReplaceRootVolumeTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the root volume replacement task to view.</p>
        pub fn replace_root_volume_task_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.replace_root_volume_task_ids(inp);
            self
        }
        pub fn set_replace_root_volume_task_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_replace_root_volume_task_ids(input);
            self
        }
        /// <p>Filter to use:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance for which the root volume replacement task was created.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call. To retrieve the remaining results,
        /// make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservedInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reserved_instances_input::Builder,
    }
    impl<C> DescribeReservedInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReservedInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeReservedInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>duration</code> - The duration of the Reserved Instance (one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>end</code> - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type that is covered by the reservation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>scope</code> - The scope of the Reserved Instance (<code>Region</code> or <code>Availability Zone</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-description</code> - The Reserved Instance product platform
        /// description. Instances that include <code>(Amazon VPC)</code> in the product platform
        /// description will only be displayed to EC2-Classic account holders and are for use with
        /// Amazon VPC (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE
        /// Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise
        /// Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Red Hat
        /// Enterprise Linux with HA (Amazon VPC)</code> | <code>Windows</code> | <code>Windows
        /// (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with
        /// SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> |
        /// <code>Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server
        /// Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon
        /// VPC)</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reserved-instances-id</code> - The ID of the Reserved Instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>start</code> - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the Reserved Instance (<code>payment-pending</code> | <code>active</code> | <code>payment-failed</code> | <code>retired</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Describes whether the Reserved Instance is Standard or Convertible.</p>
        pub fn offering_class(mut self, input: crate::model::OfferingClassType) -> Self {
            self.inner = self.inner.offering_class(input);
            self
        }
        pub fn set_offering_class(
            mut self,
            input: std::option::Option<crate::model::OfferingClassType>,
        ) -> Self {
            self.inner = self.inner.set_offering_class(input);
            self
        }
        /// <p>One or more Reserved Instance IDs.</p>
        /// <p>Default: Describes all your Reserved Instances, or only those otherwise specified.</p>
        pub fn reserved_instances_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instances_ids(inp);
            self
        }
        pub fn set_reserved_instances_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API
        /// version, you only have access to the <code>Medium Utilization</code> Reserved Instance
        /// offering type.</p>
        pub fn offering_type(mut self, input: crate::model::OfferingTypeValues) -> Self {
            self.inner = self.inner.offering_type(input);
            self
        }
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<crate::model::OfferingTypeValues>,
        ) -> Self {
            self.inner = self.inner.set_offering_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservedInstancesListings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reserved_instances_listings_input::Builder,
    }
    impl<C> DescribeReservedInstancesListings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReservedInstancesListingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeReservedInstancesListingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>reserved-instances-id</code> - The ID of the Reserved Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reserved-instances-listing-id</code> - The ID of the Reserved Instances listing.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code> - The status of the Reserved Instance listing (<code>pending</code> | <code>active</code> |
        /// <code>cancelled</code> | <code>closed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-message</code> - The reason for the status.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more Reserved Instance IDs.</p>
        pub fn reserved_instances_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instances_id(input);
            self
        }
        pub fn set_reserved_instances_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_id(input);
            self
        }
        /// <p>One or more Reserved Instance listing IDs.</p>
        pub fn reserved_instances_listing_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.reserved_instances_listing_id(input);
            self
        }
        pub fn set_reserved_instances_listing_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_listing_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservedInstancesModifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reserved_instances_modifications_input::Builder,
    }
    impl<C> DescribeReservedInstancesModifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReservedInstancesModificationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeReservedInstancesModificationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>client-token</code> - The idempotency token for the modification request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>create-date</code> - The time when the modification request was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>effective-date</code> - The time when the modification becomes effective.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modification-result.reserved-instances-id</code> - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is <code>fulfilled</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modification-result.target-configuration.availability-zone</code> - The Availability Zone for the new Reserved Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modification-result.target-configuration.instance-count </code> - The number of new Reserved Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modification-result.target-configuration.instance-type</code> - The instance type of the new Reserved Instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>modification-result.target-configuration.platform</code> - The network platform of the new Reserved Instances (<code>EC2-Classic</code> | <code>EC2-VPC</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reserved-instances-id</code> - The ID of the Reserved Instances modified.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reserved-instances-modification-id</code> - The ID of the modification request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code> - The status of the Reserved Instances modification request
        /// (<code>processing</code> | <code>fulfilled</code> | <code>failed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-message</code> - The reason for the status.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>update-date</code> - The time when the modification request was last updated.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>IDs for the submitted modification request.</p>
        pub fn reserved_instances_modification_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.reserved_instances_modification_ids(inp);
            self
        }
        pub fn set_reserved_instances_modification_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_modification_ids(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeReservedInstancesOfferings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_reserved_instances_offerings_input::Builder,
    }
    impl<C> DescribeReservedInstancesOfferings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeReservedInstancesOfferingsOutput,
            smithy_http::result::SdkError<crate::error::DescribeReservedInstancesOfferingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Availability Zone in which the Reserved Instance can be used.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be
        /// used.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>duration</code> - The duration of the Reserved Instance (for example, one year or
        /// three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fixed-price</code> - The purchase price of the Reserved Instance (for example,
        /// 9800.0).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type that is covered by the
        /// reservation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>marketplace</code> - Set to <code>true</code> to show only Reserved Instance
        /// Marketplace offerings. When this filter is not used, which is the default behavior, all
        /// offerings from both Amazon Web Services and the Reserved Instance Marketplace are listed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-description</code> - The Reserved Instance product platform description.
        /// Instances that include <code>(Amazon VPC)</code> in the product platform description will
        /// only be displayed to EC2-Classic account holders and are for use with Amazon VPC.
        /// (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE
        /// Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise
        /// Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Red Hat
        /// Enterprise Linux with HA (Amazon VPC)</code> | <code>Windows</code> | <code>Windows
        /// (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with
        /// SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> |
        /// <code> Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server
        /// Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>) </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>reserved-instances-offering-id</code> - The Reserved Instances offering
        /// ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>scope</code> - The scope of the Reserved Instance (<code>Availability Zone</code> or
        /// <code>Region</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for
        /// example, 0.84).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Include Reserved Instance Marketplace offerings in the response.</p>
        pub fn include_marketplace(mut self, input: bool) -> Self {
            self.inner = self.inner.include_marketplace(input);
            self
        }
        pub fn set_include_marketplace(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_marketplace(input);
            self
        }
        /// <p>The instance type that the reservation will cover (for example, <code>m1.small</code>). For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>The maximum duration (in seconds) to filter when searching for offerings.</p>
        /// <p>Default: 94608000 (3 years)</p>
        pub fn max_duration(mut self, input: i64) -> Self {
            self.inner = self.inner.max_duration(input);
            self
        }
        pub fn set_max_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_max_duration(input);
            self
        }
        /// <p>The maximum number of instances to filter when searching for offerings.</p>
        /// <p>Default: 20</p>
        pub fn max_instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.max_instance_count(input);
            self
        }
        pub fn set_max_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_instance_count(input);
            self
        }
        /// <p>The minimum duration (in seconds) to filter when searching for offerings.</p>
        /// <p>Default: 2592000 (1 month)</p>
        pub fn min_duration(mut self, input: i64) -> Self {
            self.inner = self.inner.min_duration(input);
            self
        }
        pub fn set_min_duration(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_min_duration(input);
            self
        }
        /// <p>The offering class of the Reserved Instance. Can be <code>standard</code> or <code>convertible</code>.</p>
        pub fn offering_class(mut self, input: crate::model::OfferingClassType) -> Self {
            self.inner = self.inner.offering_class(input);
            self
        }
        pub fn set_offering_class(
            mut self,
            input: std::option::Option<crate::model::OfferingClassType>,
        ) -> Self {
            self.inner = self.inner.set_offering_class(input);
            self
        }
        /// <p>The Reserved Instance product platform description. Instances that include <code>(Amazon
        /// VPC)</code> in the description are for use with Amazon VPC.</p>
        pub fn product_description(mut self, input: crate::model::RiProductDescription) -> Self {
            self.inner = self.inner.product_description(input);
            self
        }
        pub fn set_product_description(
            mut self,
            input: std::option::Option<crate::model::RiProductDescription>,
        ) -> Self {
            self.inner = self.inner.set_product_description(input);
            self
        }
        /// <p>One or more Reserved Instances offering IDs.</p>
        pub fn reserved_instances_offering_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.reserved_instances_offering_ids(inp);
            self
        }
        pub fn set_reserved_instances_offering_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_offering_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy
        /// of <code>dedicated</code> is applied to instances that run in a VPC on single-tenant hardware
        /// (i.e., Dedicated Instances).</p>
        /// <p>
        /// <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p>
        /// <p>Default: <code>default</code>
        /// </p>
        pub fn instance_tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.inner = self.inner.instance_tenancy(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::Tenancy>,
        ) -> Self {
            self.inner = self.inner.set_instance_tenancy(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining
        /// results of the initial request can be seen by sending another request with the returned
        /// <code>NextToken</code> value. The maximum is 100.</p>
        /// <p>Default: 100</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API
        /// version, you only have access to the <code>Medium Utilization</code> Reserved Instance
        /// offering type. </p>
        pub fn offering_type(mut self, input: crate::model::OfferingTypeValues) -> Self {
            self.inner = self.inner.offering_type(input);
            self
        }
        pub fn set_offering_type(
            mut self,
            input: std::option::Option<crate::model::OfferingTypeValues>,
        ) -> Self {
            self.inner = self.inner.set_offering_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeRouteTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_route_tables_input::Builder,
    }
    impl<C> DescribeRouteTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeRouteTablesOutput,
            smithy_http::result::SdkError<crate::error::DescribeRouteTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>association.route-table-association-id</code> - The ID of an association
        /// ID for the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.route-table-id</code> - The ID of the route table involved in
        /// the association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.subnet-id</code> - The ID of the subnet involved in the
        /// association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.main</code> - Indicates whether the route table is the main
        /// route table for the VPC (<code>true</code> | <code>false</code>). Route tables
        /// that do not have an association ID are not returned in the response.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-table-id</code> - The ID of the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.destination-cidr-block</code> - The IPv4 CIDR range specified in a
        /// route in the table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.destination-ipv6-cidr-block</code> - The IPv6 CIDR range specified in a route in the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.destination-prefix-list-id</code> - The ID (prefix) of the AWS
        /// service specified in a route in the table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.egress-only-internet-gateway-id</code> - The ID of an
        /// egress-only Internet gateway specified in a route in the route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.gateway-id</code> - The ID of a gateway specified in a route in the table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.instance-id</code> - The ID of an instance specified in a route in the table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.nat-gateway-id</code> - The ID of a NAT gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.transit-gateway-id</code> - The ID of a transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.origin</code> - Describes how the route was created.
        /// <code>CreateRouteTable</code> indicates that the route was automatically
        /// created when the route table was created; <code>CreateRoute</code> indicates
        /// that the route was manually added to the route table;
        /// <code>EnableVgwRoutePropagation</code> indicates that the route was
        /// propagated by route propagation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.state</code> - The state of a route in the route table
        /// (<code>active</code> | <code>blackhole</code>). The blackhole state
        /// indicates that the route's target isn't available (for example, the specified
        /// gateway isn't attached to the VPC, the specified NAT instance has been
        /// terminated, and so on).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.vpc-peering-connection-id</code> - The ID of a VPC peering
        /// connection specified in a route in the table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC for the route table.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more route table IDs.</p>
        /// <p>Default: Describes all your route tables.</p>
        pub fn route_table_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_ids(inp);
            self
        }
        pub fn set_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_route_table_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScheduledInstanceAvailability<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scheduled_instance_availability_input::Builder,
    }
    impl<C> DescribeScheduledInstanceAvailability<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScheduledInstanceAvailabilityOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduledInstanceAvailabilityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The time period for the first schedule to start.</p>
        pub fn first_slot_start_time_range(
            mut self,
            input: crate::model::SlotDateTimeRangeRequest,
        ) -> Self {
            self.inner = self.inner.first_slot_start_time_range(input);
            self
        }
        pub fn set_first_slot_start_time_range(
            mut self,
            input: std::option::Option<crate::model::SlotDateTimeRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_first_slot_start_time_range(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.
        /// This value can be between 5 and 300. The default value is 300.
        /// To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The maximum available duration, in hours. This value must be greater than <code>MinSlotDurationInHours</code>
        /// and less than 1,720.</p>
        pub fn max_slot_duration_in_hours(mut self, input: i32) -> Self {
            self.inner = self.inner.max_slot_duration_in_hours(input);
            self
        }
        pub fn set_max_slot_duration_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_slot_duration_in_hours(input);
            self
        }
        /// <p>The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.</p>
        pub fn min_slot_duration_in_hours(mut self, input: i32) -> Self {
            self.inner = self.inner.min_slot_duration_in_hours(input);
            self
        }
        pub fn set_min_slot_duration_in_hours(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_slot_duration_in_hours(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The schedule recurrence.</p>
        pub fn recurrence(
            mut self,
            input: crate::model::ScheduledInstanceRecurrenceRequest,
        ) -> Self {
            self.inner = self.inner.recurrence(input);
            self
        }
        pub fn set_recurrence(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstanceRecurrenceRequest>,
        ) -> Self {
            self.inner = self.inner.set_recurrence(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScheduledInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scheduled_instances_input::Builder,
    }
    impl<C> DescribeScheduledInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScheduledInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduledInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.
        /// This value can be between 5 and 300. The default value is 100.
        /// To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The Scheduled Instance IDs.</p>
        pub fn scheduled_instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_instance_ids(inp);
            self
        }
        pub fn set_scheduled_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_instance_ids(input);
            self
        }
        /// <p>The time period for the first schedule to start.</p>
        pub fn slot_start_time_range(
            mut self,
            input: crate::model::SlotStartTimeRangeRequest,
        ) -> Self {
            self.inner = self.inner.slot_start_time_range(input);
            self
        }
        pub fn set_slot_start_time_range(
            mut self,
            input: std::option::Option<crate::model::SlotStartTimeRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_slot_start_time_range(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecurityGroupReferences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_security_group_references_input::Builder,
    }
    impl<C> DescribeSecurityGroupReferences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecurityGroupReferencesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecurityGroupReferencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the security groups in your account.</p>
        pub fn group_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(inp);
            self
        }
        pub fn set_group_id(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_security_groups_input::Builder,
    }
    impl<C> DescribeSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code> - The description of the security group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.cidr</code> - An IPv4 CIDR block for an outbound
        /// security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.from-port</code> - For an outbound rule, the
        /// start of port range for the TCP and UDP protocols, or an ICMP type
        /// number.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.group-id</code> - The ID of a security group
        /// that has been referenced in an outbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.group-name</code> - The name of a security group
        /// that is referenced in an outbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.ipv6-cidr</code> - An IPv6 CIDR block for an
        /// outbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.prefix-list-id</code> - The ID of a prefix list to which a security group rule allows outbound access.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.protocol</code> - The IP protocol for an
        /// outbound security group rule (<code>tcp</code> | <code>udp</code> |
        /// <code>icmp</code>, a protocol number, or -1 for all protocols).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.to-port</code> - For an outbound rule, the end
        /// of port range for the TCP and UDP protocols, or an ICMP code.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>egress.ip-permission.user-id</code> - The ID of an AWS account that
        /// has been referenced in an outbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-id</code> - The ID of the security group. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>group-name</code> - The name of the security group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.cidr</code> - An IPv4 CIDR block for an inbound security
        /// group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.from-port</code> - For an inbound rule, the start of port
        /// range for the TCP and UDP protocols, or an ICMP type number.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.group-id</code> - The ID of a security group that has been
        /// referenced in an inbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.group-name</code> - The name of a security group that is
        /// referenced in an inbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.ipv6-cidr</code> - An IPv6 CIDR block for an inbound security
        /// group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.prefix-list-id</code> - The ID of a prefix list from which a security group rule allows inbound access.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.protocol</code> - The IP protocol for an inbound security
        /// group rule (<code>tcp</code> | <code>udp</code> | <code>icmp</code>, a
        /// protocol number, or -1 for all protocols).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.to-port</code> - For an inbound rule, the end of port range
        /// for the TCP and UDP protocols, or an ICMP code.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ip-permission.user-id</code> - The ID of an AWS account that has been
        /// referenced in an inbound security group rule.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The AWS account ID of the owner of the security group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC specified when the security group was created.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The IDs of the security groups. Required for security groups in a nondefault VPC.</p>
        /// <p>Default: Describes all your security groups.</p>
        pub fn group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ids(inp);
            self
        }
        pub fn set_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_ids(input);
            self
        }
        /// <p>[EC2-Classic and default VPC only] The names of the security groups. You can specify either
        /// the security group name or the security group ID. For security groups in a nondefault VPC, use
        /// the <code>group-name</code> filter to describe security groups by name.</p>
        /// <p>Default: Describes all your security groups.</p>
        pub fn group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_names(inp);
            self
        }
        pub fn set_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_names(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another request with the returned <code>NextToken</code> value. This value
        /// can be between 5 and 1000. If this parameter is not specified, then all results are
        /// returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSnapshotAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_snapshot_attribute_input::Builder,
    }
    impl<C> DescribeSnapshotAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSnapshotAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeSnapshotAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The snapshot attribute you would like to view.</p>
        pub fn attribute(mut self, input: crate::model::SnapshotAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::SnapshotAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the EBS snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSnapshots<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_snapshots_input::Builder,
    }
    impl<C> DescribeSnapshots<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSnapshotsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSnapshotsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code> - A description of the snapshot.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>encrypted</code> - Indicates whether the snapshot is encrypted
        /// (<code>true</code> | <code>false</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-alias</code> - The owner alias, from an Amazon-maintained list  
        /// (<code>amazon</code>).
        /// This is not the user-configured AWS account alias set using the IAM console.
        /// We recommend that you use the related parameter instead of this filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The AWS account ID of the owner. We recommend that
        /// you use the related parameter instead of this filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>progress</code> - The progress of the snapshot, as a percentage (for example,
        /// 80%).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>snapshot-id</code> - The snapshot ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>start-time</code> - The time stamp when the snapshot was initiated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code> - The status of the snapshot (<code>pending</code> |
        /// <code>completed</code> | <code>error</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-id</code> - The ID of the volume the snapshot is for.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-size</code> - The size of the volume, in GiB.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of snapshot results returned by <code>DescribeSnapshots</code> in
        /// paginated output. When this parameter is used, <code>DescribeSnapshots</code> only returns
        /// <code>MaxResults</code> results in a single page along with a <code>NextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending another
        /// <code>DescribeSnapshots</code> request with the returned <code>NextToken</code> value. This
        /// value can be between 5 and 1,000; if <code>MaxResults</code> is given a value larger than 1,000,
        /// only 1,000 results are returned. If this parameter is not used, then
        /// <code>DescribeSnapshots</code> returns all results. You cannot specify this parameter and
        /// the snapshot IDs parameter in the same request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>NextToken</code> value returned from a previous paginated
        /// <code>DescribeSnapshots</code> request where <code>MaxResults</code> was used and the
        /// results exceeded the value of that parameter. Pagination continues from the end of the
        /// previous results that returned the <code>NextToken</code> value. This value is
        /// <code>null</code> when there are no more results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Scopes the results to snapshots with the specified owners. You can specify a combination of
        /// AWS account IDs, <code>self</code>, and <code>amazon</code>.</p>
        pub fn owner_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner_ids(inp);
            self
        }
        pub fn set_owner_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_owner_ids(input);
            self
        }
        /// <p>The IDs of the AWS accounts that can create volumes from the snapshot.</p>
        pub fn restorable_by_user_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.restorable_by_user_ids(inp);
            self
        }
        pub fn set_restorable_by_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_restorable_by_user_ids(input);
            self
        }
        /// <p>The snapshot IDs.</p>
        /// <p>Default: Describes the snapshots for which you have create volume permissions.</p>
        pub fn snapshot_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_ids(inp);
            self
        }
        pub fn set_snapshot_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_snapshot_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotDatafeedSubscription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_datafeed_subscription_input::Builder,
    }
    impl<C> DescribeSpotDatafeedSubscription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotDatafeedSubscriptionOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotDatafeedSubscriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotFleetInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_fleet_instances_input::Builder,
    }
    impl<C> DescribeSpotFleetInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotFleetInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotFleetInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1
        /// and 1000. The default value is 1000. To retrieve the remaining results, make another
        /// call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_fleet_request_id(input);
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotFleetRequestHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_fleet_request_history_input::Builder,
    }
    impl<C> DescribeSpotFleetRequestHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotFleetRequestHistoryOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotFleetRequestHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The type of events to describe. By default, all events are described.</p>
        pub fn event_type(mut self, input: crate::model::EventType) -> Self {
            self.inner = self.inner.event_type(input);
            self
        }
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::EventType>,
        ) -> Self {
            self.inner = self.inner.set_event_type(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1
        /// and 1000. The default value is 1000. To retrieve the remaining results, make another
        /// call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_fleet_request_id(input);
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_id(input);
            self
        }
        /// <p>The starting date and time for the events, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotFleetRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_fleet_requests_input::Builder,
    }
    impl<C> DescribeSpotFleetRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotFleetRequestsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotFleetRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1
        /// and 1000. The default value is 1000. To retrieve the remaining results, make another
        /// call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The IDs of the Spot Fleet requests.</p>
        pub fn spot_fleet_request_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_fleet_request_ids(inp);
            self
        }
        pub fn set_spot_fleet_request_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotInstanceRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_instance_requests_input::Builder,
    }
    impl<C> DescribeSpotInstanceRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotInstanceRequestsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotInstanceRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone-group</code> - The Availability Zone group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>create-time</code> - The time stamp when the Spot Instance request was
        /// created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fault-code</code> - The fault code related to the request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fault-message</code> - The fault message related to the request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-id</code> - The ID of the instance that fulfilled the
        /// request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch-group</code> - The Spot Instance launch group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.block-device-mapping.delete-on-termination</code> - Indicates
        /// whether the EBS volume is deleted on instance termination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.block-device-mapping.device-name</code> - The device name for the
        /// volume in the block device mapping (for example, <code>/dev/sdh</code> or
        /// <code>xvdh</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.block-device-mapping.snapshot-id</code> - The ID of the snapshot
        /// for the EBS volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.block-device-mapping.volume-size</code> - The size of the EBS
        /// volume, in GiB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.block-device-mapping.volume-type</code> - The type of EBS volume:
        /// <code>gp2</code> for General Purpose SSD, <code>io1</code> or
        /// <code>io2</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput
        /// Optimized HDD, <code>sc1</code>for Cold HDD, or <code>standard</code> for
        /// Magnetic.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.group-id</code> - The ID of the security group for the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.group-name</code> - The name of the security group for the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.image-id</code> - The ID of the AMI.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.instance-type</code> - The type of instance (for example,
        /// <code>m3.medium</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.kernel-id</code> - The kernel ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.key-name</code> - The name of the key pair the instance launched
        /// with.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.monitoring-enabled</code> - Whether detailed monitoring is
        /// enabled for the Spot Instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launch.ramdisk-id</code> - The RAM disk ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>launched-availability-zone</code> - The Availability Zone in which the
        /// request is launched.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.addresses.primary</code> - Indicates whether the IP
        /// address is the primary private IP address.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.delete-on-termination</code> - Indicates whether the
        /// network interface is deleted when the instance is terminated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.description</code> - A description of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.device-index</code> - The index of the device for the
        /// network interface attachment on the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.group-id</code> - The ID of the security group
        /// associated with the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.network-interface-id</code> - The ID of the network
        /// interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.private-ip-address</code> - The primary private IP
        /// address of the network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface.subnet-id</code> - The ID of the subnet for the
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-description</code> - The product description associated with the
        /// instance (<code>Linux/UNIX</code> | <code>Windows</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spot-instance-request-id</code> - The Spot Instance request ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spot-price</code> - The maximum hourly price for any Spot Instance
        /// launched to fulfill the request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the Spot Instance request (<code>open</code>
        /// | <code>active</code> | <code>closed</code> | <code>cancelled</code> |
        /// <code>failed</code>). Spot request status information can help you track
        /// your Amazon EC2 Spot Instance requests. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot
        /// request status</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-code</code> - The short code describing the most recent
        /// evaluation of your Spot Instance request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-message</code> - The message explaining the status of the Spot
        /// Instance request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of Spot Instance request (<code>one-time</code> |
        /// <code>persistent</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>valid-from</code> - The start date of the request.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>valid-until</code> - The end date of the request.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more Spot Instance request IDs.</p>
        pub fn spot_instance_request_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_instance_request_ids(inp);
            self
        }
        pub fn set_spot_instance_request_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_spot_instance_request_ids(input);
            self
        }
        /// <p>The token to request the next set of results. This value is <code>null</code> when
        /// there are no more results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 5
        /// and 1000. To retrieve the remaining results, make another call with the returned
        /// <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSpotPriceHistory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_spot_price_history_input::Builder,
    }
    impl<C> DescribeSpotPriceHistory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSpotPriceHistoryOutput,
            smithy_http::result::SdkError<crate::error::DescribeSpotPriceHistoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone for which prices should
        /// be returned.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>instance-type</code> - The type of instance (for example,
        /// <code>m3.medium</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>product-description</code> - The product description for the Spot price
        /// (<code>Linux/UNIX</code> | <code>Red Hat Enterprise Linux</code> |
        /// <code>SUSE Linux</code> | <code>Windows</code> | <code>Linux/UNIX (Amazon
        /// VPC)</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> |
        /// <code>SUSE Linux (Amazon VPC)</code> | <code>Windows (Amazon
        /// VPC)</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>spot-price</code> - The Spot price. The value must match exactly (or use
        /// wildcards; greater than or less than comparison is not supported).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>timestamp</code> - The time stamp of the Spot price history, in UTC format
        /// (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).
        /// You can use wildcards (* and ?). Greater than or less than comparison is not
        /// supported.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Filters the results by the specified Availability Zone.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The date and time, up to the current date, from which to stop retrieving the price
        /// history data, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>Filters the results by the specified instance types.</p>
        pub fn instance_types(mut self, inp: impl Into<crate::model::InstanceType>) -> Self {
            self.inner = self.inner.instance_types(inp);
            self
        }
        pub fn set_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceType>>,
        ) -> Self {
            self.inner = self.inner.set_instance_types(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. Specify a value between 1
        /// and 1000. The default value is 1000. To retrieve the remaining results, make another
        /// call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Filters the results by the specified basic product descriptions.</p>
        pub fn product_descriptions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_descriptions(inp);
            self
        }
        pub fn set_product_descriptions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_product_descriptions(input);
            self
        }
        /// <p>The date and time, up to the past 90 days, from which to start retrieving the price
        /// history data, in UTC format (for example,
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStaleSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_stale_security_groups_input::Builder,
    }
    impl<C> DescribeStaleSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStaleSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeStaleSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeStoreImageTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_store_image_tasks_input::Builder,
    }
    impl<C> DescribeStoreImageTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeStoreImageTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeStoreImageTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AMI IDs for which to show progress. Up to 20 AMI IDs can be included in a request.</p>
        pub fn image_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_ids(inp);
            self
        }
        pub fn set_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_image_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>task-state</code> - Returns tasks in a certain state (<code>InProgress</code> |
        /// <code>Completed</code> | <code>Failed</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>bucket</code> - Returns task information for tasks that targeted a specific
        /// bucket. For the filter value, specify the bucket name.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another call with the returned <code>NextToken</code> value. This value can be
        /// between 1 and 200. You cannot specify this parameter and the <code>ImageIDs</code> parameter
        /// in the same call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSubnets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_subnets_input::Builder,
    }
    impl<C> DescribeSubnets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSubnetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeSubnetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone for the subnet. You can also use
        /// <code>availabilityZone</code> as the filter name.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone-id</code> - The ID of the Availability Zone for the subnet.
        /// You can also use <code>availabilityZoneId</code> as the filter name.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>available-ip-address-count</code> - The number of IPv4 addresses in the
        /// subnet that are available.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cidr-block</code> - The IPv4 CIDR block of the subnet. The CIDR block you
        /// specify must exactly match the subnet's CIDR block for information to be
        /// returned for the subnet. You can also use <code>cidr</code> or
        /// <code>cidrBlock</code> as the filter names.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>default-for-az</code> - Indicates whether this is the default subnet for the
        /// Availability Zone. You can also use <code>defaultForAz</code> as the filter name.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR
        /// block associated with the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.association-id</code> - An association ID
        /// for an IPv6 CIDR block associated with the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR
        /// block associated with the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>outpost-arn</code> - The Amazon Resource Name (ARN) of the Outpost.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the subnet (<code>pending</code> | <code>available</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-arn</code> - The Amazon Resource Name (ARN) of the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC for the subnet.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more subnet IDs.</p>
        /// <p>Default: Describes all your subnets.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C> DescribeTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>key</code> - The tag key.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The resource type (<code>customer-gateway</code> | <code>dedicated-host</code> | <code>dhcp-options</code> | <code>elastic-ip</code> | <code>fleet</code> | <code>fpga-image</code> | <code>host-reservation</code> | <code>image</code> | <code>instance</code> | <code>internet-gateway</code> | <code>key-pair</code> | <code>launch-template</code> | <code>natgateway</code> | <code>network-acl</code> | <code>network-interface</code> | <code>placement-group</code> | <code>reserved-instances</code> | <code>route-table</code> | <code>security-group</code> | <code>snapshot</code> | <code>spot-instances-request</code> | <code>subnet</code> | <code>volume</code> | <code>vpc</code> | <code>vpc-endpoint</code> | <code>vpc-endpoint-service</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of the tag. For example,
        /// specify "tag:Owner" for the filter name and "TeamA" for the filter value to find
        /// resources with the tag "Owner=TeamA".</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>value</code> - The tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in a single call.
        /// This value can be between 5 and 1000.
        /// To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTrafficMirrorFilters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_traffic_mirror_filters_input::Builder,
    }
    impl<C> DescribeTrafficMirrorFilters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrafficMirrorFiltersOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrafficMirrorFiltersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_ids(inp);
            self
        }
        pub fn set_traffic_mirror_filter_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code>: The Traffic Mirror filter description.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-mirror-filter-id</code>: The ID of the Traffic Mirror filter.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTrafficMirrorSessions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_traffic_mirror_sessions_input::Builder,
    }
    impl<C> DescribeTrafficMirrorSessions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrafficMirrorSessionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrafficMirrorSessionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror session.</p>
        pub fn traffic_mirror_session_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_session_ids(inp);
            self
        }
        pub fn set_traffic_mirror_session_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_session_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code>: The Traffic Mirror session description.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-id</code>: The ID of the Traffic Mirror session network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code>: The ID of the account that owns the Traffic Mirror session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>packet-length</code>: The assigned number of packets to mirror. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>session-number</code>: The assigned session number. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-mirror-filter-id</code>: The ID of the Traffic Mirror filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-mirror-session-id</code>: The ID of the Traffic Mirror session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-mirror-target-id</code>: The ID of the Traffic Mirror target.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>virtual-network-id</code>: The virtual network ID of the Traffic Mirror session.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTrafficMirrorTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_traffic_mirror_targets_input::Builder,
    }
    impl<C> DescribeTrafficMirrorTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrafficMirrorTargetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrafficMirrorTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror targets.</p>
        pub fn traffic_mirror_target_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_target_ids(inp);
            self
        }
        pub fn set_traffic_mirror_target_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_target_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>description</code>: The Traffic Mirror target description.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-interface-id</code>: The ID of the Traffic Mirror session network interface.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>network-load-balancer-arn</code>: The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code>: The ID of the account that owns the Traffic Mirror session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>traffic-mirror-target-id</code>: The ID of the Traffic Mirror target.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayAttachments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_attachments_input::Builder,
    }
    impl<C> DescribeTransitGatewayAttachments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayAttachmentsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewayAttachmentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the attachments.</p>
        pub fn transit_gateway_attachment_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_ids(inp);
            self
        }
        pub fn set_transit_gateway_attachment_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>association.state</code> - The state of the association (<code>associating</code> | <code>associated</code> |
        /// <code>disassociating</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>association.transit-gateway-route-table-id</code> - The ID of the route table for the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-owner-id</code> - The ID of the AWS account that owns the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The resource type. Valid values are <code>vpc</code>
        /// | <code>vpn</code> | <code>direct-connect-gateway</code> | <code>peering</code>
        /// | <code>connect</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the attachment. Valid values are <code>available</code> | <code>deleted</code> | <code>deleting</code> | <code>failed</code> |  <code>failing</code> | <code>initiatingRequest</code> | <code>modifying</code> | <code>pendingAcceptance</code> | <code>pending</code> | <code>rollingBack</code> | <code>rejected</code> | <code>rejecting</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-owner-id</code> - The ID of the AWS account that owns the transit gateway.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayConnectPeers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_connect_peers_input::Builder,
    }
    impl<C> DescribeTransitGatewayConnectPeers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayConnectPeersOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewayConnectPeersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the Connect peers.</p>
        pub fn transit_gateway_connect_peer_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_connect_peer_ids(inp);
            self
        }
        pub fn set_transit_gateway_connect_peer_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_connect_peer_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the Connect peer (<code>pending</code> |
        /// <code>available</code> | <code>deleting</code> |
        /// <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-connect-peer-id</code> - The ID of the Connect peer.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayConnects<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_connects_input::Builder,
    }
    impl<C> DescribeTransitGatewayConnects<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayConnectsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewayConnectsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the attachments.</p>
        pub fn transit_gateway_attachment_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_ids(inp);
            self
        }
        pub fn set_transit_gateway_attachment_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>options.protocol</code> - The tunnel protocol (<code>gre</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the attachment (<code>initiating</code> |
        /// <code>initiatingRequest</code> | <code>pendingAcceptance</code> |
        /// <code>rollingBack</code> | <code>pending</code> | <code>available</code> |
        /// <code>modifying</code> | <code>deleting</code> | <code>deleted</code> |
        /// <code>failed</code> | <code>rejected</code> | <code>rejecting</code> |
        /// <code>failing</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the
        /// Connect attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transport-transit-gateway-attachment-id</code> - The ID of the transit gateway attachment from which the Connect attachment was created.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayMulticastDomains<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_multicast_domains_input::Builder,
    }
    impl<C> DescribeTransitGatewayMulticastDomains<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayMulticastDomainsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeTransitGatewayMulticastDomainsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_ids(inp);
            self
        }
        pub fn set_transit_gateway_multicast_domain_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the transit gateway multicast domain. Valid values are <code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-multicast-domain-id</code> - The ID of the transit gateway multicast domain.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayPeeringAttachments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_peering_attachments_input::Builder,
    }
    impl<C> DescribeTransitGatewayPeeringAttachments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayPeeringAttachmentsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeTransitGatewayPeeringAttachmentsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more IDs of the transit gateway peering attachments.</p>
        pub fn transit_gateway_attachment_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_ids(inp);
            self
        }
        pub fn set_transit_gateway_attachment_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the transit gateway attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>local-owner-id</code> - The ID of your AWS account.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>remote-owner-id</code> - The ID of the AWS account in the remote Region that owns the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the peering attachment. Valid values are <code>available</code> | <code>deleted</code> | <code>deleting</code> | <code>failed</code> |  <code>failing</code> | <code>initiatingRequest</code> | <code>modifying</code> | <code>pendingAcceptance</code> | <code>pending</code> | <code>rollingBack</code> | <code>rejected</code> | <code>rejecting</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources that have a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayRouteTables<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_route_tables_input::Builder,
    }
    impl<C> DescribeTransitGatewayRouteTables<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayRouteTablesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewayRouteTablesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the transit gateway route tables.</p>
        pub fn transit_gateway_route_table_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_ids(inp);
            self
        }
        pub fn set_transit_gateway_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>default-association-route-table</code> - Indicates whether this is the default
        /// association route table for the transit gateway (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>default-propagation-route-table</code> - Indicates whether this is the default
        /// propagation route table for the transit gateway (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the route table (<code>available</code> | <code>deleting</code> | <code>deleted</code> | <code>pending</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-route-table-id</code> - The ID of the transit gateway route table.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateways_input::Builder,
    }
    impl<C> DescribeTransitGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the transit gateways.</p>
        pub fn transit_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_ids(inp);
            self
        }
        pub fn set_transit_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>options.propagation-default-route-table-id</code> - The ID of the default propagation route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.amazon-side-asn</code> - The private ASN for the Amazon side of a BGP session.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.association-default-route-table-id</code> - The ID of the default association route table.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.auto-accept-shared-attachments</code> - Indicates whether there is automatic acceptance of attachment requests (<code>enable</code> | <code>disable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.default-route-table-association</code> - Indicates whether resource attachments are automatically
        /// associated with the default association route table (<code>enable</code> | <code>disable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.default-route-table-propagation</code> - Indicates whether resource attachments automatically propagate
        /// routes to the default propagation route table (<code>enable</code> | <code>disable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.dns-support</code> - Indicates whether DNS support is enabled (<code>enable</code> | <code>disable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>options.vpn-ecmp-support</code> - Indicates whether Equal Cost Multipath Protocol support is enabled  (<code>enable</code> | <code>disable</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the transit gateway (<code>available</code> | <code>deleted</code> | <code>deleting</code> | <code>modifying</code> | <code>pending</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTransitGatewayVpcAttachments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_transit_gateway_vpc_attachments_input::Builder,
    }
    impl<C> DescribeTransitGatewayVpcAttachments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTransitGatewayVpcAttachmentsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTransitGatewayVpcAttachmentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the attachments.</p>
        pub fn transit_gateway_attachment_ids(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_ids(inp);
            self
        }
        pub fn set_transit_gateway_attachment_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_ids(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the attachment. Valid values are <code>available</code> | <code>deleted</code> | <code>deleting</code> | <code>failed</code> |  <code>failing</code> | <code>initiatingRequest</code> | <code>modifying</code> | <code>pendingAcceptance</code> | <code>pending</code> | <code>rollingBack</code> | <code>rejected</code> | <code>rejecting</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of the transit gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTrunkInterfaceAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_trunk_interface_associations_input::Builder,
    }
    impl<C> DescribeTrunkInterfaceAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTrunkInterfaceAssociationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTrunkInterfaceAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the associations.</p>
        pub fn association_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_ids(inp);
            self
        }
        pub fn set_association_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_association_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gre-key</code> - The ID of a trunk interface association.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>interface-protocol</code> - The interface protocol. Valid values are <code>VLAN</code> and <code>GRE</code>.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVolumeAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_volume_attribute_input::Builder,
    }
    impl<C> DescribeVolumeAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVolumeAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeVolumeAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The attribute of the volume. This parameter is required.</p>
        pub fn attribute(mut self, input: crate::model::VolumeAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::VolumeAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVolumes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_volumes_input::Builder,
    }
    impl<C> DescribeVolumes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVolumesOutput,
            smithy_http::result::SdkError<crate::error::DescribeVolumesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>attachment.attach-time</code> - The time stamp when the attachment
        /// initiated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.delete-on-termination</code> - Whether the volume is deleted on
        /// instance termination.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.device</code> - The device name specified in the block device mapping
        /// (for example, <code>/dev/sda1</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.instance-id</code> - The ID of the instance the volume is attached
        /// to.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.status</code> - The attachment state (<code>attaching</code> |
        /// <code>attached</code> | <code>detaching</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone in which the volume was
        /// created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>create-time</code> - The time stamp when the volume was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>encrypted</code> - Indicates whether the volume is encrypted (<code>true</code>
        /// | <code>false</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>multi-attach-enabled</code> - Indicates whether the volume is enabled for Multi-Attach (<code>true</code>
        /// | <code>false</code>)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>fast-restored</code> - Indicates whether the volume was created from a
        /// snapshot that is enabled for fast snapshot restore (<code>true</code> |
        /// <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>size</code> - The size of the volume, in GiB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>snapshot-id</code> - The snapshot from which the volume was created.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status</code> - The state of the volume (<code>creating</code> |
        /// <code>available</code> | <code>in-use</code> | <code>deleting</code> |
        /// <code>deleted</code> | <code>error</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-id</code> - The volume ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-type</code> - The Amazon EBS volume type (<code>gp2</code> | <code>gp3</code> | <code>io1</code> | <code>io2</code> |
        /// <code>st1</code> | <code>sc1</code>| <code>standard</code>)</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The volume IDs.</p>
        pub fn volume_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_ids(inp);
            self
        }
        pub fn set_volume_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_volume_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of volume results returned by <code>DescribeVolumes</code> in paginated
        /// output. When this parameter is used, <code>DescribeVolumes</code> only returns
        /// <code>MaxResults</code> results in a single page along with a <code>NextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending another
        /// <code>DescribeVolumes</code> request with the returned <code>NextToken</code> value. This
        /// value can be between 5 and 500; if <code>MaxResults</code> is given a value larger than 500,
        /// only 500 results are returned. If this parameter is not used, then
        /// <code>DescribeVolumes</code> returns all results. You cannot specify this parameter and the
        /// volume IDs parameter in the same request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>NextToken</code> value returned from a previous paginated
        /// <code>DescribeVolumes</code> request where <code>MaxResults</code> was used and the results
        /// exceeded the value of that parameter. Pagination continues from the end of the previous
        /// results that returned the <code>NextToken</code> value. This value is <code>null</code> when
        /// there are no more results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVolumesModifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_volumes_modifications_input::Builder,
    }
    impl<C> DescribeVolumesModifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVolumesModificationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVolumesModificationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the volumes.</p>
        pub fn volume_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_ids(inp);
            self
        }
        pub fn set_volume_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_volume_ids(input);
            self
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>modification-state</code> - The current modification state (modifying |
        /// optimizing | completed | failed).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>original-iops</code> - The original IOPS rate of the volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>original-size</code> - The original size of the volume, in GiB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>original-volume-type</code> - The original volume type of the volume (standard |
        /// io1 | io2 | gp2 | sc1 | st1).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>originalMultiAttachEnabled</code> - Indicates whether Multi-Attach support was enabled (true | false).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>start-time</code> - The modification start time.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>target-iops</code> - The target IOPS rate of the volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>target-size</code> - The target size of the volume, in GiB.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>target-volume-type</code> - The target volume type of the volume (standard |
        /// io1 | io2 | gp2 | sc1 | st1).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>targetMultiAttachEnabled</code> - Indicates whether Multi-Attach support is to be enabled (true | false).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-id</code> - The ID of the volume.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned by a previous paginated request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results (up to a limit of 500) to be returned in a paginated
        /// request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVolumeStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_volume_status_input::Builder,
    }
    impl<C> DescribeVolumeStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVolumeStatusOutput,
            smithy_http::result::SdkError<crate::error::DescribeVolumeStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>action.code</code> - The action code for the event (for example,
        /// <code>enable-volume-io</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>action.description</code> - A description of the action.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>action.event-id</code> - The event ID associated with the action.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone of the instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.description</code> - A description of the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.event-id</code> - The event ID.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.event-type</code> - The event type (for <code>io-enabled</code>:
        /// <code>passed</code> | <code>failed</code>; for <code>io-performance</code>:
        /// <code>io-performance:degraded</code> | <code>io-performance:severely-degraded</code> |
        /// <code>io-performance:stalled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.not-after</code> - The latest end time for the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>event.not-before</code> - The earliest start time for the event.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-status.details-name</code> - The cause for
        /// <code>volume-status.status</code> (<code>io-enabled</code> |
        /// <code>io-performance</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-status.details-status</code> - The status of
        /// <code>volume-status.details-name</code> (for <code>io-enabled</code>:
        /// <code>passed</code> | <code>failed</code>; for <code>io-performance</code>:
        /// <code>normal</code> | <code>degraded</code> | <code>severely-degraded</code> |
        /// <code>stalled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>volume-status.status</code> - The status of the volume (<code>ok</code> |
        /// <code>impaired</code> | <code>warning</code> | <code>insufficient-data</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of volume results returned by <code>DescribeVolumeStatus</code> in
        /// paginated output. When this parameter is used, the request only returns
        /// <code>MaxResults</code> results in a single page along with a <code>NextToken</code>
        /// response element. The remaining results of the initial request can be seen by sending another
        /// request with the returned <code>NextToken</code> value. This value can be between 5 and 1,000;
        /// if <code>MaxResults</code> is given a value larger than 1,000, only 1,000 results are returned.
        /// If this parameter is not used, then <code>DescribeVolumeStatus</code> returns all results. You
        /// cannot specify this parameter and the volume IDs parameter in the same request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumeStatus</code>
        /// request. When the results of the request exceed <code>MaxResults</code>, this value can be
        /// used to retrieve the next page of results. This value is <code>null</code> when there are no
        /// more results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The IDs of the volumes.</p>
        /// <p>Default: Describes all your volumes.</p>
        pub fn volume_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_ids(inp);
            self
        }
        pub fn set_volume_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_volume_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_attribute_input::Builder,
    }
    impl<C> DescribeVpcAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcAttributeOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The VPC attribute.</p>
        pub fn attribute(mut self, input: crate::model::VpcAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::VpcAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcClassicLink<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_classic_link_input::Builder,
    }
    impl<C> DescribeVpcClassicLink<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcClassicLinkOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcClassicLinkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>is-classic-link-enabled</code> - Whether the VPC is enabled for ClassicLink
        /// (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more VPCs for which you want to describe the ClassicLink status.</p>
        pub fn vpc_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_ids(inp);
            self
        }
        pub fn set_vpc_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcClassicLinkDnsSupport<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_classic_link_dns_support_input::Builder,
    }
    impl<C> DescribeVpcClassicLinkDnsSupport<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcClassicLinkDnsSupportOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcClassicLinkDnsSupportError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>One or more VPC IDs.</p>
        pub fn vpc_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_ids(inp);
            self
        }
        pub fn set_vpc_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpointConnectionNotifications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoint_connection_notifications_input::Builder,
    }
    impl<C> DescribeVpcEndpointConnectionNotifications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointConnectionNotificationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeVpcEndpointConnectionNotificationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the notification.</p>
        pub fn connection_notification_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_notification_id(input);
            self
        }
        pub fn set_connection_notification_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_notification_id(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>connection-notification-arn</code> - The ARN of the SNS topic for the
        /// notification.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>connection-notification-id</code> - The ID of the
        /// notification.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>connection-notification-state</code> - The state of the notification
        /// (<code>Enabled</code> | <code>Disabled</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>connection-notification-type</code> - The type of notification
        /// (<code>Topic</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>service-id</code> - The ID of the endpoint service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-id</code> - The ID of the VPC endpoint.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return in a single call. To retrieve the remaining
        /// results, make another request with the returned <code>NextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpointConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoint_connections_input::Builder,
    }
    impl<C> DescribeVpcEndpointConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcEndpointConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>service-id</code> - The ID of the service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-owner</code> - The AWS account number of the owner of the
        /// endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-state</code> - The state of the endpoint
        /// (<code>pendingAcceptance</code> | <code>pending</code> |
        /// <code>available</code> | <code>deleting</code> | <code>deleted</code> |
        /// <code>rejected</code> | <code>failed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-id</code> - The ID of the endpoint.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining
        /// results of the initial request can be seen by sending another request with the returned
        /// <code>NextToken</code> value. This value can be between 5 and 1,000; if
        /// <code>MaxResults</code> is given a value larger than 1,000, only 1,000 results are
        /// returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoints_input::Builder,
    }
    impl<C> DescribeVpcEndpoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcEndpointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more endpoint IDs.</p>
        pub fn vpc_endpoint_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_ids(inp);
            self
        }
        pub fn set_vpc_endpoint_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>service-name</code> - The name of the service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC in which the endpoint resides.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-id</code> - The ID of the endpoint.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-state</code> - The state of the endpoint
        /// (<code>pendingAcceptance</code> | <code>pending</code> |
        /// <code>available</code> | <code>deleting</code> | <code>deleted</code> |
        /// <code>rejected</code> | <code>failed</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-endpoint-type</code> - The type of VPC endpoint (<code>Interface</code> | <code>Gateway</code> | <code>GatewayLoadBalancer</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
        /// <p>Constraint: If the value is greater than 1,000, we return only 1,000 items.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpointServiceConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoint_service_configurations_input::Builder,
    }
    impl<C> DescribeVpcEndpointServiceConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointServiceConfigurationsOutput,
            smithy_http::result::SdkError<
                crate::error::DescribeVpcEndpointServiceConfigurationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of one or more services.</p>
        pub fn service_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_ids(inp);
            self
        }
        pub fn set_service_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_service_ids(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>service-name</code> - The name of the service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>service-id</code> - The ID of the service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>service-state</code> - The state of the service (<code>Pending</code> |
        /// <code>Available</code> | <code>Deleting</code> | <code>Deleted</code> |
        /// <code>Failed</code>). </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining
        /// results of the initial request can be seen by sending another request with the returned
        /// <code>NextToken</code> value. This value can be between 5 and 1,000; if
        /// <code>MaxResults</code> is given a value larger than 1,000, only 1,000 results are
        /// returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpointServicePermissions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoint_service_permissions_input::Builder,
    }
    impl<C> DescribeVpcEndpointServicePermissions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointServicePermissionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcEndpointServicePermissionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>principal</code> - The ARN of the principal.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>principal-type</code> - The principal type (<code>All</code> |
        /// <code>Service</code> | <code>OrganizationUnit</code> | <code>Account</code>
        /// | <code>User</code> | <code>Role</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining
        /// results of the initial request can be seen by sending another request with the returned
        /// <code>NextToken</code> value. This value can be between 5 and 1,000; if
        /// <code>MaxResults</code> is given a value larger than 1,000, only 1,000 results are
        /// returned.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcEndpointServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_endpoint_services_input::Builder,
    }
    impl<C> DescribeVpcEndpointServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcEndpointServicesOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcEndpointServicesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more service names.</p>
        pub fn service_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_names(inp);
            self
        }
        pub fn set_service_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_service_names(input);
            self
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>service-name</code> - The name of the service.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>service-type</code> - The type of service (<code>Interface</code> |
        /// <code>Gateway</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
        /// <p>Constraint: If the value is greater than 1,000, we return only 1,000 items.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcPeeringConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpc_peering_connections_input::Builder,
    }
    impl<C> DescribeVpcPeeringConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcPeeringConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcPeeringConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>accepter-vpc-info.cidr-block</code> - The IPv4 CIDR block of the accepter
        /// VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>accepter-vpc-info.owner-id</code> - The AWS account ID of the owner of the
        /// accepter VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>accepter-vpc-info.vpc-id</code> - The ID of the accepter VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>expiration-time</code> - The expiration date and time for the VPC peering
        /// connection.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-vpc-info.cidr-block</code> - The IPv4 CIDR block of the
        /// requester's VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-vpc-info.owner-id</code> - The AWS account ID of the owner of the
        /// requester VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>requester-vpc-info.vpc-id</code> - The ID of the requester VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-code</code> - The status of the VPC peering connection
        /// (<code>pending-acceptance</code> | <code>failed</code> |
        /// <code>expired</code> | <code>provisioning</code> | <code>active</code> |
        /// <code>deleting</code> | <code>deleted</code> |
        /// <code>rejected</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>status-message</code> - A message that provides more information about the status
        /// of the VPC peering connection, if applicable.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-peering-connection-id</code> - The ID of the VPC peering connection.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>One or more VPC peering connection IDs.</p>
        /// <p>Default: Describes all your VPC peering connections.</p>
        pub fn vpc_peering_connection_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_ids(inp);
            self
        }
        pub fn set_vpc_peering_connection_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_ids(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpcs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpcs_input::Builder,
    }
    impl<C> DescribeVpcs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpcsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpcsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>cidr</code> - The primary IPv4 CIDR block of the VPC. The CIDR block you
        /// specify must exactly match the VPC's CIDR block for information to be returned
        /// for the VPC. Must contain the slash followed by one or two digits (for example,
        /// <code>/28</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cidr-block-association.cidr-block</code> - An IPv4 CIDR block associated with the
        /// VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cidr-block-association.association-id</code> - The association ID for
        /// an IPv4 CIDR block associated with the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>cidr-block-association.state</code> - The state of an IPv4 CIDR block
        /// associated with the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR
        /// block associated with the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.ipv6-pool</code> - The ID of the IPv6 address pool from which the IPv6 CIDR block is allocated.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.association-id</code> - The association
        /// ID for an IPv6 CIDR block associated with the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR
        /// block associated with the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>isDefault</code> - Indicates whether the VPC is the default VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>owner-id</code> - The ID of the AWS account that owns the VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the VPC (<code>pending</code> | <code>available</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpc-id</code> - The ID of the VPC.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more VPC IDs.</p>
        /// <p>Default: Describes all your VPCs.</p>
        pub fn vpc_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_ids(inp);
            self
        }
        pub fn set_vpc_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpnConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpn_connections_input::Builder,
    }
    impl<C> DescribeVpnConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpnConnectionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpnConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>customer-gateway-configuration</code> - The configuration information for the customer gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>customer-gateway-id</code> - The ID of a customer gateway associated with the VPN connection.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the VPN connection (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>option.static-routes-only</code> - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route.destination-cidr-block</code> - The destination CIDR block. This corresponds to the subnet used in a customer data center.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>bgp-asn</code> - The BGP Autonomous System Number (ASN) associated with a BGP device.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of VPN connection. Currently the only supported type is <code>ipsec.1</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpn-connection-id</code> - The ID of the VPN connection.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpn-gateway-id</code> - The ID of a virtual private gateway associated with the VPN connection.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-id</code> - The ID of a transit gateway associated with the VPN connection.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more VPN connection IDs.</p>
        /// <p>Default: Describes your VPN connections.</p>
        pub fn vpn_connection_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_ids(inp);
            self
        }
        pub fn set_vpn_connection_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeVpnGateways<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_vpn_gateways_input::Builder,
    }
    impl<C> DescribeVpnGateways<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeVpnGatewaysOutput,
            smithy_http::result::SdkError<crate::error::DescribeVpnGatewaysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>amazon-side-asn</code> - The Autonomous System Number (ASN) for the Amazon side of the gateway.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.vpc-id</code> - The ID of an attached VPC.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>availability-zone</code> - The Availability Zone for the virtual private gateway (if applicable).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the virtual private gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag</code>:<key> - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value.
        /// For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of virtual private gateway. Currently the only supported type is <code>ipsec.1</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vpn-gateway-id</code> - The ID of the virtual private gateway.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>One or more virtual private gateway IDs.</p>
        /// <p>Default: Describes all your virtual private gateways.</p>
        pub fn vpn_gateway_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_ids(inp);
            self
        }
        pub fn set_vpn_gateway_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachClassicLinkVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_classic_link_vpc_input::Builder,
    }
    impl<C> DetachClassicLinkVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachClassicLinkVpcOutput,
            smithy_http::result::SdkError<crate::error::DetachClassicLinkVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance to unlink from the VPC.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the VPC to which the instance is linked.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachInternetGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_internet_gateway_input::Builder,
    }
    impl<C> DetachInternetGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachInternetGatewayOutput,
            smithy_http::result::SdkError<crate::error::DetachInternetGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the internet gateway.</p>
        pub fn internet_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.internet_gateway_id(input);
            self
        }
        pub fn set_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_internet_gateway_id(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachNetworkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_network_interface_input::Builder,
    }
    impl<C> DetachNetworkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachNetworkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::DetachNetworkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attachment_id(input);
            self
        }
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Specifies whether to force a detachment.</p>
        /// <note>
        /// <ul>
        /// <li>
        /// <p>Use the <code>Force</code> parameter only as a last resort to detach a network interface from a failed instance. </p>
        /// </li>
        /// <li>
        /// <p>If you use the <code>Force</code> parameter to detach a network interface, you might not be able to attach a different network interface to the same index on the instance without first stopping and starting the instance.</p>
        /// </li>
        /// <li>
        /// <p>If you force the detachment of a network interface, the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">instance metadata</a>
        /// might not get updated. This means that the attributes associated
        /// with the detached network interface might still be visible. The
        /// instance metadata will get updated when you stop and start the
        /// instance.</p>
        /// </li>
        /// </ul>
        /// </note>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_volume_input::Builder,
    }
    impl<C> DetachVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachVolumeOutput,
            smithy_http::result::SdkError<crate::error::DetachVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The device name.</p>
        pub fn device(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.device(input);
            self
        }
        pub fn set_device(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_device(input);
            self
        }
        /// <p>Forces detachment if the previous detachment attempt did not occur cleanly (for example,
        /// logging into an instance, unmounting the volume, and detaching normally). This option can lead
        /// to data loss or a corrupted file system. Use this option only as a last resort to detach a
        /// volume from a failed instance. The instance won't have an opportunity to flush file system
        /// caches or file system metadata. If you use this option, you must perform file system check and
        /// repair procedures.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>The ID of the instance. If you are detaching a Multi-Attach enabled volume, you must specify an instance ID.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachVpnGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_vpn_gateway_input::Builder,
    }
    impl<C> DetachVpnGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachVpnGatewayOutput,
            smithy_http::result::SdkError<crate::error::DetachVpnGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The ID of the virtual private gateway.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_id(input);
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableEbsEncryptionByDefault<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_ebs_encryption_by_default_input::Builder,
    }
    impl<C> DisableEbsEncryptionByDefault<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableEbsEncryptionByDefaultOutput,
            smithy_http::result::SdkError<crate::error::DisableEbsEncryptionByDefaultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableFastSnapshotRestores<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_fast_snapshot_restores_input::Builder,
    }
    impl<C> DisableFastSnapshotRestores<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableFastSnapshotRestoresOutput,
            smithy_http::result::SdkError<crate::error::DisableFastSnapshotRestoresError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more Availability Zones. For example, <code>us-east-2a</code>.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>The IDs of one or more snapshots. For example, <code>snap-1234567890abcdef0</code>.</p>
        pub fn source_snapshot_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_snapshot_ids(inp);
            self
        }
        pub fn set_source_snapshot_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_source_snapshot_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableImageDeprecation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_image_deprecation_input::Builder,
    }
    impl<C> DisableImageDeprecation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableImageDeprecationOutput,
            smithy_http::result::SdkError<crate::error::DisableImageDeprecationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableSerialConsoleAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_serial_console_access_input::Builder,
    }
    impl<C> DisableSerialConsoleAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableSerialConsoleAccessOutput,
            smithy_http::result::SdkError<crate::error::DisableSerialConsoleAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableTransitGatewayRouteTablePropagation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_transit_gateway_route_table_propagation_input::Builder,
    }
    impl<C> DisableTransitGatewayRouteTablePropagation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableTransitGatewayRouteTablePropagationOutput,
            smithy_http::result::SdkError<
                crate::error::DisableTransitGatewayRouteTablePropagationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the propagation route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableVgwRoutePropagation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_vgw_route_propagation_input::Builder,
    }
    impl<C> DisableVgwRoutePropagation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableVgwRoutePropagationOutput,
            smithy_http::result::SdkError<crate::error::DisableVgwRoutePropagationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_id(input);
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_id(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableVpcClassicLink<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_vpc_classic_link_input::Builder,
    }
    impl<C> DisableVpcClassicLink<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableVpcClassicLinkOutput,
            smithy_http::result::SdkError<crate::error::DisableVpcClassicLinkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableVpcClassicLinkDnsSupport<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_vpc_classic_link_dns_support_input::Builder,
    }
    impl<C> DisableVpcClassicLinkDnsSupport<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableVpcClassicLinkDnsSupportOutput,
            smithy_http::result::SdkError<crate::error::DisableVpcClassicLinkDnsSupportError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_address_input::Builder,
    }
    impl<C> DisassociateAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateAddressOutput,
            smithy_http::result::SdkError<crate::error::DisassociateAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The association ID. Required for EC2-VPC.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateClientVpnTargetNetwork<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_client_vpn_target_network_input::Builder,
    }
    impl<C> DisassociateClientVpnTargetNetwork<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateClientVpnTargetNetworkOutput,
            smithy_http::result::SdkError<crate::error::DisassociateClientVpnTargetNetworkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint from which to disassociate the target network.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ID of the target network association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateEnclaveCertificateIamRole<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_enclave_certificate_iam_role_input::Builder,
    }
    impl<C> DisassociateEnclaveCertificateIamRole<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateEnclaveCertificateIamRoleOutput,
            smithy_http::result::SdkError<crate::error::DisassociateEnclaveCertificateIamRoleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the ACM certificate from which to disassociate the IAM role.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>The ARN of the IAM role to disassociate.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateIamInstanceProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_iam_instance_profile_input::Builder,
    }
    impl<C> DisassociateIamInstanceProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateIamInstanceProfileOutput,
            smithy_http::result::SdkError<crate::error::DisassociateIamInstanceProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the IAM instance profile association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_route_table_input::Builder,
    }
    impl<C> DisassociateRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateRouteTableOutput,
            smithy_http::result::SdkError<crate::error::DisassociateRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The association ID representing the current association between the route table and subnet or gateway.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateSubnetCidrBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_subnet_cidr_block_input::Builder,
    }
    impl<C> DisassociateSubnetCidrBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateSubnetCidrBlockOutput,
            smithy_http::result::SdkError<crate::error::DisassociateSubnetCidrBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The association ID for the CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateTransitGatewayMulticastDomain<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_transit_gateway_multicast_domain_input::Builder,
    }
    impl<C> DisassociateTransitGatewayMulticastDomain<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateTransitGatewayMulticastDomainOutput,
            smithy_http::result::SdkError<
                crate::error::DisassociateTransitGatewayMulticastDomainError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The IDs of the subnets;</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateTransitGatewayRouteTable<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_transit_gateway_route_table_input::Builder,
    }
    impl<C> DisassociateTransitGatewayRouteTable<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateTransitGatewayRouteTableOutput,
            smithy_http::result::SdkError<crate::error::DisassociateTransitGatewayRouteTableError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateTrunkInterface<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_trunk_interface_input::Builder,
    }
    impl<C> DisassociateTrunkInterface<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateTrunkInterfaceOutput,
            smithy_http::result::SdkError<crate::error::DisassociateTrunkInterfaceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID ofthe association</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateVpcCidrBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_vpc_cidr_block_input::Builder,
    }
    impl<C> DisassociateVpcCidrBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateVpcCidrBlockOutput,
            smithy_http::result::SdkError<crate::error::DisassociateVpcCidrBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The association ID for the CIDR block.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableEbsEncryptionByDefault<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_ebs_encryption_by_default_input::Builder,
    }
    impl<C> EnableEbsEncryptionByDefault<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableEbsEncryptionByDefaultOutput,
            smithy_http::result::SdkError<crate::error::EnableEbsEncryptionByDefaultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableFastSnapshotRestores<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_fast_snapshot_restores_input::Builder,
    }
    impl<C> EnableFastSnapshotRestores<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableFastSnapshotRestoresOutput,
            smithy_http::result::SdkError<crate::error::EnableFastSnapshotRestoresError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more Availability Zones. For example, <code>us-east-2a</code>.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>The IDs of one or more snapshots. For example, <code>snap-1234567890abcdef0</code>. You can specify
        /// a snapshot that was shared with you from another AWS account.</p>
        pub fn source_snapshot_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_snapshot_ids(inp);
            self
        }
        pub fn set_source_snapshot_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_source_snapshot_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableImageDeprecation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_image_deprecation_input::Builder,
    }
    impl<C> EnableImageDeprecation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableImageDeprecationOutput,
            smithy_http::result::SdkError<crate::error::EnableImageDeprecationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>The date and time to deprecate the AMI, in UTC, in the following format:
        /// <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z.
        /// If you specify a value for seconds, Amazon EC2 rounds the seconds to the
        /// nearest minute.</p>
        /// <p>You can’t specify a date in the past. The upper limit for <code>DeprecateAt</code> is 10
        /// years from now.</p>
        pub fn deprecate_at(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.deprecate_at(input);
            self
        }
        pub fn set_deprecate_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_deprecate_at(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableSerialConsoleAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_serial_console_access_input::Builder,
    }
    impl<C> EnableSerialConsoleAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableSerialConsoleAccessOutput,
            smithy_http::result::SdkError<crate::error::EnableSerialConsoleAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableTransitGatewayRouteTablePropagation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_transit_gateway_route_table_propagation_input::Builder,
    }
    impl<C> EnableTransitGatewayRouteTablePropagation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableTransitGatewayRouteTablePropagationOutput,
            smithy_http::result::SdkError<
                crate::error::EnableTransitGatewayRouteTablePropagationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the propagation route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableVgwRoutePropagation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_vgw_route_propagation_input::Builder,
    }
    impl<C> EnableVgwRoutePropagation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableVgwRoutePropagationOutput,
            smithy_http::result::SdkError<crate::error::EnableVgwRoutePropagationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with. </p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_id(input);
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_id(input);
            self
        }
        /// <p>The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to. </p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableVolumeIO<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_volume_io_input::Builder,
    }
    impl<C> EnableVolumeIO<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableVolumeIoOutput,
            smithy_http::result::SdkError<crate::error::EnableVolumeIOError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableVpcClassicLink<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_vpc_classic_link_input::Builder,
    }
    impl<C> EnableVpcClassicLink<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableVpcClassicLinkOutput,
            smithy_http::result::SdkError<crate::error::EnableVpcClassicLinkError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableVpcClassicLinkDnsSupport<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_vpc_classic_link_dns_support_input::Builder,
    }
    impl<C> EnableVpcClassicLinkDnsSupport<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableVpcClassicLinkDnsSupportOutput,
            smithy_http::result::SdkError<crate::error::EnableVpcClassicLinkDnsSupportError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportClientVpnClientCertificateRevocationList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_client_vpn_client_certificate_revocation_list_input::Builder,
    }
    impl<C> ExportClientVpnClientCertificateRevocationList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportClientVpnClientCertificateRevocationListOutput,
            smithy_http::result::SdkError<
                crate::error::ExportClientVpnClientCertificateRevocationListError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportClientVpnClientConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_client_vpn_client_configuration_input::Builder,
    }
    impl<C> ExportClientVpnClientConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportClientVpnClientConfigurationOutput,
            smithy_http::result::SdkError<crate::error::ExportClientVpnClientConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_image_input::Builder,
    }
    impl<C> ExportImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportImageOutput,
            smithy_http::result::SdkError<crate::error::ExportImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token to enable idempotency for export image requests.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A description of the image being exported. The maximum length is 255 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The disk image format.</p>
        pub fn disk_image_format(mut self, input: crate::model::DiskImageFormat) -> Self {
            self.inner = self.inner.disk_image_format(input);
            self
        }
        pub fn set_disk_image_format(
            mut self,
            input: std::option::Option<crate::model::DiskImageFormat>,
        ) -> Self {
            self.inner = self.inner.set_disk_image_format(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the image.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>Information about the destination Amazon S3 bucket. The bucket must exist and grant WRITE
        /// and READ_ACP permissions to the AWS account vm-import-export@amazon.com.</p>
        pub fn s3_export_location(
            mut self,
            input: crate::model::ExportTaskS3LocationRequest,
        ) -> Self {
            self.inner = self.inner.s3_export_location(input);
            self
        }
        pub fn set_s3_export_location(
            mut self,
            input: std::option::Option<crate::model::ExportTaskS3LocationRequest>,
        ) -> Self {
            self.inner = self.inner.set_s3_export_location(input);
            self
        }
        /// <p>The name of the role that grants VM Import/Export permission to export images to your Amazon
        /// S3 bucket. If this parameter is not specified, the default role is named 'vmimport'.</p>
        pub fn role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(input);
            self
        }
        pub fn set_role_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(input);
            self
        }
        /// <p>The tags to apply to the export image task during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExportTransitGatewayRoutes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::export_transit_gateway_routes_input::Builder,
    }
    impl<C> ExportTransitGatewayRoutes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExportTransitGatewayRoutesOutput,
            smithy_http::result::SdkError<crate::error::ExportTransitGatewayRoutesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>attachment.transit-gateway-attachment-id</code> - The id of the transit gateway attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.resource-id</code> - The resource id of the transit gateway attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.exact-match</code> - The exact match of the specified filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.longest-prefix-match</code> - The longest prefix that matches the route.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.subnet-of-match</code> - The routes with a subnet that match the specified CIDR filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.supernet-of-match</code> - The routes with a CIDR that encompass the CIDR filter. For example, if you have 10.0.1.0/29 and 10.0.1.0/31 routes in your route table and you specify supernet-of-match as 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the route (<code>active</code> | <code>blackhole</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-route-destination-cidr-block</code> - The CIDR range.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of route (<code>propagated</code> |
        /// <code>static</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The name of the S3 bucket.</p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_bucket(input);
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_s3_bucket(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAssociatedEnclaveCertificateIamRoles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_associated_enclave_certificate_iam_roles_input::Builder,
    }
    impl<C> GetAssociatedEnclaveCertificateIamRoles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAssociatedEnclaveCertificateIamRolesOutput,
            smithy_http::result::SdkError<
                crate::error::GetAssociatedEnclaveCertificateIamRolesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the ACM certificate for which to view the associated IAM roles, encryption keys, and Amazon
        /// S3 object information.</p>
        pub fn certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate_arn(input);
            self
        }
        pub fn set_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_arn(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAssociatedIpv6PoolCidrs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_associated_ipv6_pool_cidrs_input::Builder,
    }
    impl<C> GetAssociatedIpv6PoolCidrs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAssociatedIpv6PoolCidrsOutput,
            smithy_http::result::SdkError<crate::error::GetAssociatedIpv6PoolCidrsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the IPv6 address pool.</p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_id(input);
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_id(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCapacityReservationUsage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_capacity_reservation_usage_input::Builder,
    }
    impl<C> GetCapacityReservationUsage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCapacityReservationUsageOutput,
            smithy_http::result::SdkError<crate::error::GetCapacityReservationUsageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_reservation_id(input);
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_id(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        /// <p>Valid range: Minimum value of 1. Maximum value of 1000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCoipPoolUsage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_coip_pool_usage_input::Builder,
    }
    impl<C> GetCoipPoolUsage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCoipPoolUsageOutput,
            smithy_http::result::SdkError<crate::error::GetCoipPoolUsageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the address pool.</p>
        pub fn pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pool_id(input);
            self
        }
        pub fn set_pool_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_pool_id(input);
            self
        }
        /// <p>The filters. The following are the possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-address-usage.allocation-id</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-address-usage.aws-account-id</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-address-usage.aws-service</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>coip-address-usage.co-ip</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetConsoleOutput<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_console_output_input::Builder,
    }
    impl<C> GetConsoleOutput<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetConsoleOutputOutput,
            smithy_http::result::SdkError<crate::error::GetConsoleOutputError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>When enabled, retrieves the latest console output for the instance.</p>
        /// <p>Default: disabled (<code>false</code>)</p>
        pub fn latest(mut self, input: bool) -> Self {
            self.inner = self.inner.latest(input);
            self
        }
        pub fn set_latest(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_latest(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetConsoleScreenshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_console_screenshot_input::Builder,
    }
    impl<C> GetConsoleScreenshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetConsoleScreenshotOutput,
            smithy_http::result::SdkError<crate::error::GetConsoleScreenshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>When set to <code>true</code>, acts as keystroke input and wakes up an instance that's
        /// in standby or "sleep" mode.</p>
        pub fn wake_up(mut self, input: bool) -> Self {
            self.inner = self.inner.wake_up(input);
            self
        }
        pub fn set_wake_up(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_wake_up(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDefaultCreditSpecification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_default_credit_specification_input::Builder,
    }
    impl<C> GetDefaultCreditSpecification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDefaultCreditSpecificationOutput,
            smithy_http::result::SdkError<crate::error::GetDefaultCreditSpecificationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The instance family.</p>
        pub fn instance_family(
            mut self,
            input: crate::model::UnlimitedSupportedInstanceFamily,
        ) -> Self {
            self.inner = self.inner.instance_family(input);
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<crate::model::UnlimitedSupportedInstanceFamily>,
        ) -> Self {
            self.inner = self.inner.set_instance_family(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEbsDefaultKmsKeyId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ebs_default_kms_key_id_input::Builder,
    }
    impl<C> GetEbsDefaultKmsKeyId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEbsDefaultKmsKeyIdOutput,
            smithy_http::result::SdkError<crate::error::GetEbsDefaultKmsKeyIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEbsEncryptionByDefault<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_ebs_encryption_by_default_input::Builder,
    }
    impl<C> GetEbsEncryptionByDefault<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEbsEncryptionByDefaultOutput,
            smithy_http::result::SdkError<crate::error::GetEbsEncryptionByDefaultError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFlowLogsIntegrationTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_flow_logs_integration_template_input::Builder,
    }
    impl<C> GetFlowLogsIntegrationTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFlowLogsIntegrationTemplateOutput,
            smithy_http::result::SdkError<crate::error::GetFlowLogsIntegrationTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the flow log.</p>
        pub fn flow_log_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.flow_log_id(input);
            self
        }
        pub fn set_flow_log_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_flow_log_id(input);
            self
        }
        /// <p>To store the CloudFormation template in Amazon S3, specify the location in Amazon S3.</p>
        pub fn config_delivery_s3_destination_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.config_delivery_s3_destination_arn(input);
            self
        }
        pub fn set_config_delivery_s3_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_config_delivery_s3_destination_arn(input);
            self
        }
        /// <p>Information about the service integration.</p>
        pub fn integrate_services(mut self, input: crate::model::IntegrateServices) -> Self {
            self.inner = self.inner.integrate_services(input);
            self
        }
        pub fn set_integrate_services(
            mut self,
            input: std::option::Option<crate::model::IntegrateServices>,
        ) -> Self {
            self.inner = self.inner.set_integrate_services(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGroupsForCapacityReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_groups_for_capacity_reservation_input::Builder,
    }
    impl<C> GetGroupsForCapacityReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGroupsForCapacityReservationOutput,
            smithy_http::result::SdkError<crate::error::GetGroupsForCapacityReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_reservation_id(input);
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_id(input);
            self
        }
        /// <p>The token to use to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHostReservationPurchasePreview<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_host_reservation_purchase_preview_input::Builder,
    }
    impl<C> GetHostReservationPurchasePreview<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetHostReservationPurchasePreviewOutput,
            smithy_http::result::SdkError<crate::error::GetHostReservationPurchasePreviewError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the Dedicated Hosts with which the reservation is associated.</p>
        pub fn host_id_set(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_id_set(inp);
            self
        }
        pub fn set_host_id_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_id_set(input);
            self
        }
        /// <p>The offering ID of the reservation.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(input);
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchTemplateData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_launch_template_data_input::Builder,
    }
    impl<C> GetLaunchTemplateData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchTemplateDataOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchTemplateDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetManagedPrefixListAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_managed_prefix_list_associations_input::Builder,
    }
    impl<C> GetManagedPrefixListAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetManagedPrefixListAssociationsOutput,
            smithy_http::result::SdkError<crate::error::GetManagedPrefixListAssociationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetManagedPrefixListEntries<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_managed_prefix_list_entries_input::Builder,
    }
    impl<C> GetManagedPrefixListEntries<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetManagedPrefixListEntriesOutput,
            smithy_http::result::SdkError<crate::error::GetManagedPrefixListEntriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The version of the prefix list for which to return the entries. The default is the current version.</p>
        pub fn target_version(mut self, input: i64) -> Self {
            self.inner = self.inner.target_version(input);
            self
        }
        pub fn set_target_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_target_version(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPasswordData<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_password_data_input::Builder,
    }
    impl<C> GetPasswordData<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPasswordDataOutput,
            smithy_http::result::SdkError<crate::error::GetPasswordDataError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Windows instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetReservedInstancesExchangeQuote<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_reserved_instances_exchange_quote_input::Builder,
    }
    impl<C> GetReservedInstancesExchangeQuote<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetReservedInstancesExchangeQuoteOutput,
            smithy_http::result::SdkError<crate::error::GetReservedInstancesExchangeQuoteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of the Convertible Reserved Instances to exchange.</p>
        pub fn reserved_instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instance_ids(inp);
            self
        }
        pub fn set_reserved_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instance_ids(input);
            self
        }
        /// <p>The configuration of the target Convertible Reserved Instance to exchange for your
        /// current Convertible Reserved Instances.</p>
        pub fn target_configurations(
            mut self,
            inp: impl Into<crate::model::TargetConfigurationRequest>,
        ) -> Self {
            self.inner = self.inner.target_configurations(inp);
            self
        }
        pub fn set_target_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TargetConfigurationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_target_configurations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSerialConsoleAccessStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_serial_console_access_status_input::Builder,
    }
    impl<C> GetSerialConsoleAccessStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSerialConsoleAccessStatusOutput,
            smithy_http::result::SdkError<crate::error::GetSerialConsoleAccessStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTransitGatewayAttachmentPropagations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transit_gateway_attachment_propagations_input::Builder,
    }
    impl<C> GetTransitGatewayAttachmentPropagations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTransitGatewayAttachmentPropagationsOutput,
            smithy_http::result::SdkError<
                crate::error::GetTransitGatewayAttachmentPropagationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>transit-gateway-route-table-id</code> - The ID of the transit gateway route table.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTransitGatewayMulticastDomainAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transit_gateway_multicast_domain_associations_input::Builder,
    }
    impl<C> GetTransitGatewayMulticastDomainAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTransitGatewayMulticastDomainAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::GetTransitGatewayMulticastDomainAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The type of resource. The valid value is: <code>vpc</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the subnet association. Valid values are
        /// <code>associated</code> |
        /// <code>associating</code>
        /// | <code>disassociated</code> | <code>disassociating</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The id of the transit gateway attachment.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTransitGatewayPrefixListReferences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transit_gateway_prefix_list_references_input::Builder,
    }
    impl<C> GetTransitGatewayPrefixListReferences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTransitGatewayPrefixListReferencesOutput,
            smithy_http::result::SdkError<crate::error::GetTransitGatewayPrefixListReferencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>attachment.resource-id</code> - The ID of the resource for the attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.resource-type</code> - The type of resource for the
        /// attachment. Valid values are <code>vpc</code> | <code>vpn</code> |
        /// <code>direct-connect-gateway</code> | <code>peering</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>is-blackhole</code> - Whether traffic matching the route is blocked (<code>true</code> | <code>false</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-id</code> - The ID of the prefix list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-owner-id</code> - The ID of the owner of the prefix list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the prefix list reference (<code>pending</code> | <code>available</code> | <code>modifying</code> | <code>deleting</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTransitGatewayRouteTableAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transit_gateway_route_table_associations_input::Builder,
    }
    impl<C> GetTransitGatewayRouteTableAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTransitGatewayRouteTableAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::GetTransitGatewayRouteTableAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The resource type. Valid values are <code>vpc</code>
        /// | <code>vpn</code> | <code>direct-connect-gateway</code> | <code>peering</code>
        /// | <code>connect</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetTransitGatewayRouteTablePropagations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_transit_gateway_route_table_propagations_input::Builder,
    }
    impl<C> GetTransitGatewayRouteTablePropagations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTransitGatewayRouteTablePropagationsOutput,
            smithy_http::result::SdkError<
                crate::error::GetTransitGatewayRouteTablePropagationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The resource type. Valid values are <code>vpc</code>
        /// | <code>vpn</code> | <code>direct-connect-gateway</code> | <code>peering</code>
        /// | <code>connect</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The ID of the attachment.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportClientVpnClientCertificateRevocationList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_client_vpn_client_certificate_revocation_list_input::Builder,
    }
    impl<C> ImportClientVpnClientCertificateRevocationList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportClientVpnClientCertificateRevocationListOutput,
            smithy_http::result::SdkError<
                crate::error::ImportClientVpnClientCertificateRevocationListError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint to which the client certificate revocation list applies.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The client certificate revocation list file. For more information, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/cvpn-working-certificates.html#cvpn-working-certificates-generate">Generate a Client Certificate Revocation List</a> in the
        /// <i>AWS Client VPN Administrator Guide</i>.</p>
        pub fn certificate_revocation_list(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.certificate_revocation_list(input);
            self
        }
        pub fn set_certificate_revocation_list(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_certificate_revocation_list(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_image_input::Builder,
    }
    impl<C> ImportImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportImageOutput,
            smithy_http::result::SdkError<crate::error::ImportImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The architecture of the virtual machine.</p>
        /// <p>Valid values: <code>i386</code> | <code>x86_64</code> | <code>arm64</code>
        /// </p>
        pub fn architecture(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.architecture(input);
            self
        }
        pub fn set_architecture(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_architecture(input);
            self
        }
        /// <p>The client-specific data.</p>
        pub fn client_data(mut self, input: crate::model::ClientData) -> Self {
            self.inner = self.inner.client_data(input);
            self
        }
        pub fn set_client_data(
            mut self,
            input: std::option::Option<crate::model::ClientData>,
        ) -> Self {
            self.inner = self.inner.set_client_data(input);
            self
        }
        /// <p>The token to enable idempotency for VM import requests.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A description string for the import image task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Information about the disk containers.</p>
        pub fn disk_containers(mut self, inp: impl Into<crate::model::ImageDiskContainer>) -> Self {
            self.inner = self.inner.disk_containers(inp);
            self
        }
        pub fn set_disk_containers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ImageDiskContainer>>,
        ) -> Self {
            self.inner = self.inner.set_disk_containers(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Specifies whether the destination AMI of the imported image should be encrypted. The default CMK for EBS is used
        /// unless you specify a non-default AWS Key Management Service (AWS KMS) CMK using <code>KmsKeyId</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>The target hypervisor platform.</p>
        /// <p>Valid values: <code>xen</code>
        /// </p>
        pub fn hypervisor(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.hypervisor(input);
            self
        }
        pub fn set_hypervisor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_hypervisor(input);
            self
        }
        /// <p>An identifier for the symmetric AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the
        /// encrypted AMI. This parameter is only required if you want to use a non-default CMK; if this
        /// parameter is not specified, the default CMK for EBS is used. If a <code>KmsKeyId</code> is
        /// specified, the <code>Encrypted</code> flag must also be set. </p>
        /// <p>The CMK identifier may be provided in any of the following formats: </p>
        /// <ul>
        /// <li>
        /// <p>Key ID</p>
        /// </li>
        /// <li>
        /// <p>Key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>.</p>
        /// </li>
        /// <li>
        /// <p>ARN using key ID. The ID ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>.</p>
        /// </li>
        /// <li>
        /// <p>ARN using key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>. </p>
        /// </li>
        /// </ul>
        /// <p>AWS parses <code>KmsKeyId</code> asynchronously, meaning that the action you call may appear to complete even
        /// though you provided an invalid identifier. This action will eventually report failure. </p>
        /// <p>The specified CMK must exist in the Region that the AMI is being copied to.</p>
        /// <p>Amazon EBS does not support asymmetric CMKs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The license type to be used for the Amazon Machine Image (AMI) after importing.</p>
        /// <p>By default, we detect the source-system operating system (OS) and apply the appropriate license. Specify
        /// <code>AWS</code> to replace the source-system license with an AWS license, if appropriate. Specify <code>BYOL</code>
        /// to retain the source-system license, if appropriate.</p>
        /// <p>To use <code>BYOL</code>, you must have existing licenses with rights to use these licenses in a third party
        /// cloud, such as AWS. For more information, see <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image">Prerequisites</a> in the
        /// VM Import/Export User Guide.</p>
        pub fn license_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_type(input);
            self
        }
        pub fn set_license_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_type(input);
            self
        }
        /// <p>The operating system of the virtual machine.</p>
        /// <p>Valid values: <code>Windows</code> | <code>Linux</code>
        /// </p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p>The name of the role to use when not using the default role, 'vmimport'.</p>
        pub fn role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(input);
            self
        }
        pub fn set_role_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(input);
            self
        }
        /// <p>The ARNs of the license configurations.</p>
        pub fn license_specifications(
            mut self,
            inp: impl Into<crate::model::ImportImageLicenseConfigurationRequest>,
        ) -> Self {
            self.inner = self.inner.license_specifications(inp);
            self
        }
        pub fn set_license_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ImportImageLicenseConfigurationRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_license_specifications(input);
            self
        }
        /// <p>The tags to apply to the import image task during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_instance_input::Builder,
    }
    impl<C> ImportInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportInstanceOutput,
            smithy_http::result::SdkError<crate::error::ImportInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A description for the instance being imported.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The disk image.</p>
        pub fn disk_images(mut self, inp: impl Into<crate::model::DiskImage>) -> Self {
            self.inner = self.inner.disk_images(inp);
            self
        }
        pub fn set_disk_images(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DiskImage>>,
        ) -> Self {
            self.inner = self.inner.set_disk_images(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The launch specification.</p>
        pub fn launch_specification(
            mut self,
            input: crate::model::ImportInstanceLaunchSpecification,
        ) -> Self {
            self.inner = self.inner.launch_specification(input);
            self
        }
        pub fn set_launch_specification(
            mut self,
            input: std::option::Option<crate::model::ImportInstanceLaunchSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_specification(input);
            self
        }
        /// <p>The instance operating system.</p>
        pub fn platform(mut self, input: crate::model::PlatformValues) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::PlatformValues>,
        ) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportKeyPair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_key_pair_input::Builder,
    }
    impl<C> ImportKeyPair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportKeyPairOutput,
            smithy_http::result::SdkError<crate::error::ImportKeyPairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>A unique name for the key pair.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_name(input);
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_name(input);
            self
        }
        /// <p>The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.</p>
        pub fn public_key_material(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.public_key_material(input);
            self
        }
        pub fn set_public_key_material(
            mut self,
            input: std::option::Option<smithy_types::Blob>,
        ) -> Self {
            self.inner = self.inner.set_public_key_material(input);
            self
        }
        /// <p>The tags to apply to the imported key pair.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportSnapshot<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_snapshot_input::Builder,
    }
    impl<C> ImportSnapshot<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportSnapshotOutput,
            smithy_http::result::SdkError<crate::error::ImportSnapshotError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The client-specific data.</p>
        pub fn client_data(mut self, input: crate::model::ClientData) -> Self {
            self.inner = self.inner.client_data(input);
            self
        }
        pub fn set_client_data(
            mut self,
            input: std::option::Option<crate::model::ClientData>,
        ) -> Self {
            self.inner = self.inner.set_client_data(input);
            self
        }
        /// <p>Token to enable idempotency for VM import requests.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description string for the import snapshot task.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Information about the disk container.</p>
        pub fn disk_container(mut self, input: crate::model::SnapshotDiskContainer) -> Self {
            self.inner = self.inner.disk_container(input);
            self
        }
        pub fn set_disk_container(
            mut self,
            input: std::option::Option<crate::model::SnapshotDiskContainer>,
        ) -> Self {
            self.inner = self.inner.set_disk_container(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Specifies whether the destination snapshot of the imported image should be encrypted. The default CMK for EBS is
        /// used unless you specify a non-default AWS Key Management Service (AWS KMS) CMK using <code>KmsKeyId</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>An identifier for the symmetric AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the
        /// encrypted snapshot. This parameter is only required if you want to use a non-default CMK; if this
        /// parameter is not specified, the default CMK for EBS is used. If a <code>KmsKeyId</code> is
        /// specified, the <code>Encrypted</code> flag must also be set. </p>
        /// <p>The CMK identifier may be provided in any of the following formats: </p>
        /// <ul>
        /// <li>
        /// <p>Key ID</p>
        /// </li>
        /// <li>
        /// <p>Key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>.</p>
        /// </li>
        /// <li>
        /// <p>ARN using key ID. The ID ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>.</p>
        /// </li>
        /// <li>
        /// <p>ARN using key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the Region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>. </p>
        /// </li>
        /// </ul>
        /// <p>AWS parses <code>KmsKeyId</code> asynchronously, meaning that the action you call may appear to complete even
        /// though you provided an invalid identifier. This action will eventually report failure. </p>
        /// <p>The specified CMK must exist in the Region that the snapshot is being copied to.</p>
        /// <p>Amazon EBS does not support asymmetric CMKs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The name of the role to use when not using the default role, 'vmimport'.</p>
        pub fn role_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_name(input);
            self
        }
        pub fn set_role_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_name(input);
            self
        }
        /// <p>The tags to apply to the import snapshot task during creation.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_volume_input::Builder,
    }
    impl<C> ImportVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportVolumeOutput,
            smithy_http::result::SdkError<crate::error::ImportVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Availability Zone for the resulting EBS volume.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone(input);
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone(input);
            self
        }
        /// <p>A description of the volume.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The disk image.</p>
        pub fn image(mut self, input: crate::model::DiskImageDetail) -> Self {
            self.inner = self.inner.image(input);
            self
        }
        pub fn set_image(
            mut self,
            input: std::option::Option<crate::model::DiskImageDetail>,
        ) -> Self {
            self.inner = self.inner.set_image(input);
            self
        }
        /// <p>The volume size.</p>
        pub fn volume(mut self, input: crate::model::VolumeDetail) -> Self {
            self.inner = self.inner.volume(input);
            self
        }
        pub fn set_volume(
            mut self,
            input: std::option::Option<crate::model::VolumeDetail>,
        ) -> Self {
            self.inner = self.inner.set_volume(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyAddressAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_address_attribute_input::Builder,
    }
    impl<C> ModifyAddressAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyAddressAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyAddressAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The allocation ID.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_id(input);
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allocation_id(input);
            self
        }
        /// <p>The domain name to modify for the IP address.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.domain_name(input);
            self
        }
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_domain_name(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyAvailabilityZoneGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_availability_zone_group_input::Builder,
    }
    impl<C> ModifyAvailabilityZoneGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyAvailabilityZoneGroupOutput,
            smithy_http::result::SdkError<crate::error::ModifyAvailabilityZoneGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Availability Zone group, Local Zone group, or Wavelength Zone
        /// group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>Indicates whether you are opted in to the Local Zone group or Wavelength Zone group. The
        /// only valid value is <code>opted-in</code>. You must contact <a href="https://console.aws.amazon.com/support/home#/case/create%3FissueType=customer-service%26serviceCode=general-info%26getting-started%26categoryCode=using-aws%26services">AWS Support</a> to opt out of a Local Zone group, or Wavelength Zone group.</p>
        pub fn opt_in_status(
            mut self,
            input: crate::model::ModifyAvailabilityZoneOptInStatus,
        ) -> Self {
            self.inner = self.inner.opt_in_status(input);
            self
        }
        pub fn set_opt_in_status(
            mut self,
            input: std::option::Option<crate::model::ModifyAvailabilityZoneOptInStatus>,
        ) -> Self {
            self.inner = self.inner.set_opt_in_status(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyCapacityReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_capacity_reservation_input::Builder,
    }
    impl<C> ModifyCapacityReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyCapacityReservationOutput,
            smithy_http::result::SdkError<crate::error::ModifyCapacityReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Capacity Reservation.</p>
        pub fn capacity_reservation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.capacity_reservation_id(input);
            self
        }
        pub fn set_capacity_reservation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_id(input);
            self
        }
        /// <p>The number of instances for which to reserve capacity.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity
        /// is released and you can no longer launch instances into it. The Capacity Reservation's state changes to
        /// <code>expired</code> when it reaches its end date and time.</p>
        /// <p>The Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify
        /// 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.</p>
        /// <p>You must provide an <code>EndDate</code> value if <code>EndDateType</code> is
        /// <code>limited</code>. Omit <code>EndDate</code> if <code>EndDateType</code> is
        /// <code>unlimited</code>.</p>
        pub fn end_date(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_date(input);
            self
        }
        pub fn set_end_date(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_date(input);
            self
        }
        /// <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end
        /// types:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it. Do not
        /// provide an <code>EndDate</code> value if <code>EndDateType</code> is
        /// <code>unlimited</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time. You must
        /// provide an <code>EndDate</code> value if <code>EndDateType</code> is
        /// <code>limited</code>.</p>
        /// </li>
        /// </ul>
        pub fn end_date_type(mut self, input: crate::model::EndDateType) -> Self {
            self.inner = self.inner.end_date_type(input);
            self
        }
        pub fn set_end_date_type(
            mut self,
            input: std::option::Option<crate::model::EndDateType>,
        ) -> Self {
            self.inner = self.inner.set_end_date_type(input);
            self
        }
        /// <p>Reserved. Capacity Reservations you have created are accepted by default.</p>
        pub fn accept(mut self, input: bool) -> Self {
            self.inner = self.inner.accept(input);
            self
        }
        pub fn set_accept(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_accept(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyClientVpnEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_client_vpn_endpoint_input::Builder,
    }
    impl<C> ModifyClientVpnEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyClientVpnEndpointOutput,
            smithy_http::result::SdkError<crate::error::ModifyClientVpnEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint to modify.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ARN of the server certificate to be used. The server certificate must be provisioned in AWS Certificate Manager (ACM).</p>
        pub fn server_certificate_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_certificate_arn(input);
            self
        }
        pub fn set_server_certificate_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_server_certificate_arn(input);
            self
        }
        /// <p>Information about the client connection logging options.</p>
        /// <p>If you enable client connection logging, data about client connections is sent to a
        /// Cloudwatch Logs log stream. The following information is logged:</p>
        /// <ul>
        /// <li>
        /// <p>Client connection requests</p>
        /// </li>
        /// <li>
        /// <p>Client connection results (successful and unsuccessful)</p>
        /// </li>
        /// <li>
        /// <p>Reasons for unsuccessful client connection requests</p>
        /// </li>
        /// <li>
        /// <p>Client connection termination time</p>
        /// </li>
        /// </ul>
        pub fn connection_log_options(mut self, input: crate::model::ConnectionLogOptions) -> Self {
            self.inner = self.inner.connection_log_options(input);
            self
        }
        pub fn set_connection_log_options(
            mut self,
            input: std::option::Option<crate::model::ConnectionLogOptions>,
        ) -> Self {
            self.inner = self.inner.set_connection_log_options(input);
            self
        }
        /// <p>Information about the DNS servers to be used by Client VPN connections. A Client VPN endpoint can have
        /// up to two DNS servers.</p>
        pub fn dns_servers(
            mut self,
            input: crate::model::DnsServersOptionsModifyStructure,
        ) -> Self {
            self.inner = self.inner.dns_servers(input);
            self
        }
        pub fn set_dns_servers(
            mut self,
            input: std::option::Option<crate::model::DnsServersOptionsModifyStructure>,
        ) -> Self {
            self.inner = self.inner.set_dns_servers(input);
            self
        }
        /// <p>The port number to assign to the Client VPN endpoint for TCP and UDP traffic.</p>
        /// <p>Valid Values: <code>443</code> | <code>1194</code>
        /// </p>
        /// <p>Default Value: <code>443</code>
        /// </p>
        pub fn vpn_port(mut self, input: i32) -> Self {
            self.inner = self.inner.vpn_port(input);
            self
        }
        pub fn set_vpn_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_vpn_port(input);
            self
        }
        /// <p>A brief description of the Client VPN endpoint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Indicates whether the VPN is split-tunnel.</p>
        /// <p>For information about split-tunnel VPN endpoints, see <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html">Split-Tunnel AWS Client VPN Endpoint</a> in the <i>AWS
        /// Client VPN Administrator Guide</i>.</p>
        pub fn split_tunnel(mut self, input: bool) -> Self {
            self.inner = self.inner.split_tunnel(input);
            self
        }
        pub fn set_split_tunnel(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_split_tunnel(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The IDs of one or more security groups to apply to the target network.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>The ID of the VPC to associate with the Client VPN endpoint.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>Specify whether to enable the self-service portal for the Client VPN endpoint.</p>
        pub fn self_service_portal(mut self, input: crate::model::SelfServicePortal) -> Self {
            self.inner = self.inner.self_service_portal(input);
            self
        }
        pub fn set_self_service_portal(
            mut self,
            input: std::option::Option<crate::model::SelfServicePortal>,
        ) -> Self {
            self.inner = self.inner.set_self_service_portal(input);
            self
        }
        /// <p>The options for managing connection authorization for new client connections.</p>
        pub fn client_connect_options(mut self, input: crate::model::ClientConnectOptions) -> Self {
            self.inner = self.inner.client_connect_options(input);
            self
        }
        pub fn set_client_connect_options(
            mut self,
            input: std::option::Option<crate::model::ClientConnectOptions>,
        ) -> Self {
            self.inner = self.inner.set_client_connect_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyDefaultCreditSpecification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_default_credit_specification_input::Builder,
    }
    impl<C> ModifyDefaultCreditSpecification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyDefaultCreditSpecificationOutput,
            smithy_http::result::SdkError<crate::error::ModifyDefaultCreditSpecificationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The instance family.</p>
        pub fn instance_family(
            mut self,
            input: crate::model::UnlimitedSupportedInstanceFamily,
        ) -> Self {
            self.inner = self.inner.instance_family(input);
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<crate::model::UnlimitedSupportedInstanceFamily>,
        ) -> Self {
            self.inner = self.inner.set_instance_family(input);
            self
        }
        /// <p>The credit option for CPU usage of the instance family.</p>
        /// <p>Valid Values: <code>standard</code> | <code>unlimited</code>
        /// </p>
        pub fn cpu_credits(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cpu_credits(input);
            self
        }
        pub fn set_cpu_credits(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cpu_credits(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyEbsDefaultKmsKeyId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_ebs_default_kms_key_id_input::Builder,
    }
    impl<C> ModifyEbsDefaultKmsKeyId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyEbsDefaultKmsKeyIdOutput,
            smithy_http::result::SdkError<crate::error::ModifyEbsDefaultKmsKeyIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the AWS Key Management Service (AWS KMS) customer master key (CMK) to use for Amazon EBS encryption.
        /// If this parameter is not specified, your AWS managed CMK for EBS is used. If <code>KmsKeyId</code> is
        /// specified, the encrypted state must be <code>true</code>.</p>
        /// <p>You can specify the CMK using any of the following:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Key alias. For example, alias/ExampleAlias.</p>
        /// </li>
        /// <li>
        /// <p>Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.</p>
        /// </li>
        /// <li>
        /// <p>Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.</p>
        /// </li>
        /// </ul>
        /// <p>AWS authenticates the CMK asynchronously. Therefore, if you specify an ID, alias, or ARN that is not valid,
        /// the action can appear to complete, but eventually fails.</p>  
        /// <p>Amazon EBS does not support asymmetric CMKs.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyFleet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_fleet_input::Builder,
    }
    impl<C> ModifyFleet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyFleetOutput,
            smithy_http::result::SdkError<crate::error::ModifyFleetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether running instances should be terminated if the total target capacity of
        /// the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
        pub fn excess_capacity_termination_policy(
            mut self,
            input: crate::model::FleetExcessCapacityTerminationPolicy,
        ) -> Self {
            self.inner = self.inner.excess_capacity_termination_policy(input);
            self
        }
        pub fn set_excess_capacity_termination_policy(
            mut self,
            input: std::option::Option<crate::model::FleetExcessCapacityTerminationPolicy>,
        ) -> Self {
            self.inner = self.inner.set_excess_capacity_termination_policy(input);
            self
        }
        /// <p>The launch template and overrides.</p>
        pub fn launch_template_configs(
            mut self,
            inp: impl Into<crate::model::FleetLaunchTemplateConfigRequest>,
        ) -> Self {
            self.inner = self.inner.launch_template_configs(inp);
            self
        }
        pub fn set_launch_template_configs(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::FleetLaunchTemplateConfigRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_launch_template_configs(input);
            self
        }
        /// <p>The ID of the EC2 Fleet.</p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fleet_id(input);
            self
        }
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_fleet_id(input);
            self
        }
        /// <p>The size of the EC2 Fleet.</p>
        pub fn target_capacity_specification(
            mut self,
            input: crate::model::TargetCapacitySpecificationRequest,
        ) -> Self {
            self.inner = self.inner.target_capacity_specification(input);
            self
        }
        pub fn set_target_capacity_specification(
            mut self,
            input: std::option::Option<crate::model::TargetCapacitySpecificationRequest>,
        ) -> Self {
            self.inner = self.inner.set_target_capacity_specification(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyFpgaImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_fpga_image_attribute_input::Builder,
    }
    impl<C> ModifyFpgaImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyFpgaImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyFpgaImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the AFI.</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fpga_image_id(input);
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fpga_image_id(input);
            self
        }
        /// <p>The name of the attribute.</p>
        pub fn attribute(mut self, input: crate::model::FpgaImageAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::FpgaImageAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The operation type.</p>
        pub fn operation_type(mut self, input: crate::model::OperationType) -> Self {
            self.inner = self.inner.operation_type(input);
            self
        }
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<crate::model::OperationType>,
        ) -> Self {
            self.inner = self.inner.set_operation_type(input);
            self
        }
        /// <p>The AWS account IDs. This parameter is valid only when modifying the <code>loadPermission</code> attribute.</p>
        pub fn user_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_ids(inp);
            self
        }
        pub fn set_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_user_ids(input);
            self
        }
        /// <p>The user groups. This parameter is valid only when modifying the <code>loadPermission</code> attribute.</p>
        pub fn user_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_groups(inp);
            self
        }
        pub fn set_user_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_user_groups(input);
            self
        }
        /// <p>The product codes. After you add a product code to an AFI, it can't be removed.
        /// This parameter is valid only when modifying the <code>productCodes</code> attribute.</p>
        pub fn product_codes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_codes(inp);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_product_codes(input);
            self
        }
        /// <p>The load permission for the AFI.</p>
        pub fn load_permission(mut self, input: crate::model::LoadPermissionModifications) -> Self {
            self.inner = self.inner.load_permission(input);
            self
        }
        pub fn set_load_permission(
            mut self,
            input: std::option::Option<crate::model::LoadPermissionModifications>,
        ) -> Self {
            self.inner = self.inner.set_load_permission(input);
            self
        }
        /// <p>A description for the AFI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>A name for the AFI.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyHosts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_hosts_input::Builder,
    }
    impl<C> ModifyHosts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyHostsOutput,
            smithy_http::result::SdkError<crate::error::ModifyHostsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify whether to enable or disable auto-placement.</p>
        pub fn auto_placement(mut self, input: crate::model::AutoPlacement) -> Self {
            self.inner = self.inner.auto_placement(input);
            self
        }
        pub fn set_auto_placement(
            mut self,
            input: std::option::Option<crate::model::AutoPlacement>,
        ) -> Self {
            self.inner = self.inner.set_auto_placement(input);
            self
        }
        /// <p>The IDs of the Dedicated Hosts to modify.</p>
        pub fn host_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_ids(inp);
            self
        }
        pub fn set_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_ids(input);
            self
        }
        /// <p>Indicates whether to enable or disable host recovery for the Dedicated Host. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html">
        /// Host recovery</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn host_recovery(mut self, input: crate::model::HostRecovery) -> Self {
            self.inner = self.inner.host_recovery(input);
            self
        }
        pub fn set_host_recovery(
            mut self,
            input: std::option::Option<crate::model::HostRecovery>,
        ) -> Self {
            self.inner = self.inner.set_host_recovery(input);
            self
        }
        /// <p>Specifies the instance type to be supported by the Dedicated Host. Specify this parameter to
        /// modify a Dedicated Host to support only a specific instance type.</p>
        /// <p>If you want to modify a Dedicated Host to support multiple instance types in its current instance
        /// family, omit this parameter and specify <b>InstanceFamily</b>
        /// instead. You cannot specify <b>InstanceType</b> and
        /// <b>InstanceFamily</b> in the same request.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>Specifies the instance family to be supported by the Dedicated Host. Specify this parameter
        /// to modify a Dedicated Host to support multiple instance types within its current
        /// instance family.</p>
        /// <p>If you want to modify a Dedicated Host to support a specific instance type only, omit this parameter
        /// and specify <b>InstanceType</b> instead. You cannot specify
        /// <b>InstanceFamily</b> and <b>InstanceType</b>
        /// in the same request.</p>
        pub fn instance_family(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_family(input);
            self
        }
        pub fn set_instance_family(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_family(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyIdentityIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_identity_id_format_input::Builder,
    }
    impl<C> ModifyIdentityIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyIdentityIdFormatOutput,
            smithy_http::result::SdkError<crate::error::ModifyIdentityIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify
        /// <code>all</code> to modify the ID format for all IAM users, IAM roles, and the root user of
        /// the account.</p>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(input);
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_principal_arn(input);
            self
        }
        /// <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> |
        /// <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> |
        /// <code>export-task</code> | <code>flow-log</code> | <code>image</code> |
        /// <code>import-task</code> | <code>internet-gateway</code> | <code>network-acl</code>
        /// | <code>network-acl-association</code> | <code>network-interface</code> |
        /// <code>network-interface-attachment</code> | <code>prefix-list</code> |
        /// <code>route-table</code> | <code>route-table-association</code> |
        /// <code>security-group</code> | <code>subnet</code> |
        /// <code>subnet-cidr-block-association</code> | <code>vpc</code> |
        /// <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>.</p>
        /// <p>Alternatively, use the <code>all-current</code> option to include all resource types that are
        /// currently within their opt-in period for longer IDs.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p>Indicates whether the resource should use longer IDs (17-character IDs)</p>
        pub fn use_long_ids(mut self, input: bool) -> Self {
            self.inner = self.inner.use_long_ids(input);
            self
        }
        pub fn set_use_long_ids(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_use_long_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyIdFormat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_id_format_input::Builder,
    }
    impl<C> ModifyIdFormat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyIdFormatOutput,
            smithy_http::result::SdkError<crate::error::ModifyIdFormatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> |
        /// <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> |
        /// <code>export-task</code> | <code>flow-log</code> | <code>image</code> |
        /// <code>import-task</code> | <code>internet-gateway</code> | <code>network-acl</code>
        /// | <code>network-acl-association</code> | <code>network-interface</code> |
        /// <code>network-interface-attachment</code> | <code>prefix-list</code> |
        /// <code>route-table</code> | <code>route-table-association</code> |
        /// <code>security-group</code> | <code>subnet</code> |
        /// <code>subnet-cidr-block-association</code> | <code>vpc</code> |
        /// <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>.</p>
        /// <p>Alternatively, use the <code>all-current</code> option to include all resource types that are
        /// currently within their opt-in period for longer IDs.</p>
        pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource(input);
            self
        }
        pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource(input);
            self
        }
        /// <p>Indicate whether the resource should use longer IDs (17-character IDs).</p>
        pub fn use_long_ids(mut self, input: bool) -> Self {
            self.inner = self.inner.use_long_ids(input);
            self
        }
        pub fn set_use_long_ids(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_use_long_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_image_attribute_input::Builder,
    }
    impl<C> ModifyImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the attribute to modify.
        /// The valid values are <code>description</code>, <code>launchPermission</code>, and <code>productCodes</code>.</p>
        pub fn attribute(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>A new description for the AMI.</p>
        pub fn description(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>A new launch permission for the AMI.</p>
        pub fn launch_permission(
            mut self,
            input: crate::model::LaunchPermissionModifications,
        ) -> Self {
            self.inner = self.inner.launch_permission(input);
            self
        }
        pub fn set_launch_permission(
            mut self,
            input: std::option::Option<crate::model::LaunchPermissionModifications>,
        ) -> Self {
            self.inner = self.inner.set_launch_permission(input);
            self
        }
        /// <p>The operation type.
        /// This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
        pub fn operation_type(mut self, input: crate::model::OperationType) -> Self {
            self.inner = self.inner.operation_type(input);
            self
        }
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<crate::model::OperationType>,
        ) -> Self {
            self.inner = self.inner.set_operation_type(input);
            self
        }
        /// <p>The DevPay product codes. After you add a product code to an AMI, it can't be removed.</p>
        pub fn product_codes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_codes(inp);
            self
        }
        pub fn set_product_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_product_codes(input);
            self
        }
        /// <p>The user groups.
        /// This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
        pub fn user_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_groups(inp);
            self
        }
        pub fn set_user_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_user_groups(input);
            self
        }
        /// <p>The AWS account IDs.
        /// This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
        pub fn user_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_ids(inp);
            self
        }
        pub fn set_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_user_ids(input);
            self
        }
        /// <p>The value of the attribute being modified.
        /// This parameter can be used only when the <code>Attribute</code> parameter is <code>description</code> or <code>productCodes</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstanceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_attribute_input::Builder,
    }
    impl<C> ModifyInstanceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstanceAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyInstanceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Enable or disable source/destination checks, which ensure that the instance
        /// is either the source or the destination of any traffic that it receives.
        /// If the value is <code>true</code>, source/destination checks are enabled;
        /// otherwise, they are disabled. The default value is <code>true</code>.
        /// You must disable source/destination checks if the instance runs services
        /// such as network address translation, routing, or firewalls.</p>
        pub fn source_dest_check(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.source_dest_check(input);
            self
        }
        pub fn set_source_dest_check(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_source_dest_check(input);
            self
        }
        /// <p>The name of the attribute.</p>
        pub fn attribute(mut self, input: crate::model::InstanceAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>Modifies the <code>DeleteOnTermination</code> attribute for volumes that are currently
        /// attached. The volume must be owned by the caller. If no value is specified for
        /// <code>DeleteOnTermination</code>, the default is <code>true</code> and the volume is
        /// deleted when the instance is terminated.</p>
        /// <p>To add instance store volumes to an Amazon EBS-backed instance, you must add them when
        /// you launch the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM">Updating the block device mapping when launching an instance</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::InstanceBlockDeviceMappingSpecification>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceBlockDeviceMappingSpecification>,
            >,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p>If the value is <code>true</code>, you can't terminate the instance using the Amazon
        /// EC2 console, CLI, or API; otherwise, you can. You cannot use this parameter for Spot
        /// Instances.</p>
        pub fn disable_api_termination(
            mut self,
            input: crate::model::AttributeBooleanValue,
        ) -> Self {
            self.inner = self.inner.disable_api_termination(input);
            self
        }
        pub fn set_disable_api_termination(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_disable_api_termination(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Specifies whether the instance is optimized for Amazon EBS I/O. This optimization
        /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
        /// provide optimal EBS I/O performance. This optimization isn't available with all instance
        /// types. Additional usage charges apply when using an EBS Optimized instance.</p>
        pub fn ebs_optimized(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.ebs_optimized(input);
            self
        }
        pub fn set_ebs_optimized(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_ebs_optimized(input);
            self
        }
        /// <p>Set to <code>true</code> to enable enhanced networking with ENA for the
        /// instance.</p>
        /// <p>This option is supported only for HVM instances. Specifying this option with a PV
        /// instance can make it unreachable.</p>
        pub fn ena_support(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.ena_support(input);
            self
        }
        pub fn set_ena_support(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_ena_support(input);
            self
        }
        /// <p>[EC2-VPC] Replaces the security groups of the instance with the specified security groups.
        /// You must specify at least one security group, even if it's just the default security group for the VPC. You must
        /// specify the security group ID, not the security group name.</p>
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Specifies whether an instance stops or terminates when you initiate shutdown from the
        /// instance (using the operating system command for system shutdown).</p>
        pub fn instance_initiated_shutdown_behavior(
            mut self,
            input: crate::model::AttributeValue,
        ) -> Self {
            self.inner = self.inner.instance_initiated_shutdown_behavior(input);
            self
        }
        pub fn set_instance_initiated_shutdown_behavior(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_instance_initiated_shutdown_behavior(input);
            self
        }
        /// <p>Changes the instance type to the specified value. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
        /// types</a> in the <i>Amazon EC2 User Guide</i>. If the instance type is not valid,
        /// the error returned is <code>InvalidInstanceAttributeValue</code>.</p>
        pub fn instance_type(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>Changes the instance's kernel to the specified value. We recommend that you use
        /// PV-GRUB instead of kernels and RAM disks. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
        pub fn kernel(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.kernel(input);
            self
        }
        pub fn set_kernel(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_kernel(input);
            self
        }
        /// <p>Changes the instance's RAM disk to the specified value. We recommend that you use
        /// PV-GRUB instead of kernels and RAM disks. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
        pub fn ramdisk(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.ramdisk(input);
            self
        }
        pub fn set_ramdisk(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_ramdisk(input);
            self
        }
        /// <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual
        /// Function interface for the instance.</p>
        /// <p>There is no way to disable enhanced networking with the Intel 82599 Virtual Function
        /// interface at this time.</p>
        /// <p>This option is supported only for HVM instances. Specifying this option with a PV
        /// instance can make it unreachable.</p>
        pub fn sriov_net_support(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.sriov_net_support(input);
            self
        }
        pub fn set_sriov_net_support(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_sriov_net_support(input);
            self
        }
        /// <p>Changes the instance's user data to the specified value. If you are using an Amazon Web Services SDK
        /// or command line tool, base64-encoding is performed for you, and you can load the text
        /// from a file. Otherwise, you must provide base64-encoded text.</p>
        pub fn user_data(mut self, input: crate::model::BlobAttributeValue) -> Self {
            self.inner = self.inner.user_data(input);
            self
        }
        pub fn set_user_data(
            mut self,
            input: std::option::Option<crate::model::BlobAttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_user_data(input);
            self
        }
        /// <p>A new value for the attribute. Use only with the <code>kernel</code>,
        /// <code>ramdisk</code>, <code>userData</code>, <code>disableApiTermination</code>, or
        /// <code>instanceInitiatedShutdownBehavior</code> attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.value(input);
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstanceCapacityReservationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_capacity_reservation_attributes_input::Builder,
    }
    impl<C> ModifyInstanceCapacityReservationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstanceCapacityReservationAttributesOutput,
            smithy_http::result::SdkError<
                crate::error::ModifyInstanceCapacityReservationAttributesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance to be modified.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Information about the Capacity Reservation targeting option.</p>
        pub fn capacity_reservation_specification(
            mut self,
            input: crate::model::CapacityReservationSpecification,
        ) -> Self {
            self.inner = self.inner.capacity_reservation_specification(input);
            self
        }
        pub fn set_capacity_reservation_specification(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationSpecification>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_specification(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstanceCreditSpecification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_credit_specification_input::Builder,
    }
    impl<C> ModifyInstanceCreditSpecification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstanceCreditSpecificationOutput,
            smithy_http::result::SdkError<crate::error::ModifyInstanceCreditSpecificationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>A unique, case-sensitive token that you provide to ensure idempotency of your
        /// modification request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Information about the credit option for CPU usage.</p>
        pub fn instance_credit_specifications(
            mut self,
            inp: impl Into<crate::model::InstanceCreditSpecificationRequest>,
        ) -> Self {
            self.inner = self.inner.instance_credit_specifications(inp);
            self
        }
        pub fn set_instance_credit_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceCreditSpecificationRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_instance_credit_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstanceEventStartTime<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_event_start_time_input::Builder,
    }
    impl<C> ModifyInstanceEventStartTime<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstanceEventStartTimeOutput,
            smithy_http::result::SdkError<crate::error::ModifyInstanceEventStartTimeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance with the scheduled event.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The ID of the event whose date and time you are modifying.</p>
        pub fn instance_event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_event_id(input);
            self
        }
        pub fn set_instance_event_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_event_id(input);
            self
        }
        /// <p>The new date and time when the event will take place.</p>
        pub fn not_before(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.not_before(input);
            self
        }
        pub fn set_not_before(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_not_before(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstanceMetadataOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_metadata_options_input::Builder,
    }
    impl<C> ModifyInstanceMetadataOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstanceMetadataOptionsOutput,
            smithy_http::result::SdkError<crate::error::ModifyInstanceMetadataOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not
        /// specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
        /// with or without a signed token header on your request. If you retrieve the IAM role
        /// credentials without a token, the version 1.0 role credentials are returned. If you
        /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
        /// credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any
        /// instance metadata retrieval requests. In this state, retrieving the IAM role credential
        /// always returns the version 2.0 credentials; the version 1.0 credentials are not
        /// available.</p>
        pub fn http_tokens(mut self, input: crate::model::HttpTokensState) -> Self {
            self.inner = self.inner.http_tokens(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::HttpTokensState>,
        ) -> Self {
            self.inner = self.inner.set_http_tokens(input);
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
        /// number, the further instance metadata requests can travel. If no parameter is specified, the existing state is maintained.</p>
        /// <p>Possible values: Integers from 1 to 64</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.inner = self.inner.http_put_response_hop_limit(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_http_put_response_hop_limit(input);
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
        /// the parameter is not specified, the existing state is maintained.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access your
        /// instance metadata.</p>
        /// </note>
        pub fn http_endpoint(mut self, input: crate::model::InstanceMetadataEndpointState) -> Self {
            self.inner = self.inner.http_endpoint(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        ) -> Self {
            self.inner = self.inner.set_http_endpoint(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyInstancePlacement<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_instance_placement_input::Builder,
    }
    impl<C> ModifyInstancePlacement<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyInstancePlacementOutput,
            smithy_http::result::SdkError<crate::error::ModifyInstancePlacementError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The affinity setting for the instance.</p>
        pub fn affinity(mut self, input: crate::model::Affinity) -> Self {
            self.inner = self.inner.affinity(input);
            self
        }
        pub fn set_affinity(mut self, input: std::option::Option<crate::model::Affinity>) -> Self {
            self.inner = self.inner.set_affinity(input);
            self
        }
        /// <p>The name of the placement group in which to place the instance. For spread placement
        /// groups, the instance must have a tenancy of <code>default</code>. For cluster and
        /// partition placement groups, the instance must have a tenancy of <code>default</code> or
        /// <code>dedicated</code>.</p>
        /// <p>To remove an instance from a placement group, specify an empty string
        /// ("").</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The ID of the Dedicated Host with which to associate the instance.</p>
        pub fn host_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_id(input);
            self
        }
        pub fn set_host_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_host_id(input);
            self
        }
        /// <p>The ID of the instance that you are modifying.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The tenancy for the instance.</p>
        pub fn tenancy(mut self, input: crate::model::HostTenancy) -> Self {
            self.inner = self.inner.tenancy(input);
            self
        }
        pub fn set_tenancy(
            mut self,
            input: std::option::Option<crate::model::HostTenancy>,
        ) -> Self {
            self.inner = self.inner.set_tenancy(input);
            self
        }
        /// <p>Reserved for future use.</p>
        pub fn partition_number(mut self, input: i32) -> Self {
            self.inner = self.inner.partition_number(input);
            self
        }
        pub fn set_partition_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_partition_number(input);
            self
        }
        /// <p>The ARN of the host resource group in which to place the instance.</p>
        pub fn host_resource_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_resource_group_arn(input);
            self
        }
        pub fn set_host_resource_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_host_resource_group_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyLaunchTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_launch_template_input::Builder,
    }
    impl<C> ModifyLaunchTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyLaunchTemplateOutput,
            smithy_http::result::SdkError<crate::error::ModifyLaunchTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraint: Maximum 128 ASCII characters.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_id(input);
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_id(input);
            self
        }
        /// <p>The name of the launch template. You must specify either the launch template ID or
        /// launch template name in the request.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_template_name(input);
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_name(input);
            self
        }
        /// <p>The version number of the launch template to set as the default version.</p>
        pub fn default_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_version(input);
            self
        }
        pub fn set_default_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyManagedPrefixList<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_managed_prefix_list_input::Builder,
    }
    impl<C> ModifyManagedPrefixList<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyManagedPrefixListOutput,
            smithy_http::result::SdkError<crate::error::ModifyManagedPrefixListError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The current version of the prefix list.</p>
        pub fn current_version(mut self, input: i64) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
        /// <p>A name for the prefix list.</p>
        pub fn prefix_list_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_name(input);
            self
        }
        pub fn set_prefix_list_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_name(input);
            self
        }
        /// <p>One or more entries to add to the prefix list.</p>
        pub fn add_entries(mut self, inp: impl Into<crate::model::AddPrefixListEntry>) -> Self {
            self.inner = self.inner.add_entries(inp);
            self
        }
        pub fn set_add_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AddPrefixListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_add_entries(input);
            self
        }
        /// <p>One or more entries to remove from the prefix list.</p>
        pub fn remove_entries(
            mut self,
            inp: impl Into<crate::model::RemovePrefixListEntry>,
        ) -> Self {
            self.inner = self.inner.remove_entries(inp);
            self
        }
        pub fn set_remove_entries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RemovePrefixListEntry>>,
        ) -> Self {
            self.inner = self.inner.set_remove_entries(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyNetworkInterfaceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_network_interface_attribute_input::Builder,
    }
    impl<C> ModifyNetworkInterfaceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyNetworkInterfaceAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyNetworkInterfaceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.</p>
        pub fn attachment(
            mut self,
            input: crate::model::NetworkInterfaceAttachmentChanges,
        ) -> Self {
            self.inner = self.inner.attachment(input);
            self
        }
        pub fn set_attachment(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceAttachmentChanges>,
        ) -> Self {
            self.inner = self.inner.set_attachment(input);
            self
        }
        /// <p>A description for the network interface.</p>
        pub fn description(mut self, input: crate::model::AttributeValue) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(
            mut self,
            input: std::option::Option<crate::model::AttributeValue>,
        ) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.</p>
        pub fn groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.groups(inp);
            self
        }
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_groups(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>Enable or disable source/destination checks, which ensure that the instance
        /// is either the source or the destination of any traffic that it receives.
        /// If the value is <code>true</code>, source/destination checks are enabled;
        /// otherwise, they are disabled. The default value is <code>true</code>.
        /// You must disable source/destination checks if the instance runs services
        /// such as network address translation, routing, or firewalls.</p>
        pub fn source_dest_check(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.source_dest_check(input);
            self
        }
        pub fn set_source_dest_check(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_source_dest_check(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyReservedInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_reserved_instances_input::Builder,
    }
    impl<C> ModifyReservedInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyReservedInstancesOutput,
            smithy_http::result::SdkError<crate::error::ModifyReservedInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the Reserved Instances to modify.</p>
        pub fn reserved_instances_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reserved_instances_ids(inp);
            self
        }
        pub fn set_reserved_instances_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_ids(input);
            self
        }
        /// <p>A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The configuration settings for the Reserved Instances to modify.</p>
        pub fn target_configurations(
            mut self,
            inp: impl Into<crate::model::ReservedInstancesConfiguration>,
        ) -> Self {
            self.inner = self.inner.target_configurations(inp);
            self
        }
        pub fn set_target_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReservedInstancesConfiguration>>,
        ) -> Self {
            self.inner = self.inner.set_target_configurations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifySnapshotAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_snapshot_attribute_input::Builder,
    }
    impl<C> ModifySnapshotAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifySnapshotAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifySnapshotAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The snapshot attribute to modify. Only volume creation permissions can be modified.</p>
        pub fn attribute(mut self, input: crate::model::SnapshotAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::SnapshotAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>A JSON representation of the snapshot attribute modification.</p>
        pub fn create_volume_permission(
            mut self,
            input: crate::model::CreateVolumePermissionModifications,
        ) -> Self {
            self.inner = self.inner.create_volume_permission(input);
            self
        }
        pub fn set_create_volume_permission(
            mut self,
            input: std::option::Option<crate::model::CreateVolumePermissionModifications>,
        ) -> Self {
            self.inner = self.inner.set_create_volume_permission(input);
            self
        }
        /// <p>The group to modify for the snapshot.</p>
        pub fn group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_names(inp);
            self
        }
        pub fn set_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_group_names(input);
            self
        }
        /// <p>The type of operation to perform to the attribute.</p>
        pub fn operation_type(mut self, input: crate::model::OperationType) -> Self {
            self.inner = self.inner.operation_type(input);
            self
        }
        pub fn set_operation_type(
            mut self,
            input: std::option::Option<crate::model::OperationType>,
        ) -> Self {
            self.inner = self.inner.set_operation_type(input);
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>The account ID to modify for the snapshot.</p>
        pub fn user_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_ids(inp);
            self
        }
        pub fn set_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_user_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifySpotFleetRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_spot_fleet_request_input::Builder,
    }
    impl<C> ModifySpotFleetRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifySpotFleetRequestOutput,
            smithy_http::result::SdkError<crate::error::ModifySpotFleetRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether running Spot Instances should be terminated if the target capacity
        /// of the Spot Fleet request is decreased below the current size of the Spot Fleet.</p>
        pub fn excess_capacity_termination_policy(
            mut self,
            input: crate::model::ExcessCapacityTerminationPolicy,
        ) -> Self {
            self.inner = self.inner.excess_capacity_termination_policy(input);
            self
        }
        pub fn set_excess_capacity_termination_policy(
            mut self,
            input: std::option::Option<crate::model::ExcessCapacityTerminationPolicy>,
        ) -> Self {
            self.inner = self.inner.set_excess_capacity_termination_policy(input);
            self
        }
        /// <p>The launch template and overrides. You can only use this parameter if you specified a
        /// launch template (<code>LaunchTemplateConfigs</code>) in your Spot Fleet request. If you
        /// specified <code>LaunchSpecifications</code> in your Spot Fleet request, then omit this
        /// parameter.</p>
        pub fn launch_template_configs(
            mut self,
            inp: impl Into<crate::model::LaunchTemplateConfig>,
        ) -> Self {
            self.inner = self.inner.launch_template_configs(inp);
            self
        }
        pub fn set_launch_template_configs(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateConfig>>,
        ) -> Self {
            self.inner = self.inner.set_launch_template_configs(input);
            self
        }
        /// <p>The ID of the Spot Fleet request.</p>
        pub fn spot_fleet_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_fleet_request_id(input);
            self
        }
        pub fn set_spot_fleet_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_id(input);
            self
        }
        /// <p>The size of the fleet.</p>
        pub fn target_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.target_capacity(input);
            self
        }
        pub fn set_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_target_capacity(input);
            self
        }
        /// <p>The number of On-Demand Instances in the fleet.</p>
        pub fn on_demand_target_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.on_demand_target_capacity(input);
            self
        }
        pub fn set_on_demand_target_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_on_demand_target_capacity(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifySubnetAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_subnet_attribute_input::Builder,
    }
    impl<C> ModifySubnetAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifySubnetAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifySubnetAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specify <code>true</code> to indicate that network interfaces created in the
        /// specified subnet should be assigned an IPv6 address. This includes a network interface
        /// that's created when launching an instance into the subnet (the instance therefore
        /// receives an IPv6 address). </p>
        /// <p>If you enable the IPv6 addressing feature for your subnet, your network interface
        /// or instance only receives an IPv6 address if it's created using version
        /// <code>2016-11-15</code> or later of the Amazon EC2 API.</p>
        pub fn assign_ipv6_address_on_creation(
            mut self,
            input: crate::model::AttributeBooleanValue,
        ) -> Self {
            self.inner = self.inner.assign_ipv6_address_on_creation(input);
            self
        }
        pub fn set_assign_ipv6_address_on_creation(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_assign_ipv6_address_on_creation(input);
            self
        }
        /// <p>Specify <code>true</code> to indicate that network interfaces attached to instances created in the
        /// specified subnet should be assigned a public IPv4 address.</p>
        pub fn map_public_ip_on_launch(
            mut self,
            input: crate::model::AttributeBooleanValue,
        ) -> Self {
            self.inner = self.inner.map_public_ip_on_launch(input);
            self
        }
        pub fn set_map_public_ip_on_launch(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_map_public_ip_on_launch(input);
            self
        }
        /// <p>The ID of the subnet.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>Specify <code>true</code> to indicate that network interfaces  attached to instances created in the
        /// specified subnet should be assigned a customer-owned IPv4 address.</p>
        /// <p>When this value is <code>true</code>, you must specify the customer-owned IP pool using <code>CustomerOwnedIpv4Pool</code>.</p>
        pub fn map_customer_owned_ip_on_launch(
            mut self,
            input: crate::model::AttributeBooleanValue,
        ) -> Self {
            self.inner = self.inner.map_customer_owned_ip_on_launch(input);
            self
        }
        pub fn set_map_customer_owned_ip_on_launch(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_map_customer_owned_ip_on_launch(input);
            self
        }
        /// <p>The customer-owned IPv4 address pool associated with the subnet.</p>
        /// <p>You must set this value when you specify <code>true</code> for <code>MapCustomerOwnedIpOnLaunch</code>.</p>
        pub fn customer_owned_ipv4_pool(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_owned_ipv4_pool(input);
            self
        }
        pub fn set_customer_owned_ipv4_pool(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_owned_ipv4_pool(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTrafficMirrorFilterNetworkServices<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_traffic_mirror_filter_network_services_input::Builder,
    }
    impl<C> ModifyTrafficMirrorFilterNetworkServices<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTrafficMirrorFilterNetworkServicesOutput,
            smithy_http::result::SdkError<
                crate::error::ModifyTrafficMirrorFilterNetworkServicesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_id(input);
            self
        }
        /// <p>The network service, for example Amazon DNS, that you want to mirror.</p>
        pub fn add_network_services(
            mut self,
            inp: impl Into<crate::model::TrafficMirrorNetworkService>,
        ) -> Self {
            self.inner = self.inner.add_network_services(inp);
            self
        }
        pub fn set_add_network_services(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorNetworkService>>,
        ) -> Self {
            self.inner = self.inner.set_add_network_services(input);
            self
        }
        /// <p>The network service, for example Amazon DNS, that you no longer want to mirror.</p>
        pub fn remove_network_services(
            mut self,
            inp: impl Into<crate::model::TrafficMirrorNetworkService>,
        ) -> Self {
            self.inner = self.inner.remove_network_services(inp);
            self
        }
        pub fn set_remove_network_services(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorNetworkService>>,
        ) -> Self {
            self.inner = self.inner.set_remove_network_services(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTrafficMirrorFilterRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_traffic_mirror_filter_rule_input::Builder,
    }
    impl<C> ModifyTrafficMirrorFilterRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTrafficMirrorFilterRuleOutput,
            smithy_http::result::SdkError<crate::error::ModifyTrafficMirrorFilterRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror rule.</p>
        pub fn traffic_mirror_filter_rule_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.traffic_mirror_filter_rule_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_rule_id(input);
            self
        }
        /// <p>The type of traffic (<code>ingress</code> | <code>egress</code>) to assign to the rule.</p>
        pub fn traffic_direction(mut self, input: crate::model::TrafficDirection) -> Self {
            self.inner = self.inner.traffic_direction(input);
            self
        }
        pub fn set_traffic_direction(
            mut self,
            input: std::option::Option<crate::model::TrafficDirection>,
        ) -> Self {
            self.inner = self.inner.set_traffic_direction(input);
            self
        }
        /// <p>The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given
        /// direction. The rules are processed in ascending order by rule number.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.inner = self.inner.rule_number(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_rule_number(input);
            self
        }
        /// <p>The action to assign to the rule.</p>
        pub fn rule_action(mut self, input: crate::model::TrafficMirrorRuleAction) -> Self {
            self.inner = self.inner.rule_action(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorRuleAction>,
        ) -> Self {
            self.inner = self.inner.set_rule_action(input);
            self
        }
        /// <p>The destination ports that are associated with the Traffic Mirror rule.</p>
        pub fn destination_port_range(
            mut self,
            input: crate::model::TrafficMirrorPortRangeRequest,
        ) -> Self {
            self.inner = self.inner.destination_port_range(input);
            self
        }
        pub fn set_destination_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_destination_port_range(input);
            self
        }
        /// <p>The port range to assign to the Traffic Mirror rule.</p>
        pub fn source_port_range(
            mut self,
            input: crate::model::TrafficMirrorPortRangeRequest,
        ) -> Self {
            self.inner = self.inner.source_port_range(input);
            self
        }
        pub fn set_source_port_range(
            mut self,
            input: std::option::Option<crate::model::TrafficMirrorPortRangeRequest>,
        ) -> Self {
            self.inner = self.inner.set_source_port_range(input);
            self
        }
        /// <p>The protocol, for example TCP, to assign to the Traffic Mirror rule.</p>
        pub fn protocol(mut self, input: i32) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>The destination CIDR block to assign to the Traffic Mirror rule.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The source CIDR block to assign to the Traffic Mirror rule.</p>
        pub fn source_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_cidr_block(input);
            self
        }
        pub fn set_source_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_cidr_block(input);
            self
        }
        /// <p>The description to assign to the Traffic Mirror rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The properties that you want to remove from the Traffic Mirror filter rule.</p>
        /// <p>When you remove a property from a Traffic Mirror filter rule, the property is set to the default.</p>
        pub fn remove_fields(
            mut self,
            inp: impl Into<crate::model::TrafficMirrorFilterRuleField>,
        ) -> Self {
            self.inner = self.inner.remove_fields(inp);
            self
        }
        pub fn set_remove_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorFilterRuleField>>,
        ) -> Self {
            self.inner = self.inner.set_remove_fields(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTrafficMirrorSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_traffic_mirror_session_input::Builder,
    }
    impl<C> ModifyTrafficMirrorSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTrafficMirrorSessionOutput,
            smithy_http::result::SdkError<crate::error::ModifyTrafficMirrorSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Traffic Mirror session.</p>
        pub fn traffic_mirror_session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_session_id(input);
            self
        }
        pub fn set_traffic_mirror_session_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_session_id(input);
            self
        }
        /// <p>The Traffic Mirror target. The target must be in the same VPC as the source, or have a VPC peering connection with the source.</p>
        pub fn traffic_mirror_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_target_id(input);
            self
        }
        pub fn set_traffic_mirror_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_target_id(input);
            self
        }
        /// <p>The ID of the Traffic Mirror filter.</p>
        pub fn traffic_mirror_filter_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.traffic_mirror_filter_id(input);
            self
        }
        pub fn set_traffic_mirror_filter_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_traffic_mirror_filter_id(input);
            self
        }
        /// <p>The number of bytes in each packet to mirror. These are bytes after the VXLAN header. To mirror a subset, set this to the length (in bytes) to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. Do not specify this parameter when you want to mirror the entire packet.</p>
        pub fn packet_length(mut self, input: i32) -> Self {
            self.inner = self.inner.packet_length(input);
            self
        }
        pub fn set_packet_length(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_packet_length(input);
            self
        }
        /// <p>The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets.</p>
        /// <p>Valid values are 1-32766.</p>
        pub fn session_number(mut self, input: i32) -> Self {
            self.inner = self.inner.session_number(input);
            self
        }
        pub fn set_session_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_session_number(input);
            self
        }
        /// <p>The virtual network ID of the Traffic Mirror session.</p>
        pub fn virtual_network_id(mut self, input: i32) -> Self {
            self.inner = self.inner.virtual_network_id(input);
            self
        }
        pub fn set_virtual_network_id(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_virtual_network_id(input);
            self
        }
        /// <p>The description to assign to the Traffic Mirror session.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The properties that you want to remove from the Traffic Mirror session.</p>
        /// <p>When you remove a property from a Traffic Mirror session, the property is set to the default.</p>
        pub fn remove_fields(
            mut self,
            inp: impl Into<crate::model::TrafficMirrorSessionField>,
        ) -> Self {
            self.inner = self.inner.remove_fields(inp);
            self
        }
        pub fn set_remove_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TrafficMirrorSessionField>>,
        ) -> Self {
            self.inner = self.inner.set_remove_fields(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTransitGateway<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_transit_gateway_input::Builder,
    }
    impl<C> ModifyTransitGateway<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTransitGatewayOutput,
            smithy_http::result::SdkError<crate::error::ModifyTransitGatewayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The description for the transit gateway.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The options to modify.</p>
        pub fn options(mut self, input: crate::model::ModifyTransitGatewayOptions) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::ModifyTransitGatewayOptions>,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTransitGatewayPrefixListReference<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_transit_gateway_prefix_list_reference_input::Builder,
    }
    impl<C> ModifyTransitGatewayPrefixListReference<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTransitGatewayPrefixListReferenceOutput,
            smithy_http::result::SdkError<
                crate::error::ModifyTransitGatewayPrefixListReferenceError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The ID of the attachment to which traffic is routed.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Indicates whether to drop traffic that matches this route.</p>
        pub fn blackhole(mut self, input: bool) -> Self {
            self.inner = self.inner.blackhole(input);
            self
        }
        pub fn set_blackhole(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_blackhole(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyTransitGatewayVpcAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_transit_gateway_vpc_attachment_input::Builder,
    }
    impl<C> ModifyTransitGatewayVpcAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyTransitGatewayVpcAttachmentOutput,
            smithy_http::result::SdkError<crate::error::ModifyTransitGatewayVpcAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.</p>
        pub fn add_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_subnet_ids(inp);
            self
        }
        pub fn set_add_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_subnet_ids(input);
            self
        }
        /// <p>The IDs of one or more subnets to remove.</p>
        pub fn remove_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_subnet_ids(inp);
            self
        }
        pub fn set_remove_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_subnet_ids(input);
            self
        }
        /// <p>The new VPC attachment options.</p>
        /// <note>
        /// <p>You cannot modify the IPv6 options.</p>
        /// </note>
        pub fn options(
            mut self,
            input: crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions,
        ) -> Self {
            self.inner = self.inner.options(input);
            self
        }
        pub fn set_options(
            mut self,
            input: std::option::Option<
                crate::model::ModifyTransitGatewayVpcAttachmentRequestOptions,
            >,
        ) -> Self {
            self.inner = self.inner.set_options(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVolume<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_volume_input::Builder,
    }
    impl<C> ModifyVolume<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVolumeOutput,
            smithy_http::result::SdkError<crate::error::ModifyVolumeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>The target size of the volume, in GiB. The target volume size must be greater than or
        /// equal to the existing size of the volume.</p>
        /// <p>The following are the supported volumes sizes for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code> and <code>io2</code>: 4-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>standard</code>: 1-1,024</p>
        /// </li>
        /// </ul>
        /// <p>Default: If no size is specified, the existing size is retained.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.inner = self.inner.size(input);
            self
        }
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_size(input);
            self
        }
        /// <p>The target EBS volume type of the volume. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS volume types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        /// <p>Default: If no type is specified, the existing type is retained.</p>
        pub fn volume_type(mut self, input: crate::model::VolumeType) -> Self {
            self.inner = self.inner.volume_type(input);
            self
        }
        pub fn set_volume_type(
            mut self,
            input: std::option::Option<crate::model::VolumeType>,
        ) -> Self {
            self.inner = self.inner.set_volume_type(input);
            self
        }
        /// <p>The target IOPS rate of the volume. This parameter is valid only for <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes.</p>
        /// <p>The following are the supported values for each volume type:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp3</code>: 3,000-16,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 100-64,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io2</code>: 100-64,000 IOPS</p>
        /// </li>
        /// </ul>
        /// <p>Default: If no IOPS value is specified, the existing value is retained, unless a volume type is modified that supports different values.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.inner = self.inner.iops(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_iops(input);
            self
        }
        /// <p>The target throughput of the volume, in MiB/s. This parameter is valid only for <code>gp3</code> volumes.
        /// The maximum value is 1,000.</p>
        /// <p>Default: If no throughput value is specified, the existing value is retained.</p>
        /// <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.inner = self.inner.throughput(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_throughput(input);
            self
        }
        /// <p>Specifies whether to enable Amazon EBS Multi-Attach. If you enable Multi-Attach, you can attach the
        /// volume to up to 16 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">
        /// Nitro-based instances</a> in the same Availability Zone. This parameter is
        /// supported with <code>io1</code> and <code>io2</code> volumes only. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html">
        /// Amazon EBS Multi-Attach</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn multi_attach_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.multi_attach_enabled(input);
            self
        }
        pub fn set_multi_attach_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_multi_attach_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVolumeAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_volume_attribute_input::Builder,
    }
    impl<C> ModifyVolumeAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVolumeAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyVolumeAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether the volume should be auto-enabled for I/O operations.</p>
        pub fn auto_enable_io(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.auto_enable_io(input);
            self
        }
        pub fn set_auto_enable_io(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_auto_enable_io(input);
            self
        }
        /// <p>The ID of the volume.</p>
        pub fn volume_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.volume_id(input);
            self
        }
        pub fn set_volume_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_volume_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_attribute_input::Builder,
    }
    impl<C> ModifyVpcAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcAttributeOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not.</p>
        /// <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.</p>
        pub fn enable_dns_hostnames(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.enable_dns_hostnames(input);
            self
        }
        pub fn set_enable_dns_hostnames(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_enable_dns_hostnames(input);
            self
        }
        /// <p>Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to
        /// the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP
        /// address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon
        /// provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is
        /// not enabled.</p>
        /// <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.</p>
        pub fn enable_dns_support(mut self, input: crate::model::AttributeBooleanValue) -> Self {
            self.inner = self.inner.enable_dns_support(input);
            self
        }
        pub fn set_enable_dns_support(
            mut self,
            input: std::option::Option<crate::model::AttributeBooleanValue>,
        ) -> Self {
            self.inner = self.inner.set_enable_dns_support(input);
            self
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcEndpoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_endpoint_input::Builder,
    }
    impl<C> ModifyVpcEndpoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcEndpointOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcEndpointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the endpoint.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_id(input);
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_id(input);
            self
        }
        /// <p>(Gateway endpoint) Specify <code>true</code> to reset the policy document to the
        /// default policy. The default policy allows full access to the service.</p>
        pub fn reset_policy(mut self, input: bool) -> Self {
            self.inner = self.inner.reset_policy(input);
            self
        }
        pub fn set_reset_policy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_reset_policy(input);
            self
        }
        /// <p>(Interface and gateway endpoints) A policy to attach to the endpoint that controls access to the service. The policy must
        /// be in valid JSON format.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
        /// <p>(Gateway endpoint) One or more route tables IDs to associate with the endpoint.</p>
        pub fn add_route_table_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_route_table_ids(inp);
            self
        }
        pub fn set_add_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_route_table_ids(input);
            self
        }
        /// <p>(Gateway endpoint) One or more route table IDs to disassociate from the endpoint.</p>
        pub fn remove_route_table_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_route_table_ids(inp);
            self
        }
        pub fn set_remove_route_table_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_route_table_ids(input);
            self
        }
        /// <p>(Interface and Gateway Load Balancer endpoints) One or more subnet IDs in which to serve the endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.</p>
        pub fn add_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_subnet_ids(inp);
            self
        }
        pub fn set_add_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_subnet_ids(input);
            self
        }
        /// <p>(Interface endpoint) One or more subnets IDs in which to remove the endpoint.</p>
        pub fn remove_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_subnet_ids(inp);
            self
        }
        pub fn set_remove_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_subnet_ids(input);
            self
        }
        /// <p>(Interface endpoint) One or more security group IDs to associate with the network interface.</p>
        pub fn add_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_security_group_ids(inp);
            self
        }
        pub fn set_add_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_security_group_ids(input);
            self
        }
        /// <p>(Interface endpoint) One or more security group IDs to disassociate from the network interface.</p>
        pub fn remove_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_security_group_ids(inp);
            self
        }
        pub fn set_remove_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_security_group_ids(input);
            self
        }
        /// <p>(Interface endpoint) Indicates whether a private hosted zone is associated with the
        /// VPC.</p>
        pub fn private_dns_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.private_dns_enabled(input);
            self
        }
        pub fn set_private_dns_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_private_dns_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcEndpointConnectionNotification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_endpoint_connection_notification_input::Builder,
    }
    impl<C> ModifyVpcEndpointConnectionNotification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcEndpointConnectionNotificationOutput,
            smithy_http::result::SdkError<
                crate::error::ModifyVpcEndpointConnectionNotificationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the notification.</p>
        pub fn connection_notification_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_notification_id(input);
            self
        }
        pub fn set_connection_notification_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_notification_id(input);
            self
        }
        /// <p>The ARN for the SNS topic for the notification.</p>
        pub fn connection_notification_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.connection_notification_arn(input);
            self
        }
        pub fn set_connection_notification_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_notification_arn(input);
            self
        }
        /// <p>One or more events for the endpoint. Valid values are <code>Accept</code>,
        /// <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>
        pub fn connection_events(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_events(inp);
            self
        }
        pub fn set_connection_events(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_connection_events(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcEndpointServiceConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_endpoint_service_configuration_input::Builder,
    }
    impl<C> ModifyVpcEndpointServiceConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcEndpointServiceConfigurationOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcEndpointServiceConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>(Interface endpoint configuration) The private DNS name to assign to the endpoint service.</p>
        pub fn private_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_dns_name(input);
            self
        }
        pub fn set_private_dns_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_private_dns_name(input);
            self
        }
        /// <p>(Interface endpoint configuration) Removes the private DNS name of the endpoint service.</p>
        pub fn remove_private_dns_name(mut self, input: bool) -> Self {
            self.inner = self.inner.remove_private_dns_name(input);
            self
        }
        pub fn set_remove_private_dns_name(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_remove_private_dns_name(input);
            self
        }
        /// <p>Indicates whether requests to create an endpoint to your service must be accepted.</p>
        pub fn acceptance_required(mut self, input: bool) -> Self {
            self.inner = self.inner.acceptance_required(input);
            self
        }
        pub fn set_acceptance_required(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_acceptance_required(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of Network Load Balancers to add to your service
        /// configuration.</p>
        pub fn add_network_load_balancer_arns(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.add_network_load_balancer_arns(inp);
            self
        }
        pub fn set_add_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_network_load_balancer_arns(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of Network Load Balancers to remove from your service
        /// configuration.</p>
        pub fn remove_network_load_balancer_arns(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.remove_network_load_balancer_arns(inp);
            self
        }
        pub fn set_remove_network_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_network_load_balancer_arns(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of Gateway Load Balancers to add to your service
        /// configuration.</p>
        pub fn add_gateway_load_balancer_arns(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.add_gateway_load_balancer_arns(inp);
            self
        }
        pub fn set_add_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_gateway_load_balancer_arns(input);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of Gateway Load Balancers to remove from your service
        /// configuration.</p>
        pub fn remove_gateway_load_balancer_arns(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.remove_gateway_load_balancer_arns(inp);
            self
        }
        pub fn set_remove_gateway_load_balancer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_gateway_load_balancer_arns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcEndpointServicePermissions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_endpoint_service_permissions_input::Builder,
    }
    impl<C> ModifyVpcEndpointServicePermissions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcEndpointServicePermissionsOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcEndpointServicePermissionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of one or more principals.
        /// Permissions are granted to the principals in this list.
        /// To grant permissions to all principals, specify an asterisk (*).</p>
        pub fn add_allowed_principals(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.add_allowed_principals(inp);
            self
        }
        pub fn set_add_allowed_principals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_add_allowed_principals(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of one or more principals.
        /// Permissions are revoked for principals in this list.</p>
        pub fn remove_allowed_principals(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_allowed_principals(inp);
            self
        }
        pub fn set_remove_allowed_principals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_allowed_principals(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcPeeringConnectionOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_peering_connection_options_input::Builder,
    }
    impl<C> ModifyVpcPeeringConnectionOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcPeeringConnectionOptionsOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcPeeringConnectionOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The VPC peering connection options for the accepter VPC.</p>
        pub fn accepter_peering_connection_options(
            mut self,
            input: crate::model::PeeringConnectionOptionsRequest,
        ) -> Self {
            self.inner = self.inner.accepter_peering_connection_options(input);
            self
        }
        pub fn set_accepter_peering_connection_options(
            mut self,
            input: std::option::Option<crate::model::PeeringConnectionOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_accepter_peering_connection_options(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The VPC peering connection options for the requester VPC.</p>
        pub fn requester_peering_connection_options(
            mut self,
            input: crate::model::PeeringConnectionOptionsRequest,
        ) -> Self {
            self.inner = self.inner.requester_peering_connection_options(input);
            self
        }
        pub fn set_requester_peering_connection_options(
            mut self,
            input: std::option::Option<crate::model::PeeringConnectionOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_requester_peering_connection_options(input);
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpcTenancy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpc_tenancy_input::Builder,
    }
    impl<C> ModifyVpcTenancy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpcTenancyOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpcTenancyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPC.</p>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_id(input);
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_vpc_id(input);
            self
        }
        /// <p>The instance tenancy attribute for the VPC. </p>
        pub fn instance_tenancy(mut self, input: crate::model::VpcTenancy) -> Self {
            self.inner = self.inner.instance_tenancy(input);
            self
        }
        pub fn set_instance_tenancy(
            mut self,
            input: std::option::Option<crate::model::VpcTenancy>,
        ) -> Self {
            self.inner = self.inner.set_instance_tenancy(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpnConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpn_connection_input::Builder,
    }
    impl<C> ModifyVpnConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpnConnectionOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpnConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
        /// <p>The ID of the transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The ID of the customer gateway at your end of the VPN connection.</p>
        pub fn customer_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.customer_gateway_id(input);
            self
        }
        pub fn set_customer_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_customer_gateway_id(input);
            self
        }
        /// <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
        pub fn vpn_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_gateway_id(input);
            self
        }
        pub fn set_vpn_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_gateway_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpnConnectionOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpn_connection_options_input::Builder,
    }
    impl<C> ModifyVpnConnectionOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpnConnectionOptionsOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpnConnectionOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Site-to-Site VPN connection.
        /// </p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
        /// <p>The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        /// <p>Default: <code>0.0.0.0/0</code>
        /// </p>
        pub fn local_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_ipv4_network_cidr(input);
            self
        }
        pub fn set_local_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_ipv4_network_cidr(input);
            self
        }
        /// <p>The IPv4 CIDR on the AWS side of the VPN connection.</p>
        /// <p>Default: <code>0.0.0.0/0</code>
        /// </p>
        pub fn remote_ipv4_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_ipv4_network_cidr(input);
            self
        }
        pub fn set_remote_ipv4_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_ipv4_network_cidr(input);
            self
        }
        /// <p>The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection.</p>
        /// <p>Default: <code>::/0</code>
        /// </p>
        pub fn local_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_ipv6_network_cidr(input);
            self
        }
        pub fn set_local_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_ipv6_network_cidr(input);
            self
        }
        /// <p>The IPv6 CIDR on the AWS side of the VPN connection.</p>
        /// <p>Default: <code>::/0</code>
        /// </p>
        pub fn remote_ipv6_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remote_ipv6_network_cidr(input);
            self
        }
        pub fn set_remote_ipv6_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remote_ipv6_network_cidr(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpnTunnelCertificate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpn_tunnel_certificate_input::Builder,
    }
    impl<C> ModifyVpnTunnelCertificate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpnTunnelCertificateOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpnTunnelCertificateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AWS Site-to-Site VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
        /// <p>The external IP address of the VPN tunnel.</p>
        pub fn vpn_tunnel_outside_ip_address(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.vpn_tunnel_outside_ip_address(input);
            self
        }
        pub fn set_vpn_tunnel_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_tunnel_outside_ip_address(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyVpnTunnelOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_vpn_tunnel_options_input::Builder,
    }
    impl<C> ModifyVpnTunnelOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyVpnTunnelOptionsOutput,
            smithy_http::result::SdkError<crate::error::ModifyVpnTunnelOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the AWS Site-to-Site VPN connection.</p>
        pub fn vpn_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpn_connection_id(input);
            self
        }
        pub fn set_vpn_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_connection_id(input);
            self
        }
        /// <p>The external IP address of the VPN tunnel.</p>
        pub fn vpn_tunnel_outside_ip_address(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.vpn_tunnel_outside_ip_address(input);
            self
        }
        pub fn set_vpn_tunnel_outside_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpn_tunnel_outside_ip_address(input);
            self
        }
        /// <p>The tunnel options to modify.</p>
        pub fn tunnel_options(
            mut self,
            input: crate::model::ModifyVpnTunnelOptionsSpecification,
        ) -> Self {
            self.inner = self.inner.tunnel_options(input);
            self
        }
        pub fn set_tunnel_options(
            mut self,
            input: std::option::Option<crate::model::ModifyVpnTunnelOptionsSpecification>,
        ) -> Self {
            self.inner = self.inner.set_tunnel_options(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MonitorInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::monitor_instances_input::Builder,
    }
    impl<C> MonitorInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MonitorInstancesOutput,
            smithy_http::result::SdkError<crate::error::MonitorInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MoveAddressToVpc<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::move_address_to_vpc_input::Builder,
    }
    impl<C> MoveAddressToVpc<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MoveAddressToVpcOutput,
            smithy_http::result::SdkError<crate::error::MoveAddressToVpcError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The Elastic IP address.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ProvisionByoipCidr<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::provision_byoip_cidr_input::Builder,
    }
    impl<C> ProvisionByoipCidr<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ProvisionByoipCidrOutput,
            smithy_http::result::SdkError<crate::error::ProvisionByoipCidrError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The public IPv4 or IPv6 address range, in CIDR notation. The most specific IPv4 prefix that you can
        /// specify is /24. The most specific IPv6 prefix you can specify is /56. The address range cannot overlap with another address range that you've
        /// brought to this or another Region.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr(input);
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr(input);
            self
        }
        /// <p>A signed document that proves that you are authorized to bring the specified IP address
        /// range to Amazon using BYOIP.</p>
        pub fn cidr_authorization_context(
            mut self,
            input: crate::model::CidrAuthorizationContext,
        ) -> Self {
            self.inner = self.inner.cidr_authorization_context(input);
            self
        }
        pub fn set_cidr_authorization_context(
            mut self,
            input: std::option::Option<crate::model::CidrAuthorizationContext>,
        ) -> Self {
            self.inner = self.inner.set_cidr_authorization_context(input);
            self
        }
        /// <p>(IPv6 only) Indicate whether the address range will be publicly advertised to the
        /// internet.</p>
        /// <p>Default: true</p>
        pub fn publicly_advertisable(mut self, input: bool) -> Self {
            self.inner = self.inner.publicly_advertisable(input);
            self
        }
        pub fn set_publicly_advertisable(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_publicly_advertisable(input);
            self
        }
        /// <p>A description for the address range and the address pool.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to apply to the address pool.</p>
        pub fn pool_tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.pool_tag_specifications(inp);
            self
        }
        pub fn set_pool_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_pool_tag_specifications(input);
            self
        }
        /// <para>Reserved.</para>
        pub fn multi_region(mut self, input: bool) -> Self {
            self.inner = self.inner.multi_region(input);
            self
        }
        pub fn set_multi_region(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_multi_region(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseHostReservation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_host_reservation_input::Builder,
    }
    impl<C> PurchaseHostReservation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PurchaseHostReservationOutput,
            smithy_http::result::SdkError<crate::error::PurchaseHostReservationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The currency in which the <code>totalUpfrontPrice</code>, <code>LimitPrice</code>,
        /// and <code>totalHourlyPrice</code> amounts are specified. At this time, the only
        /// supported currency is <code>USD</code>.</p>
        pub fn currency_code(mut self, input: crate::model::CurrencyCodeValues) -> Self {
            self.inner = self.inner.currency_code(input);
            self
        }
        pub fn set_currency_code(
            mut self,
            input: std::option::Option<crate::model::CurrencyCodeValues>,
        ) -> Self {
            self.inner = self.inner.set_currency_code(input);
            self
        }
        /// <p>The IDs of the Dedicated Hosts with which the reservation will be associated.</p>
        pub fn host_id_set(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_id_set(inp);
            self
        }
        pub fn set_host_id_set(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_id_set(input);
            self
        }
        /// <p>The specified limit is checked against the total upfront cost of the reservation
        /// (calculated as the offering's upfront cost multiplied by the host count). If the total
        /// upfront cost is greater than the specified price limit, the request fails. This is used
        /// to ensure that the purchase does not exceed the expected upfront cost of the purchase.
        /// At this time, the only supported currency is <code>USD</code>. For example, to indicate
        /// a limit price of USD 100, specify 100.00.</p>
        pub fn limit_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.limit_price(input);
            self
        }
        pub fn set_limit_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_limit_price(input);
            self
        }
        /// <p>The ID of the offering.</p>
        pub fn offering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.offering_id(input);
            self
        }
        pub fn set_offering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_offering_id(input);
            self
        }
        /// <p>The tags to apply to the Dedicated Host Reservation during purchase.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseReservedInstancesOffering<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_reserved_instances_offering_input::Builder,
    }
    impl<C> PurchaseReservedInstancesOffering<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PurchaseReservedInstancesOfferingOutput,
            smithy_http::result::SdkError<crate::error::PurchaseReservedInstancesOfferingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The number of Reserved Instances to purchase.</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>The ID of the Reserved Instance offering to purchase.</p>
        pub fn reserved_instances_offering_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.reserved_instances_offering_id(input);
            self
        }
        pub fn set_reserved_instances_offering_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reserved_instances_offering_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.</p>
        pub fn limit_price(mut self, input: crate::model::ReservedInstanceLimitPrice) -> Self {
            self.inner = self.inner.limit_price(input);
            self
        }
        pub fn set_limit_price(
            mut self,
            input: std::option::Option<crate::model::ReservedInstanceLimitPrice>,
        ) -> Self {
            self.inner = self.inner.set_limit_price(input);
            self
        }
        /// <p>The time at which to purchase the Reserved Instance, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        pub fn purchase_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.purchase_time(input);
            self
        }
        pub fn set_purchase_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_purchase_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PurchaseScheduledInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::purchase_scheduled_instances_input::Builder,
    }
    impl<C> PurchaseScheduledInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PurchaseScheduledInstancesOutput,
            smithy_http::result::SdkError<crate::error::PurchaseScheduledInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that ensures the idempotency of the request.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The purchase requests.</p>
        pub fn purchase_requests(mut self, inp: impl Into<crate::model::PurchaseRequest>) -> Self {
            self.inner = self.inner.purchase_requests(inp);
            self
        }
        pub fn set_purchase_requests(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PurchaseRequest>>,
        ) -> Self {
            self.inner = self.inner.set_purchase_requests(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RebootInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reboot_instances_input::Builder,
    }
    impl<C> RebootInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RebootInstancesOutput,
            smithy_http::result::SdkError<crate::error::RebootInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The instance IDs.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_image_input::Builder,
    }
    impl<C> RegisterImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterImageOutput,
            smithy_http::result::SdkError<crate::error::RegisterImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The full path to your AMI manifest in Amazon S3 storage. The specified bucket must have the
        /// <code>aws-exec-read</code> canned access control list (ACL) to ensure that it can be accessed
        /// by Amazon EC2. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">Canned ACLs</a> in the
        /// <i>Amazon S3 Service Developer Guide</i>.</p>
        pub fn image_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_location(input);
            self
        }
        pub fn set_image_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_image_location(input);
            self
        }
        /// <p>The architecture of the AMI.</p>
        /// <p>Default: For Amazon EBS-backed AMIs, <code>i386</code>.
        /// For instance store-backed AMIs, the architecture specified in the manifest file.</p>
        pub fn architecture(mut self, input: crate::model::ArchitectureValues) -> Self {
            self.inner = self.inner.architecture(input);
            self
        }
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::ArchitectureValues>,
        ) -> Self {
            self.inner = self.inner.set_architecture(input);
            self
        }
        /// <p>The block device mapping entries.</p>
        /// <p>If you specify an EBS volume using the ID of an EBS snapshot, you can't specify the encryption state of the volume.</p>
        /// <p>If you create an AMI on an Outpost, then all backing snapshots must be on the same Outpost or in the Region
        /// of that Outpost. AMIs on an Outpost that include local snapshots can be used to launch instances on the same Outpost
        /// only. For more information, <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshots-outposts.html#ami">
        /// Amazon EBS local snapshots on Outposts</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p>A description for your AMI.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Set to <code>true</code> to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI.</p>
        /// <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
        pub fn ena_support(mut self, input: bool) -> Self {
            self.inner = self.inner.ena_support(input);
            self
        }
        pub fn set_ena_support(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ena_support(input);
            self
        }
        /// <p>The ID of the kernel.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kernel_id(input);
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kernel_id(input);
            self
        }
        /// <p>A name for your AMI.</p>
        /// <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The billing product codes. Your account must be authorized to specify billing product codes. Otherwise,
        /// you can use the AWS Marketplace to bill for the use of an AMI.</p>
        pub fn billing_products(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.billing_products(inp);
            self
        }
        pub fn set_billing_products(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_billing_products(input);
            self
        }
        /// <p>The ID of the RAM disk.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ramdisk_id(input);
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ramdisk_id(input);
            self
        }
        /// <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        pub fn root_device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.root_device_name(input);
            self
        }
        pub fn set_root_device_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_root_device_name(input);
            self
        }
        /// <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.</p>
        /// <p>There is no way to disable <code>sriovNetSupport</code> at this time.</p>
        /// <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
        pub fn sriov_net_support(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sriov_net_support(input);
            self
        }
        pub fn set_sriov_net_support(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sriov_net_support(input);
            self
        }
        /// <p>The type of virtualization (<code>hvm</code> | <code>paravirtual</code>).</p>
        /// <p>Default: <code>paravirtual</code>
        /// </p>
        pub fn virtualization_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.virtualization_type(input);
            self
        }
        pub fn set_virtualization_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_virtualization_type(input);
            self
        }
        /// <p>The boot mode of the AMI. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html">Boot modes</a> in the
        /// <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        pub fn boot_mode(mut self, input: crate::model::BootModeValues) -> Self {
            self.inner = self.inner.boot_mode(input);
            self
        }
        pub fn set_boot_mode(
            mut self,
            input: std::option::Option<crate::model::BootModeValues>,
        ) -> Self {
            self.inner = self.inner.set_boot_mode(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterInstanceEventNotificationAttributes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_instance_event_notification_attributes_input::Builder,
    }
    impl<C> RegisterInstanceEventNotificationAttributes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterInstanceEventNotificationAttributesOutput,
            smithy_http::result::SdkError<
                crate::error::RegisterInstanceEventNotificationAttributesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Information about the tag keys to register.</p>
        pub fn instance_tag_attribute(
            mut self,
            input: crate::model::RegisterInstanceTagAttributeRequest,
        ) -> Self {
            self.inner = self.inner.instance_tag_attribute(input);
            self
        }
        pub fn set_instance_tag_attribute(
            mut self,
            input: std::option::Option<crate::model::RegisterInstanceTagAttributeRequest>,
        ) -> Self {
            self.inner = self.inner.set_instance_tag_attribute(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterTransitGatewayMulticastGroupMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_transit_gateway_multicast_group_members_input::Builder,
    }
    impl<C> RegisterTransitGatewayMulticastGroupMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterTransitGatewayMulticastGroupMembersOutput,
            smithy_http::result::SdkError<
                crate::error::RegisterTransitGatewayMulticastGroupMembersError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ip_address(input);
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_group_ip_address(input);
            self
        }
        /// <p>The group members' network interface IDs to register with the  transit gateway multicast group.</p>
        pub fn network_interface_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_ids(inp);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterTransitGatewayMulticastGroupSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_transit_gateway_multicast_group_sources_input::Builder,
    }
    impl<C> RegisterTransitGatewayMulticastGroupSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterTransitGatewayMulticastGroupSourcesOutput,
            smithy_http::result::SdkError<
                crate::error::RegisterTransitGatewayMulticastGroupSourcesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The IP address assigned to the  transit gateway multicast group.</p>
        pub fn group_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_ip_address(input);
            self
        }
        pub fn set_group_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_group_ip_address(input);
            self
        }
        /// <p>The group sources' network interface IDs to register with the  transit gateway multicast group.</p>
        pub fn network_interface_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_ids(inp);
            self
        }
        pub fn set_network_interface_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectTransitGatewayMulticastDomainAssociations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_transit_gateway_multicast_domain_associations_input::Builder,
    }
    impl<C> RejectTransitGatewayMulticastDomainAssociations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectTransitGatewayMulticastDomainAssociationsOutput,
            smithy_http::result::SdkError<
                crate::error::RejectTransitGatewayMulticastDomainAssociationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>The IDs of the subnets to associate with the transit gateway multicast domain.</p>
        pub fn subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_ids(inp);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnet_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectTransitGatewayPeeringAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_transit_gateway_peering_attachment_input::Builder,
    }
    impl<C> RejectTransitGatewayPeeringAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectTransitGatewayPeeringAttachmentOutput,
            smithy_http::result::SdkError<crate::error::RejectTransitGatewayPeeringAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway peering attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectTransitGatewayVpcAttachment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_transit_gateway_vpc_attachment_input::Builder,
    }
    impl<C> RejectTransitGatewayVpcAttachment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectTransitGatewayVpcAttachmentOutput,
            smithy_http::result::SdkError<crate::error::RejectTransitGatewayVpcAttachmentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectVpcEndpointConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_vpc_endpoint_connections_input::Builder,
    }
    impl<C> RejectVpcEndpointConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectVpcEndpointConnectionsOutput,
            smithy_http::result::SdkError<crate::error::RejectVpcEndpointConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
        /// <p>The IDs of one or more VPC endpoints.</p>
        pub fn vpc_endpoint_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_ids(inp);
            self
        }
        pub fn set_vpc_endpoint_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectVpcPeeringConnection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_vpc_peering_connection_input::Builder,
    }
    impl<C> RejectVpcPeeringConnection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectVpcPeeringConnectionOutput,
            smithy_http::result::SdkError<crate::error::RejectVpcPeeringConnectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReleaseAddress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::release_address_input::Builder,
    }
    impl<C> ReleaseAddress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReleaseAddressOutput,
            smithy_http::result::SdkError<crate::error::ReleaseAddressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The allocation ID. Required for EC2-VPC.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_id(input);
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allocation_id(input);
            self
        }
        /// <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
        /// <p>The set of Availability Zones, Local Zones, or Wavelength Zones from which AWS advertises
        /// IP addresses.</p>
        /// <p>If you provide an incorrect network border group, you will receive an <code>InvalidAddress.NotFound</code> error. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
        /// <note>
        /// <p>You cannot use a network border group with EC2 Classic. If you attempt this operation on EC2 classic, you will receive an <code>InvalidParameterCombination</code> error. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
        /// </note>
        pub fn network_border_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_border_group(input);
            self
        }
        pub fn set_network_border_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_border_group(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReleaseHosts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::release_hosts_input::Builder,
    }
    impl<C> ReleaseHosts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReleaseHostsOutput,
            smithy_http::result::SdkError<crate::error::ReleaseHostsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the Dedicated Hosts to release.</p>
        pub fn host_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_ids(inp);
            self
        }
        pub fn set_host_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_host_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceIamInstanceProfileAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_iam_instance_profile_association_input::Builder,
    }
    impl<C> ReplaceIamInstanceProfileAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceIamInstanceProfileAssociationOutput,
            smithy_http::result::SdkError<crate::error::ReplaceIamInstanceProfileAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.inner = self.inner.iam_instance_profile(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.inner = self.inner.set_iam_instance_profile(input);
            self
        }
        /// <p>The ID of the existing IAM instance profile association.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceNetworkAclAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_network_acl_association_input::Builder,
    }
    impl<C> ReplaceNetworkAclAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceNetworkAclAssociationOutput,
            smithy_http::result::SdkError<crate::error::ReplaceNetworkAclAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the current association between the original network ACL and the subnet.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the new network ACL to associate with the subnet.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_id(input);
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceNetworkAclEntry<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_network_acl_entry_input::Builder,
    }
    impl<C> ReplaceNetworkAclEntry<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceNetworkAclEntryOutput,
            smithy_http::result::SdkError<crate::error::ReplaceNetworkAclEntryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 network range to allow or deny, in CIDR notation (for example
        /// <code>172.16.0.0/24</code>).</p>
        pub fn cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_block(input);
            self
        }
        pub fn set_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_block(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether to replace the egress rule.</p>
        /// <p>Default: If no value is specified, we replace the ingress rule.</p>
        pub fn egress(mut self, input: bool) -> Self {
            self.inner = self.inner.egress(input);
            self
        }
        pub fn set_egress(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_egress(input);
            self
        }
        /// <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying protocol
        /// 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
        pub fn icmp_type_code(mut self, input: crate::model::IcmpTypeCode) -> Self {
            self.inner = self.inner.icmp_type_code(input);
            self
        }
        pub fn set_icmp_type_code(
            mut self,
            input: std::option::Option<crate::model::IcmpTypeCode>,
        ) -> Self {
            self.inner = self.inner.set_icmp_type_code(input);
            self
        }
        /// <p>The IPv6 network range to allow or deny, in CIDR notation (for example
        /// <code>2001:bd8:1234:1a00::/64</code>).</p>
        pub fn ipv6_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_cidr_block(input);
            self
        }
        pub fn set_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of the ACL.</p>
        pub fn network_acl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_acl_id(input);
            self
        }
        pub fn set_network_acl_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_acl_id(input);
            self
        }
        /// <p>TCP or UDP protocols: The range of ports the rule applies to.
        /// Required if specifying protocol 6 (TCP) or 17 (UDP).</p>
        pub fn port_range(mut self, input: crate::model::PortRange) -> Self {
            self.inner = self.inner.port_range(input);
            self
        }
        pub fn set_port_range(
            mut self,
            input: std::option::Option<crate::model::PortRange>,
        ) -> Self {
            self.inner = self.inner.set_port_range(input);
            self
        }
        /// <p>The protocol number. A value of "-1" means all protocols. If you specify "-1" or a
        /// protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is
        /// allowed, regardless of any ports or ICMP types or codes that you specify. If you specify
        /// protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and
        /// codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6)
        /// and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
        pub fn protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.protocol(input);
            self
        }
        pub fn set_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_protocol(input);
            self
        }
        /// <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
        pub fn rule_action(mut self, input: crate::model::RuleAction) -> Self {
            self.inner = self.inner.rule_action(input);
            self
        }
        pub fn set_rule_action(
            mut self,
            input: std::option::Option<crate::model::RuleAction>,
        ) -> Self {
            self.inner = self.inner.set_rule_action(input);
            self
        }
        /// <p>The rule number of the entry to replace.</p>
        pub fn rule_number(mut self, input: i32) -> Self {
            self.inner = self.inner.rule_number(input);
            self
        }
        pub fn set_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_rule_number(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_route_input::Builder,
    }
    impl<C> ReplaceRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceRouteOutput,
            smithy_http::result::SdkError<crate::error::ReplaceRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IPv4 CIDR address block used for the destination match. The value that you
        /// provide must match the CIDR of an existing route in the table.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The IPv6 CIDR address block used for the destination match. The value that you
        /// provide must match the CIDR of an existing route in the table.</p>
        pub fn destination_ipv6_cidr_block(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_ipv6_cidr_block(input);
            self
        }
        pub fn set_destination_ipv6_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_ipv6_cidr_block(input);
            self
        }
        /// <p>The ID of the prefix list for the route.</p>
        pub fn destination_prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_prefix_list_id(input);
            self
        }
        pub fn set_destination_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_prefix_list_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.</p>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_endpoint_id(input);
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_endpoint_id(input);
            self
        }
        /// <p>[IPv6 traffic only] The ID of an egress-only internet gateway.</p>
        pub fn egress_only_internet_gateway_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.egress_only_internet_gateway_id(input);
            self
        }
        pub fn set_egress_only_internet_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_egress_only_internet_gateway_id(input);
            self
        }
        /// <p>The ID of an internet gateway or virtual private gateway.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.gateway_id(input);
            self
        }
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_gateway_id(input);
            self
        }
        /// <p>The ID of a NAT instance in your VPC.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Specifies whether to reset the local route to its default target (<code>local</code>).</p>
        pub fn local_target(mut self, input: bool) -> Self {
            self.inner = self.inner.local_target(input);
            self
        }
        pub fn set_local_target(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_local_target(input);
            self
        }
        /// <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
        pub fn nat_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nat_gateway_id(input);
            self
        }
        pub fn set_nat_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nat_gateway_id(input);
            self
        }
        /// <p>The ID of a transit gateway.</p>
        pub fn transit_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transit_gateway_id(input);
            self
        }
        pub fn set_transit_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_id(input);
            self
        }
        /// <p>The ID of the local gateway.</p>
        pub fn local_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.local_gateway_id(input);
            self
        }
        pub fn set_local_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_id(input);
            self
        }
        /// <p>[IPv4 traffic only] The ID of a carrier gateway.</p>
        pub fn carrier_gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.carrier_gateway_id(input);
            self
        }
        pub fn set_carrier_gateway_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_carrier_gateway_id(input);
            self
        }
        /// <p>The ID of a network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
        /// <p>The ID of a VPC peering connection.</p>
        pub fn vpc_peering_connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_peering_connection_id(input);
            self
        }
        pub fn set_vpc_peering_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_peering_connection_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceRouteTableAssociation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_route_table_association_input::Builder,
    }
    impl<C> ReplaceRouteTableAssociation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceRouteTableAssociationOutput,
            smithy_http::result::SdkError<crate::error::ReplaceRouteTableAssociationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The association ID.</p>
        pub fn association_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.association_id(input);
            self
        }
        pub fn set_association_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_association_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the new route table to associate with the subnet.</p>
        pub fn route_table_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.route_table_id(input);
            self
        }
        pub fn set_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_route_table_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplaceTransitGatewayRoute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::replace_transit_gateway_route_input::Builder,
    }
    impl<C> ReplaceTransitGatewayRoute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplaceTransitGatewayRouteOutput,
            smithy_http::result::SdkError<crate::error::ReplaceTransitGatewayRouteError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR range used for the destination match. Routing decisions are based on the most specific match.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_cidr_block(input);
            self
        }
        pub fn set_destination_cidr_block(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_cidr_block(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn transit_gateway_attachment_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_attachment_id(input);
            self
        }
        pub fn set_transit_gateway_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_attachment_id(input);
            self
        }
        /// <p>Indicates whether traffic matching this route is to be dropped.</p>
        pub fn blackhole(mut self, input: bool) -> Self {
            self.inner = self.inner.blackhole(input);
            self
        }
        pub fn set_blackhole(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_blackhole(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReportInstanceStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::report_instance_status_input::Builder,
    }
    impl<C> ReportInstanceStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReportInstanceStatusOutput,
            smithy_http::result::SdkError<crate::error::ReportInstanceStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Descriptive text about the health state of your instance.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The time at which the reported instance health state ended.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The instances.</p>
        pub fn instances(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instances(inp);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instances(input);
            self
        }
        /// <p>The reason codes that describe the health state of your instance.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>instance-stuck-in-state</code>: My instance is stuck in a state.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>unresponsive</code>: My instance is unresponsive.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>not-accepting-credentials</code>: My instance is not accepting my
        /// credentials.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>password-not-available</code>: A password is not available for my
        /// instance.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>performance-network</code>: My instance is experiencing performance
        /// problems that I believe are network related.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>performance-instance-store</code>: My instance is experiencing performance
        /// problems that I believe are related to the instance stores.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>performance-ebs-volume</code>: My instance is experiencing performance
        /// problems that I believe are related to an EBS volume.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>performance-other</code>: My instance is experiencing performance
        /// problems.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>other</code>: [explain using the description parameter]</p>
        /// </li>
        /// </ul>
        pub fn reason_codes(
            mut self,
            inp: impl Into<crate::model::ReportInstanceReasonCodes>,
        ) -> Self {
            self.inner = self.inner.reason_codes(inp);
            self
        }
        pub fn set_reason_codes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReportInstanceReasonCodes>>,
        ) -> Self {
            self.inner = self.inner.set_reason_codes(input);
            self
        }
        /// <p>The time at which the reported instance health state began.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The status of all instances listed.</p>
        pub fn status(mut self, input: crate::model::ReportStatusType) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ReportStatusType>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestSpotFleet<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::request_spot_fleet_input::Builder,
    }
    impl<C> RequestSpotFleet<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestSpotFleetOutput,
            smithy_http::result::SdkError<crate::error::RequestSpotFleetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The configuration for the Spot Fleet request.</p>
        pub fn spot_fleet_request_config(
            mut self,
            input: crate::model::SpotFleetRequestConfigData,
        ) -> Self {
            self.inner = self.inner.spot_fleet_request_config(input);
            self
        }
        pub fn set_spot_fleet_request_config(
            mut self,
            input: std::option::Option<crate::model::SpotFleetRequestConfigData>,
        ) -> Self {
            self.inner = self.inner.set_spot_fleet_request_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RequestSpotInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::request_spot_instances_input::Builder,
    }
    impl<C> RequestSpotInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RequestSpotInstancesOutput,
            smithy_http::result::SdkError<crate::error::RequestSpotInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The user-specified name for a logical grouping of requests.</p>
        /// <p>When you specify an Availability Zone group in a Spot Instance request, all Spot
        /// Instances in the request are launched in the same Availability Zone. Instance proximity
        /// is maintained with this parameter, but the choice of Availability Zone is not. The group
        /// applies only to requests for Spot Instances of the same instance type. Any additional
        /// Spot Instance requests that are specified with the same Availability Zone group name are
        /// launched in that same Availability Zone, as long as at least one instance from the group
        /// is still active.</p>
        /// <p>If there is no active instance running in the Availability Zone group that you specify
        /// for a new Spot Instance request (all instances are terminated, the request is expired,
        /// or the maximum price you specified falls below current Spot price), then Amazon EC2 launches
        /// the instance in any Availability Zone where the constraint can be met. Consequently, the
        /// subsequent set of Spot Instances could be placed in a different zone from the original
        /// request, even if you specified the same Availability Zone group.</p>
        /// <p>Default: Instances are launched in any available Availability Zone.</p>
        pub fn availability_zone_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone_group(input);
            self
        }
        pub fn set_availability_zone_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone_group(input);
            self
        }
        /// <p>Deprecated.</p>
        pub fn block_duration_minutes(mut self, input: i32) -> Self {
            self.inner = self.inner.block_duration_minutes(input);
            self
        }
        pub fn set_block_duration_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_block_duration_minutes(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure
        /// Idempotency</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually
        /// making the request, and provides an error response. If you have the required
        /// permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is
        /// <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The maximum number of Spot Instances to launch.</p>
        /// <p>Default: 1</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>The instance launch group. Launch groups are Spot Instances that launch together and
        /// terminate together.</p>
        /// <p>Default: Instances are launched and terminated individually</p>
        pub fn launch_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_group(input);
            self
        }
        pub fn set_launch_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_launch_group(input);
            self
        }
        /// <p>The launch specification.</p>
        pub fn launch_specification(
            mut self,
            input: crate::model::RequestSpotLaunchSpecification,
        ) -> Self {
            self.inner = self.inner.launch_specification(input);
            self
        }
        pub fn set_launch_specification(
            mut self,
            input: std::option::Option<crate::model::RequestSpotLaunchSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_specification(input);
            self
        }
        /// <p>The maximum price per hour that you are willing to pay for a Spot Instance. The
        /// default is the On-Demand price.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_price(input);
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_spot_price(input);
            self
        }
        /// <p>The Spot Instance request type.</p>
        /// <p>Default: <code>one-time</code>
        /// </p>
        pub fn r#type(mut self, input: crate::model::SpotInstanceType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SpotInstanceType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The start date of the request. If this is a one-time request, the request becomes
        /// active at this date and time and remains active until all instances launch, the request
        /// expires, or the request is canceled. If the request is persistent, the request becomes
        /// active at this date and time and remains active until it expires or is canceled.</p>
        /// <p>The specified start date and time cannot be equal to the current date and time. You
        /// must specify a start date and time that occurs after the current date and time.</p>
        pub fn valid_from(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.valid_from(input);
            self
        }
        pub fn set_valid_from(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_valid_from(input);
            self
        }
        /// <p>The end date of the request, in UTC format
        /// (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
        /// <ul>
        /// <li>
        /// <p>For a persistent request, the request remains active until the
        /// <code>ValidUntil</code> date and time is reached. Otherwise, the request
        /// remains active until you cancel it. </p>
        /// </li>
        /// <li>
        /// <p>For a one-time request, the request remains active until all instances launch,
        /// the request is canceled, or the <code>ValidUntil</code> date and time is
        /// reached. By default, the request is valid for 7 days from the date the request
        /// was created.</p>
        /// </li>
        /// </ul>
        pub fn valid_until(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.valid_until(input);
            self
        }
        pub fn set_valid_until(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.inner = self.inner.set_valid_until(input);
            self
        }
        /// <p>The key-value pair for tagging the Spot Instance request on creation. The value for
        /// <code>ResourceType</code> must be <code>spot-instances-request</code>, otherwise the
        /// Spot Instance request fails. To tag the Spot Instance request after it has been created,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>. </p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
        pub fn instance_interruption_behavior(
            mut self,
            input: crate::model::InstanceInterruptionBehavior,
        ) -> Self {
            self.inner = self.inner.instance_interruption_behavior(input);
            self
        }
        pub fn set_instance_interruption_behavior(
            mut self,
            input: std::option::Option<crate::model::InstanceInterruptionBehavior>,
        ) -> Self {
            self.inner = self.inner.set_instance_interruption_behavior(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetAddressAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_address_attribute_input::Builder,
    }
    impl<C> ResetAddressAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetAddressAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetAddressAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>[EC2-VPC] The allocation ID.</p>
        pub fn allocation_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.allocation_id(input);
            self
        }
        pub fn set_allocation_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_allocation_id(input);
            self
        }
        /// <p>The attribute of the IP address.</p>
        pub fn attribute(mut self, input: crate::model::AddressAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::AddressAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetEbsDefaultKmsKeyId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_ebs_default_kms_key_id_input::Builder,
    }
    impl<C> ResetEbsDefaultKmsKeyId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetEbsDefaultKmsKeyIdOutput,
            smithy_http::result::SdkError<crate::error::ResetEbsDefaultKmsKeyIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetFpgaImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_fpga_image_attribute_input::Builder,
    }
    impl<C> ResetFpgaImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetFpgaImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetFpgaImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the AFI.</p>
        pub fn fpga_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fpga_image_id(input);
            self
        }
        pub fn set_fpga_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fpga_image_id(input);
            self
        }
        /// <p>The attribute.</p>
        pub fn attribute(mut self, input: crate::model::ResetFpgaImageAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::ResetFpgaImageAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetImageAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_image_attribute_input::Builder,
    }
    impl<C> ResetImageAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetImageAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetImageAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The attribute to reset (currently you can only reset the launch permission attribute).</p>
        pub fn attribute(mut self, input: crate::model::ResetImageAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::ResetImageAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the AMI.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetInstanceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_instance_attribute_input::Builder,
    }
    impl<C> ResetInstanceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetInstanceAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetInstanceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The attribute to reset.</p>
        /// <important>
        /// <p>You can only reset the following attributes: <code>kernel</code> |
        /// <code>ramdisk</code> | <code>sourceDestCheck</code>. To change an instance
        /// attribute, use <a>ModifyInstanceAttribute</a>.</p>
        /// </important>
        pub fn attribute(mut self, input: crate::model::InstanceAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::InstanceAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetNetworkInterfaceAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_network_interface_attribute_input::Builder,
    }
    impl<C> ResetNetworkInterfaceAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetNetworkInterfaceAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetNetworkInterfaceAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The source/destination checking attribute. Resets the value to <code>true</code>.</p>
        pub fn source_dest_check(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_dest_check(input);
            self
        }
        pub fn set_source_dest_check(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_dest_check(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResetSnapshotAttribute<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reset_snapshot_attribute_input::Builder,
    }
    impl<C> ResetSnapshotAttribute<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResetSnapshotAttributeOutput,
            smithy_http::result::SdkError<crate::error::ResetSnapshotAttributeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The attribute to reset. Currently, only the attribute for permission to create volumes can
        /// be reset.</p>
        pub fn attribute(mut self, input: crate::model::SnapshotAttributeName) -> Self {
            self.inner = self.inner.attribute(input);
            self
        }
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::SnapshotAttributeName>,
        ) -> Self {
            self.inner = self.inner.set_attribute(input);
            self
        }
        /// <p>The ID of the snapshot.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.snapshot_id(input);
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_snapshot_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreAddressToClassic<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::restore_address_to_classic_input::Builder,
    }
    impl<C> RestoreAddressToClassic<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RestoreAddressToClassicOutput,
            smithy_http::result::SdkError<crate::error::RestoreAddressToClassicError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The Elastic IP address.</p>
        pub fn public_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.public_ip(input);
            self
        }
        pub fn set_public_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_public_ip(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreManagedPrefixListVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::restore_managed_prefix_list_version_input::Builder,
    }
    impl<C> RestoreManagedPrefixListVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RestoreManagedPrefixListVersionOutput,
            smithy_http::result::SdkError<crate::error::RestoreManagedPrefixListVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.prefix_list_id(input);
            self
        }
        pub fn set_prefix_list_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_prefix_list_id(input);
            self
        }
        /// <p>The version to restore.</p>
        pub fn previous_version(mut self, input: i64) -> Self {
            self.inner = self.inner.previous_version(input);
            self
        }
        pub fn set_previous_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_previous_version(input);
            self
        }
        /// <p>The current version number for the prefix list.</p>
        pub fn current_version(mut self, input: i64) -> Self {
            self.inner = self.inner.current_version(input);
            self
        }
        pub fn set_current_version(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_current_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RevokeClientVpnIngress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::revoke_client_vpn_ingress_input::Builder,
    }
    impl<C> RevokeClientVpnIngress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RevokeClientVpnIngressOutput,
            smithy_http::result::SdkError<crate::error::RevokeClientVpnIngressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint with which the authorization rule is associated.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The IPv4 address range, in CIDR notation, of the network for which access is being removed.</p>
        pub fn target_network_cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_network_cidr(input);
            self
        }
        pub fn set_target_network_cidr(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_network_cidr(input);
            self
        }
        /// <p>The ID of the Active Directory group for which to revoke access. </p>
        pub fn access_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_group_id(input);
            self
        }
        pub fn set_access_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_group_id(input);
            self
        }
        /// <p>Indicates whether access should be revoked for all clients.</p>
        pub fn revoke_all_groups(mut self, input: bool) -> Self {
            self.inner = self.inner.revoke_all_groups(input);
            self
        }
        pub fn set_revoke_all_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_revoke_all_groups(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RevokeSecurityGroupEgress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::revoke_security_group_egress_input::Builder,
    }
    impl<C> RevokeSecurityGroupEgress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RevokeSecurityGroupEgressOutput,
            smithy_http::result::SdkError<crate::error::RevokeSecurityGroupEgressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the security group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>The sets of IP permissions. You can't specify a destination security group and a CIDR IP address range in the same set of permissions.</p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the CIDR.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_ip(input);
            self
        }
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_ip(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the port.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.inner = self.inner.from_port(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_from_port(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the protocol name or
        /// number.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_protocol(input);
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_protocol(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify the port.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.inner = self.inner.to_port(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_to_port(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify a
        /// destination security group.</p>
        pub fn source_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_security_group_name(input);
            self
        }
        pub fn set_source_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_name(input);
            self
        }
        /// <p>Not supported. Use a set of IP permissions to specify a destination security
        /// group.</p>
        pub fn source_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.source_security_group_owner_id(input);
            self
        }
        pub fn set_source_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_owner_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RevokeSecurityGroupIngress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::revoke_security_group_ingress_input::Builder,
    }
    impl<C> RevokeSecurityGroupIngress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RevokeSecurityGroupIngressOutput,
            smithy_http::result::SdkError<crate::error::RevokeSecurityGroupIngressError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The CIDR IP address range. You can't specify this parameter when specifying a source security group.</p>
        pub fn cidr_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr_ip(input);
            self
        }
        pub fn set_cidr_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr_ip(input);
            self
        }
        /// <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number,
        /// use <code>-1</code> to specify all ICMP types.</p>
        pub fn from_port(mut self, input: i32) -> Self {
            self.inner = self.inner.from_port(input);
            self
        }
        pub fn set_from_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_from_port(input);
            self
        }
        /// <p>The ID of the security group. You must specify either the security group ID or the
        /// security group name in the request. For security groups in a nondefault VPC, you must
        /// specify the security group ID.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the
        /// security group ID or the security group name in the request.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The sets of IP permissions. You can't specify a source security group and a CIDR IP address range in the same set of permissions.</p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
        /// <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number
        /// (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>).
        /// Use <code>-1</code> to specify all.</p>
        pub fn ip_protocol(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_protocol(input);
            self
        }
        pub fn set_ip_protocol(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_protocol(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
        pub fn source_security_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_security_group_name(input);
            self
        }
        pub fn set_source_security_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_name(input);
            self
        }
        /// <p>[EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
        pub fn source_security_group_owner_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.source_security_group_owner_id(input);
            self
        }
        pub fn set_source_security_group_owner_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_security_group_owner_id(input);
            self
        }
        /// <p>The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number,
        /// use <code>-1</code> to specify all ICMP codes for the ICMP type.</p>
        pub fn to_port(mut self, input: i32) -> Self {
            self.inner = self.inner.to_port(input);
            self
        }
        pub fn set_to_port(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_to_port(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RunInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::run_instances_input::Builder,
    }
    impl<C> RunInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RunInstancesOutput,
            smithy_http::result::SdkError<crate::error::RunInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The block device mapping entries.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p>The ID of the AMI. An AMI ID is required to launch an instance and must be
        /// specified here or in a launch template.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>The instance type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        /// <p>Default: <code>m1.small</code>
        /// </p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>[EC2-VPC] The number of IPv6 addresses to associate with the primary network
        /// interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You
        /// cannot specify this option and the option to assign specific IPv6 addresses in the same
        /// request. You can specify this option if you've specified a minimum number of instances
        /// to launch.</p>
        /// <p>You cannot specify this option and the network interfaces option in the same
        /// request.</p>
        pub fn ipv6_address_count(mut self, input: i32) -> Self {
            self.inner = self.inner.ipv6_address_count(input);
            self
        }
        pub fn set_ipv6_address_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_ipv6_address_count(input);
            self
        }
        /// <p>[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the
        /// primary network interface. You cannot specify this option and the option to assign a
        /// number of IPv6 addresses in the same request. You cannot specify this option if you've
        /// specified a minimum number of instances to launch.</p>
        /// <p>You cannot specify this option and the network interfaces option in the same
        /// request.</p>
        pub fn ipv6_addresses(mut self, inp: impl Into<crate::model::InstanceIpv6Address>) -> Self {
            self.inner = self.inner.ipv6_addresses(inp);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceIpv6Address>>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_addresses(input);
            self
        }
        /// <p>The ID of the kernel.</p>
        /// <important>
        /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        /// </important>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kernel_id(input);
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kernel_id(input);
            self
        }
        /// <p>The name of the key pair. You can create a key pair using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html">CreateKeyPair</a> or
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html">ImportKeyPair</a>.</p>
        /// <important>
        /// <p>If you do not specify a key pair, you can't connect to the instance unless you
        /// choose an AMI that is configured to allow users another way to log in.</p>
        /// </important>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_name(input);
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_name(input);
            self
        }
        /// <p>The maximum number of instances to launch. If you specify more instances than Amazon
        /// EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible
        /// number of instances above <code>MinCount</code>.</p>
        /// <p>Constraints: Between 1 and the maximum number you're allowed for the specified
        /// instance type. For more information about the default limits, and how to request an
        /// increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I
        /// run in Amazon EC2</a> in the Amazon EC2 FAQ.</p>
        pub fn max_count(mut self, input: i32) -> Self {
            self.inner = self.inner.max_count(input);
            self
        }
        pub fn set_max_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_count(input);
            self
        }
        /// <p>The minimum number of instances to launch. If you specify a minimum that is more
        /// instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2
        /// launches no instances.</p>
        /// <p>Constraints: Between 1 and the maximum number you're allowed for the specified
        /// instance type. For more information about the default limits, and how to request an
        /// increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I
        /// run in Amazon EC2</a> in the Amazon EC2 General FAQ.</p>
        pub fn min_count(mut self, input: i32) -> Self {
            self.inner = self.inner.min_count(input);
            self
        }
        pub fn set_min_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_count(input);
            self
        }
        /// <p>Specifies whether detailed monitoring is enabled for the instance.</p>
        pub fn monitoring(mut self, input: crate::model::RunInstancesMonitoringEnabled) -> Self {
            self.inner = self.inner.monitoring(input);
            self
        }
        pub fn set_monitoring(
            mut self,
            input: std::option::Option<crate::model::RunInstancesMonitoringEnabled>,
        ) -> Self {
            self.inner = self.inner.set_monitoring(input);
            self
        }
        /// <p>The placement for the instance.</p>
        pub fn placement(mut self, input: crate::model::Placement) -> Self {
            self.inner = self.inner.placement(input);
            self
        }
        pub fn set_placement(
            mut self,
            input: std::option::Option<crate::model::Placement>,
        ) -> Self {
            self.inner = self.inner.set_placement(input);
            self
        }
        /// <p>The ID of the RAM disk to select. Some kernels require additional drivers at launch.
        /// Check the kernel requirements for information about whether you need to specify a RAM
        /// disk. To find kernel requirements, go to the Amazon Web Services Resource Center and search for the
        /// kernel ID.</p>
        /// <important>
        /// <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the
        /// <i>Amazon EC2 User Guide</i>.</p>
        /// </important>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ramdisk_id(input);
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ramdisk_id(input);
            self
        }
        /// <p>The IDs of the security groups. You can create a security group using
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html">CreateSecurityGroup</a>.</p>
        /// <p>If you specify a network interface, you must specify any security groups as part of the network interface.</p>
        pub fn security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_group_ids(inp);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_group_ids(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The names of the security groups. For a nondefault VPC, you
        /// must use security group IDs instead.</p>
        /// <p>If you specify a network interface, you must specify any security groups as part of
        /// the network interface.</p>
        /// <p>Default: Amazon EC2 uses the default security group.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// <p>[EC2-VPC] The ID of the subnet to launch the instance into.</p>
        /// <p>If you specify a network interface, you must specify any subnets as part of the network interface.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>The user data to make available to the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running commands
        /// on your Linux instance at launch</a> (Linux) and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows). If you are using a command line tool,
        /// base64-encoding is performed for you, and you can load the text from a file. Otherwise,
        /// you must provide base64-encoded text. User data is limited to 16 KB.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_data(input);
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_data(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn additional_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.additional_info(input);
            self
        }
        pub fn set_additional_info(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_additional_info(input);
            self
        }
        /// <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the
        /// request. If you do not specify a client token, a randomly generated token is used for the
        /// request to ensure idempotency.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring
        /// Idempotency</a>.</p>
        /// <p>Constraints: Maximum 64 ASCII characters</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>If you set this parameter to <code>true</code>, you can't terminate the instance using
        /// the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch,
        /// use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html">ModifyInstanceAttribute</a>.
        /// Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to
        /// <code>terminate</code>, you can terminate the instance by running the shutdown
        /// command from the instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn disable_api_termination(mut self, input: bool) -> Self {
            self.inner = self.inner.disable_api_termination(input);
            self
        }
        pub fn set_disable_api_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disable_api_termination(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization
        /// provides dedicated throughput to Amazon EBS and an optimized configuration stack to
        /// provide optimal Amazon EBS I/O performance. This optimization isn't available with all
        /// instance types. Additional usage charges apply when using an EBS-optimized
        /// instance.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.inner = self.inner.ebs_optimized(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ebs_optimized(input);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of an IAM instance profile.</p>
        pub fn iam_instance_profile(
            mut self,
            input: crate::model::IamInstanceProfileSpecification,
        ) -> Self {
            self.inner = self.inner.iam_instance_profile(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<crate::model::IamInstanceProfileSpecification>,
        ) -> Self {
            self.inner = self.inner.set_iam_instance_profile(input);
            self
        }
        /// <p>Indicates whether an instance stops or terminates when you initiate shutdown from the
        /// instance (using the operating system command for system shutdown).</p>
        /// <p>Default: <code>stop</code>
        /// </p>
        pub fn instance_initiated_shutdown_behavior(
            mut self,
            input: crate::model::ShutdownBehavior,
        ) -> Self {
            self.inner = self.inner.instance_initiated_shutdown_behavior(input);
            self
        }
        pub fn set_instance_initiated_shutdown_behavior(
            mut self,
            input: std::option::Option<crate::model::ShutdownBehavior>,
        ) -> Self {
            self.inner = self.inner.set_instance_initiated_shutdown_behavior(input);
            self
        }
        /// <p>The network interfaces to associate with the instance. If you specify a network interface,
        /// you must specify any security groups and subnets as part of the network interface.</p>
        pub fn network_interfaces(
            mut self,
            inp: impl Into<crate::model::InstanceNetworkInterfaceSpecification>,
        ) -> Self {
            self.inner = self.inner.network_interfaces(inp);
            self
        }
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::InstanceNetworkInterfaceSpecification>,
            >,
        ) -> Self {
            self.inner = self.inner.set_network_interfaces(input);
            self
        }
        /// <p>[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address
        /// range of the subnet.</p>
        /// <p>Only one private IP address can be designated as primary. You can't specify this
        /// option if you've specified the option to designate a private IP address as the primary
        /// IP address in a network interface specification. You cannot specify this option if
        /// you're launching more than one instance in the request.</p>
        /// <p>You cannot specify this option and the network interfaces option in the same
        /// request.</p>
        pub fn private_ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_ip_address(input);
            self
        }
        pub fn set_private_ip_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_address(input);
            self
        }
        /// <p>An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that
        /// you can attach to your Windows instance to accelerate the graphics performance of your
        /// applications. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html">Amazon EC2 Elastic
        /// GPUs</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn elastic_gpu_specification(
            mut self,
            inp: impl Into<crate::model::ElasticGpuSpecification>,
        ) -> Self {
            self.inner = self.inner.elastic_gpu_specification(inp);
            self
        }
        pub fn set_elastic_gpu_specification(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ElasticGpuSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_elastic_gpu_specification(input);
            self
        }
        /// <p>An elastic inference accelerator to associate with the instance. Elastic inference
        /// accelerators are a resource you can attach to your Amazon EC2 instances to accelerate
        /// your Deep Learning (DL) inference workloads.</p>
        /// <p>You cannot specify accelerators from different generations in the same request.</p>
        pub fn elastic_inference_accelerators(
            mut self,
            inp: impl Into<crate::model::ElasticInferenceAccelerator>,
        ) -> Self {
            self.inner = self.inner.elastic_inference_accelerators(inp);
            self
        }
        pub fn set_elastic_inference_accelerators(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ElasticInferenceAccelerator>>,
        ) -> Self {
            self.inner = self.inner.set_elastic_inference_accelerators(input);
            self
        }
        /// <p>The tags to apply to the resources during launch. You can only tag instances and
        /// volumes on launch. The specified tags are applied to all instances or volumes that are
        /// created during launch. To tag a resource after it has been created, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html">CreateTags</a>.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>The launch template to use to launch the instances. Any parameters that you specify in
        /// <a>RunInstances</a> override the same parameters in the launch template.
        /// You can specify either the name or ID of a launch template, but not both.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        /// <p>The market (purchasing) option for the instances.</p>
        /// <p>For <a>RunInstances</a>, persistent Spot Instance requests are
        /// only supported when <b>InstanceInterruptionBehavior</b> is set
        /// to either <code>hibernate</code> or <code>stop</code>.</p>
        pub fn instance_market_options(
            mut self,
            input: crate::model::InstanceMarketOptionsRequest,
        ) -> Self {
            self.inner = self.inner.instance_market_options(input);
            self
        }
        pub fn set_instance_market_options(
            mut self,
            input: std::option::Option<crate::model::InstanceMarketOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_instance_market_options(input);
            self
        }
        /// <p>The credit option for CPU usage of the burstable performance instance. Valid values
        /// are <code>standard</code> and <code>unlimited</code>. To change this attribute after
        /// launch, use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html">
        /// ModifyInstanceCreditSpecification</a>. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html">Burstable
        /// performance instances</a> in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p>Default: <code>standard</code> (T2 instances) or <code>unlimited</code> (T3/T3a
        /// instances)</p>
        pub fn credit_specification(
            mut self,
            input: crate::model::CreditSpecificationRequest,
        ) -> Self {
            self.inner = self.inner.credit_specification(input);
            self
        }
        pub fn set_credit_specification(
            mut self,
            input: std::option::Option<crate::model::CreditSpecificationRequest>,
        ) -> Self {
            self.inner = self.inner.set_credit_specification(input);
            self
        }
        /// <p>The CPU options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU options</a> in the <i>Amazon EC2 User Guide</i>.</p>
        pub fn cpu_options(mut self, input: crate::model::CpuOptionsRequest) -> Self {
            self.inner = self.inner.cpu_options(input);
            self
        }
        pub fn set_cpu_options(
            mut self,
            input: std::option::Option<crate::model::CpuOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_cpu_options(input);
            self
        }
        /// <p>Information about the Capacity Reservation targeting option. If you do not specify this parameter, the
        /// instance's Capacity Reservation preference defaults to <code>open</code>, which enables
        /// it to run in any open Capacity Reservation that has matching attributes (instance type,
        /// platform, Availability Zone).</p>
        pub fn capacity_reservation_specification(
            mut self,
            input: crate::model::CapacityReservationSpecification,
        ) -> Self {
            self.inner = self.inner.capacity_reservation_specification(input);
            self
        }
        pub fn set_capacity_reservation_specification(
            mut self,
            input: std::option::Option<crate::model::CapacityReservationSpecification>,
        ) -> Self {
            self.inner = self.inner.set_capacity_reservation_specification(input);
            self
        }
        /// <p>Indicates whether an instance is enabled for hibernation. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate
        /// your instance</a> in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p>You can't enable hibernation and Amazon Web Services Nitro Enclaves on the same instance.</p>
        pub fn hibernation_options(
            mut self,
            input: crate::model::HibernationOptionsRequest,
        ) -> Self {
            self.inner = self.inner.hibernation_options(input);
            self
        }
        pub fn set_hibernation_options(
            mut self,
            input: std::option::Option<crate::model::HibernationOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_hibernation_options(input);
            self
        }
        /// <p>The license configurations.</p>
        pub fn license_specifications(
            mut self,
            inp: impl Into<crate::model::LicenseConfigurationRequest>,
        ) -> Self {
            self.inner = self.inner.license_specifications(inp);
            self
        }
        pub fn set_license_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LicenseConfigurationRequest>>,
        ) -> Self {
            self.inner = self.inner.set_license_specifications(input);
            self
        }
        /// <p>The metadata options for the instance. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a>.</p>
        pub fn metadata_options(
            mut self,
            input: crate::model::InstanceMetadataOptionsRequest,
        ) -> Self {
            self.inner = self.inner.metadata_options(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_metadata_options(input);
            self
        }
        /// <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves. For more information,
        /// see <a href="https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html">
        /// What is Amazon Web Services Nitro Enclaves?</a> in the <i>Amazon Web Services Nitro Enclaves User Guide</i>.</p>    
        /// <p>You can't enable Amazon Web Services Nitro Enclaves and hibernation on the same instance.</p>
        pub fn enclave_options(mut self, input: crate::model::EnclaveOptionsRequest) -> Self {
            self.inner = self.inner.enclave_options(input);
            self
        }
        pub fn set_enclave_options(
            mut self,
            input: std::option::Option<crate::model::EnclaveOptionsRequest>,
        ) -> Self {
            self.inner = self.inner.set_enclave_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RunScheduledInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::run_scheduled_instances_input::Builder,
    }
    impl<C> RunScheduledInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RunScheduledInstancesOutput,
            smithy_http::result::SdkError<crate::error::RunScheduledInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that ensures the idempotency of the request.
        /// For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The number of instances.</p>
        /// <p>Default: 1</p>
        pub fn instance_count(mut self, input: i32) -> Self {
            self.inner = self.inner.instance_count(input);
            self
        }
        pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_instance_count(input);
            self
        }
        /// <p>The launch specification. You must match the instance type, Availability Zone,
        /// network, and platform of the schedule that you purchased.</p>
        pub fn launch_specification(
            mut self,
            input: crate::model::ScheduledInstancesLaunchSpecification,
        ) -> Self {
            self.inner = self.inner.launch_specification(input);
            self
        }
        pub fn set_launch_specification(
            mut self,
            input: std::option::Option<crate::model::ScheduledInstancesLaunchSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_specification(input);
            self
        }
        /// <p>The Scheduled Instance ID.</p>
        pub fn scheduled_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_instance_id(input);
            self
        }
        pub fn set_scheduled_instance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchLocalGatewayRoutes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_local_gateway_routes_input::Builder,
    }
    impl<C> SearchLocalGatewayRoutes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchLocalGatewayRoutesOutput,
            smithy_http::result::SdkError<crate::error::SearchLocalGatewayRoutesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the local gateway route table.</p>
        pub fn local_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.local_gateway_route_table_id(input);
            self
        }
        pub fn set_local_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_local_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchTransitGatewayMulticastGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_transit_gateway_multicast_groups_input::Builder,
    }
    impl<C> SearchTransitGatewayMulticastGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchTransitGatewayMulticastGroupsOutput,
            smithy_http::result::SdkError<crate::error::SearchTransitGatewayMulticastGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway multicast domain.</p>
        pub fn transit_gateway_multicast_domain_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_multicast_domain_id(input);
            self
        }
        pub fn set_transit_gateway_multicast_domain_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_multicast_domain_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>group-ip-address</code> - The IP address of the  transit gateway multicast group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>is-group-member</code> - The resource is a group member. Valid values are <code>true</code> | <code>false</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>is-group-source</code> - The resource is a group source. Valid values are <code>true</code> | <code>false</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>member-type</code> - The member type. Valid values are <code>igmp</code> | <code>static</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-id</code> - The ID of the resource.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource-type</code> - The type of resource. Valid values are <code>vpc</code> | <code>vpn</code> | <code>direct-connect-gateway</code> | <code>tgw-peering</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>source-type</code> - The source type. Valid values are <code>igmp</code> | <code>static</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the subnet association. Valid values are <code>associated</code> | <code>associated</code> | <code>disassociated</code> | <code>disassociating</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>subnet-id</code> - The ID of the subnet.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>transit-gateway-attachment-id</code> - The id of the transit gateway attachment.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of results to return with a single call.
        /// To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SearchTransitGatewayRoutes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::search_transit_gateway_routes_input::Builder,
    }
    impl<C> SearchTransitGatewayRoutes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SearchTransitGatewayRoutesOutput,
            smithy_http::result::SdkError<crate::error::SearchTransitGatewayRoutesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.transit_gateway_route_table_id(input);
            self
        }
        pub fn set_transit_gateway_route_table_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_transit_gateway_route_table_id(input);
            self
        }
        /// <p>One or more filters. The possible values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>attachment.transit-gateway-attachment-id</code>- The id of the transit gateway attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.resource-id</code> - The resource id of the transit gateway attachment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>attachment.resource-type</code> - The attachment resource type. Valid values
        /// are <code>vpc</code> | <code>vpn</code> | <code>direct-connect-gateway</code> |
        /// <code>peering</code> | <code>connect</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>prefix-list-id</code> - The ID of the prefix list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.exact-match</code> - The exact match of the specified filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.longest-prefix-match</code> - The longest prefix that matches the route.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.subnet-of-match</code> - The routes with a subnet that match the specified CIDR filter.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>route-search.supernet-of-match</code> - The routes with a CIDR that encompass the CIDR filter. For example, if you have 10.0.1.0/29 and 10.0.1.0/31 routes in your route table and you specify supernet-of-match as 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>state</code> - The state of the route (<code>active</code> | <code>blackhole</code>).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>type</code> - The type of route (<code>propagated</code> |
        /// <code>static</code>).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The maximum number of routes to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SendDiagnosticInterrupt<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::send_diagnostic_interrupt_input::Builder,
    }
    impl<C> SendDiagnosticInterrupt<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendDiagnosticInterruptOutput,
            smithy_http::result::SdkError<crate::error::SendDiagnosticInterruptError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_instances_input::Builder,
    }
    impl<C> StartInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartInstancesOutput,
            smithy_http::result::SdkError<crate::error::StartInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn additional_info(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.additional_info(input);
            self
        }
        pub fn set_additional_info(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_additional_info(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartNetworkInsightsAnalysis<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_network_insights_analysis_input::Builder,
    }
    impl<C> StartNetworkInsightsAnalysis<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartNetworkInsightsAnalysisOutput,
            smithy_http::result::SdkError<crate::error::StartNetworkInsightsAnalysisError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the path.</p>
        pub fn network_insights_path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_insights_path_id(input);
            self
        }
        pub fn set_network_insights_path_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_insights_path_id(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the resources that the path must traverse.</p>
        pub fn filter_in_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_in_arns(inp);
            self
        }
        pub fn set_filter_in_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_filter_in_arns(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The tags to apply.</p>
        pub fn tag_specifications(
            mut self,
            inp: impl Into<crate::model::TagSpecification>,
        ) -> Self {
            self.inner = self.inner.tag_specifications(inp);
            self
        }
        pub fn set_tag_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_tag_specifications(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartVpcEndpointServicePrivateDnsVerification<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_vpc_endpoint_service_private_dns_verification_input::Builder,
    }
    impl<C> StartVpcEndpointServicePrivateDnsVerification<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartVpcEndpointServicePrivateDnsVerificationOutput,
            smithy_http::result::SdkError<
                crate::error::StartVpcEndpointServicePrivateDnsVerificationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the endpoint service.</p>
        pub fn service_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_id(input);
            self
        }
        pub fn set_service_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_service_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_instances_input::Builder,
    }
    impl<C> StopInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopInstancesOutput,
            smithy_http::result::SdkError<crate::error::StopInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Hibernates the instance if the instance was enabled for hibernation at launch. If the
        /// instance cannot hibernate successfully, a normal shutdown occurs. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html">Hibernate
        /// your instance</a> in the <i>Amazon EC2 User Guide</i>.</p>
        /// <p> Default: <code>false</code>
        /// </p>
        pub fn hibernate(mut self, input: bool) -> Self {
            self.inner = self.inner.hibernate(input);
            self
        }
        pub fn set_hibernate(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_hibernate(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>Forces the instances to stop. The instances do not have an opportunity to flush file
        /// system caches or file system metadata. If you use this option, you must perform file
        /// system check and repair procedures. This option is not recommended for Windows
        /// instances.</p>
        /// <p>Default: <code>false</code>
        /// </p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateClientVpnConnections<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::terminate_client_vpn_connections_input::Builder,
    }
    impl<C> TerminateClientVpnConnections<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TerminateClientVpnConnectionsOutput,
            smithy_http::result::SdkError<crate::error::TerminateClientVpnConnectionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Client VPN endpoint to which the client is connected.</p>
        pub fn client_vpn_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_vpn_endpoint_id(input);
            self
        }
        pub fn set_client_vpn_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_vpn_endpoint_id(input);
            self
        }
        /// <p>The ID of the client connection to be terminated.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.connection_id(input);
            self
        }
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_connection_id(input);
            self
        }
        /// <p>The name of the user who initiated the connection. Use this option to terminate all active connections for
        /// the specified user. This option can only be used if the user has established up to five connections.</p>
        pub fn username(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.username(input);
            self
        }
        pub fn set_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_username(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::terminate_instances_input::Builder,
    }
    impl<C> TerminateInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TerminateInstancesOutput,
            smithy_http::result::SdkError<crate::error::TerminateInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances.</p>
        /// <p>Constraints: Up to 1000 instance IDs. We recommend breaking up this request into
        /// smaller batches.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UnassignIpv6Addresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::unassign_ipv6_addresses_input::Builder,
    }
    impl<C> UnassignIpv6Addresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnassignIpv6AddressesOutput,
            smithy_http::result::SdkError<crate::error::UnassignIpv6AddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The IPv6 addresses to unassign from the network interface.</p>
        pub fn ipv6_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ipv6_addresses(inp);
            self
        }
        pub fn set_ipv6_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ipv6_addresses(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UnassignPrivateIpAddresses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::unassign_private_ip_addresses_input::Builder,
    }
    impl<C> UnassignPrivateIpAddresses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnassignPrivateIpAddressesOutput,
            smithy_http::result::SdkError<crate::error::UnassignPrivateIpAddressesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the network interface.</p>
        pub fn network_interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.network_interface_id(input);
            self
        }
        pub fn set_network_interface_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_network_interface_id(input);
            self
        }
        /// <p>The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.</p>
        pub fn private_ip_addresses(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.private_ip_addresses(inp);
            self
        }
        pub fn set_private_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_private_ip_addresses(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UnmonitorInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::unmonitor_instances_input::Builder,
    }
    impl<C> UnmonitorInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UnmonitorInstancesOutput,
            smithy_http::result::SdkError<crate::error::UnmonitorInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSecurityGroupRuleDescriptionsEgress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_security_group_rule_descriptions_egress_input::Builder,
    }
    impl<C> UpdateSecurityGroupRuleDescriptionsEgress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSecurityGroupRuleDescriptionsEgressOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateSecurityGroupRuleDescriptionsEgressError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the security group. You must specify either the security group ID or the
        /// security group name in the request. For security groups in a nondefault VPC, you must
        /// specify the security group ID.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>[Default VPC] The name of the security group. You must specify either the security group
        /// ID or the security group name in the request.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The IP permissions for the security group rule.</p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSecurityGroupRuleDescriptionsIngress<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_security_group_rule_descriptions_ingress_input::Builder,
    }
    impl<C> UpdateSecurityGroupRuleDescriptionsIngress<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSecurityGroupRuleDescriptionsIngressOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateSecurityGroupRuleDescriptionsIngressError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
        /// <p>The ID of the security group. You must specify either the security group ID or the
        /// security group name in the request. For security groups in a nondefault VPC, you must
        /// specify the security group ID.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_id(input);
            self
        }
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_id(input);
            self
        }
        /// <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the
        /// security group ID or the security group name in the request.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.group_name(input);
            self
        }
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_group_name(input);
            self
        }
        /// <p>The IP permissions for the security group rule. </p>
        pub fn ip_permissions(mut self, inp: impl Into<crate::model::IpPermission>) -> Self {
            self.inner = self.inner.ip_permissions(inp);
            self
        }
        pub fn set_ip_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpPermission>>,
        ) -> Self {
            self.inner = self.inner.set_ip_permissions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct WithdrawByoipCidr<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::withdraw_byoip_cidr_input::Builder,
    }
    impl<C> WithdrawByoipCidr<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::WithdrawByoipCidrOutput,
            smithy_http::result::SdkError<crate::error::WithdrawByoipCidrError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The address range, in CIDR notation.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cidr(input);
            self
        }
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cidr(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request,
        /// and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>.
        /// Otherwise, it is <code>UnauthorizedOperation</code>.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
}
